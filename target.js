var pxtTargetBundle = {
    "id": "adafruit",
    "platformid": "codal",
    "nickname": "circuitplayground",
    "name": "Adafruit Circuit Playground Express",
    "title": "Adafruit Circuit Playground Express - Blocks / Javascript editor",
    "description": "A Blocks / JavaScript code editor for the Adafruit Circuit Playground Express.",
    "corepkg": "circuit-playground",
    "bundleddirs": [
        "libs/jc",
        "libs/jcevent",
        "libs/jcstubborn",
        "libs/base",
        "libs/core",
        "libs/core---samd",
        "libs/settings",
        "libs/buttons",
        "libs/accelerometer",
        "libs/music",
        "libs/mixer",
        "libs/mixer---samd",
        "libs/microphone",
        "libs/lightsensor",
        "libs/thermometer",
        "libs/color",
        "libs/light",
        "libs/touch",
        "libs/switch",
        "libs/pulse",
        "libs/cable",
        "libs/infrared",
        "libs/circuit-playground",
        "libs/mouse",
        "libs/keyboard",
        "libs/gamepad",
        "libs/servo",
        "libs/storage",
        "libs/datalogger",
        "libs/serial"
    ],
    "serial": {
        "useHF2": true,
        "useEditor": true,
        "log": true,
        "editorTheme": {
            "graphBackground": "#d9d9d9",
            "lineColors": [
                "#009DDC",
                "#FB48C7",
                "#40bf4a",
                "#8073E5",
                "#d25b33"
            ]
        }
    },
    "simulator": {
        "autoRun": true,
        "streams": false,
        "aspectRatio": 1,
        "parts": false,
        "boardDefinition": {
            "id": "adafruit-circuit-playground-express",
            "visual": "circuitplayground",
            "gpioPinBlocks": [
                [
                    "P0"
                ],
                [
                    "P1"
                ],
                [
                    "P2"
                ],
                [
                    "P3"
                ],
                [
                    "P4",
                    "P5",
                    "P6",
                    "P7"
                ],
                [
                    "P8",
                    "P9",
                    "P10",
                    "P11",
                    "P12"
                ],
                [
                    "P16"
                ]
            ],
            "gpioPinMap": {
                "P0": "P0",
                "P1": "P1",
                "P2": "P2",
                "P3": "P3",
                "P4": "P4",
                "P5": "P5",
                "P6": "P6",
                "P7": "P7",
                "P8": "P8",
                "P9": "P9",
                "P10": "P10",
                "P11": "P11",
                "P12": "P12",
                "P13": "P13",
                "P14": "P14",
                "P15": "P15",
                "P16": "P16",
                "P19": "P19",
                "P20": "P20"
            },
            "i2cPins": {
                "SDA": "P2",
                "SCL": "P3"
            },
            "analogInPins": [
                "A0",
                "A4",
                "A5"
            ],
            "groundPins": [
                "GND_0",
                "GND_1",
                "GND_2"
            ],
            "threeVoltPins": [
                "PWR_0",
                "PWR_2"
            ],
            "attachPowerOnRight": true,
            "onboardComponents": [
                "accelerometer",
                "buttonpair",
                "speaker",
                "thermometer",
                "rgbsensor",
                "lightsensor",
                "microphone"
            ],
            "useCrocClips": true,
            "marginWhenBreadboarding": [
                0,
                0,
                80,
                0
            ],
            "bootloaderBaudSwitchInfo": {
                "vid": "0x239A",
                "pid": "0x8018"
            }
        }
    },
    "cloud": {
        "workspace": false,
        "packages": true,
        "sharing": true,
        "publishing": true,
        "importing": true,
        "thumbnails": true,
        "preferredPackages": [],
        "githubPackages": true,
        "cloudProviders": {
            "github": {}
        }
    },
    "compile": {
        "webUSB": true,
        "isNative": true,
        "useUF2": true,
        "hasHex": true,
        "deployDrives": ".*",
        "deployFileMarker": "INFO_UF2.TXT",
        "driveName": "CPLAYBOOT",
        "openocdScript": "source [find interface/cmsis-dap.cfg]; set CHIPNAME at91samd51g19; source [find target/at91samdXX.cfg]",
        "openocdScriptAlt": "source [find interface/stlink-v2.cfg]; set CPUTAPID 0x0bc11477; set CHIPNAME at91samd21g18; source [find target/at91samdXX.cfg]",
        "flashChecksumAddr": 8372,
        "flashCodeAlign": 256,
        "floatingPoint": true,
        "uf2Family": "0x68ed2b88",
        "gc": true,
        "patches": {
            "0.0.0 - 1.1.15": [
                {
                    "type": "package",
                    "map": {
                        "neopixel": "light",
                        "adafruit": "circuit-playground"
                    }
                },
                {
                    "type": "api",
                    "map": {
                        "Math\\s*\\.random\\s*\\(\\s*(\\d+)\\s*\\)": "Math.randomRange(0, $1)",
                        "light\\.pixels\\.(__)?setAll": "light.setAll",
                        "light\\.pixels\\.(__)?graph": "light.graph",
                        "light\\.pixels\\.(__)?setPixelColor": "light.setPixelColor",
                        "light\\.pixels\\.(__)?pixelColor": "light.pixelColor",
                        "light\\.pixels\\.(__)?setBrightness": "light.setBrightness",
                        "light\\.pixels\\.(__)?photonForward": "light.photonForward",
                        "light\\.pixels\\.(__)?photonFlip": "light.photonFlip",
                        "light\\.pixels\\.(__)?setPhotonColor": "light.setPhotonPenHue",
                        "light\\.pixels\\.(__)?setPhotonMode": "light.setPhotonMode",
                        "light\\.pixels\\.(__)?showAnimation": "light.showAnimation",
                        "light\\.pixels\\.(__)?showAnimationFrame": "light.showAnimation",
                        "light\\.pixels\\.(__)?clear": "light.clear",
                        "light\\.pixels\\.(__)?stopAllAnimations": "light.stopAllAnimations",
                        "light\\.createNeoPixelStrip": "light.createStrip",
                        "light\\.pixels\\.__setPixelWhiteLED": "light.pixels.setPixelWhiteLED",
                        "light\\.pixels\\.__show": "light.pixels.show",
                        "light\\.pixels\\.__length": "light.pixels.length",
                        "light\\.pixels\\.__brightness": "light.pixels.brightness",
                        "light\\.pixels\\.__range": "light.pixels.range",
                        "light\\.pixels\\.__move": "light.pixels.move",
                        "light\\.pixels\\.__setBuffered": "light.pixels.setBuffered",
                        "light\\.pixels\\.__setMode": "light.pixels.setMode",
                        "light\\.animation\\(LightAnimation\\.Rainbow\\)": "light.rainbowAnimation",
                        "light\\.animation\\(LightAnimation\\.RunningLights\\)": "light.runningLightsAnimation",
                        "light\\.animation\\(LightAnimation\\.Comet\\)": "light.cometAnimation",
                        "light\\.animation\\(LightAnimation\\.Sparkle\\)": "light.sparkleAnimation",
                        "light\\.animation\\(LightAnimation\\.TheaterChase\\)": "light.theaterChaseAnimation",
                        "light\\.animation\\(LightAnimation\\.ColorWipe\\)": "light.colorWipeAnimation"
                    }
                }
            ],
            "0.0.0 - 1.3.5": [
                {
                    "type": "api",
                    "map": {
                        "input\\.pinA([1-7])\\.": "input.touchA$1.",
                        "music\\.playSound(UntilDone)?\\(music\\.sounds\\(Sounds\\.JumpUp\\)\\)": "music.jumpUp.play$1()",
                        "music\\.playSound(UntilDone)?\\(music\\.sounds\\(Sounds\\.JumpDown\\)\\)": "music.jumpDown.play$1()",
                        "music\\.playSound(UntilDone)?\\(music\\.sounds\\(Sounds\\.PowerUp\\)\\)": "music.powerUp.play$1()",
                        "music\\.playSound(UntilDone)?\\(music\\.sounds\\(Sounds\\.PowerDown\\)\\)": "music.powerDown.play$1()",
                        "music\\.playSound(UntilDone)?\\(music\\.sounds\\(Sounds\\.BaDing\\)\\)": "music.baDing.play$1()",
                        "music\\.playSound(UntilDone)?\\(music\\.sounds\\(Sounds\\.MagicWand\\)\\)": "music.magicWand.play$1()",
                        "music\\.playSound(UntilDone)?\\(music\\.sounds\\(Sounds\\.Siren\\)\\)": "music.siren.play$1()",
                        "music\\.playSound(UntilDone)?\\(music\\.sounds\\(Sounds\\.Wawawawaa\\)\\)": "music.wawawawaa.play$1()"
                    }
                }
            ]
        },
        "hidSelectors": [
            {
                "usagePage": "0xFF97",
                "usageId": "0x0001",
                "vid": "0x239A",
                "pid": "0x0018"
            },
            {
                "usagePage": "0xFF00",
                "usageId": "0x0001",
                "vid": "0x239A",
                "pid": "0x0018"
            },
            {
                "usagePage": "0xFF00",
                "usageId": "0x0001",
                "vid": "0x239A",
                "pid": "0x0019"
            },
            {
                "usagePage": "0xFF97",
                "usageId": "0x0001",
                "vid": "0x03EB",
                "pid": "0x2402"
            }
        ],
        "nativeType": "thumb",
        "switches": {},
        "jsRefCounting": false,
        "utf8": true
    },
    "runtime": {
        "mathBlocks": true,
        "loopsBlocks": true,
        "logicBlocks": true,
        "variablesBlocks": true,
        "textBlocks": true,
        "listsBlocks": true,
        "functionBlocks": true,
        "functionsOptions": {
            "useNewFunctions": true
        },
        "onStartNamespace": "loops",
        "onStartColor": "#40bf4a",
        "onStartWeight": 100
    },
    "compileService": {
        "buildEngine": "codal",
        "codalTarget": {
            "name": "codal-circuit-playground",
            "url": "C:/Users/Hoffk/Documents/GitHub/codal-dd1",
            "branch": "master",
            "type": "git",
            "dev": 1
        },
        "codalBinary": "CIRCUIT_PLAYGROUND",
        "yottaConfig": {
            "pxt": {
                "board": {
                    "id": "BOARD_ID_CPLAY"
                }
            }
        },
        "githubCorePackage": "lancaster-university/codal",
        "gittag": "master",
        "serviceId": "codal2cp",
        "dockerImage": "jeca/codal-dd1-image"
    },
    "appTheme": {
        "accentColor": "#0089BF",
        "logoUrl": "https://www.adafruit.com/product/3333",
        "logo": "docs/static/logo.svg",
        "docsLogo": "docs/static/logo.square.svg",
        "portraitLogo": "docs/static/logo.square.svg",
        "footerLogo": "docs/static/logo.square.svg",
        "cardLogo": "docs/static/icons/android-chrome-192x192.png",
        "appLogo": "docs/static/icons/android-chrome-192x192.png",
        "organization": "Microsoft MakeCode",
        "organizationUrl": "https://makecode.com/",
        "organizationLogo": "docs/static/Microsoft-logo_rgb_c-gray-square.png",
        "organizationWideLogo": "docs/static/Microsoft-logo_rgb_c-white.png",
        "homeUrl": "/",
        "betaUrl": "https://makecode.adafruit.com/beta",
        "embedUrl": "https://makecode.adafruit.com/",
        "privacyUrl": "https://go.microsoft.com/fwlink/?LinkId=521839",
        "termsOfUseUrl": "https://go.microsoft.com/fwlink/?LinkID=206977",
        "githubUrl": "https://github.com/Microsoft/pxt-adafruit",
        "crowdinProject": "kindscript",
        "boardName": "Adafruit Circuit Playground Express",
        "driveDisplayName": "CPLAYBOOT",
        "docMenu": [
            {
                "name": "Support",
                "path": "https://aka.ms/makecodeadafruitforums"
            },
            {
                "name": "Blocks",
                "path": "/docs/blocks"
            },
            {
                "name": "JavaScript",
                "path": "/docs/javascript"
            },
            {
                "name": "Reference",
                "path": "/docs/reference"
            },
            {
                "name": "Buy",
                "path": "https://www.adafruit.com/products/3333"
            }
        ],
        "showHomeScreen": true,
        "homeScreenHero": "docs/static/getting-started/CN-banner.jpg",
        "invertedMenu": true,
        "invertedToolbox": true,
        "invertedMonaco": true,
        "invertedGitHub": true,
        "monacoToolbox": true,
        "selectLanguage": true,
        "availableLocales": [
            "en",
            "de",
            "ja"
        ],
        "simAnimationEnter": "roll in",
        "simAnimationExit": "roll out",
        "highContrast": true,
        "greenScreen": true,
        "enableTrace": true,
        "print": true,
        "hasAudio": true,
        "usbHelp": [],
        "extendEditor": true,
        "extendFieldEditors": true,
        "disableBlockIcons": true,
        "scriptManager": true,
        "baseTheme": "dark",
        "simGifTransparent": "rgba(0,0,0,0)",
        "qrCode": true,
        "importExtensionFiles": true,
        "experiments": [
            "autoWebUSBDownload",
            "debugger",
            "debugExtensionCode",
            "simScreenshot",
            "simGif"
        ],
        "socialOptions": {
            "twitterHandle": "adafruit",
            "orgTwitterHandle": "MSMakeCode",
            "hashtags": "MakeCode"
        },
        "blocklyOptions": {
            "grid": {
                "spacing": 20,
                "length": 2,
                "colour": "rgba(189, 195, 199, 0.20)",
                "snap": true
            }
        },
        "blocklyColors": {
            "insertionMarker": "#FFFFFF",
            "insertionMarkerOpacity": 0.5
        },
        "blockColors": {
            "loops": "#40bf4a",
            "logic": "#4cbfe6",
            "math": "#9966ff",
            "variables": "#FF6680",
            "text": "#ffab19",
            "advanced": "#00272B",
            "functions": "#005a9e",
            "arrays": "#8A1C7C"
        },
        "allowPackageExtensions": true,
        "appFlashingTroubleshoot": "/device/windows-app/troubleshoot",
        "githubEditor": true,
        "chooseLanguageRestrictionOnNewProject": true,
        "python": true,
        "pythonToolbox": true,
        "errorList": true,
        "blocksCollapsing": true,
        "showProjectSettings": true,
        "debugger": true,
        "simGifMaxFrames": 44,
        "simScreenshotMaxUriLength": 300000,
        "nameProjectFirst": true,
        "openProjectNewTab": true,
        "TOC": [
            {
                "name": "About",
                "path": "/about",
                "subitems": []
            },
            {
                "name": "FAQ",
                "path": "/faq",
                "subitems": []
            },
            {
                "name": "Projects",
                "path": "/projects",
                "subitems": []
            },
            {
                "name": "GitHub",
                "path": "/github",
                "subitems": []
            },
            {
                "name": "Examples",
                "path": "/examples",
                "subitems": [
                    {
                        "name": "Blinky",
                        "path": "/examples/blinky",
                        "subitems": []
                    },
                    {
                        "name": "Animation Shaker",
                        "path": "/examples/animation-shaker",
                        "subitems": []
                    },
                    {
                        "name": "Juggle Counter",
                        "path": "/examples/juggle-counter",
                        "subitems": []
                    },
                    {
                        "name": "Energy Glove",
                        "path": "/examples/energy-glove",
                        "subitems": []
                    },
                    {
                        "name": "Dice",
                        "path": "/examples/dice",
                        "subitems": []
                    },
                    {
                        "name": "Level",
                        "path": "/examples/level",
                        "subitems": []
                    },
                    {
                        "name": "Counter",
                        "path": "/examples/counter",
                        "subitems": []
                    },
                    {
                        "name": "Egg game",
                        "path": "/examples/egg-game",
                        "subitems": []
                    },
                    {
                        "name": "Reaction",
                        "path": "/examples/reaction",
                        "subitems": []
                    },
                    {
                        "name": "Photon beatbox",
                        "path": "/examples/photon-beatbox",
                        "subitems": []
                    },
                    {
                        "name": "Spin it",
                        "path": "/examples/spin-it",
                        "subitems": []
                    },
                    {
                        "name": "Metronome",
                        "path": "/examples/metronome",
                        "subitems": []
                    },
                    {
                        "name": "Beat visualizer",
                        "path": "/examples/beat-visualizer",
                        "subitems": []
                    },
                    {
                        "name": "Fireflies",
                        "path": "/examples/fireflies",
                        "subitems": []
                    }
                ]
            },
            {
                "name": "Courses",
                "path": "/courses",
                "subitems": [
                    {
                        "name": "Maker",
                        "path": "/courses/maker",
                        "subitems": []
                    },
                    {
                        "name": "Using the Pins",
                        "path": "/learnsystem/pins-tutorial",
                        "subitems": []
                    },
                    {
                        "name": "Logic Lab",
                        "path": "/learnsystem/logic-lab",
                        "subitems": []
                    }
                ]
            },
            {
                "name": "Reference",
                "path": "/reference",
                "subitems": [
                    {
                        "name": "input",
                        "path": "/reference/input",
                        "subitems": []
                    },
                    {
                        "name": "light",
                        "path": "/reference/light",
                        "subitems": []
                    },
                    {
                        "name": "music",
                        "path": "/reference/music",
                        "subitems": []
                    },
                    {
                        "name": "network",
                        "path": "/reference/network",
                        "subitems": []
                    },
                    {
                        "name": "pins",
                        "path": "/reference/pins",
                        "subitems": []
                    },
                    {
                        "name": "control",
                        "path": "/reference/control",
                        "subitems": []
                    },
                    {
                        "name": "console",
                        "path": "/reference/console",
                        "subitems": []
                    }
                ]
            },
            {
                "name": "Blocks",
                "path": "/blocks",
                "subitems": [
                    {
                        "name": "On Start",
                        "path": "/blocks/on-start",
                        "subitems": []
                    },
                    {
                        "name": "Loops",
                        "path": "/blocks/loops",
                        "subitems": [
                            {
                                "name": "repeat",
                                "path": "/blocks/loops/repeat",
                                "subitems": []
                            },
                            {
                                "name": "for",
                                "path": "/blocks/loops/for",
                                "subitems": []
                            },
                            {
                                "name": "while",
                                "path": "/blocks/loops/while",
                                "subitems": []
                            },
                            {
                                "name": "for of",
                                "path": "/blocks/loops/for-of",
                                "subitems": []
                            }
                        ]
                    },
                    {
                        "name": "Logic",
                        "path": "/blocks/logic",
                        "subitems": [
                            {
                                "name": "if",
                                "path": "/blocks/logic/if",
                                "subitems": []
                            },
                            {
                                "name": "Boolean",
                                "path": "/blocks/logic/boolean",
                                "subitems": []
                            }
                        ]
                    },
                    {
                        "name": "Variables",
                        "path": "/blocks/variables",
                        "subitems": [
                            {
                                "name": "assign",
                                "path": "/blocks/variables/assign",
                                "subitems": []
                            },
                            {
                                "name": "change var",
                                "path": "/blocks/variables/change",
                                "subitems": []
                            },
                            {
                                "name": "var",
                                "path": "/blocks/variables/var",
                                "subitems": []
                            }
                        ]
                    },
                    {
                        "name": "Math",
                        "path": "/blocks/math",
                        "subitems": []
                    },
                    {
                        "name": "JavaScript blocks",
                        "path": "/blocks/javascript-blocks",
                        "subitems": []
                    },
                    {
                        "name": "Custom blocks",
                        "path": "/blocks/custom",
                        "subitems": []
                    }
                ]
            },
            {
                "name": "Python",
                "path": "/python",
                "subitems": [
                    {
                        "name": "Calling",
                        "path": "/python/call",
                        "subitems": []
                    },
                    {
                        "name": "Sequencing",
                        "path": "/python/sequence",
                        "subitems": []
                    },
                    {
                        "name": "Variables",
                        "path": "/python/variables",
                        "subitems": []
                    },
                    {
                        "name": "Operators",
                        "path": "/python/operators",
                        "subitems": []
                    },
                    {
                        "name": "Statements",
                        "path": "/python/statements",
                        "subitems": []
                    },
                    {
                        "name": "Functions",
                        "path": "/python/functions",
                        "subitems": []
                    },
                    {
                        "name": "Classes",
                        "path": "/python/classes",
                        "subitems": []
                    }
                ]
            },
            {
                "name": "JavaScript",
                "path": "/javascript",
                "subitems": [
                    {
                        "name": "Calling",
                        "path": "/javascript/call",
                        "subitems": []
                    },
                    {
                        "name": "Sequencing",
                        "path": "/javascript/sequence",
                        "subitems": []
                    },
                    {
                        "name": "Variables",
                        "path": "/javascript/variables",
                        "subitems": []
                    },
                    {
                        "name": "Operators",
                        "path": "/javascript/operators",
                        "subitems": []
                    },
                    {
                        "name": "Statements",
                        "path": "/javascript/statements",
                        "subitems": []
                    },
                    {
                        "name": "Functions",
                        "path": "/javascript/functions",
                        "subitems": []
                    },
                    {
                        "name": "Types",
                        "path": "/javascript/types",
                        "subitems": []
                    },
                    {
                        "name": "Classes",
                        "path": "/javascript/classes",
                        "subitems": []
                    },
                    {
                        "name": "Interfaces",
                        "path": "/javascript/interfaces",
                        "subitems": []
                    },
                    {
                        "name": "Generics",
                        "path": "/javascript/generics",
                        "subitems": []
                    }
                ]
            },
            {
                "name": "Types",
                "path": "/types",
                "subitems": [
                    {
                        "name": "Number",
                        "path": "/types/number",
                        "subitems": []
                    },
                    {
                        "name": "String",
                        "path": "/types/string",
                        "subitems": []
                    },
                    {
                        "name": "Boolean",
                        "path": "/types/boolean",
                        "subitems": []
                    },
                    {
                        "name": "Array",
                        "path": "/types/array",
                        "subitems": []
                    },
                    {
                        "name": "Function",
                        "path": "/types/function",
                        "subitems": []
                    }
                ]
            },
            {
                "name": "Miscellaneous",
                "path": "",
                "subitems": [
                    {
                        "name": "About",
                        "path": "/about",
                        "subitems": []
                    },
                    {
                        "name": "Support",
                        "path": "/support",
                        "subitems": []
                    },
                    {
                        "name": "Translate",
                        "path": "/translate",
                        "subitems": []
                    },
                    {
                        "name": "Sharing projects",
                        "path": "/share",
                        "subitems": []
                    },
                    {
                        "name": "Offline support",
                        "path": "/offline",
                        "subitems": []
                    },
                    {
                        "name": "Save",
                        "path": "/save",
                        "subitems": []
                    }
                ]
            },
            {
                "name": "Developers",
                "path": "",
                "subitems": [
                    {
                        "name": "Command Line Interface",
                        "path": "/cli",
                        "subitems": []
                    },
                    {
                        "name": "Visual Studio Code support",
                        "path": "/code",
                        "subitems": []
                    },
                    {
                        "name": "Blocks Embed",
                        "path": "/blocks-embed",
                        "subitems": []
                    }
                ]
            },
            {
                "name": "Projects",
                "path": "/projects",
                "subitems": [
                    {
                        "name": "Magic Wand",
                        "path": "/projects/magic-wand",
                        "subitems": []
                    },
                    {
                        "name": "Dandelion",
                        "path": "/projects/dandelion",
                        "subitems": []
                    },
                    {
                        "name": "Fidget Spinner",
                        "path": "/projects/fidget-spinner",
                        "subitems": []
                    },
                    {
                        "name": "Watch Timer",
                        "path": "/projects/watch-timer",
                        "subitems": []
                    },
                    {
                        "name": "Lucky Wheel",
                        "path": "/projects/lucky-wheel",
                        "subitems": []
                    },
                    {
                        "name": "Headlamp",
                        "path": "/projects/headlamp",
                        "subitems": []
                    },
                    {
                        "name": "Guitar",
                        "path": "/projects/guitar",
                        "subitems": []
                    },
                    {
                        "name": "Hot Potato",
                        "path": "/projects/hot-potato",
                        "subitems": []
                    },
                    {
                        "name": "Light Monster",
                        "path": "/projects/light-monster",
                        "subitems": []
                    },
                    {
                        "name": "Reaction!",
                        "path": "/projects/reaction",
                        "subitems": []
                    },
                    {
                        "name": "Wearable NeoPixels",
                        "path": "/projects/wearable-neopixels",
                        "subitems": []
                    },
                    {
                        "name": "Fabric Friend",
                        "path": "/projects/fabric-friend",
                        "subitems": []
                    }
                ]
            },
            {
                "name": "Hardware",
                "path": "/device",
                "subitems": [
                    {
                        "name": "Simulator",
                        "path": "/device/simulator",
                        "subitems": []
                    },
                    {
                        "name": "USB",
                        "path": "/device/usb",
                        "subitems": []
                    }
                ]
            }
        ],
        "id": "adafruit",
        "title": "Adafruit Circuit Playground Express - Blocks / Javascript editor",
        "name": "Adafruit Circuit Playground Express",
        "description": "A Blocks / JavaScript code editor for the Adafruit Circuit Playground Express.",
        "htmlDocIncludes": {}
    },
    "uploadDocs": true,
    "unsupportedBrowsers": [
        {
            "id": "ie"
        }
    ],
    "versions": {
        "target": "1.6.8",
        "pxt": "6.8.38"
    },
    "blocksprj": {
        "id": "blocksprj",
        "config": {
            "name": "{0}",
            "dependencies": {
                "circuit-playground": "*"
            },
            "description": "",
            "files": [
                "main.blocks",
                "main.ts",
                "README.md"
            ],
            "additionalFilePaths": []
        },
        "files": {
            "main.blocks": "<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"forever\"></block>\n</xml>",
            "main.ts": "\n",
            "README.md": ""
        }
    },
    "tsprj": {
        "id": "tsprj",
        "config": {
            "name": "{0}",
            "dependencies": {
                "circuit-playground": "*"
            },
            "description": "",
            "files": [
                "main.ts",
                "README.md"
            ],
            "additionalFilePaths": []
        },
        "files": {
            "main.ts": "\n",
            "README.md": ""
        }
    },
    "bundledpkgs": {
        "jc": {
            "jc.cpp": "#include \"pxt.h\"\r\nusing namespace pxt;\r\nnamespace jcNamespace {\r\n    //%\r\n    int readSomething() {\r\n        return 5;\r\n    }\r\n}\r\n",
            "jc.ts": "/**\n * access to jc\n */\n//% color=190 weight=100 block=\"jc\"\nnamespace jcNamespace {\n    /**\n     * function to return something\n     * @returns something\n     */\n    //% shim=jcNamespace::readSomething\n    //% blockId=jcNamespace_readSomething block=\"readSomething\"\n    export function readSomething(): int32 {\n\t\t  return 2;   \n    }\n}\n",
            "pxt.json": "{\n    \"name\": \"jc\",\n    \"description\": \"experimental jc\",\n    \"dependencies\": {\n        \"core---samd\": \"*\"\n    },\n    \"files\": [\n        \"jc.cpp\",\n        \"jc.ts\"\n    ],\n    \"public\": false,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n"
        },
        "jcevent": {
            "jcevent.cpp": "#include \"pxt.h\"\r\n\r\n// namespace pxt {\r\n//     codal::LevelDetectorSPL* getMicrophoneLevel();\r\n// }\r\n\r\n#define DEVICE_ID_US 973\r\n\r\nnamespace input {\r\n/**\r\n* Registers an event\r\n*/\r\n//% help=input/on-event\r\n//% blockId=input_on_event block=\"on event\"\r\n//% weight=88 blockGap=12\r\nvoid onEvent(Action handler) {\r\n//    pxt::getMicrophoneLevel(); // wake up service\r\n    registerWithDal(DEVICE_ID_US, 50, handler);\r\n}\r\n\r\n/**\r\n* trigger the event\r\n*/\r\n//% help=input/trigger\r\n//% blockId=input_trigger block=\"trigger\"\r\n//% weight=14 blockGap=8\r\nvoid trigger() {\r\n    // auto level = pxt::getMicrophoneLevel();\r\n    // if (NULL == level)\r\n    //     return;\r\n\r\n    Event(DEVICE_ID_US, 50);\r\n}\r\n}",
            "pxt.json": "{\n    \"name\": \"jcevent\",\n    \"description\": \"jc event test library\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"jcevent.cpp\",\n        \"shims.d.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Registers an event\n     */\n    //% help=input/on-event\n    //% blockId=input_on_event block=\"on event\"\n    //% weight=88 blockGap=12 shim=input::onEvent\n    function onEvent(handler: () => void): void;\n\n    /**\n     * trigger the event\n     */\n    //% help=input/trigger\n    //% blockId=input_trigger block=\"trigger\"\n    //% weight=14 blockGap=8 shim=input::trigger\n    function trigger(): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "jcstubborn": {
            "enums.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace jctwo {\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "jcstubborn.cpp": "#include \"pxt.h\"\r\nusing namespace pxt;\r\n\r\n// if you annotate the namespace here, it'll generate both the shims.d.ts and the enums.d.ts\r\n// for you to add to pxt.json . \r\n\r\n//% color=190 weight=100 block=\"jc more\"\r\nnamespace jctwo {\r\n/**\r\n * Reads something\r\n * @returns something\r\n */\r\n//% blockId=jcreadsomething block=\"readsomme\"\r\nint readsome() {\r\n    return 99;\r\n}\r\n}\r\n",
            "pxt.json": "{\n    \"name\": \"jcstubborn\",\n    \"description\": \"experimental jc stubborn\",\n    \"dependencies\": {\n        \"core---samd\": \"*\"\n    },\n    \"files\": [\n        \"jcstubborn.cpp\",\n        \"enums.d.ts\",\n        \"shims.d.ts\"\n    ],\n    \"public\": false,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\n\n    //% color=190 weight=100 block=\"jc more\"\ndeclare namespace jctwo {\n\n    /**\n     * Reads something\n     * @returns something\n     */\n    //% blockId=jcreadsomething block=\"readsomme\" shim=jctwo::readsome\n    function readsome(): int32;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "base": {
            "README.md": "# base\n\nThe base library, shared by all C++ targets (not only Codal-based).\n\n\n",
            "advmath.cpp": "#include \"pxtbase.h\"\n\nusing namespace std;\n\n#define SINGLE(op) return fromDouble(::op(toDouble(x)));\n\nnamespace Math_ {\n\n//%\nTNumber log2(TNumber x){SINGLE(log2)}\n//%\nTNumber exp(TNumber x){SINGLE(exp)}\n//%\nTNumber tanh(TNumber x){SINGLE(tanh)}\n//%\nTNumber sinh(TNumber x){SINGLE(sinh)}\n//%\nTNumber cosh(TNumber x){SINGLE(cosh)}\n//%\nTNumber atanh(TNumber x){SINGLE(atanh)}\n//%\nTNumber asinh(TNumber x){SINGLE(asinh)}\n//%\nTNumber acosh(TNumber x){SINGLE(acosh)}\n\n}",
            "buffer.cpp": "#include \"pxtbase.h\"\n#include <limits.h>\n\nusing namespace std;\n\n//% indexerGet=BufferMethods::getByte indexerSet=BufferMethods::setByte\nnamespace BufferMethods {\n//%\nuint8_t *getBytes(Buffer buf) {\n    return buf->data;\n}\n\n//%\nint getByte(Buffer buf, int off) {\n    if (buf && 0 <= off && off < buf->length)\n        return buf->data[off];\n    return 0;\n}\n\n//%\nvoid setByte(Buffer buf, int off, int v) {\n    if (buf && 0 <= off && off < buf->length)\n        buf->data[off] = v;\n}\n\n/**\n* Reads an unsigned byte at a particular location\n*/\n//%\nint getUint8(Buffer buf, int off) {\n    return getByte(buf, off);\n}\n\n/**\n * Returns false when the buffer can be written to.\n */\n//%\nbool isReadOnly(Buffer buf) {\n    return buf->isReadOnly();\n}\n\n/**\n* Writes an unsigned byte at a particular location\n*/\n//%\nvoid setUint8(Buffer buf, int off, int v) {\n    setByte(buf, off, v);\n}\n\nint writeBuffer(Buffer buf, int dstOffset, Buffer src, int srcOffset = 0, int length = -1) {\n    if (length < 0)\n        length = src->length;\n\n    if (srcOffset < 0 || dstOffset < 0 || dstOffset > buf->length)\n        return -1;\n\n    length = min(src->length - srcOffset, buf->length - dstOffset);\n\n    if (length < 0)\n        return -1;\n\n    if (buf == src) {\n        memmove(buf->data + dstOffset, src->data + srcOffset, length);\n    } else {\n        memcpy(buf->data + dstOffset, src->data + srcOffset, length);\n    }\n\n    return 0;\n}\n\n/**\n * Write a number in specified format in the buffer.\n */\n//%\nvoid setNumber(Buffer buf, NumberFormat format, int offset, TNumber value) {\n    if (offset < 0)\n        return;\n    setNumberCore(buf->data + offset, buf->length - offset, format, value);\n}\n\n/**\n * Read a number in specified format from the buffer.\n */\n//%\nTNumber getNumber(Buffer buf, NumberFormat format, int offset) {\n    if (offset < 0)\n        return fromInt(0);\n    return getNumberCore(buf->data + offset, buf->length - offset, format);\n}\n\n/** Returns the length of a Buffer object. */\n//% property\nint length(Buffer s) {\n    return s->length;\n}\n\n/**\n * Fill (a fragment) of the buffer with given value.\n */\n//%\nvoid fill(Buffer buf, int value, int offset = 0, int length = -1) {\n    if (offset < 0 || offset > buf->length)\n        return; // DEVICE_INVALID_PARAMETER;\n    if (length < 0)\n        length = buf->length;\n    length = min(length, buf->length - offset);\n    memset(buf->data + offset, value, length);\n}\n\n/**\n * Return a copy of a fragment of a buffer.\n */\n//%\nBuffer slice(Buffer buf, int offset = 0, int length = -1) {\n    offset = min((int)buf->length, offset);\n    if (length < 0)\n        length = buf->length;\n    length = min(length, buf->length - offset);\n    return mkBuffer(buf->data + offset, length);\n}\n\n/**\n * Shift buffer left in place, with zero padding.\n * @param offset number of bytes to shift; use negative value to shift right\n * @param start start offset in buffer. Default is 0.\n * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n * start. eg: -1\n */\n//%\nvoid shift(Buffer buf, int offset, int start = 0, int length = -1) {\n    if (length < 0)\n        length = buf->length - start;\n    if (start < 0 || start + length > buf->length || start + length < start || length == 0 ||\n        offset == 0 || offset == INT_MIN)\n        return;\n    if (offset <= -length || offset >= length) {\n        fill(buf, 0);\n        return;\n    }\n\n    uint8_t *data = buf->data + start;\n    if (offset < 0) {\n        offset = -offset;\n        memmove(data + offset, data, length - offset);\n        memset(data, 0, offset);\n    } else {\n        length = length - offset;\n        memmove(data, data + offset, length);\n        memset(data + length, 0, offset);\n    }\n}\n\n/**\n * Convert a buffer to string assuming UTF8 encoding\n */\n//%\nString toString(Buffer buf) {\n    return mkString((char *)buf->data, buf->length);\n}\n\n/**\n * Convert a buffer to its hexadecimal representation.\n */\n//%\nString toHex(Buffer buf) {\n    const char *hex = \"0123456789abcdef\";\n    auto res = mkStringCore(NULL, buf->length * 2);\n    for (int i = 0; i < buf->length; ++i) {\n        res->ascii.data[i << 1] = hex[buf->data[i] >> 4];\n        res->ascii.data[(i << 1) + 1] = hex[buf->data[i] & 0xf];\n    }\n    return res;\n}\n\n/**\n * Rotate buffer left in place.\n * @param offset number of bytes to shift; use negative value to shift right\n * @param start start offset in buffer. Default is 0.\n * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n * start. eg: -1\n */\n//%\nvoid rotate(Buffer buf, int offset, int start = 0, int length = -1) {\n    if (length < 0)\n        length = buf->length - start;\n    if (start < 0 || start + length > buf->length || start + length < start || length == 0 ||\n        offset == 0 || offset == INT_MIN)\n        return;\n\n    if (offset < 0)\n        offset += length << 8; // try to make it positive\n    offset %= length;\n    if (offset < 0)\n        offset += length;\n\n    uint8_t *data = buf->data + start;\n\n    uint8_t *n_first = data + offset;\n    uint8_t *first = data;\n    uint8_t *next = n_first;\n    uint8_t *last = data + length;\n\n    while (first != next) {\n        uint8_t tmp = *first;\n        *first++ = *next;\n        *next++ = tmp;\n        if (next == last) {\n            next = n_first;\n        } else if (first == n_first) {\n            n_first = next;\n        }\n    }\n}\n\n/**\n * Write contents of `src` at `dstOffset` in current buffer.\n */\n//%\nvoid write(Buffer buf, int dstOffset, Buffer src) {\n    // srcOff and length not supported, we only do up to 4 args :/\n    writeBuffer(buf, dstOffset, src, 0, -1);\n}\n\n/**\n * Compute k-bit FNV-1 non-cryptographic hash of the buffer.\n */\n//%\nuint32_t hash(Buffer buf, int bits) {\n    if (bits < 1)\n        return 0;\n    uint32_t h = hash_fnv1(buf->data, buf->length);\n    if (bits >= 32)\n        return h;\n    else\n        return ((h ^ (h >> bits)) & ((1 << bits) - 1));\n}\n\n} // namespace BufferMethods\n\n// The functions below are deprecated in control namespace, but they are referenced\n// in Buffer namespaces via explicit shim=...\nnamespace control {\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//% deprecated=1\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n\n\n/**\n * Create a new buffer with UTF8-encoded string\n * @param str the string to put in the buffer\n */\n//% deprecated=1\nBuffer createBufferFromUTF8(String str) {\n#if PXT_UTF8\n    auto sz = toRealUTF8(str, NULL);\n    auto r = mkBuffer(NULL, sz);\n    toRealUTF8(str, r->data);\n    return r;\n#else\n    return mkBuffer((const uint8_t *)str->getUTF8Data(), str->getUTF8Size());\n#endif\n}\n} // namespace control\n\nnamespace pxt {\nstatic int writeBytes(uint8_t *dst, uint8_t *src, int length, bool swapBytes, int szLeft) {\n    if (szLeft < length) {\n        return -1;\n    }\n\n    if (swapBytes) {\n        uint8_t *p = dst + length;\n        for (int i = 0; i < length; ++i)\n            *--p = src[i];\n    } else {\n        if (length == 4 && ((uintptr_t)dst & 3) == 0)\n            *(uint32_t *)dst = *(uint32_t *)src;\n        else if (length == 2 && ((uintptr_t)dst & 1) == 0)\n            *(uint16_t *)dst = *(uint16_t *)src;\n        else\n            memcpy(dst, src, length);\n    }\n\n    return 0;\n}\n\nstatic int readBytes(uint8_t *src, uint8_t *dst, int length, bool swapBytes, int szLeft) {\n    if (szLeft < length) {\n        memset(dst, 0, length);\n        return -1;\n    }\n\n    if (swapBytes) {\n        uint8_t *p = src + length;\n        for (int i = 0; i < length; ++i)\n            dst[i] = *--p;\n    } else {\n        if (length == 4 && ((uintptr_t)src & 3) == 0)\n            *(uint32_t *)dst = *(uint32_t *)src;\n        else if (length == 2 && ((uintptr_t)src & 1) == 0)\n            *(uint16_t *)dst = *(uint16_t *)src;\n        else\n            memcpy(dst, src, length);\n    }\n\n    return 0;\n}\n\nvoid setNumberCore(uint8_t *buf, int szLeft, NumberFormat format, TNumber value) {\n    int8_t i8;\n    uint8_t u8;\n    int16_t i16;\n    uint16_t u16;\n    int32_t i32;\n    uint32_t u32;\n    float f32;\n    double f64;\n\n// Assume little endian\n#define WRITEBYTES(isz, swap, toInt)                                                               \\\n    isz = toInt(value);                                                                            \\\n    writeBytes(buf, (uint8_t *)&isz, sizeof(isz), swap, szLeft);                                   \\\n    break\n\n    switch (format) {\n    case NumberFormat::Int8LE:\n        WRITEBYTES(i8, false, toInt);\n    case NumberFormat::UInt8LE:\n        WRITEBYTES(u8, false, toInt);\n    case NumberFormat::Int16LE:\n        WRITEBYTES(i16, false, toInt);\n    case NumberFormat::UInt16LE:\n        WRITEBYTES(u16, false, toInt);\n    case NumberFormat::Int32LE:\n        WRITEBYTES(i32, false, toInt);\n    case NumberFormat::UInt32LE:\n        WRITEBYTES(u32, false, toUInt);\n\n    case NumberFormat::Int8BE:\n        WRITEBYTES(i8, true, toInt);\n    case NumberFormat::UInt8BE:\n        WRITEBYTES(u8, true, toInt);\n    case NumberFormat::Int16BE:\n        WRITEBYTES(i16, true, toInt);\n    case NumberFormat::UInt16BE:\n        WRITEBYTES(u16, true, toInt);\n    case NumberFormat::Int32BE:\n        WRITEBYTES(i32, true, toInt);\n    case NumberFormat::UInt32BE:\n        WRITEBYTES(u32, true, toUInt);\n\n    case NumberFormat::Float32LE:\n        WRITEBYTES(f32, false, toFloat);\n    case NumberFormat::Float32BE:\n        WRITEBYTES(f32, true, toFloat);\n    case NumberFormat::Float64LE:\n        WRITEBYTES(f64, false, toDouble);\n    case NumberFormat::Float64BE:\n        WRITEBYTES(f64, true, toDouble);\n    }\n}\n\nTNumber getNumberCore(uint8_t *buf, int szLeft, NumberFormat format) {\n    int8_t i8;\n    uint8_t u8;\n    int16_t i16;\n    uint16_t u16;\n    int32_t i32;\n    uint32_t u32;\n    float f32;\n    double f64;\n\n// Assume little endian\n#define READBYTES(isz, swap, conv)                                                                 \\\n    readBytes(buf, (uint8_t *)&isz, sizeof(isz), swap, szLeft);                                    \\\n    return conv(isz)\n\n    switch (format) {\n    case NumberFormat::Int8LE:\n        READBYTES(i8, false, fromInt);\n    case NumberFormat::UInt8LE:\n        READBYTES(u8, false, fromInt);\n    case NumberFormat::Int16LE:\n        READBYTES(i16, false, fromInt);\n    case NumberFormat::UInt16LE:\n        READBYTES(u16, false, fromInt);\n    case NumberFormat::Int32LE:\n        READBYTES(i32, false, fromInt);\n    case NumberFormat::UInt32LE:\n        READBYTES(u32, false, fromUInt);\n\n    case NumberFormat::Int8BE:\n        READBYTES(i8, true, fromInt);\n    case NumberFormat::UInt8BE:\n        READBYTES(u8, true, fromInt);\n    case NumberFormat::Int16BE:\n        READBYTES(i16, true, fromInt);\n    case NumberFormat::UInt16BE:\n        READBYTES(u16, true, fromInt);\n    case NumberFormat::Int32BE:\n        READBYTES(i32, true, fromInt);\n    case NumberFormat::UInt32BE:\n        READBYTES(u32, true, fromUInt);\n\n    case NumberFormat::Float32LE:\n        READBYTES(f32, false, fromFloat);\n    case NumberFormat::Float32BE:\n        READBYTES(f32, true, fromFloat);\n    case NumberFormat::Float64LE:\n        READBYTES(f64, false, fromDouble);\n    case NumberFormat::Float64BE:\n        READBYTES(f64, true, fromDouble);\n    }\n\n    return 0;\n}\n} // namespace pxt\n",
            "buffer.ts": "namespace pins {\n    //% deprecated=1\n    export function sizeOf(format: NumberFormat) {\n        return Buffer.sizeOfNumberFormat(format)\n    }\n\n    //% deprecated=1\n    export function createBufferFromArray(bytes: number[]) {\n        return Buffer.fromArray(bytes)\n    }\n\n    //% deprecated=1\n    export function packedSize(format: string) {\n        return Buffer.packedSize(format)\n    }\n\n    //% deprecated=1\n    export function packBuffer(format: string, nums: number[]) {\n        return Buffer.pack(format, nums)\n    }\n\n    //% deprecated=1\n    export function packIntoBuffer(format: string, buf: Buffer, offset: number, nums: number[]) {\n        buf.packAt(offset, format, nums)\n    }\n\n    //% deprecated=1\n    export function unpackBuffer(format: string, buf: Buffer, offset = 0) {\n        return buf.unpack(format, offset)\n    }\n\n    //% deprecated=1\n    export function concatBuffers(bufs: Buffer[]) {\n        return Buffer.concat(bufs)\n    }\n}\n\n// see http://msgpack.org/ for the spec\n// it currently only implements numbers and their sequances\n// once we handle any type and typeof expressions we can do more\n\nnamespace msgpack {\n    function tagFormat(tag: number) {\n        switch (tag) {\n            case 0xCB: return NumberFormat.Float64BE\n            case 0xCC: return NumberFormat.UInt8BE\n            case 0xCD: return NumberFormat.UInt16BE\n            case 0xCE: return NumberFormat.UInt32BE\n            case 0xD0: return NumberFormat.Int8BE\n            case 0xD1: return NumberFormat.Int16BE\n            case 0xD2: return NumberFormat.Int32BE\n            default:\n                return null\n        }\n    }\n\n    function packNumberCore(buf: Buffer, offset: number, num: number) {\n        let tag = 0xCB\n        if (num == (num << 0) || num == (num >>> 0)) {\n            if (-31 <= num && num <= 127) {\n                if (buf) buf[offset] = num\n                return 1\n            } else if (0 <= num) {\n                if (num <= 0xff) {\n                    tag = 0xCC\n                } else if (num <= 0xffff) {\n                    tag = 0xCD\n                } else {\n                    tag = 0xCE\n                }\n            } else {\n                if (-0x7f <= num) {\n                    tag = 0xD0\n                } else if (-0x7fff <= num) {\n                    tag = 0xD1\n                } else {\n                    tag = 0xD2\n                }\n            }\n        }\n        let fmt = tagFormat(tag)\n        if (buf) {\n            buf[offset] = tag\n            buf.setNumber(fmt, offset + 1, num)\n        }\n        return pins.sizeOf(fmt) + 1\n    }\n\n    /**\n     * Unpacks a buffer into a number array.\n     */\n    export function unpackNumberArray(buf: Buffer, offset = 0): number[] {\n        let res: number[] = []\n\n        while (offset < buf.length) {\n            let fmt = tagFormat(buf[offset++])\n            if (fmt === null) {\n                let v = buf.getNumber(NumberFormat.Int8BE, offset - 1)\n                if (-31 <= v && v <= 127)\n                    res.push(v)\n                else\n                    return null\n            } else {\n                res.push(buf.getNumber(fmt, offset))\n                offset += pins.sizeOf(fmt)\n            }\n            // padding at the end\n            while (buf[offset] === 0xc1) offset++;\n        }\n\n        return res\n    }\n\n    /**\n     * Pack a number array into a buffer.\n     * @param nums the numbers to be packed\n     */\n    export function packNumberArray(nums: number[]): Buffer {\n        let off = 0\n        for (let n of nums) {\n            off += packNumberCore(null, off, n)\n        }\n        let buf = Buffer.create(off)\n        off = 0\n        for (let n of nums) {\n            off += packNumberCore(buf, off, n)\n        }\n        return buf\n    }\n}\n\nnamespace helpers {\n    export function bufferConcat(a: Buffer, b: Buffer) {\n        const r = Buffer.create(a.length + b.length)\n        r.write(0, a)\n        r.write(a.length, b)\n        return r\n    }\n\n    export function bufferEquals(l: Buffer, r: Buffer) {\n        if (!l || !r) return !!l == !!r;\n        if (l.length != r.length) return false;\n        for (let i = 0; i < l.length; ++i) {\n            if (l[i] != r[i])\n                return false;\n        }\n        return true;\n    }\n\n    export function bufferIndexOf(a: Buffer, b: Buffer) {\n        for (let i = 0; i <= a.length - b.length; ++i) {\n            if (a[i] == b[0]) {\n                let j = 0\n                while (j < b.length) {\n                    if (a[i + j] != b[j])\n                        break\n                    j++\n                }\n                if (j >= b.length)\n                    return i\n            }\n        }\n        return -1\n    }\n\n    export function bufferUnpack(buf: Buffer, format: string, offset?: number) {\n        if (!offset) offset = 0\n        let res: number[] = []\n        Buffer.__packUnpackCore(format, res, buf, false, offset)\n        return res\n    }\n\n    export function bufferPackAt(buf: Buffer, offset: number, format: string, nums: number[]) {\n        Buffer.__packUnpackCore(format, nums, buf, true, offset)\n    }\n\n    export function bufferChunked(buf: Buffer, maxBytes: number) {\n        if (buf.length <= maxBytes) return [buf]\n        else {\n            const r: Buffer[] = []\n            for (let i = 0; i < buf.length; i += maxBytes)\n                r.push(buf.slice(i, maxBytes))\n            return r\n        }\n    }\n\n    export function bufferToArray(buf: Buffer, format: NumberFormat) {\n        const sz = Buffer.sizeOfNumberFormat(format)\n        const len = buf.length - sz\n        const r: number[] = []\n        for (let i = 0; i <= len; i += sz)\n            r.push(buf.getNumber(format, i))\n        return r\n    }\n}\n\ninterface Buffer {\n    [index: number]: number;\n\n    /**\n     * Return concatenation of current buffer and the given buffer\n     */\n    //% helper=bufferConcat\n    concat(other: Buffer): Buffer;\n\n    /**\n     * Return position of other buffer in current buffer\n     */\n    //% helper=bufferIndexOf\n    indexOf(other: Buffer): number;\n\n    /**\n     * Reads numbers from the buffer according to the format\n     */\n    //% helper=bufferUnpack\n    unpack(format: string, offset?: number): number[];\n\n    /**\n     * Writes numbers to the buffer according to the format\n     */\n    //% helper=bufferPackAt\n    packAt(offset: number, format: string, nums: number[]): void;\n\n    /**\n     * Returns true if this and the other buffer hold the same data\n     */\n    //% helper=bufferEquals\n    equals(other: Buffer): boolean;\n\n    /**\n     * Splits buffer into parts no larger than specified\n     */\n    //% helper=bufferChunked\n    chunked(maxSize: number): Buffer[];\n\n\n    /**\n     * Read contents of buffer as an array in specified format\n     */\n    //% helper=bufferToArray\n    toArray(format: NumberFormat): number[];\n\n    // rest defined in buffer.cpp\n}\n\nnamespace Buffer {\n    /**\n     * Allocate a new buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=control::createBuffer\n    export declare function create(size: number): Buffer;\n\n    /**\n     * Create a new buffer, decoding a hex string\n     */\n    export function fromHex(hex: string) {\n        const hexStr = \"0123456789abcdef\"\n        const res = Buffer.create(hex.length >> 1)\n        hex = hex.toLowerCase()\n        for (let i = 0; i < hex.length; i += 2) {\n            const p0 = hexStr.indexOf(hex.charAt(i))\n            const p1 = hexStr.indexOf(hex.charAt(i + 1))\n            if (p0 < 0 || p1 < 0)\n                throw \"Invalid hex\"\n            res[i >> 1] = (p0 << 4) | p1\n        }\n        return res\n    }\n\n    /**\n     * Create a new buffer with UTF8-encoded string\n     * @param str the string to put in the buffer\n     */\n    //% shim=control::createBufferFromUTF8\n    export declare function fromUTF8(str: string): Buffer;\n\n    function chunkLen(s: string, off: number, maxlen: number) {\n        let L = Math.idiv(maxlen, 3)\n        let R = maxlen\n\n        if (fromUTF8(s.slice(off, off + R)).length <= maxlen)\n            return R\n\n        while (L < R) {\n            const m = (L + R) >> 1\n            if (m == L)\n                break\n            const ll = fromUTF8(s.slice(off, off + m)).length\n            if (ll <= maxlen)\n                L = m\n            else\n                R = m\n        }\n\n        return L\n    }\n\n    export function chunkedFromUTF8(str: string, maxBytes: number) {\n        if (maxBytes < 3)\n            throw \"Oops\"\n        const chunks: Buffer[] = []\n        let pos = 0\n        while (pos < str.length) {\n            const len = chunkLen(str, pos, maxBytes)\n            chunks.push(fromUTF8(str.slice(pos, pos + len)))\n            pos += len\n        }\n        return chunks\n    }\n\n    /**\n     * Create a new buffer initialized to bytes from given array.\n     * @param bytes data to initialize with\n     */\n    export function fromArray(bytes: number[]) {\n        let buf = Buffer.create(bytes.length)\n        for (let i = 0; i < bytes.length; ++i)\n            buf[i] = bytes[i]\n        return buf\n    }\n\n    /**\n     * Concatenates all buffers in the list\n     */\n    export function concat(buffers: Buffer[]) {\n        let len = 0\n        for (let b of buffers)\n            len += b.length\n        const r = Buffer.create(len)\n        len = 0\n        for (let b of buffers) {\n            r.write(len, b)\n            len += b.length\n        }\n        return r\n    }\n\n    // Python-like packing, see https://docs.python.org/3/library/struct.html\n\n    export function packedSize(format: string) {\n        return __packUnpackCore(format, null, null, true)\n    }\n\n    export function pack(format: string, nums: number[]) {\n        let buf = Buffer.create(packedSize(format))\n        __packUnpackCore(format, nums, buf, true)\n        return buf\n    }\n\n    function getFormat(pychar: string, isBig: boolean) {\n        switch (pychar) {\n            case 'B':\n                return NumberFormat.UInt8LE\n            case 'b':\n                return NumberFormat.Int8LE\n            case 'H':\n                return isBig ? NumberFormat.UInt16BE : NumberFormat.UInt16LE\n            case 'h':\n                return isBig ? NumberFormat.Int16BE : NumberFormat.Int16LE\n            case 'I':\n            case 'L':\n                return isBig ? NumberFormat.UInt32BE : NumberFormat.UInt32LE\n            case 'i':\n            case 'l':\n                return isBig ? NumberFormat.Int32BE : NumberFormat.Int32LE\n            case 'f':\n                return isBig ? NumberFormat.Float32BE : NumberFormat.Float32LE\n            case 'd':\n                return isBig ? NumberFormat.Float64BE : NumberFormat.Float64LE\n            default:\n                return null as NumberFormat\n        }\n    }\n\n    function isDigit(ch: string) {\n        const code = ch.charCodeAt(0)\n        return 0x30 <= code && code <= 0x39\n    }\n\n    export function __packUnpackCore(format: string, nums: number[], buf: Buffer, isPack: boolean, off = 0) {\n        let isBig = false\n        let idx = 0\n        for (let i = 0; i < format.length; ++i) {\n            switch (format[i]) {\n                case ' ':\n                case '<':\n                case '=':\n                    isBig = false\n                    break\n                case '>':\n                case '!':\n                    isBig = true\n                    break\n                default:\n                    const i0 = i\n                    while (isDigit(format[i])) i++\n                    let reps = 1\n                    if (i0 != i)\n                        reps = parseInt(format.slice(i0, i))\n                    if (format[i] == 'x')\n                        off += reps\n                    else\n                        while (reps--) {\n                            let fmt = getFormat(format[i], isBig)\n                            if (fmt === null) {\n                                control.fail(\"Unsupported format character: \" + format[i])\n                            } else {\n                                if (buf) {\n                                    if (isPack)\n                                        buf.setNumber(fmt, off, nums[idx++])\n                                    else\n                                        nums.push(buf.getNumber(fmt, off))\n                                }\n\n                                off += sizeOfNumberFormat(fmt)\n                            }\n                        }\n                    break\n            }\n        }\n        return off\n    }\n\n    /**\n     * Get the size in bytes of specified number format.\n     */\n    export function sizeOfNumberFormat(format: NumberFormat) {\n        switch (format) {\n            case NumberFormat.Int8LE:\n            case NumberFormat.UInt8LE:\n            case NumberFormat.Int8BE:\n            case NumberFormat.UInt8BE:\n                return 1;\n            case NumberFormat.Int16LE:\n            case NumberFormat.UInt16LE:\n            case NumberFormat.Int16BE:\n            case NumberFormat.UInt16BE:\n                return 2;\n            case NumberFormat.Int32LE:\n            case NumberFormat.Int32BE:\n            case NumberFormat.UInt32BE:\n            case NumberFormat.UInt32LE:\n            case NumberFormat.Float32BE:\n            case NumberFormat.Float32LE:\n                return 4;\n            case NumberFormat.Float64BE:\n            case NumberFormat.Float64LE:\n                return 8;\n        }\n        return 0;\n    }\n}\n",
            "configkeys.h": "#ifndef __PXT_CONFIGKEYS_H\n#define __PXT_CONFIGKEYS_H\n\n// used by pins.cpp to mask off the pin name from any config\n// lower 16 pins of value are the pin name\n#define CFG_PIN_NAME_MSK 0x0000ffff\n// upper 16 bits of value is any configuration of the pin.\n#define CFG_PIN_CONFIG_MSK 0xffff0000\n\n// begin optional pin configurations\n#define CFG_PIN_CONFIG_ACTIVE_LO 0x10000\n\n\n#define CFG_MAGIC0 0x1e9e10f1\n#define CFG_MAGIC1 0x20227a79\n\n// these define keys for getConfig() function\n#define CFG_PIN_ACCELEROMETER_INT 1\n#define CFG_PIN_ACCELEROMETER_SCL 2\n#define CFG_PIN_ACCELEROMETER_SDA 3\n#define CFG_PIN_BTN_A 4\n#define CFG_PIN_BTN_B 5\n#define CFG_PIN_BTN_SLIDE 6\n#define CFG_PIN_DOTSTAR_CLOCK 7\n#define CFG_PIN_DOTSTAR_DATA 8\n#define CFG_PIN_FLASH_CS 9\n#define CFG_PIN_FLASH_MISO 10\n#define CFG_PIN_FLASH_MOSI 11\n#define CFG_PIN_FLASH_SCK 12\n#define CFG_PIN_LED 13\n#define CFG_PIN_LIGHT 14\n#define CFG_PIN_MICROPHONE 15\n#define CFG_PIN_MIC_CLOCK 16\n#define CFG_PIN_MIC_DATA 17\n#define CFG_PIN_MISO 18\n#define CFG_PIN_MOSI 19\n// the preferred pin to drive an external neopixel strip\n#define CFG_PIN_NEOPIXEL 20\n#define CFG_PIN_RX 21\n#define CFG_PIN_RXLED 22\n#define CFG_PIN_SCK 23\n#define CFG_PIN_SCL 24\n#define CFG_PIN_SDA 25\n#define CFG_PIN_SPEAKER_AMP 26\n#define CFG_PIN_TEMPERATURE 27\n#define CFG_PIN_TX 28\n#define CFG_PIN_TXLED 29\n#define CFG_PIN_IR_OUT 30\n#define CFG_PIN_IR_IN 31\n#define CFG_PIN_DISPLAY_SCK 32\n#define CFG_PIN_DISPLAY_MISO 33\n#define CFG_PIN_DISPLAY_MOSI 34\n#define CFG_PIN_DISPLAY_CS 35\n#define CFG_PIN_DISPLAY_DC 36\n#define CFG_DISPLAY_WIDTH 37\n#define CFG_DISPLAY_HEIGHT 38\n#define CFG_DISPLAY_CFG0 39\n#define CFG_DISPLAY_CFG1 40\n#define CFG_DISPLAY_CFG2 41\n#define CFG_DISPLAY_CFG3 42\n#define CFG_PIN_DISPLAY_RST 43\n#define CFG_PIN_DISPLAY_BL 44\n#define CFG_PIN_SERVO_1 45\n#define CFG_PIN_SERVO_2 46\n#define CFG_PIN_BTN_LEFT 47\n#define CFG_PIN_BTN_RIGHT 48\n#define CFG_PIN_BTN_UP 49\n#define CFG_PIN_BTN_DOWN 50\n#define CFG_PIN_BTN_MENU 51\n#define CFG_PIN_LED_R 52\n#define CFG_PIN_LED_G 53\n#define CFG_PIN_LED_B 54\n#define CFG_PIN_LED1 55\n#define CFG_PIN_LED2 56\n#define CFG_PIN_LED3 57\n#define CFG_PIN_LED4 58\n#define CFG_SPEAKER_VOLUME 59\n\n#define CFG_PIN_JACK_TX 60\n#define CFG_PIN_JACK_SENSE 61\n#define CFG_PIN_JACK_HPEN 62\n#define CFG_PIN_JACK_BZEN 63\n#define CFG_PIN_JACK_PWREN 64\n#define CFG_PIN_JACK_SND 65\n#define CFG_PIN_JACK_BUSLED 66\n#define CFG_PIN_JACK_COMMLED 67\n\n#define CFG_PIN_BTN_SOFT_RESET 69\n#define CFG_ACCELEROMETER_TYPE 70\n#define CFG_PIN_BTNMX_LATCH 71\n#define CFG_PIN_BTNMX_CLOCK 72\n#define CFG_PIN_BTNMX_DATA 73\n#define CFG_PIN_BTN_MENU2 74\n#define CFG_PIN_BATTSENSE 75\n#define CFG_PIN_VIBRATION 76\n#define CFG_PIN_PWREN 77\n#define CFG_DISPLAY_TYPE 78\n\n#define CFG_PIN_ROTARY_ENCODER_A 79\n#define CFG_PIN_ROTARY_ENCODER_B 80\n\n#define CFG_ACCELEROMETER_SPACE 81\n\n#define CFG_PIN_WIFI_MOSI 82\n#define CFG_PIN_WIFI_MISO 83\n#define CFG_PIN_WIFI_SCK 84\n#define CFG_PIN_WIFI_TX 85\n#define CFG_PIN_WIFI_RX 86\n#define CFG_PIN_WIFI_CS 87\n#define CFG_PIN_WIFI_BUSY 88\n#define CFG_PIN_WIFI_RESET 89\n#define CFG_PIN_WIFI_GPIO0 90\n#define CFG_PIN_WIFI_AT_TX 91\n#define CFG_PIN_WIFI_AT_RX 92\n\n#define CFG_PIN_USB_POWER 93\n\n// default I2C address\n#define ACCELEROMETER_TYPE_LIS3DH 0x32\n#define ACCELEROMETER_TYPE_LIS3DH_ALT 0x30\n#define ACCELEROMETER_TYPE_MMA8453 0x38\n#define ACCELEROMETER_TYPE_FXOS8700 0x3C\n#define ACCELEROMETER_TYPE_MMA8653 0x3A\n#define ACCELEROMETER_TYPE_MSA300 0x4C\n#define ACCELEROMETER_TYPE_MPU6050 0x68\n\n#define DISPLAY_TYPE_ST7735 7735\n#define DISPLAY_TYPE_ILI9341 9341\n#define DISPLAY_TYPE_SMART 4242\n\n#define CFG_PIN_A0 100\n#define CFG_PIN_A1 101\n#define CFG_PIN_A2 102\n#define CFG_PIN_A3 103\n#define CFG_PIN_A4 104\n#define CFG_PIN_A5 105\n#define CFG_PIN_A6 106\n#define CFG_PIN_A7 107\n#define CFG_PIN_A8 108\n#define CFG_PIN_A9 109\n#define CFG_PIN_A10 110\n#define CFG_PIN_A11 111\n#define CFG_PIN_A12 112\n#define CFG_PIN_A13 113\n#define CFG_PIN_A14 114\n#define CFG_PIN_A15 115\n#define CFG_PIN_A16 116\n#define CFG_PIN_A17 117\n#define CFG_PIN_A18 118\n#define CFG_PIN_A19 119\n#define CFG_PIN_A20 120\n#define CFG_PIN_A21 121\n#define CFG_PIN_A22 122\n#define CFG_PIN_A23 123\n#define CFG_PIN_A24 124\n#define CFG_PIN_A25 125\n#define CFG_PIN_A26 126\n#define CFG_PIN_A27 127\n#define CFG_PIN_A28 128\n#define CFG_PIN_A29 129\n#define CFG_PIN_A30 130\n#define CFG_PIN_A31 131\n\n#define CFG_PIN_D0 150\n#define CFG_PIN_D1 151\n#define CFG_PIN_D2 152\n#define CFG_PIN_D3 153\n#define CFG_PIN_D4 154\n#define CFG_PIN_D5 155\n#define CFG_PIN_D6 156\n#define CFG_PIN_D7 157\n#define CFG_PIN_D8 158\n#define CFG_PIN_D9 159\n#define CFG_PIN_D10 160\n#define CFG_PIN_D11 161\n#define CFG_PIN_D12 162\n#define CFG_PIN_D13 163\n#define CFG_PIN_D14 164\n#define CFG_PIN_D15 165\n#define CFG_PIN_D16 166\n#define CFG_PIN_D17 167\n#define CFG_PIN_D18 168\n#define CFG_PIN_D19 169\n#define CFG_PIN_D20 170\n#define CFG_PIN_D21 171\n#define CFG_PIN_D22 172\n#define CFG_PIN_D23 173\n#define CFG_PIN_D24 174\n#define CFG_PIN_D25 175\n#define CFG_PIN_D26 176\n#define CFG_PIN_D27 177\n#define CFG_PIN_D28 178\n#define CFG_PIN_D29 179\n#define CFG_PIN_D30 180\n#define CFG_PIN_D31 181\n\n#define CFG_NUM_NEOPIXELS 200\n#define CFG_NUM_DOTSTARS 201\n#define CFG_DEFAULT_BUTTON_MODE 202\n#define CFG_SWD_ENABLED 203\n#define CFG_FLASH_BYTES 204\n#define CFG_RAM_BYTES 205\n#define CFG_SYSTEM_HEAP_BYTES 206\n#define CFG_LOW_MEM_SIMULATION_KB 207\n#define CFG_BOOTLOADER_BOARD_ID 208\n#define CFG_UF2_FAMILY 209\n#define CFG_PINS_PORT_SIZE 210\n#define CFG_BOOTLOADER_PROTECTION 211\n#define CFG_POWER_DEEPSLEEP_TIMEOUT 212\n#define CFG_ANALOG_BUTTON_THRESHOLD 213\n#define CFG_CPU_MHZ 214\n#define CFG_CONTROLLER_LIGHT_MAX_BRIGHTNESS 215\n#define CFG_ANALOG_JOYSTICK_MIN 216\n#define CFG_ANALOG_JOYSTICK_MAX 217\n#define CFG_TIMERS_TO_USE 218\n// configs to specify the onboard (built-in) dotstar or neopixel strips\n// some boards have a combination of dotstar, neopixel strips like neotrellis\n#define CFG_PIN_ONBOARD_DOTSTAR_CLOCK 219\n#define CFG_PIN_ONBOARD_DOTSTAR_DATA 220\n#define CFG_NUM_ONBOARD_DOTSTARS 221\n#define CFG_PIN_ONBOARD_NEOPIXEL 222\n#define CFG_NUM_ONBOARD_NEOPIXELS 223\n\n#define CFG_MATRIX_KEYPAD_MESSAGE_ID 239\n#define CFG_NUM_MATRIX_KEYPAD_ROWS 240\n#define CFG_PIN_MATRIX_KEYPAD_ROW0 241\n#define CFG_PIN_MATRIX_KEYPAD_ROW1 242\n#define CFG_PIN_MATRIX_KEYPAD_ROW2 243\n#define CFG_PIN_MATRIX_KEYPAD_ROW3 244\n#define CFG_PIN_MATRIX_KEYPAD_ROW4 245\n#define CFG_PIN_MATRIX_KEYPAD_ROW5 246\n#define CFG_PIN_MATRIX_KEYPAD_ROW6 247\n#define CFG_PIN_MATRIX_KEYPAD_ROW7 248\n#define CFG_NUM_MATRIX_KEYPAD_COLS 250\n#define CFG_PIN_MATRIX_KEYPAD_COL0 251\n#define CFG_PIN_MATRIX_KEYPAD_COL1 252\n#define CFG_PIN_MATRIX_KEYPAD_COL2 253\n#define CFG_PIN_MATRIX_KEYPAD_COL3 254\n#define CFG_PIN_MATRIX_KEYPAD_COL4 255\n#define CFG_PIN_MATRIX_KEYPAD_COL5 256\n#define CFG_PIN_MATRIX_KEYPAD_COL6 257\n#define CFG_PIN_MATRIX_KEYPAD_COL7 258\n\n#define CFG_PIN_B0 300\n#define CFG_PIN_B1 301\n#define CFG_PIN_B2 302\n#define CFG_PIN_B3 303\n#define CFG_PIN_B4 304\n#define CFG_PIN_B5 305\n#define CFG_PIN_B6 306\n#define CFG_PIN_B7 307\n#define CFG_PIN_B8 308\n#define CFG_PIN_B9 309\n#define CFG_PIN_B10 310\n#define CFG_PIN_B11 311\n#define CFG_PIN_B12 312\n#define CFG_PIN_B13 313\n#define CFG_PIN_B14 314\n#define CFG_PIN_B15 315\n#define CFG_PIN_B16 316\n#define CFG_PIN_B17 317\n#define CFG_PIN_B18 318\n#define CFG_PIN_B19 319\n#define CFG_PIN_B20 320\n#define CFG_PIN_B21 321\n#define CFG_PIN_B22 322\n#define CFG_PIN_B23 323\n#define CFG_PIN_B24 324\n#define CFG_PIN_B25 325\n#define CFG_PIN_B26 326\n#define CFG_PIN_B27 327\n#define CFG_PIN_B28 328\n#define CFG_PIN_B29 329\n#define CFG_PIN_B30 330\n#define CFG_PIN_B31 331\n\n#define CFG_PIN_C0 350\n#define CFG_PIN_C1 351\n#define CFG_PIN_C2 352\n#define CFG_PIN_C3 353\n#define CFG_PIN_C4 354\n#define CFG_PIN_C5 355\n#define CFG_PIN_C6 356\n#define CFG_PIN_C7 357\n#define CFG_PIN_C8 358\n#define CFG_PIN_C9 359\n#define CFG_PIN_C10 360\n#define CFG_PIN_C11 361\n#define CFG_PIN_C12 362\n#define CFG_PIN_C13 363\n#define CFG_PIN_C14 364\n#define CFG_PIN_C15 365\n#define CFG_PIN_C16 366\n#define CFG_PIN_C17 367\n#define CFG_PIN_C18 368\n#define CFG_PIN_C19 369\n#define CFG_PIN_C20 370\n#define CFG_PIN_C21 371\n#define CFG_PIN_C22 372\n#define CFG_PIN_C23 373\n#define CFG_PIN_C24 374\n#define CFG_PIN_C25 375\n#define CFG_PIN_C26 376\n#define CFG_PIN_C27 377\n#define CFG_PIN_C28 378\n#define CFG_PIN_C29 379\n#define CFG_PIN_C30 380\n#define CFG_PIN_C31 381\n\n#define CFG_PIN_P0 400\n#define CFG_PIN_P1 401\n#define CFG_PIN_P2 402\n#define CFG_PIN_P3 403\n#define CFG_PIN_P4 404\n#define CFG_PIN_P5 405\n#define CFG_PIN_P6 406\n#define CFG_PIN_P7 407\n#define CFG_PIN_P8 408\n#define CFG_PIN_P9 409\n#define CFG_PIN_P10 410\n#define CFG_PIN_P11 411\n#define CFG_PIN_P12 412\n#define CFG_PIN_P13 413\n#define CFG_PIN_P14 414\n#define CFG_PIN_P15 415\n#define CFG_PIN_P16 416\n#define CFG_PIN_P17 417\n#define CFG_PIN_P18 418\n#define CFG_PIN_P19 419\n#define CFG_PIN_P20 420\n#define CFG_PIN_P21 421\n#define CFG_PIN_P22 422\n#define CFG_PIN_P23 423\n#define CFG_PIN_P24 424\n#define CFG_PIN_P25 425\n#define CFG_PIN_P26 426\n#define CFG_PIN_P27 427\n#define CFG_PIN_P28 428\n#define CFG_PIN_P29 429\n#define CFG_PIN_P30 430\n#define CFG_PIN_P31 431\n\n#define CFG_PIN_LORA_MISO 1001\n#define CFG_PIN_LORA_MOSI 1002\n#define CFG_PIN_LORA_SCK 1003\n#define CFG_PIN_LORA_CS 1004\n#define CFG_PIN_LORA_BOOT 1005\n#define CFG_PIN_LORA_RESET 1006\n#define CFG_PIN_IRRXLED 1007\n#define CFG_PIN_IRTXLED 1008\n#define CFG_PIN_LCD_RESET 1009\n#define CFG_PIN_LCD_ENABLE 1010\n#define CFG_PIN_LCD_DATALINE4 1011\n#define CFG_PIN_LCD_DATALINE5 1012\n#define CFG_PIN_LCD_DATALINE6 1013\n#define CFG_PIN_LCD_DATALINE7 1014\n#define CFG_NUM_LCD_COLUMNS 1015\n#define CFG_NUM_LCD_ROWS 1016\n\n//RoboHAT MM1 pinout\n#define CFG_PIN_RCC0 1017\n#define CFG_PIN_RCC1 1018\n#define CFG_PIN_RCC2 1019\n#define CFG_PIN_RCC3 1020\n#define CFG_PIN_RCC4 1021\n#define CFG_PIN_RCC5 1022\n#define CFG_PIN_RCC6 1023\n#define CFG_PIN_RCC7 1024\n#define CFG_PIN_SERVO0 1025\n#define CFG_PIN_SERVO1 1026\n#define CFG_PIN_SERVO2 1027\n#define CFG_PIN_SERVO3 1028\n#define CFG_PIN_SERVO4 1029\n#define CFG_PIN_SERVO5 1030\n#define CFG_PIN_SERVO6 1031\n#define CFG_PIN_SERVO7 1032\n#define CFG_PIN_SERVO8 1033\n#define CFG_PIN_PI_TX 1034\n#define CFG_PIN_PI_RX 1035\n#define CFG_PIN_GPS_SDA 1036\n#define CFG_PIN_GPS_SCL 1037\n#define CFG_PIN_GPS_TX 1038\n#define CFG_PIN_GPS_RX 1039\n#define CFG_PIN_GROVE0 1040\n#define CFG_PIN_GROVE1 1041\n#define CFG_PIN_SS 1042\n\n// Adafruit Grand Central M4\n#define CFG_PIN_D33 183\n#define CFG_PIN_D34 184\n#define CFG_PIN_D35 185\n#define CFG_PIN_D36 186\n#define CFG_PIN_D37 187\n#define CFG_PIN_D38 188\n#define CFG_PIN_D39 189\n#define CFG_PIN_D40 190\n#define CFG_PIN_D41 191\n#define CFG_PIN_D42 192\n#define CFG_PIN_D43 193\n#define CFG_PIN_D44 194\n#define CFG_PIN_D45 195\n#define CFG_PIN_D46 196\n#define CFG_PIN_D47 197\n#define CFG_PIN_D48 198\n#define CFG_PIN_D49 199\n#define CFG_PIN_D50 259\n#define CFG_PIN_D51 260\n#define CFG_PIN_D52 261\n#define CFG_PIN_D53 262\n\n#define CFG_PIN_TX1 263\n#define CFG_PIN_TX2 264\n#define CFG_PIN_TX3 265\n#define CFG_PIN_RX1 266\n#define CFG_PIN_RX2 267\n#define CFG_PIN_RX3 268\n#define CFG_PIN_SCL1 269\n#define CFG_PIN_SDA1 270\n#define CFG_PIN_PCC_D0 271\n#define CFG_PIN_PCC_D1 272\n#define CFG_PIN_PCC_D2 273\n#define CFG_PIN_PCC_D3 274\n#define CFG_PIN_PCC_D4 275\n#define CFG_PIN_PCC_D5 276\n#define CFG_PIN_PCC_D6 277\n#define CFG_PIN_PCC_D7 278\n#define CFG_PIN_PCC_D8 279\n#define CFG_PIN_PCC_D9 280\n#define CFG_PIN_PCC_D10 281\n#define CFG_PIN_PCC_D11 282\n#define CFG_PIN_PCC_D12 283\n#define CFG_PIN_PCC_D13 284\n#define CFG_PIN_CC_DEN1 285\n#define CFG_PIN_CC_DEN2 286\n#define CFG_PIN_CC_CLK 287\n#define CFG_PIN_XCC_CLK 288\n\n\n#define CFG_PIN_JDPWR_PRE_SENSE 1100\n#define CFG_PIN_JDPWR_GND_SENSE 1101\n#define CFG_PIN_JDPWR_PULSE 1102\n#define CFG_PIN_JDPWR_OVERLOAD_LED 1103\n#define CFG_PIN_JDPWR_ENABLE 1104\n#define CFG_PIN_JDPWR_FAULT 1105\n\n#endif\n",
            "console.ts": "/// <reference no-default-lib=\"true\"/>\n\nenum ConsolePriority {\n    Debug = 0,\n    Log = 1,\n    Warning = 2,\n    Error = 3,\n    Silent = 4\n}\n\n/**\n * Reading and writing data to the console output.\n */\n//% weight=12 color=#002050 icon=\"\\uf120\"\n//% advanced=true\nnamespace console {\n    type Listener = (priority: ConsolePriority, text: string) => void;\n\n    /**\n     * Minimum priority to send messages to listeners\n     */\n    export let minPriority = ConsolePriority.Log;\n\n    //% whenUsed\n    const listeners: Listener[] = [\n        function (priority: ConsolePriority, text: string) { control.__log(priority, text); }\n    ];\n\n    export function add(priority: ConsolePriority, message: any) {\n        if (priority < minPriority) return;\n        let text = inspect(message);\n        // add new line\n        text += \"\\n\";\n        // send to listeners\n        for (let i = 0; i < listeners.length; ++i)\n            listeners[i](priority, text);\n    }\n\n    export function debug(text: any) {\n        add(ConsolePriority.Debug, text);\n    }\n\n    export function warn(text: any) {\n        add(ConsolePriority.Warning, text);\n    }\n\n    export function error(text: any) {\n        add(ConsolePriority.Error, text);\n    }\n\n    /**\n     * Write a line of text to the console output.\n     * @param value to send\n     */\n    //% weight=90\n    //% help=console/log blockGap=8\n    //% blockId=console_log block=\"console log $value\"\n    //% value.shadow=text\n    export function log(value: any): void {\n        add(ConsolePriority.Log, value);\n    }\n\n    /**\n     * Write a name:value pair as a line of text to the console output.\n     * @param name name of the value stream, eg: \"x\"\n     * @param value to write\n     */\n    //% weight=88 blockGap=8\n    //% help=console/log-value\n    //% blockId=console_log_value block=\"console|log value %name|= %value\"\n    //% name.shadow=text\n    //% value.shadow=math_number\n    export function logValue(name: any, value: any): void {\n        log(name ? `${inspect(name)}: ${inspect(value)}` : `${inspect(value)}`)\n    }\n\n    /**\n     * Convert any object or value to a string representation\n     * @param obj value to be converted to a string\n     * @param maxElements [optional] max number values in an object to include in output\n     */\n    export function inspect(obj: any, maxElements = 20): string {\n        if (typeof obj == \"string\") {\n            return obj;\n        } else if (typeof obj == \"number\") {\n            return \"\" + obj;\n        } else if (Array.isArray(obj)) {\n            const asArr = (obj as Array<string>);\n            if (asArr.length <= maxElements) {\n                return asArr.join(\",\");\n            } else {\n                return `${asArr.slice(0, maxElements).join(\",\")}...`;\n            }\n        } else {\n            const asString = obj + \"\";\n            if (asString != \"[object Object]\"\n                && asString != \"[Object]\") { // on arcade at least, default toString is [Object] on hardware instead of standard\n                return asString;\n            }\n\n            let keys = Object.keys(obj);\n            const snipped = keys.length > maxElements;\n            if (snipped) {\n                keys = keys.slice(0, maxElements);\n            }\n\n            return `{${\n                keys.reduce(\n                    (prev, currKey) => prev + `\\n    ${currKey}: ${obj[currKey]}`,\n                    \"\"\n                ) + (snipped ? \"\\n    ...\" : \"\")\n            }\n}`;\n        }\n    }\n\n    /**\n     * Adds a listener for the log messages\n     * @param listener\n     */\n    //%\n    export function addListener(listener: (priority: ConsolePriority, text: string) => void) {\n        if (!listener || listeners.indexOf(listener) > -1) return;\n        listeners.push(listener);\n    }\n\n    /**\n     * Removes a listener\n     * @param listener\n     */\n    //%\n    export function removeListener(listener: (priority: ConsolePriority, text: string) => void) {\n        if (!listener) return;\n        const i = listeners.indexOf(listener);\n        if (i > -1)\n            listeners.splice(i, 1);\n    }\n}",
            "control.cpp": "#include \"pxtbase.h\"\n\n\nnamespace control {\n    /**\n    * Gets the number of milliseconds elapsed since power on.\n    */\n    //% help=control/millis weight=50\n    //% blockId=control_running_time block=\"millis (ms)\"\n    int millis() {\n        return current_time_ms();\n    }\n\n    /**\n    * Gets current time in microseconds. Overflows every ~18 minutes.\n    */\n    //%\n    int micros() {\n        return current_time_us() & 0x3fffffff;\n    }\n\n    /**\n    * Used internally\n    */\n    //%\n    void internalOnEvent(int src, int value, Action handler, int flags = 16) {\n        registerWithDal(src, value, handler, flags);\n    }\n\n    /**\n     * Reset the device.\n     */\n    //% weight=30 async help=control/reset blockGap=8\n    //% blockId=\"control_reset\" block=\"reset\"\n    void reset() {\n        target_reset();\n    }\n\n    /**\n    * Block the current fiber for the given microseconds\n    * @param micros number of micro-seconds to wait. eg: 4\n    */\n    //% help=control/wait-micros weight=29 async\n    //% blockId=\"control_wait_us\" block=\"wait (s)%micros\"\n    void waitMicros(int micros) {\n        sleep_us(micros);\n    }\n\n    /**\n     * Run other code in the parallel.\n     */\n    //% help=control/run-in-parallel handlerStatement=1\n    //% blockId=\"control_run_in_parallel\" block=\"run in parallel\" blockGap=8\n    void runInParallel(Action a) {\n        pxt::runInParallel(a);\n    }\n\n    /**\n    * Blocks the calling thread until the specified event is raised.\n    */\n    //% help=control/wait-for-event async\n    //% blockId=control_wait_for_event block=\"wait for event|from %src|with value %value\"\n    void waitForEvent(int src, int value) {\n        pxt::waitForEvent(src, value);\n    }\n\n    /**\n    * Derive a unique, consistent serial number of this device from internal data.\n    */\n    //% blockId=\"control_device_serial_number\" block=\"device serial number\" weight=9\n    //% help=control/device-serial-number\n    int deviceSerialNumber() {\n        uint64_t serial_num = pxt::getLongSerialNumber();\n        return hash_fnv1(&serial_num, sizeof(serial_num)) & 0x3fffffff;\n    }\n\n    /**\n    * Derive a unique, consistent 64-bit serial number of this device from internal data.\n    */\n    //% blockId=\"control_device_long_serial_number\" block=\"device long serial number\" weight=9\n    //% help=control/device-long-serial-number\n    Buffer deviceLongSerialNumber() {\n        uint64_t serial_num = pxt::getLongSerialNumber();\n        return mkBuffer((uint8_t*)&serial_num, sizeof(uint64_t));\n    }\n\n    /**\n    *\n    */\n    //%\n    void __log(int prority, String text) {\n        if (NULL == text) return;\n        pxt::sendSerial(text->getUTF8Data(), text->getUTF8Size());\n    }\n\n    /**\n     * Dump internal information about a value.\n     */\n    //%\n    void dmesgValue(TValue v) {\n        anyPrint(v);\n    }\n\n    /**\n     * Force GC and dump basic information about heap.\n     */\n    //%\n    void gc() {\n        pxt::gc(1);\n    }\n\n    /**\n     * Force GC and halt waiting for debugger to do a full heap dump.\n     */\n    //%\n    void heapDump() {\n        pxt::gc(2);\n        target_panic(PANIC_HEAP_DUMPED);\n    }\n\n\n    /**\n     * Set flags used when connecting an external debugger.\n     */\n    //%\n    void setDebugFlags(int flags) {\n        debugFlags = flags;\n    }\n\n    /**\n     * Record a heap snapshot to debug memory leaks.\n     */\n    //%\n    void heapSnapshot() {\n        // only in JS backend for now\n    }\n\n    /**\n     * Return true if profiling is enabled in the current build.\n     */\n    //%\n    bool profilingEnabled() {\n#ifdef PXT_PROFILE\n        return true;\n#else\n        return false;\n#endif\n    }\n}\n",
            "control.ts": "/**\n* Program controls and events.\n*/\n//% weight=90 color=\"#FF5722\" icon=\"\\uf110\" advanced=true\nnamespace control {\n    /**\n     * Deprecated, use ``control.runInParallel`` instead.\n     */\n    //% deprecated=1 hidden=1 help=control/run-in-background blockAllowMultiple=1 afterOnStart=true\n    //% blockId=\"control_run_in_background\" block=\"run in background\" blockGap=8 weight=0\n    export function runInBackground(a: () => void) {\n        control.runInParallel(a);\n    }\n\n    export const enum PXT_PANIC {\n        CODAL_OOM = 20,\n        GC_OOM = 21,\n        GC_TOO_BIG_ALLOCATION = 22,\n        CODAL_HEAP_ERROR = 30,\n        CODAL_NULL_DEREFERENCE = 40,\n        CODAL_USB_ERROR = 50,\n        CODAL_HARDWARE_CONFIGURATION_ERROR = 90,\n\n        INVALID_BINARY_HEADER = 901,\n        OUT_OF_BOUNDS = 902,\n        REF_DELETED = 903,\n        SIZE = 904,\n        INVALID_VTABLE = 905,\n        INTERNAL_ERROR = 906,\n        NO_SUCH_CONFIG = 907,\n        NO_SUCH_PIN = 908,\n        INVALID_ARGUMENT = 909,\n        MEMORY_LIMIT_EXCEEDED = 910,\n        SCREEN_ERROR = 911,\n        MISSING_PROPERTY = 912,\n        INVALID_IMAGE = 913,\n        CALLED_FROM_ISR = 914,\n        HEAP_DUMPED = 915,\n        STACK_OVERFLOW = 916,\n        BLOCKING_TO_STRING = 917,\n        VM_ERROR = 918,\n        SETTINGS_CLEARED = 920,\n        SETTINGS_OVERLOAD = 921,\n        SETTINGS_SECRET_MISSING = 922,\n        DELETE_ON_CLASS = 923,\n\n        CAST_FIRST = 980,\n        CAST_FROM_UNDEFINED = 980,\n        CAST_FROM_BOOLEAN = 981,\n        CAST_FROM_NUMBER = 982,\n        CAST_FROM_STRING = 983,\n        CAST_FROM_OBJECT = 984,\n        CAST_FROM_FUNCTION = 985,\n        CAST_FROM_NULL = 989,\n\n        UNHANDLED_EXCEPTION = 999,\n    }\n    /**\n     * Display an error code and stop the program.\n     * @param code an error number to display. eg: 5\n     */\n    //% help=control/panic weight=29\n    //% blockId=\"control_panic\" block=\"panic %code\"\n    //% shim=pxtrt::panic\n    export function panic(code: number) { }\n\n    /**\n     * Enable profiling for current function.\n     */\n    //% shim=TD_NOOP shimArgument=perfCounter\n    export function enablePerfCounter(name?: string) { }\n\n    /**\n     * Dump values of profiling performance counters.\n     */\n    //% shim=pxt::dumpPerfCounters\n    export function dmesgPerfCounters() { }\n\n    /**\n     * Display an error code and stop the program when the assertion is `false`.\n     */\n    //% help=control/assert weight=30\n    //% blockId=\"control_assert\" block=\"assert %cond|with value %code\"\n    export function assert(cond: boolean, code: number) {\n        if (!cond) {\n            fail(\"Assertion failed, code=\" + code)\n        }\n    }\n\n    export function fail(message: string) {\n        console.log(\"Fatal failure: \")\n        console.log(message)\n        dmesg(message)\n        panic(108)\n    }\n\n    export class AnimationQueue {\n        running: boolean;\n        eventID: number;\n        public interval: number;\n\n        constructor() {\n            this.running = false;\n            this.eventID = control.allocateNotifyEvent();\n            this.interval = 1;\n        }\n\n        /**\n         * Runs 'render' in a loop until it returns false or the 'stop' function is called\n         */\n        runUntilDone(render: () => boolean) {\n            const evid = this.eventID;\n\n            // if other animation, wait for turn\n            if (this.running)\n                control.waitForEvent(DAL.DEVICE_ID_NOTIFY, evid);\n\n            // check if the animation hasn't been cancelled since we've waiting\n            if (this.isCancelled(evid))\n                return;\n\n            // run animation\n            this.running = true;\n            while (this.running\n                && !this.isCancelled(evid)\n                && render()) {\n                pause(this.interval);\n            }\n\n            // check if the animation hasn't been cancelled since we've been waiting\n            if (this.isCancelled(evid))\n                return;\n\n            // we're done\n            this.running = false;\n            // unblock 1 fiber\n            control.raiseEvent(DAL.DEVICE_ID_NOTIFY_ONE, this.eventID);\n        }\n\n        isCancelled(evid: number) {\n            return this.eventID !== evid;\n        }\n\n        /**\n         * Cancels the current running animation and clears the queue\n         */\n        cancel() {\n            if (this.running) {\n                this.running = false;\n                const evid = this.eventID;\n                this.eventID = control.allocateNotifyEvent();\n                // unblock fibers\n                control.raiseEvent(DAL.DEVICE_ID_NOTIFY, evid);\n            }\n        }\n    }\n\n    //% shim=pxt::getConfig\n    export declare function getConfigValue(key: int32, defl: int32): number;\n\n    //% shim=pxt::programHash\n    export declare function programHash(): number;\n\n    //% shim=pxt::programName\n    export declare function programName(): string;\n\n    //% shim=control::_ramSize\n    function _ramSize() {\n        return 32 * 1024 * 1024;\n    }\n\n    /** Returns estimated size of memory in bytes. */\n    export function ramSize() {\n        return getConfigValue(DAL.CFG_RAM_BYTES, 0) || _ramSize();\n    }\n\n    /** Runs the function and returns run time in microseconds. */\n    export function benchmark(f: () => void) {\n        const t0 = micros()\n        f()\n        let t = micros() - t0\n        if (t < 0)\n            t += 0x3fffffff\n        return t\n    }\n}\n\n/**\n * Convert any value to text\n * @param value value to be converted to text\n */\n//% help=text/convert-to-text weight=1\n//% block=\"convert $value=math_number to text\"\n//% blockId=variable_to_text blockNamespace=\"text\"\nfunction convertToText(value: any): string {\n    return \"\" + value;\n}\n",
            "controlmessage.ts": "namespace control.simmessages {\n    // these events are raised by JS simulator when messages come in\n    export const CONTROL_MESSAGE_EVT_ID = 2999;\n    export const CONTROL_MESSAGE_RECEIVED = 1;\n\n    //% shim=pxt::sendMessage\n    export declare function send(channel: string, message: Buffer, parentOnly?: boolean) : void;\n\n    //% shim=pxt::peekMessageChannel\n    declare function peekMessageChannel(): string;\n\n    //% shim=pxt::readMessageData\n    declare function readMessageData(): Buffer;\n\n    let handlers: { [channel: string] : (msg: Buffer) => void}\n    function consumeMessages() {\n        while(true) {\n            // peek channel of next message\n            const channel = peekMessageChannel();\n            if (!channel) break;\n            // read next message\n            const msg = readMessageData();\n            // send to handler\n            const handler = handlers && handlers[channel];\n            if (handler)\n                handler(msg);\n        }\n    }\n\n    /**\n     * Registers the handler for a message on a given channel\n     **/\n    export function onReceived(channel: string, handler: (msg: Buffer) => void) {\n        if (!channel) return;\n\n        if (!handlers)\n            handlers = {};\n        handlers[channel] = handler;\n        control.onEvent(CONTROL_MESSAGE_EVT_ID, CONTROL_MESSAGE_RECEIVED, consumeMessages);\n    }\n}",
            "core.cpp": "#include \"pxtbase.h\"\n#include <limits.h>\n#include <stdlib.h>\n\nusing namespace std;\n\n#define p10(v) __builtin_powi(10, v)\n\n// try not to create cons-strings shorter than this\n#define SHORT_CONCAT_STRING 50\n\n// bigger value - less memory, but slower\n// 16/20 keeps s.length and s.charCodeAt(i) at about 200 cycles (for actual unicode strings),\n// which is similar to amortized allocation time\n#define SKIP_INCR 16 // needs to be power of 2; needs to be kept in sync with compiler\n#define MIN_SKIP 20  // min. size of string to use skip list; static code has its own limit\n\nnamespace pxt {\n\nPXT_DEF_STRING(emptyString, \"\")\n\nstatic HandlerBinding *handlerBindings;\n\nHandlerBinding *nextBinding(HandlerBinding *curr, int source, int value) {\n    for (auto p = curr; p; p = p->next) {\n        // DEVICE_ID_ANY == DEVICE_EXT_ANY == 0\n        if ((p->source == source || p->source == 0) && (value == -1 || p->value == value || p->value == 0)) {\n            return p;\n        }\n    }\n    return 0;\n}\n\nHandlerBinding *findBinding(int source, int value) {\n    return nextBinding(handlerBindings, source, value);\n}\n\nvoid setBinding(int source, int value, Action act) {\n    HandlerBinding *curr = NULL;\n    for (auto p = handlerBindings; p; p = p->next) {\n        if ((p->source == source) && (p->value == value)) {\n            curr = p;\n            break;\n        }\n    }\n    if (curr) {\n        curr->action = act;\n        return;\n    }\n    curr = new (app_alloc(sizeof(HandlerBinding))) HandlerBinding();\n    curr->next = handlerBindings;\n    curr->source = source;\n    curr->value = value;\n    curr->action = act;\n    registerGC(&curr->action);\n    handlerBindings = curr;\n}\n\nvoid coreReset() {\n    // these are allocated on GC heap, so they will go away together with the reset\n    handlerBindings = NULL;\n}\n\nstatic const char emptyBuffer[] __attribute__((aligned(4))) = \"@PXT#:\\x00\\x00\\x00\";\n\n#if PXT_UTF8\nint utf8Len(const char *data, int size) {\n    int len = 0;\n    for (int i = 0; i < size; ++i) {\n        char c = data[i];\n        len++;\n        if ((c & 0x80) == 0x00) {\n            // skip\n        } else if ((c & 0xe0) == 0xc0) {\n            i++;\n        } else if ((c & 0xf0) == 0xe0) {\n            i += 2;\n        } else {\n            // error; just skip\n        }\n    }\n    return len;\n}\n\nconst char *utf8Skip(const char *data, int size, int skip) {\n    int len = 0;\n    for (int i = 0; i <= size; ++i) {\n        char c = data[i];\n        len++;\n        if (len > skip)\n            return data + i;\n        if ((c & 0x80) == 0x00) {\n            // skip\n        } else if ((c & 0xe0) == 0xc0) {\n            i++;\n        } else if ((c & 0xf0) == 0xe0) {\n            i += 2;\n        } else {\n            // error; just skip over\n        }\n    }\n    return NULL;\n}\n\nstatic char *write3byte(char *dst, uint32_t charCode) {\n    if (dst) {\n        *dst++ = 0xe0 | (charCode >> 12);\n        *dst++ = 0x80 | (0x3f & (charCode >> 6));\n        *dst++ = 0x80 | (0x3f & (charCode >> 0));\n    }\n    return dst;\n}\n\nstatic char *write2byte(char *dst, uint32_t charCode) {\n    if (dst) {\n        *dst++ = 0xc0 | (charCode >> 6);\n        *dst++ = 0x80 | (0x3f & charCode);\n    }\n    return dst;\n}\n\nstatic int utf8canon(char *dst, const char *data, int size) {\n    int outsz = 0;\n    for (int i = 0; i < size;) {\n        uint8_t c = data[i];\n        uint32_t charCode = c;\n        if ((c & 0x80) == 0x00) {\n            charCode = c;\n            i++;\n        } else if ((c & 0xe0) == 0xc0 && i + 1 < size && (data[i + 1] & 0xc0) == 0x80) {\n            charCode = ((c & 0x1f) << 6) | (data[i + 1] & 0x3f);\n            if (charCode < 0x80)\n                goto error;\n            else\n                i += 2;\n        } else if ((c & 0xf0) == 0xe0 && i + 2 < size && (data[i + 1] & 0xc0) == 0x80 &&\n                   (data[i + 2] & 0xc0) == 0x80) {\n            charCode = ((c & 0x0f) << 12) | (data[i + 1] & 0x3f) << 6 | (data[i + 2] & 0x3f);\n            // don't exclude surrogate pairs, since we're generating them\n            if (charCode < 0x800 /*|| (0xd800 <= charCode && charCode <= 0xdfff)*/)\n                goto error;\n            else\n                i += 3;\n        } else if ((c & 0xf8) == 0xf0 && i + 3 < size && (data[i + 1] & 0xc0) == 0x80 &&\n                   (data[i + 2] & 0xc0) == 0x80 && (data[i + 3] & 0xc0) == 0x80) {\n            charCode = ((c & 0x07) << 18) | (data[i + 1] & 0x3f) << 12 | (data[i + 2] & 0x3f) << 6 |\n                       (data[i + 3] & 0x3f);\n            if (charCode < 0x10000 || charCode > 0x10ffff)\n                goto error;\n            else\n                i += 4;\n        } else {\n            goto error;\n        }\n\n        if (charCode < 0x80) {\n            outsz += 1;\n            if (dst)\n                *dst++ = charCode;\n        } else if (charCode < 0x800) {\n            outsz += 2;\n            dst = write2byte(dst, charCode);\n        } else if (charCode < 0x10000) {\n            outsz += 3;\n            dst = write3byte(dst, charCode);\n        } else {\n            outsz += 6; // a surrogate pair\n            charCode -= 0x10000;\n            dst = write3byte(dst, 0xd800 + (charCode >> 10));\n            dst = write3byte(dst, 0xdc00 + (charCode & 0x3ff));\n        }\n\n        continue;\n\n    error:\n        i++;\n        outsz += 2;\n        dst = write2byte(dst, c);\n    }\n    return outsz;\n}\n\nstatic int utf8CharCode(const char *data) {\n    unsigned char c = *data;\n    if ((c & 0x80) == 0) {\n        return c;\n    } else if ((c & 0xe0) == 0xc0) {\n        return ((c & 0x1f) << 6) | (data[1] & 0x3f);\n    } else if ((c & 0xf0) == 0xe0) {\n        return ((c & 0x0f) << 12) | (data[1] & 0x3f) << 6 | (data[2] & 0x3f);\n    } else {\n        return c; // error\n    }\n}\n\nstatic bool isUTF8(const char *data, int len) {\n    for (int i = 0; i < len; ++i) {\n        if (data[i] & 0x80)\n            return true;\n    }\n    return false;\n}\n\n#define NUM_SKIP_ENTRIES(p) ((p)->skip.length / SKIP_INCR)\n#define SKIP_DATA(p) (const char *)(p->skip.list + NUM_SKIP_ENTRIES(p))\n\nstatic void setupSkipList(String r, const char *data) {\n    char *dst = (char *)SKIP_DATA(r);\n    auto len = r->skip.size;\n    if (data)\n        memcpy(dst, data, len);\n    dst[len] = 0;\n    const char *ptr = dst;\n    auto skipEntries = NUM_SKIP_ENTRIES(r);\n    for (int i = 0; i < skipEntries; ++i) {\n        ptr = utf8Skip(ptr, (int)(len - (ptr - dst)), SKIP_INCR);\n        if (!ptr)\n            oops(80);\n        r->skip.list[i] = ptr - dst;\n    }\n}\n#endif\n\n#ifdef PXT_VM\nString mkInternalString(const char *str) {\n    int len = (int)strlen(str);\n    String r = new (xmalloc(sizeof(void *) + 2 + len + 1)) BoxedString(&string_inline_ascii_vt);\n    r->ascii.length = len;\n    memcpy(r->ascii.data, str, len);\n    r->ascii.data[len] = 0;\n    return r;\n}\n#endif\n\nString mkStringCore(const char *data, int len) {\n    if (len < 0)\n        len = (int)strlen(data);\n    if (len == 0 && !inGCPrealloc())\n        return (String)emptyString;\n\n    auto vt = &string_inline_ascii_vt;\n    String r;\n\n#if PXT_UTF8\n    if (data && isUTF8(data, len)) {\n        vt = len >= MIN_SKIP ? &string_skiplist16_vt : &string_inline_utf8_vt;\n    }\n    if (vt == &string_skiplist16_vt) {\n        r = new (gcAllocate(sizeof(void *) + sizeof(r->skip))) BoxedString(vt);\n        r->skip.list = NULL;\n        registerGCObj(r);\n        r->skip.size = len;\n        r->skip.length = utf8Len(data, len);\n        r->skip.list = NULL; // in case gc triggers below\n        r->skip.list = (uint16_t *)gcAllocateArray(NUM_SKIP_ENTRIES(r) * 2 + len + 1);\n        setupSkipList(r, data);\n        unregisterGCObj(r);\n    } else\n#endif\n    {\n        // for ASCII and UTF8 the layout is the same\n        r = new (gcAllocate(sizeof(void *) + 2 + len + 1)) BoxedString(vt);\n        r->ascii.length = len;\n        if (data)\n            memcpy(r->ascii.data, data, len);\n        r->ascii.data[len] = 0;\n    }\n\n    MEMDBG(\"mkString: len=%d => %p\", len, r);\n    return r;\n}\n\nString mkString(const char *data, int len) {\n#if PXT_UTF8\n    if (len < 0)\n        len = (int)strlen(data);\n    if (len == 0 && !inGCPrealloc())\n        return (String)emptyString;\n\n    int sz = utf8canon(NULL, data, len);\n    if (sz == len)\n        return mkStringCore(data, len);\n    // this could be optimized, but it only kicks in when the string isn't valid utf8\n    // (or we need to introduce surrogate pairs) which is unlikely to be performance critical\n    char *tmp = (char *)app_alloc(sz);\n    utf8canon(tmp, data, len);\n    auto r = mkStringCore(tmp, sz);\n    app_free(tmp);\n    return r;\n#else\n    return mkStringCore(data, len);\n#endif\n}\n\n#if PXT_UTF8\n// This converts surrogate pairs, which are encoded as 2 characters of 3 bytes each\n// into a proper 4 byte utf-8 character.\nuint32_t toRealUTF8(String str, uint8_t *dst) {\n    auto src = str->getUTF8Data();\n    auto len = str->getUTF8Size();\n    auto dlen = 0;\n\n    for (unsigned i = 0; i < len; ++i) {\n        if ((uint8_t)src[i] == 0xED && i + 5 < len) {\n            auto c0 = utf8CharCode(src + i);\n            auto c1 = utf8CharCode(src + i + 3);\n            if (0xd800 <= c0 && c0 < 0xdc00 && 0xdc00 <= c1 && c1 < 0xe000) {\n                i += 5;\n                auto charCode = ((c0 - 0xd800) << 10) + (c1 - 0xdc00) + 0x10000;\n                if (dst) {\n                    dst[dlen] = 0xf0 | (charCode >> 18);\n                    dst[dlen + 1] = 0x80 | (0x3f & (charCode >> 12));\n                    dst[dlen + 2] = 0x80 | (0x3f & (charCode >> 6));\n                    dst[dlen + 3] = 0x80 | (0x3f & (charCode >> 0));\n                }\n                dlen += 4;\n            }\n        } else {\n            if (dst)\n                dst[dlen] = src[i];\n            dlen++;\n        }\n    }\n    return dlen;\n}\n#endif\n\nBuffer mkBuffer(const void *data, int len) {\n    if (len <= 0 && !inGCPrealloc())\n        return (Buffer)emptyBuffer;\n    Buffer r = new (gcAllocate(sizeof(BoxedBuffer) + len)) BoxedBuffer();\n    r->length = len;\n    if (data)\n        memcpy(r->data, data, len);\n    else\n        memset(r->data, 0, len);\n    MEMDBG(\"mkBuffer: len=%d => %p\", len, r);\n    return r;\n}\n\nstatic unsigned random_value = 0xC0DA1;\n\n//%\nvoid seedRandom(unsigned seed) {\n    random_value = seed;\n}\n\n//% expose\nvoid seedAddRandom(unsigned seed) {\n    random_value ^= 0xCA2557CB * seed;\n}\n\nunsigned getRandom(unsigned max) {\n    unsigned m, result;\n\n    do {\n        m = (unsigned)max;\n        result = 0;\n\n        do {\n            // Cycle the LFSR (Linear Feedback Shift Register).\n            // We use an optimal sequence with a period of 2^32-1, as defined by Bruce Schneier here\n            // (a true legend in the field!),\n            // For those interested, it's documented in his paper:\n            // \"Pseudo-Random Sequence Generator for 32-Bit CPUs: A fast, machine-independent\n            // generator for 32-bit Microprocessors\"\n            // https://www.schneier.com/paper-pseudorandom-sequence.html\n            unsigned r = random_value;\n\n            r = ((((r >> 31) ^ (r >> 6) ^ (r >> 4) ^ (r >> 2) ^ (r >> 1) ^ r) & 1) << 31) |\n                (r >> 1);\n\n            random_value = r;\n\n            result = ((result << 1) | (r & 0x00000001));\n        } while (m >>= 1);\n    } while (result > (unsigned)max);\n\n    return result;\n}\n\nTNumber BoxedString::charCodeAt(int pos) {\n#if PXT_UTF8\n    auto ptr = this->getUTF8DataAt(pos);\n    if (!ptr)\n        return TAG_NAN;\n    auto code = utf8CharCode(ptr);\n    if (!code && ptr == this->getUTF8Data() + this->getUTF8Size())\n        return TAG_NAN;\n    return fromInt(code);\n#else\n    if (0 <= pos && pos < this->ascii.length) {\n        return fromInt(this->ascii.data[pos]);\n    } else {\n        return TAG_NAN;\n    }\n#endif\n}\n\nPXT_DEF_STRING(sTrue, \"true\")\nPXT_DEF_STRING(sFalse, \"false\")\nPXT_DEF_STRING(sUndefined, \"undefined\")\nPXT_DEF_STRING(sNull, \"null\")\nPXT_DEF_STRING(sObject, \"[Object]\")\nPXT_DEF_STRING(sFunction, \"[Function]\")\nPXT_DEF_STRING(sNaN, \"NaN\")\nPXT_DEF_STRING(sInf, \"Infinity\")\nPXT_DEF_STRING(sMInf, \"-Infinity\")\n} // namespace pxt\n\n#ifndef X86_64\n\nnamespace String_ {\n\n//%\nString mkEmpty() {\n    return (String)emptyString;\n}\n\n// TODO support var-args somehow?\n\n//%\nString fromCharCode(int code) {\n#if PXT_UTF8\n    char buf[3];\n    int len;\n    code &= 0xffff; // JS semantics\n    if (code < 0x80) {\n        buf[0] = code;\n        len = 1;\n    } else if (code < 0x800) {\n        buf[0] = 0xc0 | (code >> 6);\n        buf[1] = 0x80 | ((code >> 0) & 0x3f);\n        len = 2;\n    } else {\n        buf[0] = 0xe0 | (code >> 12);\n        buf[1] = 0x80 | ((code >> 6) & 0x3f);\n        buf[2] = 0x80 | ((code >> 0) & 0x3f);\n        len = 3;\n    }\n    return mkStringCore(buf, len);\n#else\n    char buf[] = {(char)code, 0};\n    return mkStringCore(buf, 1);\n#endif\n}\n\n//%\nTNumber charCodeAt(String s, int pos) {\n    if (!s)\n        return TAG_NAN;\n    return s->charCodeAt(pos);\n}\n\n//%\nString charAt(String s, int pos) {\n    auto v = charCodeAt(s, pos);\n    if (v == TAG_NAN)\n        return mkEmpty();\n    if (!isInt(v))\n        oops(81);\n    return fromCharCode(numValue(v));\n}\n\n#define IS_CONS(s) ((s)->vtable == (uintptr_t)&string_cons_vt)\n#define IS_EMPTY(s) ((s) == (String)emptyString)\n\n//%\nString concat(String s, String other) {\n    if (!s)\n        s = (String)sNull;\n    if (!other)\n        other = (String)sNull;\n    if (IS_EMPTY(s))\n        return other;\n    if (IS_EMPTY(other))\n        return s;\n\n    uint32_t lenA, lenB;\n\n#if PXT_UTF8\n    if (IS_CONS(s)) {\n        // (s->cons.left + s->cons.right) + other = s->cons.left + (s->cons.right + other)\n        if (IS_CONS(other) || IS_CONS(s->cons.right))\n            goto mkCons;\n        auto lenAR = s->cons.right->getUTF8Size();\n        lenB = other->getUTF8Size();\n        if (lenAR + lenB > SHORT_CONCAT_STRING)\n            goto mkCons;\n        // if (s->cons.right + other) is short enough, use associativity\n        // to construct a shallower tree; this should keep the live set reasonable\n        // when someone decides to construct a long string by concatenating\n        // single characters\n\n        // allocate [r] first, and keep it alive\n        String r = new (gcAllocate(3 * sizeof(void *))) BoxedString(&string_cons_vt);\n        registerGCObj(r);\n        r->cons.left = s->cons.left;\n        // this concat() might trigger GC\n        r->cons.right = concat(s->cons.right, other);\n        unregisterGCObj(r);\n        return r;\n    }\n#endif\n\n    lenA = s->getUTF8Size();\n    lenB = other->getUTF8Size();\n#if PXT_UTF8\n    if (lenA + lenB > SHORT_CONCAT_STRING)\n        goto mkCons;\n#endif\n    String r;\n    {\n        auto dataA = s->getUTF8Data();\n        auto dataB = other->getUTF8Data();\n        r = mkStringCore(NULL, lenA + lenB);\n        auto dst = (char *)r->getUTF8Data();\n        memcpy(dst, dataA, lenA);\n        memcpy(dst + lenA, dataB, lenB);\n#if PXT_UTF8\n        if (isUTF8(dst, lenA + lenB))\n            r->vtable = PXT_VTABLE_TO_INT(&string_inline_utf8_vt);\n#endif\n        return r;\n    }\n\n#if PXT_UTF8\nmkCons:\n    r = new (gcAllocate(3 * sizeof(void *))) BoxedString(&string_cons_vt);\n    r->cons.left = s;\n    r->cons.right = other;\n    return r;\n#endif\n}\n\nint compare(String a, String b) {\n    if (a == b)\n        return 0;\n\n    auto lenA = a->getUTF8Size();\n    auto lenB = b->getUTF8Size();\n    auto dataA = a->getUTF8Data();\n    auto dataB = b->getUTF8Data();\n    auto len = lenA < lenB ? lenA : lenB;\n\n    // this also works for UTF8, provided canonical encoding\n    // which is guaranteed by the constructor\n    for (unsigned i = 0; i <= len; ++i) {\n        unsigned char cA = dataA[i];\n        unsigned char cB = dataB[i];\n        if (cA == cB)\n            continue;\n        return cA < cB ? -1 : 1;\n    }\n    return 0;\n}\n\n//%\nint length(String s) {\n    return s->getLength();\n}\n\n#define isspace(c) ((c) == ' ')\n#define iswhitespace(c) ((c) == 0x09 || (c) == 0x0B || (c) == 0x0C || (c) == 0x20 || (c) == 0xA0 || (c) == 0x0A || (c) == 0x0D)\n\nNUMBER mystrtod(const char *p, char **endp) {\n    while (iswhitespace(*p))\n        p++;\n    NUMBER m = 1;\n    NUMBER v = 0;\n    int dot = 0;\n    int hasDigit = 0;\n    if (*p == '+')\n        p++;\n    if (*p == '-') {\n        m = -1;\n        p++;\n    }\n\n    while (*p) {\n        int c = *p - '0';\n        if (0 <= c && c <= 9) {\n            v *= 10;\n            v += c;\n            if (dot)\n                m /= 10;\n            hasDigit = 1;\n        } else if (!dot && *p == '.') {\n            dot = 1;\n        } else if (!hasDigit) {\n            return NAN;\n        } else {\n            break;\n        }\n        p++;\n    }\n\n    v *= m;\n\n    if (*p == 'e' || *p == 'E') {\n        p++;\n        int pw = (int)strtol(p, endp, 10);\n        v *= p10(pw);\n    } else {\n        *endp = (char *)p;\n    }\n\n    return v;\n}\n\n//%\nTNumber toNumber(String s) {\n    // JSCHECK\n    char *endptr;\n    auto data = s->getUTF8Data();\n    NUMBER v = mystrtod(data, &endptr);\n    if (v == 0.0 || v == -0.0) {\n        // nothing\n    } else if (!isnormal(v))\n        v = NAN;\n    return fromDouble(v);\n}\n\n//%\nString substr(String s, int start, int length) {\n    if (length <= 0)\n        return mkEmpty();\n    auto slen = (int)s->getLength();\n    if (start < 0)\n        start = max(slen + start, 0);\n    length = min(length, slen - start);\n    if (length <= 0)\n        return mkEmpty();\n    auto p = s->getUTF8DataAt(start);\n#if PXT_UTF8\n    auto ep = s->getUTF8DataAt(start + length);\n    if (ep == NULL)\n        oops(82);\n    return mkStringCore(p, (int)(ep - p));\n#else\n    return mkStringCore(p, length);\n#endif\n}\n\n//%\nint indexOf(String s, String searchString, int start) {\n    if (!s || !searchString)\n        return -1;\n\n    if (start < 0)\n        start = 0;\n\n    auto dataA0 = s->getUTF8Data();\n    auto dataA = s->getUTF8DataAt(start);\n    auto offset = dataA - dataA0;\n    auto lenA = s->getUTF8Size() - offset;\n    auto lenB = searchString->getUTF8Size();\n\n    if (dataA == NULL || lenB > lenA)\n        return -1;\n\n    auto dataB = searchString->getUTF8Data();\n    auto firstB = dataB[0];\n    while (lenA >= lenB) {\n        if (*dataA == firstB && !memcmp(dataA, dataB, lenB))\n#if PXT_UTF8\n            return utf8Len(dataA0, (int)(dataA - dataA0));\n#else\n            return dataA - dataA0;\n#endif\n        dataA++;\n        lenA--;\n    }\n    return -1;\n}\n\n//%\nint includes(String s, String searchString, int start) {\n    return -1 != indexOf(s, searchString, start);\n}\n\n} // namespace String_\n\nnamespace Boolean_ {\n//%\nbool bang(bool v) {\n    return v == 0;\n}\n} // namespace Boolean_\n\nnamespace pxt {\n\n// ES5 9.5, 9.6\nunsigned toUInt(TNumber v) {\n    if (isInt(v))\n        return numValue(v);\n    if (isSpecial(v)) {\n        if ((intptr_t)v >> 6)\n            return 1;\n        else\n            return 0;\n    }\n    if (!v)\n        return 0;\n\n    NUMBER num = toDouble(v);\n    if (!isnormal(num))\n        return 0;\n#ifdef PXT_USE_FLOAT\n    float rem = fmodf(truncf(num), 4294967296.0);\n#else\n    double rem = fmod(trunc(num), 4294967296.0);\n#endif\n    if (rem < 0.0)\n        rem += 4294967296.0;\n    return (unsigned)rem;\n}\nint toInt(TNumber v) {\n    return (int)toUInt(v);\n}\n\nNUMBER toDouble(TNumber v) {\n    if (v == TAG_NAN || v == TAG_UNDEFINED)\n        return NAN;\n    if (isTagged(v))\n        return toInt(v);\n\n#ifdef PXT64\n    if (isDouble(v))\n        return doubleVal(v);\n#endif\n\n    ValType t = valType(v);\n\n#ifndef PXT64\n    if (t == ValType::Number) {\n        BoxedNumber *p = (BoxedNumber *)v;\n        return p->num;\n    }\n#endif\n\n    if (t == ValType::String) {\n        // TODO avoid allocation\n        auto tmp = String_::toNumber((String)v);\n        auto r = toDouble(tmp);\n        return r;\n    } else {\n        return NAN;\n    }\n}\n\nfloat toFloat(TNumber v) {\n    if (v == TAG_NAN || v == TAG_UNDEFINED)\n        return NAN;\n    // optimize for the int case - this will avoid software conversion when FPU is present\n    if (isTagged(v))\n        return toInt(v);\n    return (float)toDouble(v);\n}\n\n#if !defined(PXT_HARD_FLOAT) && !defined(PXT_USE_FLOAT)\nunion NumberConv {\n    double v;\n    struct {\n        uint32_t word0;\n        uint32_t word1;\n    };\n};\n\nstatic inline TValue doubleToInt(double x) {\n    NumberConv cnv;\n    cnv.v = x;\n\n    if (cnv.word1 == 0 && cnv.word0 == 0)\n        return TAG_NUMBER(0);\n\n    auto ex = (int)((cnv.word1 << 1) >> 21) - 1023;\n\n    // DMESG(\"v=%d/1000 %p %p %d\", (int)(x * 1000), cnv.word0, cnv.word1, ex);\n\n    if (ex < 0 || ex > 29) {\n        // the 'MININT' case\n        if (ex == 30 && cnv.word0 == 0 && cnv.word1 == 0xC1D00000)\n            return (TValue)(0x80000001);\n        return NULL;\n    }\n\n    int32_t r;\n\n    if (ex <= 20) {\n        if (cnv.word0)\n            return TAG_UNDEFINED;\n        if (cnv.word1 << (ex + 12))\n            return TAG_UNDEFINED;\n        r = ((cnv.word1 << 11) | 0x80000000) >> (20 - ex + 11);\n    } else {\n        if (cnv.word0 << (ex - 20))\n            return TAG_UNDEFINED;\n        r = ((cnv.word1 << 11) | 0x80000000) >> (20 - ex + 11);\n        r |= cnv.word0 >> (32 - (ex - 20));\n    }\n\n    if (cnv.word1 >> 31)\n        return TAG_NUMBER(-r);\n    else\n        return TAG_NUMBER(r);\n}\n#else\nstatic inline TValue doubleToInt(NUMBER r) {\n#ifdef PXT64\n    if ((int)r == r)\n        return TAG_NUMBER((int)r);\n#else\n    int ri = ((int)r) << 1;\n    if ((ri >> 1) == r)\n        return (TNumber)(uintptr_t)(ri | 1);\n#endif\n    return TAG_UNDEFINED;\n}\n#endif\n\nTNumber fromDouble(NUMBER r) {\n#ifndef PXT_BOX_DEBUG\n    auto i = doubleToInt(r);\n    if (i)\n        return i;\n#endif\n    if (isnan(r))\n        return TAG_NAN;\n#ifdef PXT64\n    return tvalueFromDouble(r);\n#else\n    BoxedNumber *p = NEW_GC(BoxedNumber);\n    p->num = r;\n    MEMDBG(\"mkNum: %d/1000 => %p\", (int)(r * 1000), p);\n    return (TNumber)p;\n#endif\n}\n\nTNumber fromFloat(float r) {\n    // TODO optimize\n    return fromDouble(r);\n}\n\nTNumber fromInt(int v) {\n    if (canBeTagged(v))\n        return TAG_NUMBER(v);\n    return fromDouble(v);\n}\n\nTNumber fromUInt(unsigned v) {\n#ifndef PXT_BOX_DEBUG\n    if (v <= 0x3fffffff)\n        return TAG_NUMBER(v);\n#endif\n    return fromDouble(v);\n}\n\nTValue fromBool(bool v) {\n    if (v)\n        return TAG_TRUE;\n    else\n        return TAG_FALSE;\n}\n\nTNumber eqFixup(TNumber v) {\n    if (v == TAG_NULL)\n        return TAG_UNDEFINED;\n    if (v == TAG_TRUE)\n        return TAG_NUMBER(1);\n    if (v == TAG_FALSE)\n        return TAG_NUMBER(0);\n    return v;\n}\n\nstatic inline bool eq_core(TValue a, TValue b, ValType ta) {\n#ifndef PXT_BOX_DEBUG\n    auto aa = (intptr_t)a;\n    auto bb = (intptr_t)b;\n\n    // if at least one of the values is tagged, they are not equal\n    if ((aa | bb) & 3)\n        return false;\n#endif\n\n    if (ta == ValType::String)\n        return String_::compare((String)a, (String)b) == 0;\n    else if (ta == ValType::Number)\n        return toDouble(a) == toDouble(b);\n    else\n        return a == b;\n}\n\nbool eqq_bool(TValue a, TValue b) {\n    if (a == TAG_NAN || b == TAG_NAN)\n        return false;\n\n    if (a == b)\n        return true;\n\n    if (bothNumbers(a, b))\n        return false;\n\n    ValType ta = valType(a);\n    ValType tb = valType(b);\n\n    if (ta != tb)\n        return false;\n\n    return eq_core(a, b, ta);\n}\n\nbool eq_bool(TValue a, TValue b) {\n    if (a == TAG_NAN || b == TAG_NAN)\n        return false;\n\n    if (eqFixup(a) == eqFixup(b))\n        return true;\n\n    if (bothNumbers(a, b))\n        return false;\n\n    ValType ta = valType(a);\n    ValType tb = valType(b);\n\n    if ((ta == ValType::String && tb == ValType::Number) ||\n        (tb == ValType::String && ta == ValType::Number))\n        return toDouble(a) == toDouble(b);\n\n    if (ta == ValType::Boolean) {\n        a = eqFixup(a);\n        ta = ValType::Number;\n    }\n    if (tb == ValType::Boolean) {\n        b = eqFixup(b);\n        tb = ValType::Number;\n    }\n\n    if (ta != tb)\n        return false;\n\n    return eq_core(a, b, ta);\n}\n\n// TODO move to assembly\n//%\nbool switch_eq(TValue a, TValue b) {\n    if (eq_bool(a, b)) {\n        return true;\n    }\n    return false;\n}\n\n} // namespace pxt\n\n#define NUMOP(op) return fromDouble(toDouble(a) op toDouble(b));\n#define BITOP(op) return fromInt(toInt(a) op toInt(b));\nnamespace numops {\n\nint toBool(TValue v) {\n    if (isTagged(v)) {\n        if (v == TAG_FALSE || v == TAG_UNDEFINED || v == TAG_NAN || v == TAG_NULL ||\n            v == TAG_NUMBER(0))\n            return 0;\n        else\n            return 1;\n    }\n\n    ValType t = valType(v);\n    if (t == ValType::String) {\n        String s = (String)v;\n        if (IS_EMPTY(s))\n            return 0;\n    } else if (t == ValType::Number) {\n        auto x = toDouble(v);\n        if (isnan(x) || x == 0.0 || x == -0.0)\n            return 0;\n        else\n            return 1;\n    }\n\n    return 1;\n}\n\nint toBoolDecr(TValue v) {\n    if (v == TAG_TRUE)\n        return 1;\n    if (v == TAG_FALSE)\n        return 0;\n    return toBool(v);\n}\n\n// The integer, non-overflow case for add/sub/bit opts is handled in assembly\n\n#ifdef PXT_VM\n#define NUMOP2(op)                                                                                 \\\n    if (bothNumbers(a, b)) {                                                                       \\\n        auto tmp = (int64_t)numValue(a) op(int64_t) numValue(b);                                   \\\n        if ((int)tmp == tmp)                                                                       \\\n            return TAG_NUMBER((int)tmp);                                                           \\\n    }                                                                                              \\\n    NUMOP(op)\n#else\n#define NUMOP2(op) NUMOP(op)\n#endif\n\n//%\nTNumber adds(TNumber a, TNumber b){NUMOP2(+)}\n\n//%\nTNumber subs(TNumber a, TNumber b){NUMOP2(-)}\n\n//%\nTNumber muls(TNumber a, TNumber b) {\n    if (bothNumbers(a, b)) {\n#ifdef PXT64\n        auto tmp = (int64_t)numValue(a) * (int64_t)numValue(b);\n        if ((int)tmp == tmp)\n            return TAG_NUMBER((int)tmp);\n#else\n        int aa = (int)a;\n        int bb = (int)b;\n        // if both operands fit 15 bits, the result will not overflow int\n        if ((aa >> 15 == 0 || aa >> 15 == -1) && (bb >> 15 == 0 || bb >> 15 == -1)) {\n            // it may overflow 31 bit int though - use fromInt to convert properly\n            return fromInt((aa >> 1) * (bb >> 1));\n        }\n#endif\n    }\n    NUMOP(*)\n}\n\n//%\nTNumber div(TNumber a, TNumber b){NUMOP(/)}\n\n//%\nTNumber mod(TNumber a, TNumber b) {\n    if (isInt(a) && isInt(b) && numValue(b))\n        BITOP(%)\n    return fromDouble(fmod(toDouble(a), toDouble(b)));\n}\n\n//%\nTNumber lsls(TNumber a, TNumber b) {\n    return fromInt(toInt(a) << (toInt(b) & 0x1f));\n}\n\n//%\nTNumber lsrs(TNumber a, TNumber b) {\n    return fromUInt(toUInt(a) >> (toUInt(b) & 0x1f));\n}\n\n//%\nTNumber asrs(TNumber a, TNumber b) {\n    return fromInt(toInt(a) >> (toInt(b) & 0x1f));\n}\n\n//%\nTNumber eors(TNumber a, TNumber b){BITOP (^)}\n\n//%\nTNumber orrs(TNumber a, TNumber b){BITOP(|)}\n\n//%\nTNumber bnot(TNumber a) {\n    return fromInt(~toInt(a));\n}\n\n//%\nTNumber ands(TNumber a, TNumber b) {\n    BITOP(&)\n}\n\n#ifdef PXT64\n#define CMPOP_RAW(op, t, f)                                                                        \\\n    if (bothNumbers(a, b))                                                                         \\\n        return numValue(a) op numValue(b) ? t : f;                                                 \\\n    int cmp = valCompare(a, b);                                                                    \\\n    return cmp != -2 && cmp op 0 ? t : f;\n#else\n#define CMPOP_RAW(op, t, f)                                                                        \\\n    if (bothNumbers(a, b))                                                                         \\\n        return (intptr_t)a op((intptr_t)b) ? t : f;                                                \\\n    int cmp = valCompare(a, b);                                                                    \\\n    return cmp != -2 && cmp op 0 ? t : f;\n#endif\n\n#define CMPOP(op) CMPOP_RAW(op, TAG_TRUE, TAG_FALSE)\n\n// 7.2.13 Abstract Relational Comparison\nstatic int valCompare(TValue a, TValue b) {\n    if (a == TAG_NAN || b == TAG_NAN)\n        return -2;\n\n    ValType ta = valType(a);\n    ValType tb = valType(b);\n\n    if (ta == ValType::String && tb == ValType::String)\n        return String_::compare((String)a, (String)b);\n\n    if (a == b)\n        return 0;\n\n    auto da = toDouble(a);\n    auto db = toDouble(b);\n\n    if (isnan(da) || isnan(db))\n        return -2;\n\n    if (da < db)\n        return -1;\n    else if (da > db)\n        return 1;\n    else\n        return 0;\n}\n\n//%\nbool lt_bool(TNumber a, TNumber b){CMPOP_RAW(<, true, false)}\n\n//%\nTNumber le(TNumber a, TNumber b){CMPOP(<=)}\n\n//%\nTNumber lt(TNumber a, TNumber b){CMPOP(<)}\n\n//%\nTNumber ge(TNumber a, TNumber b){CMPOP(>=)}\n\n//%\nTNumber gt(TNumber a, TNumber b){CMPOP(>)}\n\n//%\nTNumber eq(TNumber a, TNumber b) {\n    return pxt::eq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber neq(TNumber a, TNumber b) {\n    return !pxt::eq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber eqq(TNumber a, TNumber b) {\n    return pxt::eqq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n//%\nTNumber neqq(TNumber a, TNumber b) {\n    return !pxt::eqq_bool(a, b) ? TAG_TRUE : TAG_FALSE;\n}\n\n// How many significant digits mycvt() should output.\n// This cannot be more than 15, as this is the most that can be accurately represented\n// in 64 bit double. Otherwise this code may crash.\n#define DIGITS 15\n\nstatic const uint64_t pows[] = {\n    1LL,           10LL,           100LL,           1000LL,           10000LL,\n    100000LL,      1000000LL,      10000000LL,      100000000LL,      1000000000LL,\n    10000000000LL, 100000000000LL, 1000000000000LL, 10000000000000LL, 100000000000000LL,\n};\n\n// The basic idea is we convert d to a 64 bit integer with DIGITS\n// digits, and then print it out, putting dot in the right place.\n\nvoid mycvt(NUMBER d, char *buf) {\n    if (d < 0) {\n        *buf++ = '-';\n        d = -d;\n    }\n\n    if (!d) {\n        *buf++ = '0';\n        *buf++ = 0;\n        return;\n    }\n\n    int pw = (int)log10(d);\n    int e = 1;\n\n    // if outside 1e-6 -- 1e21 range, we use the e-notation\n    if (d < 1e-6 || d > 1e21) {\n        // normalize number to 1.XYZ, save e, and reset pw\n        if (pw < 0)\n            d *= p10(-pw);\n        else\n            d /= p10(pw);\n        e = pw;\n        pw = 0;\n    }\n\n    int trailingZ = 0;\n    int dotAfter = pw + 1; // at which position the dot should be in the number\n\n    uint64_t dd;\n\n    // normalize number to be integer with exactly DIGITS digits\n    if (pw >= DIGITS) {\n        // if the number is larger than DIGITS, we need trailing zeroes\n        trailingZ = pw - DIGITS + 1;\n        dd = (uint64_t)(d / p10(trailingZ) + 0.5);\n    } else {\n        dd = (uint64_t)(d * p10(DIGITS - pw - 1) + 0.5);\n    }\n\n    // if number is less than 1, we need 0.00...00 at the beginning\n    if (dotAfter < 1) {\n        *buf++ = '0';\n        *buf++ = '.';\n        int n = -dotAfter;\n        while (n--)\n            *buf++ = '0';\n    }\n\n    // now print out the actual number\n    for (int i = DIGITS - 1; i >= 0; i--) {\n        uint64_t q = pows[i];\n        // this may be faster than fp-division and fmod(); or maybe not\n        // anyways, it works\n        int k = '0';\n        while (dd >= q) {\n            dd -= q;\n            k++;\n        }\n        *buf++ = k;\n        // if we're after dot, and what's left is zeroes, stop\n        if (dd == 0 && (DIGITS - i) >= dotAfter)\n            break;\n        // print the dot, if we arrived at it\n        if ((DIGITS - i) == dotAfter)\n            *buf++ = '.';\n    }\n\n    // print out remaining trailing zeroes if any\n    while (trailingZ-- > 0)\n        *buf++ = '0';\n\n    // if we used e-notation, handle that\n    if (e != 1) {\n        *buf++ = 'e';\n        if (e > 0)\n            *buf++ = '+';\n        itoa(e, buf);\n    } else {\n        *buf = 0;\n    }\n}\n\n#if 0\n//%\nTValue floatAsInt(TValue x) {\n    return doubleToInt(toDouble(x));\n}\n\n//% shim=numops::floatAsInt\nfunction floatAsInt(v: number): number { return 0 }\n\nfunction testInt(i: number) {\n    if (floatAsInt(i) != i)\n        control.panic(101)\n    if (floatAsInt(i + 0.5) != null)\n        control.panic(102)\n    if (floatAsInt(i + 0.00001) != null)\n        control.panic(103)\n}\n\nfunction testFloat(i: number) {\n    if (floatAsInt(i) != null)\n        control.panic(104)\n}\n\nfunction testFloatAsInt() {\n    for (let i = 0; i < 0xffff; ++i) {\n        testInt(i)\n        testInt(-i)\n        testInt(i * 10000)\n        testInt(i << 12)\n        testInt(i + 0x3fff0001)\n        testInt(-i - 0x3fff0002)\n        testFloat(i + 0x3fffffff + 1)\n        testFloat((i + 10000) * 1000000)\n    }\n}\n#endif\n\nString toString(TValue v) {\n    ValType t = valType(v);\n\n    if (t == ValType::String) {\n        return (String)v;\n    } else if (t == ValType::Number) {\n        char buf[64];\n\n        if (isInt(v)) {\n            itoa(numValue(v), buf);\n            return mkStringCore(buf);\n        }\n\n        if (v == TAG_NAN)\n            return (String)(void *)sNaN;\n\n        auto x = toDouble(v);\n\n#ifdef PXT_BOX_DEBUG\n        if (x == (int)x) {\n            itoa((int)x, buf);\n            return mkStringCore(buf);\n        }\n#endif\n\n        if (isinf(x)) {\n            if (x < 0)\n                return (String)(void *)sMInf;\n            else\n                return (String)(void *)sInf;\n        } else if (isnan(x)) {\n            return (String)(void *)sNaN;\n        }\n        mycvt(x, buf);\n\n        return mkStringCore(buf);\n    } else if (t == ValType::Function) {\n        return (String)(void *)sFunction;\n    } else {\n        if (v == TAG_UNDEFINED)\n            return (String)(void *)sUndefined;\n        else if (v == TAG_FALSE)\n            return (String)(void *)sFalse;\n        else if (v == TAG_NAN)\n            return (String)(void *)sNaN;\n        else if (v == TAG_TRUE)\n            return (String)(void *)sTrue;\n        else if (v == TAG_NULL)\n            return (String)(void *)sNull;\n        return (String)(void *)sObject;\n    }\n}\n\n} // namespace numops\n\nnamespace Math_ {\n//%\nTNumber pow(TNumber x, TNumber y) {\n#ifdef PXT_POWI\n    // regular pow() from math.h is 4k of code\n    return fromDouble(__builtin_powi(toDouble(x), toInt(y)));\n#else\n    return fromDouble(::pow(toDouble(x), toDouble(y)));\n#endif\n}\n\nNUMBER randomDouble() {\n    return getRandom(UINT_MAX) / ((NUMBER)UINT_MAX + 1) +\n           getRandom(0xffffff) / ((NUMBER)UINT_MAX * 0xffffff);\n}\n\n//%\nTNumber random() {\n    return fromDouble(randomDouble());\n}\n\n//%\nTNumber randomRange(TNumber min, TNumber max) {\n    if (isInt(min) && isInt(max)) {\n        int mini = numValue(min);\n        int maxi = numValue(max);\n        if (mini > maxi) {\n            int temp = mini;\n            mini = maxi;\n            maxi = temp;\n        }\n        if (maxi == mini)\n            return fromInt(mini);\n        else\n            return fromInt(mini + getRandom(maxi - mini));\n    } else {\n        auto mind = toDouble(min);\n        auto maxd = toDouble(max);\n        if (mind > maxd) {\n            auto temp = mind;\n            mind = maxd;\n            maxd = temp;\n        }\n        if (maxd == mind)\n            return fromDouble(mind);\n        else {\n            return fromDouble(mind + randomDouble() * (maxd - mind));\n        }\n    }\n}\n\n#define SINGLE(op) return fromDouble(::op(toDouble(x)));\n\n//%\nTNumber log(TNumber x){SINGLE(log)}\n\n//%\nTNumber log10(TNumber x){SINGLE(log10)}\n\n//%\nTNumber floor(TNumber x){SINGLE(floor)}\n\n//%\nTNumber ceil(TNumber x){SINGLE(ceil)}\n\n//%\nTNumber trunc(TNumber x){SINGLE(trunc)}\n\n//%\nTNumber round(TNumber x) {\n    // In C++, round(-1.5) == -2, while in JS, round(-1.5) == -1. Align to the JS convention for\n    // consistency between simulator and device. The following does rounding with ties (x.5) going\n    // towards positive infinity.\n    return fromDouble(::floor(toDouble(x) + 0.5));\n}\n\n//%\nint imul(int x, int y) {\n    return x * y;\n}\n\n//%\nint idiv(int x, int y) {\n    return x / y;\n}\n} // namespace Math_\n\nnamespace Array_ {\nRefCollection *mk() {\n    auto r = NEW_GC(RefCollection);\n    MEMDBG(\"mkColl: => %p\", r);\n    return r;\n}\nint length(RefCollection *c) {\n    return c->length();\n}\nvoid setLength(RefCollection *c, int newLength) {\n    c->setLength(newLength);\n}\nvoid push(RefCollection *c, TValue x) {\n    c->head.push(x);\n}\nTValue pop(RefCollection *c) {\n    return c->head.pop();\n}\nTValue getAt(RefCollection *c, int x) {\n    return c->head.get(x);\n}\nvoid setAt(RefCollection *c, int x, TValue y) {\n    c->head.set(x, y);\n}\nTValue removeAt(RefCollection *c, int x) {\n    return c->head.remove(x);\n}\nvoid insertAt(RefCollection *c, int x, TValue value) {\n    c->head.insert(x, value);\n}\nint indexOf(RefCollection *c, TValue x, int start) {\n    auto data = c->head.getData();\n    auto len = c->head.getLength();\n    for (unsigned i = 0; i < len; i++) {\n        if (pxt::eq_bool(data[i], x)) {\n            return (int)i;\n        }\n    }\n    return -1;\n}\nbool removeElement(RefCollection *c, TValue x) {\n    int idx = indexOf(c, x, 0);\n    if (idx >= 0) {\n        decr(removeAt(c, idx));\n        return 1;\n    }\n    return 0;\n}\n} // namespace Array_\n\nnamespace pxt {\nint debugFlags;\n\n//%\nvoid *ptrOfLiteral(int offset);\n\n#ifdef PXT_VM\nunsigned programSize() {\n    return 0;\n}\n#else\n//%\nunsigned programSize() {\n    return bytecode[17] * 8;\n}\n#endif\n\nvoid deepSleep() __attribute__((weak));\n//%\nvoid deepSleep() {}\n\nint *getBootloaderConfigData() __attribute__((weak));\nint *getBootloaderConfigData() {\n    return NULL;\n}\n\n//%\nint getConfig(int key, int defl) {\n#ifdef PXT_VM\n    int *cfgData = vmImg->configData;\n#else\n    int *cfgData = bytecode ? *(int **)&bytecode[18] : NULL;\n#endif\n\n    if (cfgData) {\n        for (int i = 0;; i += 2) {\n            if (cfgData[i] == key)\n                return cfgData[i + 1];\n            if (cfgData[i] == 0)\n                break;\n        }\n    }\n\n    cfgData = getBootloaderConfigData();\n\n    if (cfgData) {\n        for (int i = 0;; i += 2) {\n            if (cfgData[i] == key)\n                return cfgData[i + 1];\n            if (cfgData[i] == 0)\n                break;\n        }\n    }\n\n    return defl;\n}\n\n} // namespace pxt\n\nnamespace pxtrt {\n//%\nTValue ldlocRef(RefRefLocal *r) {\n    return r->v;\n}\n\n//%\nvoid stlocRef(RefRefLocal *r, TValue v) {\n    r->v = v;\n}\n\n//%\nRefRefLocal *mklocRef() {\n    auto r = NEW_GC(RefRefLocal);\n    MEMDBG(\"mklocRef: => %p\", r);\n    return r;\n}\n\n// Store a captured local in a closure. It returns the action, so it can be chained.\n//%\nRefAction *stclo(RefAction *a, int idx, TValue v) {\n    // DBG(\"STCLO \"); a->print(); DBG(\"@%d = %p\\n\", idx, (void*)v);\n    a->stCore(idx, v);\n    return a;\n}\n\n//%\nvoid panic(int code) {\n    soft_panic(code);\n}\n\n//%\nString emptyToNull(String s) {\n    if (!s || IS_EMPTY(s))\n        return NULL;\n    return s;\n}\n\n//%\nint ptrToBool(TValue p) {\n    if (p) {\n        decr(p);\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nRefMap *mkMap() {\n    auto r = NEW_GC(RefMap);\n    MEMDBG(\"mkMap: => %p\", r);\n    return r;\n}\n\nTValue mapGetByString(RefMap *map, String key) {\n    int i = map->findIdx(key);\n    if (i < 0) {\n        return 0;\n    }\n    return map->values.get(i);\n}\n\n#ifdef PXT_VM\n#define IFACE_MEMBER_NAMES vmImg->ifaceMemberNames\n#else\n#define IFACE_MEMBER_NAMES *(uintptr_t **)&bytecode[22]\n#endif\n\nint lookupMapKey(String key) {\n    auto arr = IFACE_MEMBER_NAMES;\n    auto len = *arr++;\n    int l = 1U; // skip index 0 - it's invalid\n    int r = (int)len - 1;\n    auto ikey = (uintptr_t)key;\n    if (arr[l] <= ikey && ikey <= arr[r]) {\n        while (l <= r) {\n            auto m = (l + r) >> 1;\n            if (arr[m] == ikey)\n                return m;\n            else if (arr[m] < ikey)\n                l = m + 1;\n            else\n                r = m - 1;\n        }\n    } else {\n        while (l <= r) {\n            int m = (l + r) >> 1;\n            auto cmp = String_::compare((String)arr[m], key);\n            if (cmp == 0)\n                return m;\n            else if (cmp < 0)\n                l = m + 1;\n            else\n                r = m - 1;\n        }\n    }\n    return 0;\n}\n\nTValue mapGet(RefMap *map, unsigned key) {\n    auto arr = (String *)IFACE_MEMBER_NAMES;\n    auto r = mapGetByString(map, arr[key + 1]);\n    map->unref();\n    return r;\n}\n\nvoid mapSetByString(RefMap *map, String key, TValue val) {\n    int i = map->findIdx(key);\n    if (i < 0) {\n        map->keys.push((TValue)key);\n        map->values.push(val);\n    } else {\n        map->values.set(i, val);\n    }\n}\n\nvoid mapSet(RefMap *map, unsigned key, TValue val) {\n    auto arr = (String *)IFACE_MEMBER_NAMES;\n    mapSetByString(map, arr[key + 1], val);\n    decr(val);\n    map->unref();\n}\n\n//\n// Debugger\n//\n\n// This is only to be called once at the beginning of lambda function\n//%\nvoid *getGlobalsPtr() {\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    return globals;\n}\n\n//%\nvoid runtimeWarning(String s) {\n    // noop for now\n}\n} // namespace pxtrt\n#endif\n\nnamespace pxt {\n\n//%\nValType valType(TValue v) {\n    if (isTagged(v)) {\n        if (!v)\n            return ValType::Undefined;\n\n        if (isInt(v) || v == TAG_NAN)\n            return ValType::Number;\n        if (v == TAG_TRUE || v == TAG_FALSE)\n            return ValType::Boolean;\n        else if (v == TAG_NULL)\n            return ValType::Object;\n        else {\n            oops(1);\n            return ValType::Object;\n        }\n#ifdef PXT64\n    } else if (isDouble(v)) {\n        return ValType::Number;\n#endif\n    } else {\n        auto vt = getVTable((RefObject *)v);\n        if (vt->magic == VTABLE_MAGIC)\n            return vt->objectType;\n        else\n            return ValType::Object;\n    }\n}\n\nPXT_DEF_STRING(sObjectTp, \"object\")\nPXT_DEF_STRING(sBooleanTp, \"boolean\")\nPXT_DEF_STRING(sStringTp, \"string\")\nPXT_DEF_STRING(sNumberTp, \"number\")\nPXT_DEF_STRING(sFunctionTp, \"function\")\nPXT_DEF_STRING(sUndefinedTp, \"undefined\")\n\n//% expose\nString typeOf(TValue v) {\n    switch (valType(v)) {\n    case ValType::Undefined:\n        return (String)sUndefinedTp;\n    case ValType::Boolean:\n        return (String)sBooleanTp;\n    case ValType::Number:\n        return (String)sNumberTp;\n    case ValType::String:\n        return (String)sStringTp;\n    case ValType::Object:\n        return (String)sObjectTp;\n    case ValType::Function:\n        return (String)sFunctionTp;\n    default:\n        oops(2);\n        return 0;\n    }\n}\n\n// Maybe in future we will want separate print methods; for now ignore\nvoid anyPrint(TValue v) {\n    if (valType(v) == ValType::Object) {\n        if (isRefCounted(v)) {\n            auto o = (RefObject *)v;\n            auto vt = getVTable(o);\n            auto meth = ((RefObjectMethod)vt->methods[1]);\n            if ((void *)meth == (void *)&anyPrint)\n                DMESG(\"[RefObject vt=%p cl=%d sz=%d]\", o->vtable, vt->classNo,\n                      vt->numbytes);\n            else\n                meth(o);\n        } else {\n            DMESG(\"[Native %p]\", v);\n        }\n    } else {\n#ifndef X86_64\n        String s = numops::toString(v);\n        DMESG(\"[%s %p = %s]\", pxt::typeOf(v)->getUTF8Data(), v, s->getUTF8Data());\n        decr((TValue)s);\n#endif\n    }\n}\n\nstatic void dtorDoNothing() {}\n\n#define PRIM_VTABLE(name, objectTp, tp, szexpr)                                                    \\\n    static uint32_t name##_size(tp *p) { return TOWORDS(sizeof(tp) + szexpr); }                    \\\n    DEF_VTABLE(name##_vt, tp, objectTp, (void *)&dtorDoNothing, (void *)&anyPrint, 0,              \\\n               (void *)&name##_size)\n\n#define NOOP ((void)0)\n\n#define STRING_VT(name, fix, scan, gcsize, data, utfsize, length, dataAt)                          \\\n    static uint32_t name##_gcsize(BoxedString *p) { return TOWORDS(sizeof(void *) + (gcsize)); }   \\\n    static void name##_gcscan(BoxedString *p) { scan; }                                            \\\n    static const char *name##_data(BoxedString *p) {                                               \\\n        fix;                                                                                       \\\n        return data;                                                                               \\\n    }                                                                                              \\\n    static uint32_t name##_utfsize(BoxedString *p) {                                               \\\n        fix;                                                                                       \\\n        return utfsize;                                                                            \\\n    }                                                                                              \\\n    static uint32_t name##_length(BoxedString *p) {                                                \\\n        fix;                                                                                       \\\n        return length;                                                                             \\\n    }                                                                                              \\\n    static const char *name##_dataAt(BoxedString *p, uint32_t idx) {                               \\\n        fix;                                                                                       \\\n        return dataAt;                                                                             \\\n    }                                                                                              \\\n    DEF_VTABLE(name##_vt, BoxedString, ValType::String, (void *)&dtorDoNothing, (void *)&anyPrint, \\\n               (void *)&name##_gcscan, (void *)&name##_gcsize, (void *)&name##_data,               \\\n               (void *)&name##_utfsize, (void *)&name##_length, (void *)&name##_dataAt)\n\nvoid gcMarkArray(void *data);\nvoid gcScan(TValue v);\n\n#if PXT_UTF8\nstatic const char *skipLookup(BoxedString *p, uint32_t idx) {\n    if (idx > p->skip.length)\n        return NULL;\n    auto ent = idx / SKIP_INCR;\n    auto data = SKIP_DATA(p);\n    auto size = p->skip.size;\n    if (ent) {\n        auto off = p->skip.list[ent - 1];\n        data += off;\n        size -= off;\n        idx &= SKIP_INCR - 1;\n    }\n    return utf8Skip(data, size, idx);\n}\n\nextern LLSegment workQueue;\n\nstatic uint32_t fixSize(BoxedString *p, uint32_t *len) {\n    uint32_t tlen = 0;\n    uint32_t sz = 0;\n    if (workQueue.getLength())\n        oops(81);\n    workQueue.push((TValue)p);\n    while (workQueue.getLength()) {\n        p = (BoxedString *)workQueue.pop();\n        if (IS_CONS(p)) {\n            workQueue.push((TValue)p->cons.right);\n            workQueue.push((TValue)p->cons.left);\n        } else {\n            tlen += p->getLength();\n            sz += p->getUTF8Size();\n        }\n    }\n    *len = tlen;\n    return sz;\n}\n\nstatic void fixCopy(BoxedString *p, char *dst) {\n    if (workQueue.getLength())\n        oops(81);\n\n    workQueue.push((TValue)p);\n    while (workQueue.getLength()) {\n        p = (BoxedString *)workQueue.pop();\n        if (IS_CONS(p)) {\n            workQueue.push((TValue)p->cons.right);\n            workQueue.push((TValue)p->cons.left);\n        } else {\n            auto sz = p->getUTF8Size();\n            memcpy(dst, p->getUTF8Data(), sz);\n            dst += sz;\n        }\n    }\n}\n\n// switches CONS representation into skip list representation\n// does not switch representation of CONS' children\nstatic void fixCons(BoxedString *r) {\n    uint32_t length = 0;\n    auto sz = fixSize(r, &length);\n    auto numSkips = length / SKIP_INCR;\n    // allocate first, while [r] still holds references to its children\n    // because allocation might trigger GC\n    auto data = (uint16_t *)gcAllocateArray(numSkips * 2 + sz + 1);\n    // copy, while [r] is still cons\n    fixCopy(r, (char *)(data + numSkips));\n    // now, set [r] up properly\n    r->vtable = PXT_VTABLE_TO_INT(&string_skiplist16_vt);\n    r->skip.size = sz;\n    r->skip.length = length;\n    r->skip.list = data;\n    setupSkipList(r, NULL);\n}\n#endif\n\nSTRING_VT(string_inline_ascii, NOOP, NOOP, 2 + p->ascii.length + 1, p->ascii.data, p->ascii.length,\n          p->ascii.length, idx <= p->ascii.length ? p->ascii.data + idx : NULL)\n#if PXT_UTF8\nSTRING_VT(string_inline_utf8, NOOP, NOOP, 2 + p->utf8.length + 1, p->utf8.data, p->utf8.length,\n          utf8Len(p->utf8.data, p->utf8.length), utf8Skip(p->utf8.data, p->utf8.length, idx))\nSTRING_VT(string_skiplist16, NOOP, if (p->skip.list) gcMarkArray(p->skip.list), 2 * sizeof(void *),\n          SKIP_DATA(p), p->skip.size, p->skip.length, skipLookup(p, idx))\nSTRING_VT(string_cons, fixCons(p), (gcScan((TValue)p->cons.left), gcScan((TValue)p->cons.right)),\n          2 * sizeof(void *), SKIP_DATA(p), p->skip.size, p->skip.length, skipLookup(p, idx))\n#endif\n\nPRIM_VTABLE(number, ValType::Number, BoxedNumber, 0)\nPRIM_VTABLE(buffer, ValType::Object, BoxedBuffer, p->length)\n// PRIM_VTABLE(action, ValType::Function, RefAction, )\n\nvoid failedCast(TValue v, void *addr) {\n    DMESG(\"failed type check for %p @%p\", v, addr);\n    auto vt = getAnyVTable(v);\n    if (vt) {\n        DMESG(\"VT %p - objtype %d classNo %d\", vt, vt->objectType, vt->classNo);\n    }\n\n    int code;\n    if (v == TAG_NULL)\n        code = PANIC_CAST_FROM_NULL;\n    else\n        code = PANIC_CAST_FIRST + (int)valType(v);\n    soft_panic(code);\n}\n\nvoid missingProperty(TValue v) {\n    DMESG(\"missing property on %p\", v);\n    soft_panic(PANIC_MISSING_PROPERTY);\n}\n\n#ifdef PXT_PROFILE\nstruct PerfCounter *perfCounters;\n\nstruct PerfCounterInfo {\n    uint32_t numPerfCounters;\n    char *perfCounterNames[0];\n};\n\n#define PERF_INFO ((PerfCounterInfo *)(((uintptr_t *)bytecode)[13]))\n\nvoid initPerfCounters() {\n    auto n = PERF_INFO->numPerfCounters;\n    perfCounters = new PerfCounter[n];\n    memset(perfCounters, 0, n * sizeof(PerfCounter));\n}\n\nvoid dumpPerfCounters() {\n    auto info = PERF_INFO;\n    DMESG(\"calls,us,name\");\n    for (uint32_t i = 0; i < info->numPerfCounters; ++i) {\n        auto c = &perfCounters[i];\n        DMESG(\"%d,%d,%s\", c->numstops, c->value, info->perfCounterNames[i]);\n    }\n}\n\nvoid startPerfCounter(PerfCounters n) {\n    if (!perfCounters)\n        return;\n    auto c = &perfCounters[(uint32_t)n];\n    if (c->start)\n        oops(50);\n    c->start = PERF_NOW();\n}\n\nvoid stopPerfCounter(PerfCounters n) {\n    if (!perfCounters)\n        return;\n    auto c = &perfCounters[(uint32_t)n];\n    if (!c->start)\n        oops(51);\n    c->value += PERF_NOW() - c->start;\n    c->start = 0;\n    c->numstops++;\n}\n#endif\n\n// Exceptions\n\n#ifndef PXT_EXN_CTX\n#define PXT_EXN_CTX() getThreadContext()\n#endif\n\ntypedef void (*RestoreStateType)(TryFrame *, ThreadContext *);\n#ifndef pxt_restore_exception_state\n#define pxt_restore_exception_state ((RestoreStateType)(((uintptr_t *)bytecode)[14]))\n#endif\n\n//%\nTryFrame *beginTry() {\n    auto ctx = PXT_EXN_CTX();\n    auto frame = (TryFrame *)app_alloc(sizeof(TryFrame));\n    frame->parent = ctx->tryFrame;\n    ctx->tryFrame = frame;\n    return frame;\n}\n\n//% expose\nvoid endTry() {\n    auto ctx = PXT_EXN_CTX();\n    auto f = ctx->tryFrame;\n    if (!f)\n        oops(51);\n    ctx->tryFrame = f->parent;\n    app_free(f);\n}\n\n//% expose\nvoid throwValue(TValue v) {\n    auto ctx = PXT_EXN_CTX();\n    auto f = ctx->tryFrame;\n    if (!f) {\n        DMESG(\"unhandled exception, value:\");\n        anyPrint(v);\n        target_panic(PANIC_UNHANDLED_EXCEPTION);\n    }\n    ctx->tryFrame = f->parent;\n    TryFrame copy = *f;\n    app_free(f);\n    ctx->thrownValue = v;\n    pxt_restore_exception_state(&copy, ctx);\n}\n\n//% expose\nTValue getThrownValue() {\n    auto ctx = PXT_EXN_CTX();\n    auto v = ctx->thrownValue;\n    ctx->thrownValue = TAG_NON_VALUE;\n    if (v == TAG_NON_VALUE)\n        oops(51);\n    return v;\n}\n\n//% expose\nvoid endFinally() {\n    auto ctx = PXT_EXN_CTX();\n    if (ctx->thrownValue == TAG_NON_VALUE)\n        return;\n    throwValue(getThrownValue());\n}\n\n// https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\nuint32_t hash_fnv1(const void *data, unsigned len) {\n    const uint8_t *d = (const uint8_t *)data;\n    uint32_t h = 0x811c9dc5;\n    while (len--)\n        h = (h * 0x1000193) ^ *d++;\n    return h;\n}\n\n// redefined in melody.cpp\n__attribute__((weak)) int redirectSamples(int16_t *dst, int numsamples, int samplerate) {\n    return 0;\n}\n\n} // namespace pxt\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum NumberFormat {\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    }\n\n\n    declare const enum PerfCounters {\n    GC = 0,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "eventcontext.ts": "namespace control {\n    /**\n     * Run code when a registered event happens.\n     * @param id the event compoent id\n     * @param value the event value to match\n     */\n    //% weight=20 blockGap=8 blockId=\"control_on_event\" block=\"on event|from %src|with value %value\"\n    //% blockExternalInputs=1\n    //% help=\"control/on-event\"\n    export function onEvent(src: number, value: number, handler: () => void, flags = 16) { // EVENT_LISTENER_DEFAULT_FLAGS\n        const ctx = control.eventContext();\n        if (!ctx)\n            control.internalOnEvent(src, value, handler, flags);\n        else\n            ctx.registerHandler(src, value, handler, flags);\n    }\n\n    export class FrameCallback {\n        order: number\n        handler: () => void\n    }\n\n    class EventHandler {\n        constructor(\n            public src: number,\n            public value: number,\n            public handler: () => void,\n            public flags: number\n        ) { }\n\n        register() {\n            control.internalOnEvent(this.src, this.value, () => {\n                if (this.handler) this.handler();\n            }, this.flags)\n        }\n\n        unregister() {\n            control.internalOnEvent(this.src, this.value, doNothing, this.flags);\n        }\n    }\n\n    function doNothing() { }\n\n\n\n    export class EventContext {\n        private handlers: EventHandler[];\n        private frameCallbacks: FrameCallback[];\n        private frameWorker: number;\n        private framesInSample: number;\n        private timeInSample: number;\n        public deltaTimeMillis: number;\n        private prevTimeMillis: number;\n        private idleCallbacks: (() => void)[];\n\n        static lastStats: string;\n        static onStats: (stats: string) => void;\n\n        constructor() {\n            this.handlers = [];\n            this.framesInSample = 0;\n            this.timeInSample = 0;\n            this.deltaTimeMillis = 0;\n            this.frameWorker = 0;\n            this.idleCallbacks = undefined;\n            if (!EventContext.lastStats) {\n                EventContext.lastStats = \"\";\n            }\n        }\n\n        get deltaTime() {\n            return this.deltaTimeMillis / 1000;\n        }\n\n        private runCallbacks() {\n            control.enablePerfCounter(\"all frame callbacks\")\n\n            let loopStart = control.millis()\n            this.deltaTimeMillis = loopStart - this.prevTimeMillis;\n            this.prevTimeMillis = loopStart;\n            for (let f of this.frameCallbacks) {\n                f.handler()\n            }\n            let runtime = control.millis() - loopStart\n            this.timeInSample += runtime\n            this.framesInSample++\n            if (this.timeInSample > 1000 || this.framesInSample > 30) {\n                const fps = this.framesInSample / (this.timeInSample / 1000);\n                EventContext.lastStats = `fps:${Math.round(fps)}`;\n                if (fps < 99)\n                    EventContext.lastStats += \".\" + (Math.round(fps * 10) % 10)\n                if (control.ramSize() > 2000000 && control.profilingEnabled()) {\n                    control.dmesg(`${(fps * 100) | 0}/100 fps - ${this.framesInSample} frames`)\n                    control.gc()\n                    control.dmesgPerfCounters()\n                }\n                this.timeInSample = 0\n                this.framesInSample = 0\n            }\n            let delay = Math.max(1, 20 - runtime)\n\n            return delay\n        }\n\n        private runningCallbacks: boolean;\n        private registerFrameCallbacks() {\n            if (!this.frameCallbacks) return;\n\n            const worker = this.frameWorker;\n            control.runInParallel(() => {\n                if (this.runningCallbacks) {\n                    // this context is still running in a different fiber;\n                    // delay until the other fiber doing so has ceased.\n                    pauseUntil(() => !this.runningCallbacks);\n                }\n                this.runningCallbacks = true;\n\n                this.framesInSample = 0;\n                this.timeInSample = 0;\n                this.deltaTimeMillis = 0;\n                this.prevTimeMillis = control.millis();\n\n                while (worker == this.frameWorker) {\n                    let delay = this.runCallbacks()\n                    pause(delay)\n                }\n\n                this.runningCallbacks = false;\n            })\n        }\n\n        register() {\n            for (const h of this.handlers)\n                h.register();\n            this.registerFrameCallbacks();\n        }\n\n        unregister() {\n            for (const h of this.handlers)\n                h.unregister();\n            this.frameWorker++;\n        }\n\n        registerFrameHandler(order: number, handler: () => void): FrameCallback {\n            if (!this.frameCallbacks) {\n                this.frameCallbacks = [];\n                this.registerFrameCallbacks();\n            }\n\n            const fn = new FrameCallback()\n            fn.order = order\n            fn.handler = handler\n            for (let i = 0; i < this.frameCallbacks.length; ++i) {\n                if (this.frameCallbacks[i].order > order) {\n                    this.frameCallbacks.insertAt(i, fn)\n                    return fn;\n                }\n            }\n            this.frameCallbacks.push(fn);\n            return fn;\n        }\n\n        unregisterFrameHandler(fn: FrameCallback) {\n            if (!fn || !this.frameCallbacks) return;\n            const i = this.frameCallbacks.indexOf(fn);\n            if (i > -1)\n                this.frameCallbacks.splice(i, 1);\n        }\n\n        registerHandler(src: number, value: number, handler: () => void, flags: number) {\n            // already there?\n            for (const h of this.handlers) {\n                if (h.src == src && h.value == value) {\n                    h.flags = flags;\n                    h.handler = handler;\n                    return;\n                }\n            }\n            // register and push\n            const hn = new EventHandler(src, value, handler, flags);\n            this.handlers.push(hn);\n            hn.register();\n        }\n\n        addIdleHandler(handler: () => void) {\n            if (!this.idleCallbacks) {\n                this.idleCallbacks = [];\n                this.registerHandler(15/*DAL.DEVICE_ID_SCHEDULER*/, 2/*DAL.DEVICE_SCHEDULER_EVT_IDLE*/, () => this.runIdleHandler(), 16);\n            }\n            this.idleCallbacks.push(handler);\n        }\n\n        removeIdleHandler(handler: () => void) {\n            if (handler && this.idleCallbacks)\n                this.idleCallbacks.removeElement(handler);\n        }\n\n        private runIdleHandler() {\n            if (this.idleCallbacks) {\n                const ics = this.idleCallbacks.slice(0);\n                ics.forEach(ic => ic());\n            }\n        }\n    }\n    let eventContexts: EventContext[];\n\n    /**\n     * Gets the current event context if any\n     */\n    export function eventContext(): EventContext {\n        return eventContexts ? eventContexts[eventContexts.length - 1] : undefined;\n    }\n\n    /**\n     * Pushes a new event context and clears all handlers\n     */\n    export function pushEventContext(): EventContext {\n        if (!eventContexts)\n            eventContexts = [];\n\n        // unregister previous context\n        const ctx = eventContext();\n        if (ctx) ctx.unregister();\n        // register again\n        const n = new EventContext();\n        eventContexts.push(n);\n        return n;\n    }\n\n    /**\n     * Pops the current event context and restore handlers if any previous context\n     */\n    export function popEventContext() {\n        if (!eventContexts) return;\n\n        // clear current context\n        const ctx = eventContexts.pop();\n        if (!ctx) return;\n        ctx.unregister();\n\n        // register old context again\n        const context = eventContexts[eventContexts.length - 1];\n        if (context)\n            context.register();\n        else\n            eventContexts = undefined;\n    }\n\n    let _idleCallbacks: (() => void)[];\n    /**\n     * Registers a function to run when the device is idling\n     * @param handler\n    */\n    export function onIdle(handler: () => void) {\n        if (!handler) return;\n\n        const ctx = eventContext();\n        if (ctx) ctx.addIdleHandler(handler);\n        else {\n            if (!_idleCallbacks) {\n                _idleCallbacks = [];\n                control.runInBackground(function () {\n                    while (_idleCallbacks) {\n                        _idleCallbacks.slice(0).forEach(cb => cb());\n                        pause(20);\n                    }\n                })\n                /*\n                control.internalOnEvent(\n                    15. // DAL.DEVICE_ID_SCHEDULER\n                    2, // DAL.DEVICE_SCHEDULER_EVT_IDLE\n                    function() {\n                        pins.LED.digitalWrite(on = !on);\n                        if (_idleCallbacks)\n                            _idleCallbacks.slice(0).forEach(cb => cb());\n                    }, 192); // MESSAGE_BUS_LISTENER_IMMEDIATE\n                */\n            }\n            _idleCallbacks.push(handler);\n        }\n    }\n\n    export function removeIdleHandler(handler: () => void) {\n        if (!handler) return;\n        const ctx = eventContext();\n        if (ctx) ctx.removeIdleHandler(handler);\n        else if (_idleCallbacks) _idleCallbacks.removeElement(handler);\n    }\n}",
            "fixed.ts": "interface Fx8 {\n    _dummyFx8: string;\n}\n\nfunction Fx8(v: number) {\n    return ((v * 256) | 0) as any as Fx8\n}\n\nnamespace Fx {\n    export const zeroFx8 = 0 as any as Fx8\n    export const oneHalfFx8 = 128 as any as Fx8\n    export const oneFx8 = 256 as any as Fx8\n    export const twoFx8 = 512 as any as Fx8\n\n    export function neg(a: Fx8) {\n        return (-(a as any as number)) as any as Fx8\n    }\n    export function toIntShifted(a: Fx8, n: number) {\n        return (a as any as number) >> (n + 8)\n    }\n    export function add(a: Fx8, b: Fx8) {\n        return ((a as any as number) + (b as any as number)) as any as Fx8\n    }\n    export function iadd(a: number, b: Fx8) {\n        return ((a << 8) + (b as any as number)) as any as Fx8\n    }\n    export function sub(a: Fx8, b: Fx8) {\n        return ((a as any as number) - (b as any as number)) as any as Fx8\n    }\n    export function mul(a: Fx8, b: Fx8) {\n        return (Math.imul((a as any as number), (b as any as number)) >> 8) as any as Fx8\n    }\n    export function imul(a: Fx8, b: number) {\n        return Math.imul((a as any as number), (b as any as number)) as any as Fx8\n    }\n    export function div(a: Fx8, b: Fx8) {\n        return Math.idiv((a as any as number) << 8, b as any as number) as any as Fx8\n    }\n    export function idiv(a: Fx8, b: number) {\n        return Math.idiv((a as any as number), b) as any as Fx8\n    }\n    export function compare(a: Fx8, b: Fx8) {\n        return (a as any as number) - (b as any as number)\n    }\n    export function abs(a: Fx8) {\n        if ((a as any as number) < 0)\n            return (-(a as any as number)) as any as Fx8\n        else\n            return a\n    }\n    export function min(a: Fx8, b: Fx8) {\n        if (a < b)\n            return a\n        else\n            return b\n    }\n    export function max(a: Fx8, b: Fx8) {\n        if (a > b)\n            return a\n        else\n            return b\n    }\n    export function leftShift(a: Fx8, n: number) {\n        return (a as any as number << n) as any as Fx8\n    }\n    export function rightShift(a: Fx8, n: number) {\n        return (a as any as number >> n) as any as Fx8\n    }\n    export function toInt(v: Fx8) {\n        return ((v as any as number) + 128) >> 8\n    }\n    export function toFloat(v: Fx8) {\n        return (v as any as number) / 256\n    }\n}",
            "forever.ts": "/**\n * Repeats the code forever in the background. On each iteration, allows other codes to run.\n * @param body code to execute\n */\n//% help=loops/forever weight=100 afterOnStart=true blockNamespace=\"loops\"\n//% blockId=forever block=\"forever\" blockAllowMultiple=1\nfunction forever(a: () => void): void {\n    loops.forever(a);\n}\n\n// micro:bit compatibility\n// these functions allow some level of reuse\n// between micro:bit and other maker-style editors\nnamespace basic {\n    export function forever(a: () => void) {\n        loops.forever(a);\n    }\n}",
            "gc.cpp": "#include \"pxtbase.h\"\n\n#ifndef GC_BLOCK_SIZE\n#define GC_BLOCK_SIZE (1024 * 16)\n#endif\n\n#ifndef GC_MAX_ALLOC_SIZE\n#define GC_MAX_ALLOC_SIZE (GC_BLOCK_SIZE - 16)\n#endif\n\n#ifndef GC_ALLOC_BLOCK\n#define GC_ALLOC_BLOCK xmalloc\n#endif\n\n#ifdef PXT64\n#define HIGH_SHIFT 48\n#define BYTES_TO_WORDS(x) ((x) >> 3)\n#define WORDS_TO_BYTES(x) ((x) << 3)\n#define ALIGN_TO_WORD(x) (((x) + 7) & (~7ULL))\n#define VAR_BLOCK_WORDS(vt) ((uint32_t)(vt) >> 2)\n#else\n#define HIGH_SHIFT 28\n#define BYTES_TO_WORDS(x) ((x) >> 2)\n#define WORDS_TO_BYTES(x) ((x) << 2)\n#define ALIGN_TO_WORD(x) (((x) + 3) & (~3U))\n#define VAR_BLOCK_WORDS(vt) (((uint32_t)(vt) << 4) >> (4 + 2))\n#endif\n\n#define FREE_MASK (1ULL << (HIGH_SHIFT + 3))\n#define ARRAY_MASK (1ULL << (HIGH_SHIFT + 2))\n#define PERMA_MASK (1ULL << (HIGH_SHIFT + 1))\n#define MARKED_MASK 0x1\n#define ANY_MARKED_MASK 0x3\n\n// the bit operations should be faster than loading large constants\n#define IS_FREE(vt) ((uintptr_t)(vt) >> (HIGH_SHIFT + 3))\n#define IS_ARRAY(vt) (((uintptr_t)(vt) >> (HIGH_SHIFT + 2)) & 1)\n#define IS_PERMA(vt) (((uintptr_t)(vt) >> (HIGH_SHIFT + 1)) & 1)\n#define IS_VAR_BLOCK(vt) ((uintptr_t)(vt) >> (HIGH_SHIFT + 2))\n#define IS_MARKED(vt) ((uintptr_t)(vt)&MARKED_MASK)\n#define IS_LIVE(vt) (IS_MARKED(vt) || (((uintptr_t)(vt) >> (HIGH_SHIFT)) == 0x6))\n\n//#define PXT_GC_DEBUG 1\n#ifndef PXT_GC_CHECKS\n#define PXT_GC_CHECKS 1\n#endif\n//#define PXT_GC_STRESS 1\n\n//#define PXT_GC_CHECKS 1\n\n#define MARK(v)                                                                                    \\\n    do {                                                                                           \\\n        GC_CHECK(inGCArea(v), 42);                                                                 \\\n        *(uintptr_t *)(v) |= MARKED_MASK;                                                          \\\n    } while (0)\n\n#ifdef PXT_GC_DEBUG\n#define LOG DMESG\n#define VLOG DMESG\n#define VVLOG DMESG\n#else\n#define LOG NOLOG\n#define VLOG NOLOG\n#define VVLOG NOLOG\n#endif\n\n#ifdef PXT_GC_CHECKS\n#define GC_CHECK(cond, code)                                                                       \\\n    if (!(cond))                                                                                   \\\n    oops(code)\n#else\n#define GC_CHECK(cond, code) ((void)0)\n#endif\n\nnamespace pxt {\n\n// keep in sync with base/control.ts, function gcStats()\nstruct GCStats {\n    uint32_t numGC;\n    uint32_t numBlocks;\n    uint32_t totalBytes;\n    uint32_t lastFreeBytes;\n    uint32_t lastMaxBlockBytes;\n    uint32_t minFreeBytes;\n};\n\nstatic GCStats gcStats;\n\n//% expose\nBuffer getGCStats() {\n    return mkBuffer((uint8_t *)&gcStats, sizeof(gcStats));\n}\n\n//%\nvoid popThreadContext(ThreadContext *ctx);\n//%\nThreadContext *pushThreadContext(void *sp, void *endSP);\n\nunsigned RefRecord_gcsize(RefRecord *r) {\n    VTable *tbl = getVTable(r);\n    return BYTES_TO_WORDS(tbl->numbytes);\n}\n\n#ifdef PXT_GC_THREAD_LIST\nThreadContext *threadContexts;\n#endif\n\n#define IN_GC_ALLOC 1\n#define IN_GC_COLLECT 2\n#define IN_GC_FREEZE 4\n#define IN_GC_PREALLOC 8\n\n#ifndef PXT_VM\nstatic TValue *tempRoot;\nstatic uint8_t tempRootLen;\n#endif\n\nuint8_t inGC;\n\nvoid popThreadContext(ThreadContext *ctx) {\n#ifndef PXT_VM\n    VLOG(\"pop: %p\", ctx);\n\n    if (!ctx)\n        return;\n\n    auto n = ctx->stack.next;\n    if (n) {\n        VLOG(\"seg %p\", n);\n        ctx->stack.top = n->top;\n        ctx->stack.bottom = n->bottom;\n        ctx->stack.next = n->next;\n        app_free(n);\n    } else {\n#ifdef PXT_GC_THREAD_LIST\n        if (ctx->next)\n            ctx->next->prev = ctx->prev;\n        if (ctx->prev)\n            ctx->prev->next = ctx->next;\n        else {\n            if (threadContexts != ctx)\n                oops(41);\n            threadContexts = ctx->next;\n            if (threadContexts)\n                threadContexts->prev = NULL;\n        }\n#endif\n        app_free(ctx);\n        setThreadContext(NULL);\n    }\n#endif\n}\n\n#define ALLOC(tp) (tp *)app_alloc(sizeof(tp))\n\nThreadContext *pushThreadContext(void *sp, void *endSP) {\n#ifdef PXT_VM\n    return NULL;\n#else\n    if (PXT_IN_ISR())\n        target_panic(PANIC_CALLED_FROM_ISR);\n\n    auto curr = getThreadContext();\n    tempRoot = (TValue *)endSP;\n    tempRootLen = (uintptr_t *)sp - (uintptr_t *)endSP;\n    if (curr) {\n#ifdef PXT_GC_THREAD_LIST\n#ifdef PXT_GC_DEBUG\n        auto ok = false;\n        for (auto p = threadContexts; p; p = p->next)\n            if (p == curr) {\n                ok = true;\n                break;\n            }\n        if (!ok)\n            oops(49);\n#endif\n#endif\n        auto seg = ALLOC(StackSegment);\n        VLOG(\"stack %p / %p\", seg, curr);\n        seg->top = curr->stack.top;\n        seg->bottom = curr->stack.bottom;\n        seg->next = curr->stack.next;\n        curr->stack.next = seg;\n    } else {\n        curr = ALLOC(ThreadContext);\n        LOG(\"push: %p\", curr);\n        curr->globals = globals;\n        curr->stack.next = NULL;\n        curr->thrownValue = TAG_NON_VALUE;\n        curr->tryFrame = NULL;\n\n#ifdef PXT_GC_THREAD_LIST\n        curr->next = threadContexts;\n        curr->prev = NULL;\n        if (curr->next)\n            curr->next->prev = curr;\n        threadContexts = curr;\n#endif\n        setThreadContext(curr);\n    }\n    tempRootLen = 0;\n    curr->stack.bottom = sp;\n    curr->stack.top = NULL;\n    return curr;\n#endif\n}\n\nclass RefBlock : public RefObject {\n  public:\n    RefBlock *nextFree;\n};\n\nstruct GCBlock {\n    GCBlock *next;\n    uint32_t blockSize;\n    RefObject data[0];\n};\n\nstruct PendingArray {\n    PendingArray *next;\n    TValue *data;\n    unsigned len;\n};\n\n#define PENDING_ARRAY_THR 100\n\nstatic PendingArray *pendingArrays;\nstatic LLSegment gcRoots;\nLLSegment workQueue; // (ab)used by consString making\nstatic GCBlock *firstBlock;\nstatic RefBlock *firstFree;\nstatic uint8_t *midPtr;\n\nstatic bool inGCArea(void *ptr) {\n    for (auto block = firstBlock; block; block = block->next) {\n        if ((void *)block->data <= ptr && ptr < (void *)((uint8_t *)block->data + block->blockSize))\n            return true;\n    }\n    return false;\n}\n\n#define NO_MAGIC(vt) ((VTable *)vt)->magic != VTABLE_MAGIC\n#define VT(p) (*(uintptr_t *)(p))\n#define SKIP_PROCESSING(p)                                                                         \\\n    (isReadOnly(p) || (VT(p) & (ANY_MARKED_MASK | ARRAY_MASK)) || NO_MAGIC(VT(p)))\n\nvoid gcMarkArray(void *data) {\n    auto segBl = (uintptr_t *)data - 1;\n    GC_CHECK(!IS_MARKED(VT(segBl)), 47);\n    MARK(segBl);\n}\n\nvoid gcScan(TValue v) {\n    if (SKIP_PROCESSING(v))\n        return;\n    MARK(v);\n    workQueue.push(v);\n}\n\nvoid gcScanMany(TValue *data, unsigned len) {\n    // VLOG(\"scan: %p %d\", data, len);\n    for (unsigned i = 0; i < len; ++i) {\n        auto v = data[i];\n        // VLOG(\"psh: %p %d %d\", v, isReadOnly(v), (*(uint32_t *)v & 1));\n        if (SKIP_PROCESSING(v))\n            continue;\n        MARK(v);\n        workQueue.push(v);\n        if (workQueue.getLength() > PENDING_ARRAY_THR) {\n            i++;\n            // store rest of the work for later, when we have cleared the queue\n            auto pa = (PendingArray *)xmalloc(sizeof(PendingArray));\n            pa->next = pendingArrays;\n            pa->data = data + i;\n            pa->len = len - i;\n            pendingArrays = pa;\n            break;\n        }\n    }\n}\n\nvoid gcScanSegment(Segment &seg) {\n    auto data = seg.getData();\n    if (!data)\n        return;\n    VVLOG(\"seg %p %d\", data, seg.getLength());\n    gcMarkArray(data);\n    gcScanMany(data, seg.getLength());\n}\n\n#define getScanMethod(vt) ((RefObjectMethod)(((VTable *)(vt))->methods[2]))\n#define getSizeMethod(vt) ((RefObjectSizeMethod)(((VTable *)(vt))->methods[3]))\n\nvoid gcProcess(TValue v) {\n    if (SKIP_PROCESSING(v))\n        return;\n    VVLOG(\"gcProcess: %p\", v);\n    MARK(v);\n    auto scan = getScanMethod(VT(v) & ~ANY_MARKED_MASK);\n    if (scan)\n        scan((RefObject *)v);\n    for (;;) {\n        while (workQueue.getLength()) {\n            auto curr = (RefObject *)workQueue.pop();\n            VVLOG(\" - %p\", curr);\n            scan = getScanMethod(curr->vtable & ~ANY_MARKED_MASK);\n            if (scan)\n                scan(curr);\n        }\n        if (pendingArrays) {\n            auto pa = pendingArrays;\n            pendingArrays = pa->next;\n            auto data = pa->data;\n            auto len = pa->len;\n            xfree(pa);\n            gcScanMany(data, len);\n        } else {\n            break;\n        }\n    }\n}\n\nstatic void mark(int flags) {\n#ifdef PXT_GC_DEBUG\n    flags |= 2;\n#endif\n    auto data = gcRoots.getData();\n    auto len = gcRoots.getLength();\n    if (flags & 2) {\n        DMESG(\"--MARK\");\n        DMESG(\"RP:%p/%d\", data, len);\n    }\n    for (unsigned i = 0; i < len; ++i) {\n        auto d = data[i];\n        if ((uintptr_t)d & 1) {\n            d = *(TValue *)((uintptr_t)d & ~1);\n        }\n        gcProcess(d);\n    }\n\n#ifdef PXT_GC_THREAD_LIST\n    for (auto ctx = threadContexts; ctx; ctx = ctx->next) {\n        gcProcess(ctx->thrownValue);\n        for (auto seg = &ctx->stack; seg; seg = seg->next) {\n            auto ptr = (TValue *)threadAddressFor(ctx, seg->top);\n            auto end = (TValue *)threadAddressFor(ctx, seg->bottom);\n            VLOG(\"mark: %p - %p\", ptr, end);\n            while (ptr < end) {\n                gcProcess(*ptr++);\n            }\n        }\n    }\n#else\n    gcProcessStacks(flags);\n#endif\n\n    if (globals) {\n#ifdef PXT_VM\n        auto nonPtrs = vmImg->infoHeader->nonPointerGlobals;\n#else\n        auto nonPtrs = bytecode[21];\n#endif\n        len = getNumGlobals() - nonPtrs;\n        data = globals + nonPtrs;\n        if (flags & 2)\n            DMESG(\"RG:%p/%d\", data, len);\n        VLOG(\"globals: %p %d\", data, len);\n        for (unsigned i = 0; i < len; ++i) {\n            gcProcess(*data++);\n        }\n    }\n\n#ifndef PXT_VM\n    data = tempRoot;\n    len = tempRootLen;\n    for (unsigned i = 0; i < len; ++i) {\n        gcProcess(*data++);\n    }\n#endif\n}\n\nstatic uint32_t getObjectSize(RefObject *o) {\n    auto vt = o->vtable & ~ANY_MARKED_MASK;\n    uint32_t r;\n    GC_CHECK(vt != 0, 49);\n    if (IS_VAR_BLOCK(vt)) {\n        r = VAR_BLOCK_WORDS(vt);\n    } else {\n        auto sz = getSizeMethod(vt);\n        // GC_CHECK(0x2000 <= (intptr_t)sz && (intptr_t)sz <= 0x100000, 47);\n        r = sz(o);\n    }\n    GC_CHECK(1 <= r && (r <= BYTES_TO_WORDS(GC_MAX_ALLOC_SIZE) || IS_FREE(vt)), 41);\n    return r;\n}\n\nstatic void setupFreeBlock(GCBlock *curr) {\n    gcStats.numBlocks++;\n    gcStats.totalBytes += curr->blockSize;\n    curr->data[0].vtable = FREE_MASK | (TOWORDS(curr->blockSize) << 2);\n    ((RefBlock *)curr->data)[0].nextFree = firstFree;\n    firstFree = (RefBlock *)curr->data;\n    midPtr = (uint8_t *)curr->data + curr->blockSize / 4;\n}\n\nstatic void linkFreeBlock(GCBlock *curr) {\n    // blocks need to be sorted by address for midPtr to work\n    if (!firstBlock || curr < firstBlock) {\n        curr->next = firstBlock;\n        firstBlock = curr;\n    } else {\n        for (auto p = firstBlock; p; p = p->next) {\n            if (!p->next || curr < p->next) {\n                curr->next = p->next;\n                p->next = curr;\n                break;\n            }\n        }\n    }\n}\n\nvoid gcPreAllocateBlock(uint32_t sz) {\n    auto curr = (GCBlock *)GC_ALLOC_BLOCK(sz);\n    curr->blockSize = sz - sizeof(GCBlock);\n    LOG(\"GC pre-alloc: %p\", curr);\n    GC_CHECK((curr->blockSize & 3) == 0, 40);\n    setupFreeBlock(curr);\n    linkFreeBlock(curr);\n}\n\nstatic GCBlock *allocateBlockCore() {\n    int sz = GC_BLOCK_SIZE;\n    void *dummy = NULL;\n#ifdef GC_GET_HEAP_SIZE\n    if (firstBlock) {\n#ifdef GC_STACK_BASE\n        if (!firstBlock->next) {\n            int memSize = getConfig(CFG_RAM_BYTES, 0);\n            int codalEnd = GC_STACK_BASE;\n            // round up to 1k - there is sometimes a few bytes below the stack\n            codalEnd = (codalEnd + 1024) & ~1023;\n            int codalSize = codalEnd & 0xffffff;\n            sz = memSize - codalSize - 4;\n            if (sz > 0) {\n                auto curr = (GCBlock *)codalEnd;\n                curr->blockSize = sz - sizeof(GCBlock);\n                return curr;\n            }\n        }\n#endif\n        gc(2); // dump roots\n        target_panic(PANIC_GC_OOM);\n    }\n    auto lowMem = getConfig(CFG_LOW_MEM_SIMULATION_KB, 0);\n    auto sysHeapSize = getConfig(CFG_SYSTEM_HEAP_BYTES, 4 * 1024);\n    auto heapSize = GC_GET_HEAP_SIZE();\n    sz = heapSize - sysHeapSize;\n    if (lowMem) {\n        auto memIncrement = 32 * 1024;\n        // get the memory size - assume it's increment of 32k,\n        // and we don't statically allocate more than 32k\n        auto memSize = ((heapSize + memIncrement - 1) / memIncrement) * memIncrement;\n        int fillerSize = memSize - lowMem * 1024;\n        if (fillerSize > 0) {\n            dummy = GC_ALLOC_BLOCK(fillerSize);\n            sz -= fillerSize;\n        }\n    }\n#endif\n    auto curr = (GCBlock *)GC_ALLOC_BLOCK(sz);\n    curr->blockSize = sz - sizeof(GCBlock);\n    // make sure reference to allocated block is stored somewhere, otherwise\n    // GCC optimizes out the call to GC_ALLOC_BLOCK\n    curr->data[4].vtable = (uint32_t)(uintptr_t)dummy;\n    return curr;\n}\n\n__attribute__((noinline)) static void allocateBlock() {\n    auto curr = allocateBlockCore();\n    DMESG(\"GC block %db @ %p\", curr->blockSize, curr);\n    GC_CHECK((curr->blockSize & 3) == 0, 40);\n    setupFreeBlock(curr);\n    linkFreeBlock(curr);\n}\n\nstatic void sweep(int flags) {\n    RefBlock *prevFreePtr = NULL;\n    uint32_t freeSize = 0;\n    uint32_t totalSize = 0;\n    uint32_t maxFreeBlock = 0;\n    firstFree = NULL;\n\n    gcStats.numGC++;\n\n    for (auto h = firstBlock; h; h = h->next) {\n        auto d = h->data;\n        auto words = BYTES_TO_WORDS(h->blockSize);\n        auto end = d + words;\n        totalSize += words;\n        VLOG(\"sweep: %p - %p\", d, end);\n        while (d < end) {\n            if (IS_LIVE(d->vtable)) {\n                VVLOG(\"Live %p\", d);\n                d->vtable &= ~MARKED_MASK;\n                d += getObjectSize(d);\n            } else {\n                auto start = (RefBlock *)d;\n                while (d < end) {\n                    if (IS_FREE(d->vtable)) {\n                        VVLOG(\"Free %p\", d);\n                    } else if (IS_LIVE(d->vtable)) {\n                        break;\n                    } else if (IS_ARRAY(d->vtable)) {\n                        VVLOG(\"Dead Arr %p\", d);\n                    } else {\n                        VVLOG(\"Dead Obj %p\", d);\n                        GC_CHECK(((VTable *)d->vtable)->magic == VTABLE_MAGIC, 41);\n                        d->destroyVT();\n                        VVLOG(\"destroyed\");\n                    }\n                    d += getObjectSize(d);\n                }\n                auto sz = d - (RefObject *)start;\n                freeSize += sz;\n                if (sz > (int)maxFreeBlock)\n                    maxFreeBlock = sz;\n#ifdef PXT_GC_CHECKS\n                memset((void *)start, 0xff, WORDS_TO_BYTES(sz));\n#endif\n                start->vtable = (sz << 2) | FREE_MASK;\n                if (sz > 1) {\n                    start->nextFree = NULL;\n                    if (!prevFreePtr) {\n                        firstFree = start;\n                    } else {\n                        prevFreePtr->nextFree = start;\n                    }\n                    prevFreePtr = start;\n                }\n            }\n        }\n    }\n\n    if (midPtr) {\n        uint32_t currFree = 0;\n        auto limit = freeSize * 1 / 2;\n        for (auto p = firstFree; p; p = p->nextFree) {\n            auto len = VAR_BLOCK_WORDS(p->vtable);\n            currFree += len;\n            if (currFree > limit) {\n                midPtr = (uint8_t *)p + ((limit - currFree + len) << 2);\n                break;\n            }\n        }\n    }\n\n    freeSize = WORDS_TO_BYTES(freeSize);\n    totalSize = WORDS_TO_BYTES(totalSize);\n    maxFreeBlock = WORDS_TO_BYTES(maxFreeBlock);\n\n    gcStats.lastFreeBytes = freeSize;\n    gcStats.lastMaxBlockBytes = maxFreeBlock;\n\n    if (gcStats.minFreeBytes == 0 || gcStats.minFreeBytes > freeSize)\n        gcStats.minFreeBytes = freeSize;\n\n    if (flags & 1)\n        DMESG(\"GC %d/%d free; %d maxBlock\", freeSize, totalSize, maxFreeBlock);\n    else\n        LOG(\"GC %d/%d free; %d maxBlock\", freeSize, totalSize, maxFreeBlock);\n\n#ifndef GC_GET_HEAP_SIZE\n    // if the heap is 90% full, allocate a new block\n    if (freeSize * 10 <= totalSize) {\n        allocateBlock();\n    }\n#endif\n}\n\nvoid gc(int flags) {\n    startPerfCounter(PerfCounters::GC);\n    GC_CHECK(!(inGC & IN_GC_COLLECT), 40);\n    inGC |= IN_GC_COLLECT;\n    VLOG(\"GC mark\");\n    mark(flags);\n    VLOG(\"GC sweep\");\n    sweep(flags);\n    VLOG(\"GC done\");\n    stopPerfCounter(PerfCounters::GC);\n    inGC &= ~IN_GC_COLLECT;\n}\n\n#ifdef GC_GET_HEAP_SIZE\nextern \"C\" void free(void *ptr) {\n    if (!ptr)\n        return;\n    if (inGCArea(ptr))\n        app_free(ptr);\n    else\n        xfree(ptr);\n}\n\nextern \"C\" void *malloc(size_t sz) {\n    if (PXT_IN_ISR() || inGC)\n        return xmalloc(sz);\n    else\n        return app_alloc(sz);\n}\n\nextern \"C\" void *realloc(void *ptr, size_t size) {\n    if (inGCArea(ptr)) {\n        void *mem = malloc(size);\n\n        if (ptr != NULL && mem != NULL) {\n            auto r = (uintptr_t *)ptr;\n            GC_CHECK((r[-1] >> (HIGH_SHIFT + 1)) == 3, 41);\n            size_t blockSize = VAR_BLOCK_WORDS(r[-1]);\n            memcpy(mem, ptr, min(blockSize * sizeof(void *), size));\n            free(ptr);\n        }\n\n        return mem;\n    } else {\n        return device_realloc(ptr, size);\n    }\n}\n#endif\n\nvoid *gcAllocateArray(int numbytes) {\n    numbytes = ALIGN_TO_WORD(numbytes);\n    numbytes += sizeof(void *);\n    auto r = (uintptr_t *)gcAllocate(numbytes);\n    *r = ARRAY_MASK | (TOWORDS(numbytes) << 2);\n    return r + 1;\n}\n\nstatic void *gcAllocAt(void *hint, int numbytes) {\n    gc(0);\n    size_t numwords = BYTES_TO_WORDS(ALIGN_TO_WORD(numbytes));\n\n    for (auto p = firstFree; p; p = p->nextFree) {\n        GC_CHECK(!isReadOnly((TValue)p), 49);\n        auto vt = p->vtable;\n        GC_CHECK(IS_FREE(vt), 43);\n        int offset = BYTES_TO_WORDS((uint8_t *)hint - (uint8_t *)p);\n        int left = (int)(VAR_BLOCK_WORDS(vt) - numwords - offset);\n        // we give ourselves some space here, so we don't get some strange overlaps\n        if (offset >= 8 && left >= 8) {\n            auto nf = (RefBlock *)((void **)p + numwords + offset);\n            nf->vtable = (left << 2) | FREE_MASK;\n            nf->nextFree = p->nextFree;\n            p->nextFree = nf;\n            p->vtable = (offset << 2) | FREE_MASK;\n            p = (RefBlock *)((void **)p + offset);\n            p->vtable = 0;\n            return p;\n        }\n    }\n\n    return NULL;\n}\n\nvoid *app_alloc_at(void *at, int numbytes) {\n    if (numbytes < 8)\n        return NULL;\n    if (!at)\n        return NULL;\n\n    numbytes = ALIGN_TO_WORD(numbytes) + sizeof(void *);\n    auto r = (uintptr_t *)gcAllocAt((uintptr_t *)at - 1, numbytes);\n    if (!r)\n        return NULL;\n    *r = ARRAY_MASK | PERMA_MASK | (TOWORDS(numbytes) << 2);\n    gc(0);\n    return r + 1;\n}\n\nvoid *app_alloc(int numbytes) {\n    if (!numbytes)\n        return NULL;\n\n    // gc(0);\n    auto r = (uintptr_t *)gcAllocateArray(numbytes);\n    r[-1] |= PERMA_MASK;\n    return r;\n}\n\nvoid *app_free(void *ptr) {\n    auto r = (uintptr_t *)ptr;\n    GC_CHECK((r[-1] >> (HIGH_SHIFT + 1)) == 3, 41);\n    r[-1] |= FREE_MASK;\n    return r;\n}\n\nvoid gcFreeze() {\n    inGC |= IN_GC_FREEZE;\n}\n\nvoid gcReset() {\n    inGC &= ~IN_GC_FREEZE;\n\n    gcRoots.setLength(0);\n\n    if (inGC)\n        oops(41);\n\n    if (workQueue.getLength())\n        oops(41);\n\n    memset(&gcStats, 0, sizeof(gcStats));\n    firstFree = NULL;\n    for (auto h = firstBlock; h; h = h->next) {\n        setupFreeBlock(h);\n    }\n}\n\n#ifdef PXT_VM\nstatic uint8_t *preallocBlock;\nstatic uint8_t *preallocPointer;\n\n#define PREALLOC_SIZE (1024 * 1024)\n\nvoid gcPreStartup() {\n    xfree(preallocBlock);\n    preallocBlock = (uint8_t *)xmalloc(PREALLOC_SIZE);\n    preallocPointer = preallocBlock;\n    if (!isReadOnly((TValue)preallocBlock))\n        oops(40);\n    inGC |= IN_GC_PREALLOC;\n}\n\nvoid gcStartup() {\n    inGC &= ~IN_GC_PREALLOC;\n    preallocPointer = NULL;\n}\n\nvoid *gcPrealloc(int numbytes) {\n    if (!preallocPointer)\n        oops(49);\n    void *r = preallocPointer;\n    preallocPointer += ALIGN_TO_WORD(numbytes);\n    if (preallocPointer > preallocBlock + PREALLOC_SIZE) {\n        DMESG(\"pre-alloc size exceeded! block=%p ptr=%p sz=%d\", preallocBlock, preallocPointer,\n              (int)PREALLOC_SIZE);\n        oops(48);\n    }\n    return r;\n}\n\nbool inGCPrealloc() {\n    return (inGC & IN_GC_PREALLOC) != 0;\n}\n#endif\n\nvoid *gcAllocate(int numbytes) {\n    size_t numwords = BYTES_TO_WORDS(ALIGN_TO_WORD(numbytes));\n    // VVLOG(\"alloc %d bytes %d words\", numbytes, numwords);\n\n    if (numbytes > GC_MAX_ALLOC_SIZE)\n        target_panic(PANIC_GC_TOO_BIG_ALLOCATION);\n\n    if (PXT_IN_ISR() || (inGC & (IN_GC_ALLOC | IN_GC_COLLECT | IN_GC_FREEZE)))\n        target_panic(PANIC_CALLED_FROM_ISR);\n\n#ifdef PXT_VM\n    if (inGCPrealloc())\n        return gcPrealloc(numbytes);\n#endif\n\n    inGC |= IN_GC_ALLOC;\n\n#if defined(PXT_GC_CHECKS) && !defined(PXT_VM)\n    {\n        auto curr = getThreadContext();\n        if (curr && !curr->stack.top)\n            oops(46);\n    }\n#endif\n\n#ifdef PXT_GC_STRESS\n    gc(0);\n#endif\n\n    for (int i = 0;; ++i) {\n        RefBlock *prev = NULL;\n        for (auto p = firstFree; p; p = p->nextFree) {\n            VVLOG(\"p=%p\", p);\n            if (i == 0 && (uint8_t *)p > midPtr) {\n                VLOG(\"past midptr %p; gc\", midPtr);\n                break;\n            }\n            GC_CHECK(!isReadOnly((TValue)p), 49);\n            auto vt = p->vtable;\n            if (!IS_FREE(vt))\n                oops(43);\n            int left = (int)(VAR_BLOCK_WORDS(vt) - numwords);\n            VVLOG(\"%p %d - %d = %d\", (void *)vt, (int)VAR_BLOCK_WORDS(vt), (int)numwords, left);\n            if (left >= 0) {\n                auto nf = (RefBlock *)((void **)p + numwords);\n                auto nextFree = p->nextFree; // p and nf can overlap when allocating 4 bytes\n                // VVLOG(\"nf=%p nef=%p\", nf, nextFree);\n                if (left)\n                    nf->vtable = (left << 2) | FREE_MASK;\n                if (left >= 2) {\n                    nf->nextFree = nextFree;\n                } else {\n                    nf = nextFree;\n                }\n                if (prev)\n                    prev->nextFree = nf;\n                else\n                    firstFree = nf;\n                p->vtable = 0;\n                VVLOG(\"GC=>%p %d %p -> %p,%p\", p, numwords, nf, nf ? nf->nextFree : 0,\n                      nf ? (void *)nf->vtable : 0);\n                GC_CHECK(!nf || !nf->nextFree || !isReadOnly((TValue)nf->nextFree), 48);\n                inGC &= ~IN_GC_ALLOC;\n                return p;\n            }\n            prev = p;\n        }\n\n        // we didn't find anything, try GC\n        if (i == 0)\n            gc(0);\n        // GC didn't help, try new block\n        else if (i == 1)\n            allocateBlock();\n        else\n            // the block allocated was apparently too small\n            target_panic(PANIC_GC_OOM);\n    }\n}\n\nstatic void removePtr(TValue v) {\n    int len = gcRoots.getLength();\n    auto data = gcRoots.getData();\n    // scan from the back, as this is often used as a stack\n    for (int i = len - 1; i >= 0; --i) {\n        if (data[i] == v) {\n            if (i == len - 1) {\n                gcRoots.pop();\n            } else {\n                data[i] = gcRoots.pop();\n            }\n            return;\n        }\n    }\n    oops(40);\n}\n\nvoid registerGC(TValue *root, int numwords) {\n    if (!numwords)\n        return;\n\n    if (numwords > 1) {\n        while (numwords-- > 0) {\n            registerGC(root++, 1);\n        }\n        return;\n    }\n\n    gcRoots.push((TValue)((uintptr_t)root | 1));\n}\n\nvoid unregisterGC(TValue *root, int numwords) {\n    if (!numwords)\n        return;\n    if (numwords > 1) {\n        while (numwords-- > 0) {\n            unregisterGC(root++, 1);\n        }\n        return;\n    }\n\n    removePtr((TValue)((uintptr_t)root | 1));\n}\n\nvoid registerGCPtr(TValue ptr) {\n    if (isReadOnly(ptr))\n        return;\n    gcRoots.push(ptr);\n}\n\nvoid unregisterGCPtr(TValue ptr) {\n    if (isReadOnly(ptr))\n        return;\n    removePtr(ptr);\n}\n\nvoid RefImage::scan(RefImage *t) {\n    gcScan((TValue)t->buffer);\n}\n\nvoid RefCollection::scan(RefCollection *t) {\n    gcScanSegment(t->head);\n}\n\nvoid RefAction::scan(RefAction *t) {\n    gcScanMany(t->fields, t->len);\n}\n\nvoid RefRefLocal::scan(RefRefLocal *t) {\n    gcScan(t->v);\n}\n\nvoid RefMap::scan(RefMap *t) {\n    gcScanSegment(t->keys);\n    gcScanSegment(t->values);\n}\n\nvoid RefRecord_scan(RefRecord *r) {\n    VTable *tbl = getVTable(r);\n    gcScanMany(r->fields, BYTES_TO_WORDS(tbl->numbytes - sizeof(RefRecord)));\n}\n\n#define SIZE(off) TOWORDS(sizeof(*t) + (off))\n\nunsigned RefImage::gcsize(RefImage *t) {\n    return SIZE(0);\n}\n\nunsigned RefCollection::gcsize(RefCollection *t) {\n    return SIZE(0);\n}\n\nunsigned RefAction::gcsize(RefAction *t) {\n    return SIZE(WORDS_TO_BYTES(t->len));\n}\n\nunsigned RefRefLocal::gcsize(RefRefLocal *t) {\n    return SIZE(0);\n}\n\nunsigned RefMap::gcsize(RefMap *t) {\n    return SIZE(0);\n}\n\n} // namespace pxt\n",
            "gcstats.ts": "namespace control {\n    //% shim=pxt::getGCStats\n    function getGCStats(): Buffer {\n        return null\n    }\n\n    export interface GCStats {\n        numGC: number;\n        numBlocks: number;\n        totalBytes: number;\n        lastFreeBytes: number;\n        lastMaxBlockBytes: number;\n        minFreeBytes: number;\n    }\n\n    /**\n     * Get various statistics about the garbage collector (GC)\n     */\n    export function gcStats(): GCStats {\n        const buf = getGCStats()\n        if (!buf)\n            return null\n        let off = 0\n        const res: any = {}\n\n        addField(\"numGC\")\n        addField(\"numBlocks\")\n        addField(\"totalBytes\")\n        addField(\"lastFreeBytes\")\n        addField(\"lastMaxBlockBytes\")\n        addField(\"minFreeBytes\")\n\n        return res\n\n        function addField(name: string) {\n            res[name] = buf.getNumber(NumberFormat.UInt32LE, off)\n            off += 4\n        }\n    }    \n}",
            "interval.ts": "namespace control {\n    export enum IntervalMode {\n        Interval,\n        Timeout,\n        Immediate\n    }\n\n    let _intervals: Interval[] = undefined;\n    class Interval {\n\n        id: number;\n        func: () => void;\n        delay: number;\n        mode: IntervalMode;\n\n        constructor(func: () => void, delay: number, mode: IntervalMode) {\n            this.id = _intervals.length == 0\n                ? 1 : _intervals[_intervals.length - 1].id + 1;\n            this.func = func;\n            this.delay = delay;\n            this.mode = mode;\n            _intervals.push(this);\n\n            control.runInParallel(() => this.work());\n        }\n\n        work() {\n            // execute\n            switch (this.mode) {\n                case IntervalMode.Immediate:\n                case IntervalMode.Timeout:\n                    if (this.delay > 0)\n                        pause(this.delay); // timeout\n                    if (this.delay >= 0) // immediate, timeout\n                        this.func();\n                    break;\n                case IntervalMode.Interval:\n                    while (this.delay > 0) {\n                        pause(this.delay);\n                        // might have been cancelled during this duration\n                        if (this.delay > 0)\n                            this.func();\n                    }\n                    break;\n            }\n            // remove from interval array\n            _intervals.removeElement(this);\n        }\n\n        cancel() {\n            this.delay = -1;\n        }\n    }\n\n    export function setInterval(func: () => void, delay: number, mode: IntervalMode): number {\n        if (!func || delay < 0) return 0;\n        if (!_intervals) _intervals = [];\n        const interval = new Interval(func, delay, mode);\n        return interval.id;\n    }\n\n    export function clearInterval(intervalId: number, mode: IntervalMode): void {\n        if (!_intervals) return;\n        for (let i = 0; i < _intervals.length; ++i) {\n            const it = _intervals[i];\n            if (it.id == intervalId && it.mode == mode) {\n                it.cancel();\n                break;\n            }\n        }\n    }\n}",
            "json.ts": "namespace JSON {\n    export function parseIntRadix(s: string, base?: number) {\n        if (base == null || base == 10) {\n            return parseFloat(s) | 0\n        }\n\n        let m = false\n        let r = 0\n        for (let i = 0; i < s.length; ++i) {\n            let c = s.charCodeAt(i)\n            if (c == 0x20 || c == 10 || c == 13 || c == 9)\n                continue\n            if (r == 0 && !m && c == 0x2d) {\n                m = true\n                continue\n            }\n\n            let v = -1\n            if (0x30 <= c && c <= 0x39)\n                v = c - 0x30\n            else {\n                c |= 0x20\n                if (0x61 <= c && c <= 0x7a)\n                    v = c - 0x61 + 10\n            }\n\n            if (0 <= v && v < base) {\n                r *= base\n                r += v\n            } else {\n                return undefined\n            }\n        }\n\n        return m ? -r : r\n    }\n\n\n    class Parser {\n        ptr: number\n        s: string\n        errorMsg: string\n\n        error(msg: string) {\n            if (!this.errorMsg) {\n                this.errorMsg = msg + \" at position \" + this.ptr\n                this.ptr = this.s.length\n            }\n        }\n\n        skipWS() {\n            for (; ;) {\n                const c = this.nextChar()\n                if (c == 0x20 || c == 0x0a || c == 0x0d || c == 0x09) {\n                    // OK\n                } else {\n                    this.ptr--\n                    return c\n                }\n            }\n        }\n\n        nextChar() {\n            if (this.ptr < this.s.length)\n                return this.s.charCodeAt(this.ptr++)\n            return 0\n        }\n\n        doString() {\n            let r = \"\"\n            this.ptr++\n            for (; ;) {\n                const c = this.s.charAt(this.ptr++)\n                if (c == \"\\\"\")\n                    return r\n                if (c == \"\\\\\") {\n                    let q = this.s.charAt(this.ptr++)\n                    if (q == \"b\") q = \"\\b\"\n                    else if (q == \"n\") q = \"\\n\"\n                    else if (q == \"r\") q = \"\\r\"\n                    else if (q == \"t\") q = \"\\t\"\n                    else if (q == \"u\") {\n                        q = String.fromCharCode(parseIntRadix(this.s.slice(this.ptr, this.ptr + 4), 16))\n                        this.ptr += 4\n                    }\n                    r += q\n                } else {\n                    r += c\n                }\n            }\n        }\n\n        doArray(): any[] {\n            const r = []\n            this.ptr++\n            for (; ;) {\n                let c = this.skipWS()\n                if (c == 0x5d) {\n                    this.ptr++\n                    return r\n                }\n                const v = this.value()\n                if (this.errorMsg)\n                    return null\n                r.push(v)\n                c = this.skipWS()\n                if (c == 0x2c) {\n                    this.ptr++\n                    continue\n                }\n                if (c == 0x5d)\n                    continue\n                this.error(\"expecting comma\")\n            }\n        }\n\n        doObject() {\n            const r: any = {}\n            this.ptr++\n            for (; ;) {\n                let c = this.skipWS()\n                if (c == 0x7d) {\n                    this.ptr++\n                    return r\n                }\n                if (c != 0x22) {\n                    this.error(\"expecting key\")\n                    return r\n                }\n                const k = this.doString()\n                c = this.skipWS()\n                if (c != 0x3a) {\n                    this.error(\"expecting colon\")\n                    return r\n                }\n                this.ptr++\n                const v = this.value()\n                if (this.errorMsg)\n                    return null\n                r[k] = v\n                c = this.skipWS()\n                if (c == 0x2c) {\n                    this.ptr++\n                    continue\n                }\n                if (c == 0x7d)\n                    continue\n                this.error(\"expecting comma, got \" + String.fromCharCode(c))\n            }\n        }\n\n        doNumber() {\n            const beg = this.ptr\n            for (; ;) {\n                const c = this.nextChar()\n                if ((0x30 <= c && c <= 0x39) || c == 0x2b || c == 0x2d || c == 0x2e || c == 0x45 || c == 0x65) {\n                    // one more\n                } else {\n                    this.ptr--\n                    break\n                }\n            }\n            const ss = this.s.slice(beg, this.ptr)\n            if (ss.length == 0) {\n                this.error(\"expecting number\")\n                return 0\n            }\n            return parseFloat(ss)\n        }\n\n        checkKw(k: string) {\n            if (this.s.slice(this.ptr, this.ptr + k.length) == k) {\n                this.ptr += k.length\n                return true\n            }\n            return false\n        }\n\n        value() {\n            if (this.errorMsg)\n                return null\n\n            const c = this.skipWS()\n            if (c == 0x7b)\n                return this.doObject()\n            else if (c == 0x5b)\n                return this.doArray()\n            else if ((0x30 <= c && c <= 0x39) || c == 0x2d)\n                return this.doNumber()\n            else if (c == 0x22)\n                return this.doString()\n            else if (c == 0x74 && this.checkKw(\"true\"))\n                return true\n            else if (c == 0x66 && this.checkKw(\"false\"))\n                return false\n            else if (c == 0x6e && this.checkKw(\"null\"))\n                return null\n\n            this.error(\"unexpected token\")\n            return null\n        }\n    }\n\n    class Stringifier {\n        currIndent: string\n        indentStep: string\n        indent: number\n\n        doString(s: string) {\n            let r = \"\\\"\"\n            for (let i = 0; i < s.length; ++i) {\n                let c = s[i]\n                if (c == \"\\n\") c = \"\\\\n\"\n                else if (c == \"\\r\") c = \"\\\\r\"\n                else if (c == \"\\t\") c = \"\\\\t\"\n                else if (c == \"\\b\") c = \"\\\\b\"\n                else if (c == \"\\\\\") c = \"\\\\\\\\\"\n                else if (c == \"\\\"\") c = \"\\\\\\\"\"\n                r += c\n            }\n            return r + \"\\\"\"\n        }\n\n        go(v: any) {\n            const t = typeof v\n            if (t == \"string\")\n                return this.doString(v)\n            else if (t == \"boolean\" || t == \"number\" || v == null)\n                return \"\" + v\n            else if (Array.isArray(v)) {\n                const arr = v as any[]\n                if (arr.length == 0)\n                    return \"[]\"\n                else {\n                    let r = \"[\"\n                    if (this.indent) {\n                        this.currIndent += this.indentStep\n                        r += \"\\n\"\n                    }\n                    for (let i = 0; i < arr.length; ++i) {\n                        r += this.currIndent + this.go(arr[i])\n                        if (i != arr.length - 1)\n                            r += \",\"\n                        if (this.indent)\n                            r += \"\\n\"\n                    }\n                    if (this.indent)\n                        this.currIndent = this.currIndent.slice(this.indent)\n                    r += this.currIndent + \"]\"\n                    return r\n                }\n            } else {\n                const keys = Object.keys(v)\n                if (keys.length == 0)\n                    return \"{}\"\n\n                let r = \"{\"\n                if (this.indent) {\n                    this.currIndent += this.indentStep\n                    r += \"\\n\"\n                }\n                for (let i = 0; i < keys.length; ++i) {\n                    const k = keys[i]\n                    r += this.currIndent + this.doString(k)\n                    if (this.indent)\n                        r += \": \"\n                    else\n                        r += \":\"\n                    r += this.go(v[k])\n                    if (i != keys.length - 1)\n                        r += \",\"\n                    if (this.indent)\n                        r += \"\\n\"\n                }\n                if (this.indent)\n                    this.currIndent = this.currIndent.slice(this.indent)\n                r += this.currIndent + \"}\"\n                return r\n            }\n        }\n    }\n\n    /**\n     * Converts a JavaScript value to a JavaScript Object Notation (JSON) string.\n     * @param value A JavaScript value, usually an object or array, to be converted.\n     * @param replacer Not supported; use null.\n     * @param indent Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\n     */\n    export function stringify(value: any, replacer: any = null, indent: number = 0) {\n        const ss = new Stringifier()\n        ss.currIndent = \"\"\n        indent |= 0\n        if (indent < 0) indent = 0\n        if (indent > 10) indent = 10\n        ss.indentStep = \"\"\n        ss.currIndent = \"\"\n        ss.indent = indent\n        while (indent-- > 0)\n            ss.indentStep += \" \"\n        return ss.go(value)\n    }\n\n\n    /**\n     * Converts a JavaScript Object Notation (JSON) string into an object.\n     * @param text A valid JSON string.\n     */\n    export function parse(s: string) {\n        const p = new Parser()\n        p.ptr = 0\n        p.s = s\n        const r = p.value()\n        if (p.skipWS()) {\n            p.error(\"excessive input\")\n        }\n        if (p.errorMsg) {\n            control.dmesg(\"Invalid JSON: \" + p.errorMsg)\n            return undefined\n        }\n        return r\n    }\n}\n",
            "loops.cpp": "#include \"pxtbase.h\"\n\nnamespace loops {\n\n/**\n * Repeats the code forever in the background. On each iteration, allows other codes to run.\n * @param body code to execute\n */\n//% help=loops/forever weight=100 afterOnStart=true deprecated=true\n//% blockId=forever_deprecated block=\"forever\" blockAllowMultiple=1\nvoid forever(Action a) {\n    runForever(a);\n}\n\n/**\n * Pause for the specified time in milliseconds\n * @param ms how long to pause for, eg: 100, 200, 500, 1000, 2000\n */\n//% help=loops/pause weight=99 deprecated=true\n//% async block=\"pause %pause=timePicker|ms\"\n//% blockId=device_pause_deprecated\nvoid pause(int ms) {\n    if (ms < 0) return;\n    sleep_ms(ms);\n}\n\n}",
            "math.ts": "namespace Math {\n\n    export const E = 2.718281828459045;\n    export const LN2 = 0.6931471805599453;\n    export const LN10 = 2.302585092994046;\n    export const LOG2E = 1.4426950408889634;\n    export const LOG10E = 0.4342944819032518;\n    export const PI = 3.141592653589793;\n    export const SQRT1_2 = 0.7071067811865476;\n    export const SQRT2 = 1.4142135623730951;\n\n    /**\n     * Re-maps a number from one range to another. That is, a value of ``from low`` would get mapped to ``to low``, a value of ``from high`` to ``to high``, values in-between to values in-between, etc.\n     * @param value value to map in ranges\n     * @param fromLow the lower bound of the value's current range\n     * @param fromHigh the upper bound of the value's current range, eg: 1023\n     * @param toLow the lower bound of the value's target range\n     * @param toHigh the upper bound of the value's target range, eg: 4\n     */\n    //% help=math/map weight=10 blockGap=8\n    //% blockId=math_map block=\"map %value|from low %fromLow|high %fromHigh|to low %toLow|high %toHigh\"\n    //% inlineInputMode=inline\n    export function map(value: number, fromLow: number, fromHigh: number, toLow: number, toHigh: number): number {\n        return ((value - fromLow) * (toHigh - toLow)) / (fromHigh - fromLow) + toLow;\n    }    \n\n    /**\n     * Constrains a number to be within a range\n     * @param x the number to constrain, all data types\n     * @param y the lower end of the range, all data types\n     * @param z the upper end of the range, all data types\n     */\n    //% help=math/constrain weight=11 blockGap=8\n    //% blockId=\"math_constrain_value\" block=\"constrain %value|between %low|and %high\"\n    export function constrain(value: number, low: number, high: number): number {\n        return value < low ? low : value > high ? high : value;\n    }\n\n    const b_m16: number[] = [0, 49, 49, 41, 90, 27, 117, 10]\n    /**\n     * Returns the sine of an input angle. This is an 8-bit approximation.\n     * @param theta input angle from 0-255\n     */\n    //% help=math/isin weight=11 advanced=true blockGap=8\n    export function isin(theta: number) {\n        //reference: based on FASTLed's sin approximation method: [https://github.com/FastLED/FastLED](MIT)\n        let offset = theta;\n        if( theta & 0x40 ) {\n            offset = 255 - offset;\n        }\n        offset &= 0x3F; // 0..63\n\n        let secoffset  = offset & 0x0F; // 0..15\n        if( theta & 0x40) secoffset++;\n\n        let section = offset >> 4; // 0..3\n        let s2 = section * 2;\n\n        let b = b_m16[s2];\n        let m16 = b_m16[s2+1];\n        let mx = (m16 * secoffset) >> 4;\n        \n        let y = mx + b;\n        if( theta & 0x80 ) y = -y;\n\n        y += 128;\n\n        return y;\n    }\n\n    /**\n     * Returns the cosine of an input angle. This is an 8-bit approximation. \n     * @param theta input angle from 0-255\n     */\n    //% help=math/icos weight=10 advanced=true blockGap=8\n    export function icos(theta: number) {\n        return isin(theta + 16384);\n    }\n}\n\nnamespace Number {\n    export const EPSILON = 2.220446049250313e-16;\n}",
            "ns.ts": "\n/**\n * Respond to and read data from buttons and sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}\n",
            "pause.ts": "/**\n * Pause for the specified time in milliseconds\n * @param ms how long to pause for, eg: 100, 200, 500, 1000, 2000\n */\n//% help=loops/pause weight=99\n//% async block=\"pause %pause=timePicker|ms\"\n//% blockId=device_pause blockNamespace=\"loops\"\nfunction pause(ms: number): void {\n    loops.pause(ms);\n}\n\n// micro:bit compatibility\n// these functions allow some level of reuse\n// between micro:bit and other maker-style editors\nnamespace basic {\n    export function pause(millis: number) {\n        loops.pause(millis);\n    }\n}",
            "poll.ts": "namespace control {\n    class PollEvent {\n        public eid: number;\n        public vid: number;\n        public start: number;\n        public timeOut: number;\n        public condition: () => boolean;\n        public once: boolean;\n        constructor(eid: number, vid: number, start: number, timeOut: number, condition: () => boolean, once: boolean) {\n            this.eid = eid;\n            this.vid = vid;\n            this.start = start;\n            this.timeOut = timeOut;\n            this.condition = condition;\n            this.once = once;\n        }\n    }\n\n    let _pollEventQueue: PollEvent[] = undefined;\n\n    function pollEvents() {\n        while (_pollEventQueue.length > 0) {\n            const now = control.millis();\n            for (let i = 0; i < _pollEventQueue.length; ++i) {\n                const ev = _pollEventQueue[i];\n                if (ev.condition() || (ev.timeOut > 0 && now - ev.start > ev.timeOut)) {\n                    control.raiseEvent(ev.eid, ev.vid);\n                    if (ev.once) {\n                        _pollEventQueue.splice(i, 1);\n                        --i;\n                    }\n                }\n            }\n            pause(50);\n        }\n        // release fiber\n        _pollEventQueue = undefined;\n    }\n\n    export function __queuePollEvent(timeOut: number, condition: () => boolean, handler: () => void) {\n        const ev = new PollEvent(\n            control.allocateNotifyEvent(),\n            1,\n            control.millis(),\n            timeOut,\n            condition,\n            !handler\n        );\n\n        // start polling fiber if needed\n        if (!_pollEventQueue) {\n            _pollEventQueue = [ev];\n            control.runInParallel(pollEvents);\n        }\n        else {\n            // add to the queue\n            _pollEventQueue.push(ev)\n        }\n\n        // register event\n        if (handler)\n            control.onEvent(ev.eid, ev.vid, handler);\n        else // or wait\n            control.waitForEvent(ev.eid, ev.vid);\n    }    \n}\n\n/**\n * Busy wait for a condition to be true\n * @param condition condition to test for\n * @param timeOut if positive, maximum duration to wait for in milliseconds\n */\n//% blockId=\"pxt_pause_until\"\nfunction pauseUntil(condition: () => boolean, timeOut?: number): void {\n    if (!condition || condition()) return; // optimistic path\n    if (!timeOut) timeOut = 0;\n    control.__queuePollEvent(timeOut, condition, undefined);\n}\n",
            "pxt-core.d.ts": "/// <reference no-default-lib=\"true\"/>\n\ninterface Array<T> {\n    /**\n      * Get or set the length of an array. This number is one more than the index of the last element the array.\n      */\n    //% shim=Array_::length weight=84\n    //% blockId=\"lists_length\" block=\"length of %VALUE\" blockBuiltin=true blockNamespace=\"arrays\"\n    length: number;\n\n    /**\n      * Append a new element to an array.\n      * @param items New elements of the Array.\n      */\n    //% help=arrays/push\n    //% shim=Array_::push weight=50\n    //% blockId=\"array_push\" block=\"%list| add value %value| to end\" blockNamespace=\"arrays\"\n    //% group=\"Modify\"\n    push(item: T): void;\n\n    /**\n      * Concatenates the values with another array.\n      * @param arr The other array that is being concatenated with\n      */\n    //% helper=arrayConcat weight=40\n    concat(arr: T[]): T[];\n\n    /**\n      * Remove the last element from an array and return it.\n      */\n    //% help=arrays/pop\n    //% shim=Array_::pop weight=45\n    //% blockId=\"array_pop\" block=\"get and remove last value from %list\" blockNamespace=\"arrays\"\n    //% group=\"Read\"\n    pop(): T;\n\n    /**\n      * Reverse the elements in an array. The first array element becomes the last, and the last array element becomes the first.\n      */\n    //% help=arrays/reverse\n    //% helper=arrayReverse weight=10\n    //% blockId=\"array_reverse\" block=\"reverse %list\" blockNamespace=\"arrays\"\n    //% group=\"Operations\"\n    reverse(): void;\n\n    /**\n      * Remove the first element from an array and return it. This method changes the length of the array.\n      */\n    //% help=arrays/shift\n    //% helper=arrayShift weight=30\n    //% blockId=\"array_shift\" block=\"get and remove first value from %list\" blockNamespace=\"arrays\"\n    //% group=\"Read\"\n    shift(): T;\n\n    /**\n      * Add one element to the beginning of an array and return the new length of the array.\n      * @param element to insert at the start of the Array.\n      */\n    //% help=arrays/unshift\n    //% helper=arrayUnshift weight=25\n    //% blockId=\"array_unshift\" block=\"%list| insert %value| at beginning\" blockNamespace=\"arrays\"\n    //% group=\"Modify\"\n    //unshift(...values:T[]): number; //rest is not supported in our compiler yet.\n    unshift(value: T): number;\n\n    /**\n      * Return a section of an array.\n      * @param start The beginning of the specified portion of the array. eg: 0\n      * @param end The end of the specified portion of the array. eg: 0\n      */\n    //% help=arrays/slice\n    //% helper=arraySlice weight=41 blockNamespace=\"arrays\"\n    slice(start?: number, end?: number): T[];\n\n    /**\n      * Remove elements from an array.\n      * @param start The zero-based location in the array from which to start removing elements. eg: 0\n      * @param deleteCount The number of elements to remove. eg: 0\n      */\n    //% helper=arraySplice weight=40\n    splice(start: number, deleteCount: number): void;\n\n    /**\n      * joins all elements of an array into a string and returns this string.\n      * @param sep the string separator\n      */\n    //% helper=arrayJoin weight=40\n    join(sep?: string): string;\n\n    /**\n      * Tests whether at least one element in the array passes the test implemented by the provided function.\n      * @param callbackfn A function that accepts up to two arguments. The some method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arraySome weight=40\n    some(callbackfn: (value: T, index: number) => boolean): boolean;\n\n    /**\n      * Tests whether all elements in the array pass the test implemented by the provided function.\n      * @param callbackfn A function that accepts up to two arguments. The every method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayEvery weight=40\n    every(callbackfn: (value: T, index: number) => boolean): boolean;\n\n    /**\n      * Sort the elements of an array in place and returns the array. The sort is not necessarily stable.\n      * @param specifies a function that defines the sort order. If omitted, the array is sorted according to the prmitive type\n      */\n    //% helper=arraySort weight=40\n    sort(callbackfn?: (value1: T, value2: T) => number): T[];\n\n    /**\n      * Call a defined callback function on each element of an array, and return an array containing the results.\n      * @param callbackfn A function that accepts up to two arguments. The map method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayMap weight=40\n    map<U>(callbackfn: (value: T, index: number) => U): U[];\n\n    /**\n      * Call a defined callback function on each element of an array.\n      * @param callbackfn A function that accepts up to two arguments. The forEach method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayForEach weight=40\n    forEach(callbackfn: (value: T, index: number) => void): void;\n\n    /**\n      * Return the elements of an array that meet the condition specified in a callback function.\n      * @param callbackfn A function that accepts up to two arguments. The filter method calls the callbackfn function one time for each element in the array.\n      */\n    //% helper=arrayFilter weight=40\n    filter(callbackfn: (value: T, index: number) => boolean): T[];\n\n    /**\n      * Fills all the elements of an array from a start index to an end index with a static value. The end index is not included.\n      */\n    //% helper=arrayFill weight=39\n    fill(value: T, start?: number, end?: number): T[];\n\n    /**\n     * Returns the value of the first element in the array that satisfies the provided testing function. Otherwise undefined is returned.\n     * @param callbackfn\n     */\n    //% helper=arrayFind weight=40\n    find(callbackfn: (value: T, index: number) => boolean): T;\n\n    /**\n      * Call the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function.\n      * @param callbackfn A function that accepts up to three arguments. The reduce method calls the callbackfn function one time for each element in the array.\n      * @param initialValue Initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.\n      */\n    //% helper=arrayReduce weight=40\n    reduce<U>(callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U, initialValue: U): U;\n\n\n    /** Remove the first occurence of an object. Returns true if removed. */\n    //% shim=Array_::removeElement weight=48\n    removeElement(element: T): boolean;\n\n    /** Remove the element at a certain index. */\n    //% help=arrays/remove-at\n    //% shim=Array_::removeAt weight=47\n    //% blockId=\"array_removeat\" block=\"%list| get and remove value at %index\" blockNamespace=\"arrays\"\n    //% group=\"Read\"\n    removeAt(index: number): T;\n\n    /**\n     * Insert the value at a particular index, increases length by 1\n     * @param index the zero-based position in the list to insert the value, eg: 0\n     * @param the value to insert, eg: 0\n     */\n    //% help=arrays/insert-at\n    //% shim=Array_::insertAt weight=20\n    //% blockId=\"array_insertAt\" block=\"%list| insert at %index| value %value\" blockNamespace=\"arrays\"\n    //% group=\"Modify\"\n    insertAt(index: number, value: T): void;\n\n    /**\n      * Return the index of the first occurrence of a value in an array.\n      * @param item The value to locate in the array.\n      * @param fromIndex The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.\n      */\n    //% help=arrays/index-of\n    //% shim=Array_::indexOf weight=40\n    //% blockId=\"array_indexof\" block=\"%list| find index of %value\" blockNamespace=\"arrays\"\n    //% group=\"Operations\"\n    indexOf(item: T, fromIndex?: number): number;\n\n    /**\n     * Get the value at a particular index\n     * @param index the zero-based position in the list of the item, eg: 0\n     */\n    //% help=arrays/get\n    //% shim=Array_::getAt weight=85\n    get(index: number): T;\n\n    /**\n     * Store a value at a particular index\n     * @param index the zero-based position in the list to store the value, eg: 0\n     * @param value the value to insert, eg: 0\n     */\n    //% help=arrays/set\n    //% shim=Array_::setAt weight=84\n    set(index: number, value: T): void;\n\n    /**\n     * Return a random value from the array\n     */\n    //% help=arrays/pick-random\n    //% helper=arrayPickRandom weight=25\n    //% blockId=\"array_pickRandom\" block=\"get random value from %list\"\n    //% blockNamespace=\"arrays\"\n    //% group=\"Read\"\n    _pickRandom(): T;\n\n    [n: number]: T;\n\n    /**\n      * Add one element to the beginning of an array and return the new length of the array.\n      * @param element to insert at the start of the Array.\n      */\n    //% help=arrays/unshift\n    //% helper=arrayUnshift weight=24\n    //% blockId=\"array_unshift_statement\" block=\"%list| insert %value| at beginning\" blockNamespace=\"arrays\"\n    //% blockAliasFor=\"Array.unshift\"\n    //% group=\"Modify\"\n    _unshiftStatement(value: T): void;\n\n    /**\n      * Remove the last element from an array and return it.\n      */\n    //% help=arrays/pop\n    //% shim=Array_::pop weight=44\n    //% blockId=\"array_pop_statement\" block=\"remove last value from %list\" blockNamespace=\"arrays\"\n    //% blockAliasFor=\"Array.pop\"\n    //% group=\"Modify\"\n    _popStatement(): void;\n\n    /**\n      * Remove the first element from an array and return it. This method changes the length of the array.\n      */\n    //% help=arrays/shift\n    //% helper=arrayShift weight=29\n    //% blockId=\"array_shift_statement\" block=\"remove first value from %list\" blockNamespace=\"arrays\"\n    //% blockAliasFor=\"Array.shift\"\n    //% group=\"Modify\"\n    _shiftStatement(): void;\n\n    /** Remove the element at a certain index. */\n    //% help=arrays/remove-at\n    //% shim=Array_::removeAt weight=14\n    //% blockId=\"array_removeat_statement\" block=\"%list| remove value at %index\" blockNamespace=\"arrays\"\n    //% blockAliasFor=\"Array.removeAt\"\n    //% group=\"Modify\"\n    _removeAtStatement(index: number): void;\n}\n\ndeclare interface String {\n    // This block is currently disabled in favor of the built-in Blockly \"Create text with\" block, which compiles to \"\" + \"\"\n    // Add % sign back to the block annotation to re-enable\n    /**\n     * Returns a string that contains the concatenation of two or more strings.\n     * @param other The string to append to the end of the string.\n     */\n    //% shim=String_::concat weight=49\n    //% blockId=\"string_concat\" blockNamespace=\"text\"\n    // block=\"join %list=text|%other\"\n    concat(other: string): string;\n\n    /**\n     * Return the character at the specified index.\n     * @param index The zero-based index of the desired character.\n     */\n    //% shim=String_::charAt weight=48\n    //% help=text/char-at\n    //% blockId=\"string_get\" block=\"char from %this=text|at %pos\" blockNamespace=\"text\"\n    charAt(index: number): string;\n\n    /** Returns the length of a String object. */\n    //% property shim=String_::length weight=47\n    //% blockId=\"text_length\" block=\"length of %VALUE\" blockBuiltin=true blockNamespace=\"text\"\n    length: number;\n\n    /**\n     * Return the Unicode value of the character at the specified location.\n     * @param index The zero-based index of the desired character. If there is no character at the specified index, NaN is returned.\n     */\n    //% shim=String_::charCodeAt\n    charCodeAt(index: number): number;\n\n    /**\n     * See how the order of characters in two strings is different (in ASCII encoding).\n     * @param that String to compare to target string\n     */\n    //% shim=String_::compare\n    //% help=text/compare\n    //% blockId=\"string_compare\" block=\"compare %this=text| to %that\" blockNamespace=\"text\"\n    compare(that: string): number;\n\n    /**\n     * Return a substring of the current string.\n     * @param start first character index; can be negative from counting from the end, eg:0\n     * @param length number of characters to extract, eg: 10\n     */\n    //% helper=stringSubstr\n    //% help=text/substr\n    //% blockId=\"string_substr\" block=\"substring of %this=text|from %start|of length %length\" blockNamespace=\"text\"\n    substr(start: number, length?: number): string;\n\n    /**\n     * Return the current string with the first occurence of toReplace\n     * replaced with the replacer\n     * @param toReplace the substring to replace in the current string\n     * @param replacer either the string that replaces toReplace in the current string,\n     *                or a function that accepts the substring and returns the replacement string.\n     */\n    //% helper=stringReplace\n    replace(toReplace: string, replacer: string | ((sub: string) => string)): string;\n\n    /**\n     * Return the current string with each occurence of toReplace\n     * replaced with the replacer\n     * @param toReplace the substring to replace in the current string\n     * @param replacer either the string that replaces toReplace in the current string,\n     *                or a function that accepts the substring and returns the replacement string.\n     */\n    //% helper=stringReplaceAll\n    replaceAll(toReplace: string, replacer: string | ((sub: string) => string)): string;\n\n    /**\n     * Return a substring of the current string.\n     * @param start first character index; can be negative from counting from the end, eg:0\n     * @param end one-past-last character index\n     */\n    //% helper=stringSlice\n    slice(start: number, end?: number): string;\n\n    /** Returns a value indicating if the string is empty */\n    //% helper=stringEmpty\n    //% help=text/is-empty\n    //% blockId=\"string_isempty\" blockNamespace=\"text\"\n    //% block=\"%this=text| is empty\"\n    isEmpty(): boolean;\n\n    /**\n     * Returns the position of the first occurrence of a specified value in a string.\n     * @param searchValue the text to find\n     * @param start optional start index for the search\n     */\n    //% shim=String_::indexOf\n    //% help=text/index-of\n    //% blockId=\"string_indexof\" blockNamespace=\"text\"\n    //% block=\"%this=text|find index of %searchValue\"\n    indexOf(searchValue: string, start?: number): number;\n\n    /**\n     * Determines whether a string contains the characters of a specified string.\n     * @param searchValue the text to find\n     * @param start optional start index for the search\n     */\n    //% shim=String_::includes\n    //% help=text/includes\n    //% blockId=\"string_includes\" blockNamespace=\"text\"\n    //% block=\"%this=text|includes %searchValue\"\n    includes(searchValue: string, start?: number): boolean;\n\n    /**\n     * Splits the string according to the separators\n     * @param separator\n     * @param limit\n     */\n    //% helper=stringSplit\n    //% help=text/split\n    //% blockId=\"string_split\" blockNamespace=\"text\"\n    //% block=\"split %this=text|at %separator\"\n    split(separator?: string, limit?: number): string[];\n\n    /**\n     * Return a substring of the current string with whitespace removed from both ends\n     */\n    //% helper=stringTrim\n    trim(): string;\n\n    /**\n     * Converts the string to lower case characters.\n     */\n    //% helper=stringToLowerCase\n    //% help=text/to-lower-case\n    toLowerCase(): string;\n\n    [index: number]: string;\n}\n\n/**\n  * Convert a string to a number.\n  * @param s A string to convert into a number. eg: 123\n  */\n//% shim=String_::toNumber\n//% help=text/parse-float\n//% blockId=\"string_parsefloat\" block=\"parse to number %text\" blockNamespace=\"text\"\n//% text.defl=\"123\"\ndeclare function parseFloat(text: string): number;\n\n/**\n * Returns a pseudorandom number between min and max included.\n * If both numbers are integral, the result is integral.\n * @param min the lower inclusive bound, eg: 0\n * @param max the upper inclusive bound, eg: 10\n */\n//% blockId=\"device_random\" block=\"pick random %min|to %limit\"\n//% blockNamespace=\"Math\"\n//% help=math/randint\n//% shim=Math_::randomRange\ndeclare function randint(min: number, max: number): number;\n\ninterface Object { }\ninterface Function {\n  __assignableToFunction: Function;\n}\ninterface IArguments {\n  __assignableToIArguments: IArguments;\n}\ninterface RegExp {\n  __assignableToRegExp: RegExp;\n}\ntype TemplateStringsArray = Array<string>;\n\ntype uint8 = number;\ntype uint16 = number;\ntype uint32 = number;\ntype int8 = number;\ntype int16 = number;\ntype int32 = number;\n\n\ndeclare interface Boolean {\n    /**\n     * Returns a string representation of an object.\n     */\n    //% shim=numops::toString\n    toString(): string;\n}\n\n/**\n * Combine, split, and search text strings.\n*/\n//% blockNamespace=\"text\"\ndeclare namespace String {\n\n    /**\n     * Make a string from the given ASCII character code.\n     */\n    //% help=math/from-char-code\n    //% shim=String_::fromCharCode weight=1\n    //% blockNamespace=\"text\" blockId=\"stringFromCharCode\" block=\"text from char code %code\"\n    function fromCharCode(code: number): string;\n}\n\ndeclare interface Number {\n    /**\n     * Returns a string representation of a number.\n     */\n    //% shim=numops::toString\n    toString(): string;\n}\n\n/**\n * Add, remove, and replace items in lists.\n*/\n//% blockNamespace=\"Arrays\"\ndeclare namespace Array {\n    /**\n     * Check if a given object is an array.\n     */\n    //% shim=Array_::isArray\n    function isArray(obj: any): boolean;\n}\n\ndeclare namespace Object {\n    /**\n     * Return the field names in an object.\n     */\n    //% shim=pxtrt::keysOf\n    function keys(obj: any): string[];\n}\n\n/**\n * More complex operations with numbers.\n*/\ndeclare namespace Math {\n    /**\n     * Returns the value of a base expression taken to a specified power.\n     * @param x The base value of the expression.\n     * @param y The exponent value of the expression.\n     */\n    //% shim=Math_::pow\n    function pow(x: number, y: number): number;\n\n    /**\n     * Returns a pseudorandom number between 0 and 1.\n     */\n    //% shim=Math_::random\n    //% help=math/random\n    function random(): number;\n\n    /**\n     * Returns a pseudorandom number between min and max included.\n     * If both numbers are integral, the result is integral.\n     * @param min the lower inclusive bound, eg: 0\n     * @param max the upper inclusive bound, eg: 10\n     */\n    //% blockId=\"device_random_deprecated\" block=\"pick random %min|to %limit\"\n    //% help=math/random-range deprecated\n    //% shim=Math_::randomRange\n    function randomRange(min: number, max: number): number;\n\n    /**\n     * Returns the natural logarithm (base e) of a number.\n     * @param x A number\n     */\n    //% shim=Math_::log\n    function log(x: number): number;\n\n    /**\n     * Returns returns ``e^x``.\n     * @param x A number\n     */\n    //% shim=Math_::exp\n    function exp(x: number): number;\n\n    /**\n     * Returns the sine of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::sin\n    //% help=math/trigonometry\n    function sin(x: number): number;\n\n    /**\n     * Returns the cosine of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::cos\n    //% help=math/trigonometry\n    function cos(x: number): number;\n\n    /**\n     * Returns the tangent of a number.\n     * @param x An angle in radians\n     */\n    //% shim=Math_::tan\n    function tan(x: number): number;\n\n    /**\n     * Returns the arcsine (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::asin\n    function asin(x: number): number;\n\n    /**\n     * Returns the arccosine (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::acos\n    function acos(x: number): number;\n\n    /**\n     * Returns the arctangent (in radians) of a number\n     * @param x A number\n     */\n    //% shim=Math_::atan\n    function atan(x: number): number;\n\n    /**\n     * Returns the arctangent of the quotient of its arguments.\n     * @param y A number\n     * @param x A number\n     */\n    //% shim=Math_::atan2\n    function atan2(y: number, x: number): number;\n\n    /**\n     * Returns the square root of a number.\n     * @param x A numeric expression.\n     */\n    //% shim=Math_::sqrt\n    function sqrt(x: number): number;\n\n    /**\n     * Returns the smallest number greater than or equal to its numeric argument.\n     * @param x A numeric expression.\n     */\n    //% shim=Math_::ceil\n      //% help=math\n    function ceil(x: number): number;\n\n    /**\n      * Returns the greatest number less than or equal to its numeric argument.\n      * @param x A numeric expression.\n      */\n    //% shim=Math_::floor\n      //% help=math\n    function floor(x: number): number;\n\n    /**\n      * Returns the number with the decimal part truncated.\n      * @param x A numeric expression.\n      */\n    //% shim=Math_::trunc\n    //% help=math\n    function trunc(x: number): number;\n\n    /**\n      * Returns a supplied numeric expression rounded to the nearest number.\n      * @param x The value to be rounded to the nearest number.\n      */\n    //% shim=Math_::round\n    //% help=math\n    function round(x: number): number;\n\n    /**\n     * Returns the value of integer signed 32 bit multiplication of two numbers.\n     * @param x The first number\n     * @param y The second number\n     */\n    //% shim=Math_::imul\n    function imul(x: number, y: number): number;\n\n    /**\n     * Returns the value of integer signed 32 bit division of two numbers.\n     * @param x The first number\n     * @param y The second number\n     */\n    //% shim=Math_::idiv\n    function idiv(x: number, y: number): number;\n}\n\ndeclare namespace control {\n    //% shim=_control::_onCodeStart\n    export function _onCodeStart(arg: any): void;\n\n    //% shim=_control::_onCodeStop\n    export function _onCodeStop(arg: any): void;\n}",
            "pxt-helpers.ts": "type Action = () => void;\n\n/**\n * Constant representing Not-A-Number.\n */\nconst NaN = 0 / 0\n\n/**\n * Constant representing positive infinity.\n */\nconst Infinity = 1 / 0\n\nfunction isNaN(x: number) {\n    x = +x // convert to number\n    return x !== x\n}\n\nnamespace Number {\n    /**\n     * Check if a given value is of type Number and it is a NaN.\n     */\n    export function isNaN(x: any): boolean {\n        return typeof x == \"number\" && x !== x\n    }\n}\n\n/**\n * A dictionary from string key to string values\n */\ninterface StringMap {\n    [index: string]: string;\n}\n\n/**\n  * Convert a string to an integer.\n  * @param text A string to convert into an integral number. eg: \"123\"\n  * @param radix optional A value between 2 and 36 that specifies the base of the number in text.\n  * If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.\n  * All other strings are considered decimal.\n  */\n//% help=text/parse-int\n//% blockId=\"string_parseint\" block=\"parse to integer %text\" blockNamespace=\"text\"\n//% text.defl=\"123\"\n//% blockHidden=1\nfunction parseInt(text: string, radix?: number): number {\n    // roughly based on https://www.ecma-international.org/ecma-262/5.1/#sec-15.1.2.2\n    // with some consideration for avoiding unnecessary slices where easy\n    if (!text || (radix != null && (radix < 2 || radix > 36)))\n        return NaN;\n\n    let start = 0;\n    while (start < text.length && helpers.isWhitespace(text.charCodeAt(start)))\n        ++start;\n\n    if (start === text.length)\n        return NaN;\n\n    const numberOffset = 48; // 0\n    const numCount = 10;\n    const letterOffset = 97; // a\n    const letterCount = 26;\n    const lowerCaseMask = 0x20;\n\n    let sign = 1;\n    switch (text.charAt(start)) {\n        case \"-\":\n            sign = -1;\n            // fallthrough\n        case \"+\":\n            ++start;\n    }\n\n    if ((!radix || radix == 16)\n            && \"0\" === text[start]\n            && (\"x\" === text[start + 1] || \"X\" === text[start + 1])) {\n        radix = 16;\n        start += 2;\n    } else if (!radix) {\n        radix = 10;\n    }\n\n    let output = 0;\n    let hasDigit = false;\n    for (let i = start; i < text.length; ++i) {\n        const code = text.charCodeAt(i) | lowerCaseMask;\n        let val: number = undefined;\n\n        if (code >= numberOffset && code < numberOffset + numCount)\n            val = code - numberOffset;\n        else if (code >= letterOffset && code < letterOffset + letterCount)\n            val = numCount + code - letterOffset;\n\n        if (val == undefined || val >= radix) {\n            if (!hasDigit) {\n                return NaN;\n            }\n            break;\n        }\n        hasDigit = true;\n        output = output * radix + val;\n    }\n\n    return sign * output;\n}\n\nnamespace helpers {\n    export function arrayFill<T>(O: T[], value: T, start?: number, end?: number) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill\n        // Steps 3-5.\n        const len = O.length >>> 0;\n\n        // Steps 6-7.\n        const relativeStart = start === undefined ? 0 : start >> 0;\n\n        // Step 8.\n        let k = relativeStart < 0 ?\n            Math.max(len + relativeStart, 0) :\n            Math.min(relativeStart, len);\n\n        // Steps 9-10.\n        const relativeEnd = end === undefined ? len : end >> 0;\n\n        // Step 11.\n        const final = relativeEnd < 0 ?\n            Math.max(len + relativeEnd, 0) :\n            Math.min(relativeEnd, len);\n\n        // Step 12.\n        while (k < final) {\n            O[k] = value;\n            k++;\n        }\n\n        // Step 13.\n        return O;\n    }\n\n    export function arraySplice<T>(arr: T[], start: number, len: number) {\n        if (start < 0) {\n            return;\n        }\n        for (let i = 0; i < len; ++i) {\n            arr.removeAt(start)\n        }\n    }\n\n    export function arrayReverse<T>(arr: T[]): void {\n        let len = arr.length;\n        for (let i = 0; i < len / 2; i++) {\n            swap(arr, i, len - i - 1);\n        }\n    }\n\n    export function arrayShift<T>(arr: T[]): T {\n        return arr.removeAt(0);\n    }\n\n    export function arrayJoin<T>(arr: T[], sep?: string): string {\n        if (sep === undefined || sep === null) {\n            sep = \",\";\n        }\n\n        let r = \"\";\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i) {\n            if (i > 0 && sep)\n                r += sep;\n            r += (arr[i] === undefined || arr[i] === null) ? \"\" : arr[i];\n        }\n        return r;\n    }\n\n    /*TODO: Enable this multiple value unshift, after rest is enabled in our compiler.\n        export function arrayUnshift<T>(arr: T[], ...values: T[]) : number {\n            for(let i = values.length; i > 0; --i) {\n                arr.insertAt(0, values[i - 1]);\n            }\n            return arr.length;\n        }\n    */\n    export function arrayUnshift<T>(arr: T[], value: T): number {\n        arr.insertAt(0, value);\n        return arr.length;\n    }\n\n    function swap<T>(arr: T[], i: number, j: number): void {\n        let temp: T = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n\n    function sortHelper<T>(arr: T[], callbackfn?: (value1: T, value2: T) => number): T[] {\n        if (arr.length <= 0 || !callbackfn) {\n            return arr;\n        }\n        let len = arr.length;\n        // simple selection sort.\n        for (let i = 0; i < len - 1; ++i) {\n            for (let j = i + 1; j < len; ++j) {\n                if (callbackfn(arr[i], arr[j]) > 0) {\n                    swap(arr, i, j);\n                }\n            }\n        }\n        return arr;\n    }\n\n    export function arraySort<T>(arr: T[], callbackfn?: (value1: T, value2: T) => number): T[] {\n        if (!callbackfn && arr.length > 1) {\n            callbackfn = (a, b) => {\n                // default is sort as if the element were a string, with null < undefined\n                const aIsUndef = a === undefined;\n                const bIsUndef = b === undefined;\n                if (aIsUndef && bIsUndef) return 0;\n                else if (aIsUndef) return 1;\n                else if (bIsUndef) return -1;\n\n                const aIsNull = a === null;\n                const bIsNull = b === null;\n                if (aIsNull && bIsNull) return 0;\n                else if (aIsNull) return 1;\n                else if (bIsNull) return -1;\n\n                return (a + \"\").compare(b + \"\");\n            }\n        }\n        return sortHelper(arr, callbackfn);\n    }\n\n    export function arrayMap<T, U>(arr: T[], callbackfn: (value: T, index: number) => U): U[] {\n        let res: U[] = []\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i) {\n            res.push(callbackfn(arr[i], i))\n        }\n        return res\n    }\n\n    export function arraySome<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): boolean {\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i)\n            if (callbackfn(arr[i], i))\n                return true;\n        return false;\n    }\n\n    export function arrayEvery<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): boolean {\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i)\n            if (!callbackfn(arr[i], i))\n                return false;\n        return true;\n    }\n\n    export function arrayForEach<T>(arr: T[], callbackfn: (value: T, index: number) => void): void {\n        let len = arr.length // caching this seems to match V8\n        for (let i = 0; i < len; ++i) {\n            callbackfn(arr[i], i);\n        }\n    }\n\n    export function arrayFilter<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): T[] {\n        let res: T[] = []\n        let len = arr.length\n        for (let i = 0; i < len; ++i) {\n            let v = arr[i] // need to cache\n            if (callbackfn(v, i)) res.push(v)\n        }\n        return res\n    }\n\n    export function arrayFind<T>(arr: T[], callbackfn: (value: T, index: number) => boolean): T {\n        let len = arr.length\n        for (let i = 0; i < len; ++i) {\n            let v = arr[i] // need to cache\n            if (callbackfn(v, i)) return v;\n        }\n        return undefined;\n    }\n\n    export function arrayReduce<T, U>(arr: T[], callbackfn: (previousValue: U, currentValue: T, currentIndex: number) => U, initialValue: U): U {\n        let len = arr.length\n        for (let i = 0; i < len; ++i) {\n            initialValue = callbackfn(initialValue, arr[i], i)\n        }\n        return initialValue\n    }\n\n    export function arrayConcat<T>(arr: T[], otherArr: T[]): T[] {\n        let out: T[] = [];\n        for (let value of arr) {\n            out.push(value);\n        }\n        for (let value of otherArr) {\n            out.push(value);\n        }\n        return out;\n    }\n\n    export function arrayPickRandom<T>(arr: T[]): T {\n        return arr[Math.randomRange(0, arr.length - 1)];\n    }\n\n    export function arraySlice<T>(arr: T[], start?: number, end?: number): T[] {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice\n        const res: T[] = [];\n        const len = arr.length;\n\n        if (start === undefined)\n            start = 0;\n        else if (start < 0)\n            start = Math.max(len + start, 0);\n\n        if (start > len)\n            return res;\n\n        if (end === undefined)\n            end = len;\n        else if (end < 0)\n            end = len + end;\n\n        if (end > len)\n            end = len;\n\n        for (let i = start; i < end; ++i) {\n            res.push(arr[i]);\n        }\n        return res;\n    }\n\n    export function stringReplace(s: string, toReplace: string, replacer: string | ((sub: string) => string)) {\n        toReplace = toReplace + \"\";\n        const ind = s.indexOf(toReplace);\n        if (ind == -1)\n            return s;\n\n        const begin = s.slice(0, ind);\n        const end = s.slice(ind + toReplace.length);\n\n        if (typeof replacer == \"string\" || !replacer) {\n            return begin + replacer + end;\n        } else {\n            return begin + replacer(toReplace) + end;\n        }\n    }\n\n    export function stringReplaceAll(s: string, toReplace: string, replacer: string | ((sub: string) => string)) {\n        toReplace = toReplace + \"\";\n        const split = s.split(toReplace);\n        const empty = toReplace.isEmpty();\n\n        let output = (empty ? applyReplace(toReplace, replacer) : \"\");\n\n        if (split.length) {\n            output += split[0];\n        }\n\n        for (let i = 1; i < split.length; ++i) {\n            output += applyReplace(toReplace, replacer) + split[i];\n        }\n\n        if (!s.isEmpty() && empty) {\n            output += applyReplace(toReplace, replacer);\n        }\n\n        return output;\n\n        function applyReplace(r: string, replacer: string | ((sub: string) => string)): string {\n            if (typeof replacer == \"string\" || !replacer) {\n                return replacer as string;\n            } else {\n                return replacer(r);\n            }\n        }\n    }\n\n    //% shim=String_::substr\n    declare function stringSubstrHelper(s: string, start: number, length?: number): string;\n\n    export function stringSubstr(s: string, start: number, length?: number): string {\n        length = length === undefined ? s.length : length || 0;\n        return stringSubstrHelper(s, start, length);\n    }\n\n    export function stringSlice(s: string, start: number, end?: number): string {\n        const len = s.length;\n\n        if (start < 0) {\n            start = Math.max(len + start, 0);\n        }\n\n        if (end === undefined) {\n            end = len;\n        } else if (end === null) {\n            end = 0;\n        }\n\n        if (end < 0) {\n            end = len + end;\n        }\n\n        return stringSubstrHelper(s, start, end - start);\n    }\n\n    // TODO move to PXT\n    // also note this doesn't handle unicode, but neither does JS (there's toLocaleLowerCase())\n    export function stringToLowerCase(s: string): string {\n        let r = \"\"\n        let prev = 0\n        for (let i = 0; i < s.length; i++) {\n            const c = s.charCodeAt(i)\n            if (65 <= c && c <= 90) {\n                r += s.slice(prev, i) + String.fromCharCode(c + 32)\n                prev = i + 1\n            }\n        }\n        r += s.slice(prev)\n        return r\n    }\n\n    export function stringSplit(S: string, separator?: string, limit?: number): string[] {\n        // https://www.ecma-international.org/ecma-262/6.0/#sec-string.prototype.split\n        const A: string[] = [];\n        let lim = 0;\n        if (limit === undefined)\n            lim = (1 << 29) - 1; // spec says 1 << 53, leaving it at 29 for constant folding\n        else if (limit < 0)\n            lim = 0;\n        else\n            lim = limit | 0;\n        const s = S.length;\n        let p = 0;\n        const R = separator;\n        if (lim == 0)\n            return A;\n        if (separator === undefined) {\n            A[0] = S;\n            return A;\n        }\n        if (s == 0) {\n            let z = splitMatch(S, 0, R);\n            if (z > -1) return A;\n            A[0] = S;\n            return A;\n        }\n        let T: string;\n        let q = p;\n        while (q != s) {\n            let e = splitMatch(S, q, R);\n            if (e < 0) q++;\n            else {\n                if (e == p) q++;\n                else {\n                    T = stringSlice(S, p, q);\n                    A.push(T);\n                    if (A.length == lim) return A;\n                    p = e;\n                    q = p;\n                }\n            }\n        }\n        T = stringSlice(S, p, q);\n        A.push(T);\n        return A;\n    }\n\n    function splitMatch(S: string, q: number, R: string): number {\n        const r = R.length;\n        const s = S.length;\n        if (q + r > s) return -1;\n        for (let i = 0; i < r; ++i) {\n            if (S[q + i] != R[i])\n                return -1;\n        }\n        return q + r;\n    }\n\n    export function stringTrim(s: string): string {\n        let start = 0;\n        let end = s.length - 1;\n\n        while (start <= end && isWhitespace(s.charCodeAt(start)))\n            ++start;\n\n        while (end > start && isWhitespace(s.charCodeAt(end)))\n            --end;\n        return s.slice(start, end + 1);\n    }\n\n    export function isWhitespace(c: number): boolean {\n        // https://www.ecma-international.org/ecma-262/6.0/#sec-white-space\n        switch (c) {\n            case 0x0009:  // character tab\n            case 0x000B:  // line tab\n            case 0x000C:  // form feed\n            case 0x0020:  // space\n            case 0x00A0:  // no-break space\n            case 0xFEFF:  // zero width no break space\n            case 0x000A:  // line feed\n            case 0x000D:  // carriage return\n            case 0x2028:  // line separator\n            case 0x2029:  // paragraph separator\n                return true;\n            default:\n                return false;\n        }\n    }\n\n    export function stringEmpty(S: string): boolean {\n        return !S;\n    }\n}\n\nnamespace Math {\n    export function clamp(min: number, max: number, value: number): number {\n        return Math.min(max, Math.max(min, value));\n    }\n\n    /**\n      * Returns the absolute value of a number (the value without regard to whether it is positive or negative).\n      * For example, the absolute value of -5 is the same as the absolute value of 5.\n      * @param x A numeric expression for which the absolute value is needed.\n      */\n    //% help=math/abs\n    export function abs(x: number): number {\n        return x < 0 ? -x : x;\n    }\n\n    /**\n      * Returns the sign of the x, indicating whether x is positive, negative or zero.\n      * @param x The numeric expression to test\n      */\n    export function sign(x: number): number {\n        if (x == 0) return 0;\n        if (x > 0) return 1;\n        return -1;\n    }\n\n    /**\n      * Returns the larger of two supplied numeric expressions.\n      */\n    //% help=math/max\n    export function max(a: number, b: number): number {\n        if (a >= b) return a;\n        return b;\n    }\n\n    /**\n      * Returns the smaller of two supplied numeric expressions.\n      */\n    //% help=math/min\n    export function min(a: number, b: number): number {\n        if (a <= b) return a;\n        return b;\n    }\n\n    /**\n     * Rounds ``x`` to a number with the given number of ``digits``\n     * @param x the number to round\n     * @param digits the number of resulting digits\n     */\n    //%\n    export function roundWithPrecision(x: number, digits: number): number {\n        digits = digits | 0;\n        // invalid digits input\n        if (digits <= 0) return Math.round(x);\n        if (x == 0) return 0;\n        let r = 0;\n        do {\n            const d = Math.pow(10, digits);\n            r = Math.round(x * d) / d;\n            digits++;\n        } while (r == 0 && digits < 21);\n        return r;\n    }\n}\n\n\n//% blockHidden=1\nnamespace __internal {\n    /**\n     * A shim to render a boolean as a down/up toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleDownUp block=\"%down\"\n    //% down.fieldEditor=toggledownup\n    //% down.fieldOptions.decompileLiterals=true\n    export function __downUp(down: boolean): boolean {\n        return down;\n    }\n\n    /**\n     * A shim to render a boolean as a up/down toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleUpDown block=\"%up\"\n    //% up.fieldEditor=toggleupdown\n    //% up.fieldOptions.decompileLiterals=true\n    export function __upDown(up: boolean): boolean {\n        return up;\n    }\n\n    /**\n     * A shim to render a boolean as a high/low toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleHighLow block=\"%high\"\n    //% high.fieldEditor=togglehighlow\n    //% high.fieldOptions.decompileLiterals=true\n    export function __highLow(high: boolean): boolean {\n        return high;\n    }\n\n    /**\n     * A shim to render a boolean as a on/off toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleOnOff block=\"%on\"\n    //% on.fieldEditor=toggleonoff\n    //% on.fieldOptions.decompileLiterals=true\n    export function __onOff(on: boolean): boolean {\n        return on;\n    }\n\n    /**\n     * A shim to render a boolean as a yes/no toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleYesNo block=\"%yes\"\n    //% yes.fieldEditor=toggleyesno\n    //% yes.fieldOptions.decompileLiterals=true\n    export function __yesNo(yes: boolean): boolean {\n        return yes;\n    }\n\n    /**\n     * A shim to render a boolean as a win/lose toggle\n     */\n    //% shim=TD_ID blockHidden=1\n    //% blockId=toggleWinLose block=\"%win\"\n    //% win.fieldEditor=togglewinlose\n    //% win.fieldOptions.decompileLiterals=true\n    export function __winLose(win: boolean): boolean {\n        return win;\n    }\n\n    /**\n     * Get the color wheel field editor\n     * @param color color, eg: #ff0000\n     */\n    //% blockId=colorNumberPicker block=\"%value\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colornumber\" value.fieldOptions.decompileLiterals=true\n    //% value.defl='#ff0000'\n    //% value.fieldOptions.colours='[\"#ff0000\",\"#ff8000\",\"#ffff00\",\"#ff9da5\",\"#00ff00\",\"#b09eff\",\"#00ffff\",\"#007fff\",\"#65471f\",\"#0000ff\",\"#7f00ff\",\"#ff0080\",\"#ff00ff\",\"#ffffff\",\"#999999\",\"#000000\"]'\n    //% value.fieldOptions.columns=4 value.fieldOptions.className='rgbColorPicker'\n    export function __colorNumberPicker(value: number) {\n        return value;\n    }\n\n    /**\n     * Get the color wheel field editor\n     * @param value value between 0 to 255 to get a color value, eg: 10\n     */\n    //% blockId=colorWheelPicker block=\"%value\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colorwheel\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.sliderWidth='200'\n    //% value.fieldOptions.min=0 value.fieldOptions.max=255\n    export function __colorWheelPicker(value: number) {\n        return value;\n    }\n\n    /**\n    * Get the color wheel field editor using HSV values\n    * @param value value between 0 to 255 to get a color value, eg: 10\n    */\n    //% blockId=colorWheelHsvPicker block=\"%value\"\n    //% blockHidden=true\n    //% shim=TD_ID colorSecondary=\"#FFFFFF\"\n    //% value.fieldEditor=\"colorwheel\" value.fieldOptions.decompileLiterals=true\n    //% value.fieldOptions.sliderWidth='200'\n    //% value.fieldOptions.min=0 value.fieldOptions.max=255\n    //% value.fieldOptions.channel=hsvfast\n    export function __colorWheelHsvPicker(value: number) {\n        return value;\n    }\n\n    /**\n     * A speed picker\n     * @param speed the speed, eg: 50\n     */\n    //% blockId=speedPicker block=\"%speed\" shim=TD_ID\n    //% speed.fieldEditor=\"speed\" colorSecondary=\"#FFFFFF\"\n    //% weight=0 blockHidden=1 speed.fieldOptions.decompileLiterals=1\n    export function __speedPicker(speed: number): number {\n        return speed;\n    }\n\n    /**\n     * A turn ratio picker\n     * @param turnratio the turn ratio, eg: 0\n     */\n    //% blockId=turnRatioPicker block=\"%turnratio\" shim=TD_ID\n    //% turnratio.fieldEditor=\"turnratio\" colorSecondary=\"#FFFFFF\"\n    //% weight=0 blockHidden=1 turnRatio.fieldOptions.decompileLiterals=1\n    export function __turnRatioPicker(turnratio: number): number {\n        return turnratio;\n    }\n\n    /**\n     * A field editor that displays a protractor\n     */\n    //% blockId=protractorPicker block=\"%angle\"\n    //% shim=TD_ID\n    //% angle.fieldEditor=protractor\n    //% angle.fieldOptions.decompileLiterals=1\n    //% colorSecondary=\"#FFFFFF\"\n    //% blockHidden=1\n    export function __protractor(angle: number) {\n        return angle;\n    }\n\n    /**\n      * Get the time field editor\n      * @param ms time duration in milliseconds, eg: 500, 1000\n      */\n    //% blockId=timePicker block=\"%ms\"\n    //% blockHidden=true shim=TD_ID\n    //% colorSecondary=\"#FFFFFF\"\n    //% ms.fieldEditor=\"numberdropdown\" ms.fieldOptions.decompileLiterals=true\n    //% ms.fieldOptions.data='[[\"100 ms\", 100], [\"200 ms\", 200], [\"500 ms\", 500], [\"1 second\", 1000], [\"2 seconds\", 2000], [\"5 seconds\", 5000]]'\n    export function __timePicker(ms: number): number {\n        return ms;\n    }\n}",
            "pxt.cpp": "#include \"pxtbase.h\"\n\nusing namespace std;\n\nnamespace pxt {\n\nAction mkAction(int totallen, RefAction *act) {\n    check(getVTable(act)->classNo == BuiltInType::RefAction, PANIC_INVALID_BINARY_HEADER, 1);\n#ifdef PXT_VM\n    check(act->initialLen <= totallen, PANIC_INVALID_BINARY_HEADER, 13);\n#endif\n\n    if (totallen == 0) {\n        return (TValue)act; // no closure needed\n    }\n\n    void *ptr = gcAllocate(sizeof(RefAction) + totallen * sizeof(void *));\n    RefAction *r = new (ptr) RefAction();\n    r->len = totallen;\n#ifdef PXT_VM\n    r->numArgs = act->numArgs;\n    r->initialLen = act->initialLen;\n    r->flags = 0;\n#endif\n    r->func = act->func;\n    memset(r->fields, 0, r->len * sizeof(void *));\n\n    MEMDBG(\"mkAction: start=%p => %p\", act, r);\n\n    return (Action)r;\n}\n\nRefRecord *mkClassInstance(VTable *vtable) {\n    intcheck(vtable->methods[0] == &RefRecord_destroy, PANIC_SIZE, 3);\n    // intcheck(vtable->methods[1] == &RefRecord_print, PANIC_SIZE, 4);\n\n    void *ptr = gcAllocate(vtable->numbytes);\n    RefRecord *r = new (ptr) RefRecord(vtable);\n    memset(r->fields, 0, vtable->numbytes - sizeof(RefRecord));\n    MEMDBG(\"mkClass: vt=%p => %p\", vtable, r);\n    return r;\n}\n\nTValue RefRecord::ld(int idx) {\n    // intcheck((reflen == 255 ? 0 : reflen) <= idx && idx < len, PANIC_OUT_OF_BOUNDS, 1);\n    return fields[idx];\n}\n\nTValue RefRecord::ldref(int idx) {\n    // DMESG(\"LD %p len=%d reflen=%d idx=%d\", this, len, reflen, idx);\n    // intcheck(0 <= idx && idx < reflen, PANIC_OUT_OF_BOUNDS, 2);\n    return fields[idx];\n}\n\nvoid RefRecord::st(int idx, TValue v) {\n    // intcheck((reflen == 255 ? 0 : reflen) <= idx && idx < len, PANIC_OUT_OF_BOUNDS, 3);\n    fields[idx] = v;\n}\n\nvoid RefRecord::stref(int idx, TValue v) {\n    // DMESG(\"ST %p len=%d reflen=%d idx=%d\", this, len, reflen, idx);\n    // intcheck(0 <= idx && idx < reflen, PANIC_OUT_OF_BOUNDS, 4);\n    fields[idx] = v;\n}\n\nvoid RefObject::destroyVT() {\n    ((RefObjectMethod)getVTable(this)->methods[0])(this);\n}\n\n//%\nvoid deleteRefObject(RefObject *obj) {\n    obj->destroyVT();\n}\n\nvoid RefObject::printVT() {\n    ((RefObjectMethod)getVTable(this)->methods[1])(this);\n}\n\nvoid RefRecord_destroy(RefRecord *) {}\n\nvoid RefRecord_print(RefRecord *r) {\n    DMESG(\"RefRecord %p size=%d bytes\", r, getVTable(r)->numbytes);\n}\n\nvoid Segment::set(unsigned i, TValue value) {\n    if (i < size) {\n        data[i] = value;\n    } else if (i < Segment::MaxSize) {\n        growByMin(i + 1);\n        data[i] = value;\n    } else {\n        return;\n    }\n    if (length <= i) {\n        length = i + 1;\n    }\n\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::set\");\n    this->print();\n#endif\n\n    return;\n}\n\nstatic inline int growthFactor(int size) {\n    if (size == 0) {\n        return 4;\n    }\n    if (size < 64) {\n        return size * 2; // Double\n    }\n    if (size < 512) {\n        return size * 5 / 3; // Grow by 1.66 rate\n    }\n    // Grow by constant rate\n    if ((unsigned)size + 256 < Segment::MaxSize)\n        return size + 256;\n    else\n        return Segment::MaxSize;\n}\n\nvoid LLSegment::setLength(unsigned newLen) {\n    if (newLen > Segment::MaxSize)\n        return;\n\n    if (newLen > size) {\n        int newSize = growthFactor(size);\n        if (newSize < (int)newLen)\n            newSize = newLen;\n\n        // this will throw if unable to allocate\n        TValue *tmp = (TValue *)(xmalloc(newSize * sizeof(TValue)));\n\n        // Copy existing data\n        if (size) {\n            memcpy(tmp, data, size * sizeof(TValue));\n        }\n        // fill the rest with default value\n        memset(tmp + size, 0, (newSize - size) * sizeof(TValue));\n\n        // free older segment;\n        xfree(data);\n\n        data = tmp;\n        size = newSize;\n    } else if (newLen < length) {\n        memset(data + newLen, 0, (length - newLen) * sizeof(TValue));\n    }\n\n    length = newLen;\n}\n\nvoid LLSegment::set(unsigned idx, TValue v) {\n    if (idx >= Segment::MaxSize)\n        return;\n    if (idx >= length)\n        setLength(idx + 1);\n    data[idx] = v;\n}\n\nTValue LLSegment::pop() {\n    if (length > 0) {\n        --length;\n        TValue value = data[length];\n        data[length] = 0;\n        return value;\n    }\n    return 0;\n}\n\nvoid LLSegment::destroy() {\n    length = size = 0;\n    xfree(data);\n    data = nullptr;\n}\n\nvoid Segment::growByMin(ramint_t minSize) {\n    ramint_t newSize = max(minSize, (ramint_t)growthFactor(size));\n\n    if (size < newSize) {\n        // this will throw if unable to allocate\n        TValue *tmp = (TValue *)(gcAllocateArray(newSize * sizeof(TValue)));\n\n        // Copy existing data\n        if (size)\n            memcpy(tmp, data, size * sizeof(TValue));\n        // fill the rest with default value\n        memset(tmp + size, 0, (newSize - size) * sizeof(TValue));\n\n        data = tmp;\n        size = newSize;\n\n#ifdef DEBUG_BUILD\n        DMESG(\"growBy - after reallocation\");\n        this->print();\n#endif\n    }\n    // else { no shrinking yet; }\n    return;\n}\n\nvoid Segment::ensure(ramint_t newSize) {\n    if (newSize < size) {\n        return;\n    }\n    growByMin(newSize);\n}\n\nvoid Segment::setLength(unsigned newLength) {\n    if (newLength > size) {\n        ensure(newLength);\n    }\n    length = newLength;\n    return;\n}\n\nTValue Segment::pop() {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::pop\");\n    this->print();\n#endif\n\n    if (length > 0) {\n        --length;\n        TValue value = data[length];\n        data[length] = Segment::DefaultValue;\n        return value;\n    }\n    return Segment::DefaultValue;\n}\n\n// this function removes an element at index i and shifts the rest of the elements to\n// left to fill the gap\nTValue Segment::remove(unsigned i) {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::remove index:%d\", i);\n    this->print();\n#endif\n    if (i < length) {\n        // value to return\n        TValue ret = data[i];\n        if (i + 1 < length) {\n            // Move the rest of the elements to fill in the gap.\n            memmove(data + i, data + i + 1, (length - i - 1) * sizeof(void *));\n        }\n        length--;\n        data[length] = Segment::DefaultValue;\n#ifdef DEBUG_BUILD\n        DMESG(\"After Segment::remove index:%d\", i);\n        this->print();\n#endif\n        return ret;\n    }\n    return Segment::DefaultValue;\n}\n\n// this function inserts element value at index i by shifting the rest of the elements right.\nvoid Segment::insert(unsigned i, TValue value) {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::insert index:%d value:%d\", i, value);\n    this->print();\n#endif\n\n    if (i < length) {\n        ensure(length + 1);\n\n        // Move the rest of the elements to fill in the gap.\n        memmove(data + i + 1, data + i, (length - i) * sizeof(void *));\n\n        data[i] = value;\n        length++;\n    } else {\n        // This is insert beyond the length, just call set which will adjust the length\n        set(i, value);\n    }\n#ifdef DEBUG_BUILD\n    DMESG(\"After Segment::insert index:%d\", i);\n    this->print();\n#endif\n}\n\nvoid Segment::print() {\n    DMESG(\"Segment: %p, length: %d, size: %d\", data, (unsigned)length, (unsigned)size);\n    for (unsigned i = 0; i < size; i++) {\n        DMESG(\"-> %d\", (unsigned)(uintptr_t)data[i]);\n    }\n}\n\nvoid Segment::destroy() {\n#ifdef DEBUG_BUILD\n    DMESG(\"In Segment::destroy\");\n    this->print();\n#endif\n    length = size = 0;\n    data = nullptr;\n}\n\nPXT_VTABLE_CTOR(RefCollection) {}\n\nvoid RefCollection::destroy(RefCollection *t) {\n    t->head.destroy();\n}\n\nvoid RefCollection::print(RefCollection *t) {\n    DMESG(\"RefCollection %p size=%d\", t, t->head.getLength());\n    t->head.print();\n}\n\nPXT_VTABLE(RefAction, ValType::Function)\nRefAction::RefAction() : PXT_VTABLE_INIT(RefAction) {}\n\n// fields[] contain captured locals\nvoid RefAction::destroy(RefAction *t) {}\n\nvoid RefAction::print(RefAction *t) {\n#ifdef PXT_VM\n    DMESG(\"RefAction %p pc=%X size=%d\", t,\n          (const uint8_t *)t->func - (const uint8_t *)vmImg->dataStart, t->len);\n#else\n    DMESG(\"RefAction %p pc=%X size=%d\", t, (const uint8_t *)t->func - (const uint8_t *)bytecode,\n          t->len);\n#endif\n}\n\nPXT_VTABLE_CTOR(RefRefLocal) {\n    v = 0;\n}\n\nvoid RefRefLocal::print(RefRefLocal *t) {\n    DMESG(\"RefRefLocal %p v=%p\", t, (void *)t->v);\n}\n\nvoid RefRefLocal::destroy(RefRefLocal *t) {\n    decr(t->v);\n}\n\nPXT_VTABLE_CTOR(RefMap) {}\n\nvoid RefMap::destroy(RefMap *t) {\n    t->keys.destroy();\n    t->values.destroy();\n}\n\nint RefMap::findIdx(String key) {\n    auto len = keys.getLength();\n    auto data = (String *)keys.getData();\n\n    // fast path\n    for (unsigned i = 0; i < len; ++i) {\n        if (data[i] == key)\n            return i;\n    }\n\n    // slow path\n    auto keylen = key->getUTF8Size();\n    auto keydata = key->getUTF8Data();\n    for (unsigned i = 0; i < len; ++i) {\n        auto s = data[i];\n        if (s->getUTF8Size() == keylen && memcmp(keydata, s->getUTF8Data(), keylen) == 0)\n            return i;\n    }\n\n    return -1;\n}\n\nvoid RefMap::print(RefMap *t) {\n    DMESG(\"RefMap %p size=%d\", t, t->keys.getLength());\n}\n\nvoid debugMemLeaks() {}\n\nvoid error(PXT_PANIC code, int subcode) {\n    DMESG(\"Error: %d [%d]\", code, subcode);\n    target_panic(code);\n}\n\n#ifndef PXT_VM\nuint16_t *bytecode;\n#endif\nTValue *globals;\n\nvoid checkStr(bool cond, const char *msg) {\n    if (!cond) {\n        while (true) {\n            // uBit.display.scroll(msg, 100);\n            // uBit.sleep(100);\n        }\n    }\n}\n\n#ifdef PXT_VM\nint templateHash() {\n    return (int)vmImg->infoHeader->hexHash;\n}\n\nint programHash() {\n    return (int)vmImg->infoHeader->programHash;\n}\n\nint getNumGlobals() {\n    return (int)vmImg->infoHeader->allocGlobals;\n}\n\nString programName() {\n    return mkString((char *)vmImg->infoHeader->name);\n}\n#else\nint templateHash() {\n    return ((int *)bytecode)[4];\n}\n\nint programHash() {\n    return ((int *)bytecode)[6];\n}\n\nint getNumGlobals() {\n    return bytecode[16];\n}\n\nString programName() {\n    return ((String *)bytecode)[15];\n}\n#endif\n\n#ifndef PXT_VM\nvoid variantNotSupported(const char *v) {\n    DMESG(\"variant not supported: %s\", v);\n    target_panic(PANIC_VARIANT_NOT_SUPPORTED);\n}\n\nvoid exec_binary(unsigned *pc) {\n    // XXX re-enable once the calibration code is fixed and [editor/embedded.ts]\n    // properly prepends a call to [internal_main].\n    // ::touch_develop::internal_main();\n\n    // unique group for radio based on source hash\n    // ::touch_develop::micro_bit::radioDefaultGroup = programHash();\n\n    unsigned ver = *pc++;\n    checkStr(ver == 0x4210, \":( Bad runtime version\");\n\n    bytecode = *((uint16_t **)pc++); // the actual bytecode is here\n\n    if (((uint32_t *)bytecode)[0] == 0x923B8E71) {\n        variantNotSupported((const char *)bytecode + 16);\n        return;\n    }\n\n    globals = (TValue *)app_alloc(sizeof(TValue) * getNumGlobals());\n    memset(globals, 0, sizeof(TValue) * getNumGlobals());\n\n    // can be any valid address, best in RAM for speed\n    globals[0] = (TValue)&globals;\n\n    // just compare the first word\n    // TODO\n    checkStr(((uint32_t *)bytecode)[0] == 0x923B8E70 && (unsigned)templateHash() == *pc,\n             \":( Failed partial flash\");\n\n    uintptr_t startptr = (uintptr_t)bytecode;\n\n    startptr += 64; // header\n\n    initPerfCounters();\n\n    initRuntime();\n\n    runAction0((Action)startptr);\n\n    pxt::releaseFiber();\n}\n\nvoid start() {\n    exec_binary((unsigned *)functionsAndBytecode);\n}\n#endif\n\n} // namespace pxt\n\nnamespace Array_ {\n//%\nbool isArray(TValue arr) {\n    auto vt = getAnyVTable(arr);\n    return vt && vt->classNo == BuiltInType::RefCollection;\n}\n} // namespace Array_\n\nnamespace pxtrt {\n//% expose\nRefCollection *keysOf(TValue v) {\n    auto r = NEW_GC(RefCollection);\n    MEMDBG(\"mkColl[keys]: => %p\", r);\n    if (getAnyVTable(v) != &RefMap_vtable)\n        return r;\n    auto rm = (RefMap *)v;\n    auto len = rm->keys.getLength();\n    if (!len)\n        return r;\n    registerGCObj(r);\n    r->setLength(len);\n    auto dst = r->getData();\n    memcpy(dst, rm->keys.getData(), len * sizeof(TValue));\n    unregisterGCObj(r);\n    return r;\n}\n//% expose\nTValue mapDeleteByString(RefMap *map, String key) {\n    if (getAnyVTable((TValue)map) != &RefMap_vtable)\n        target_panic(PANIC_DELETE_ON_CLASS);\n    int i = map->findIdx(key);\n    if (i >= 0) {\n        map->keys.remove(i);\n        map->values.remove(i);\n    }\n    return TAG_TRUE;\n}\n\n} // namespace pxtrt\n",
            "pxt.json": "{\n    \"name\": \"base\",\n    \"description\": \"The base library\",\n    \"dependencies\": {},\n    \"files\": [\n        \"README.md\",\n        \"pxt-core.d.ts\",\n        \"pxt.cpp\",\n        \"gc.cpp\",\n        \"configkeys.h\",\n        \"pxtbase.h\",\n        \"core.cpp\",\n        \"advmath.cpp\",\n        \"trig.cpp\",\n        \"pxt-helpers.ts\",\n        \"fixed.ts\",\n        \"buffer.cpp\",\n        \"buffer.ts\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"loops.cpp\",\n        \"math.ts\",\n        \"ns.ts\",\n        \"control.cpp\",\n        \"control.ts\",\n        \"interval.ts\",\n        \"gcstats.ts\",\n        \"poll.ts\",\n        \"console.ts\",\n        \"json.ts\",\n        \"templates.ts\",\n        \"eventcontext.ts\",\n        \"pause.ts\",\n        \"forever.ts\",\n        \"utfdecoder.ts\",\n        \"scheduling.ts\",\n        \"controlmessage.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"partial\": true,\n    \"yotta\": {\n        \"optionalConfig\": {\n            \"PXT_GC_CHECKS\": 0\n        },\n        \"userConfigs\": [\n            {\n                \"description\": \"(Diagnostics) Garbage Collection checks.\",\n                \"config\": {\n                    \"PXT_GC_CHECKS\": 1\n                }\n            }\n        ]\n    }\n}\n",
            "pxtbase.h": "#ifndef __PXTBASE_H\n#define __PXTBASE_H\n\n#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n#pragma GCC diagnostic ignored \"-Wformat\"\n#pragma GCC diagnostic ignored \"-Warray-bounds\"\n\n// needed for gcc6; not sure why\n#undef min\n#undef max\n\n#define NOLOG(...)                                                                                 \\\n    do {                                                                                           \\\n    } while (0)\n\n#define MEMDBG NOLOG\n//#define MEMDBG DMESG\n#define MEMDBG2 NOLOG\n\n#include \"pxtconfig.h\"\n#include \"configkeys.h\"\n\n#ifndef PXT_UTF8\n#define PXT_UTF8 0\n#endif\n\n#if defined(PXT_VM)\n#include <stdint.h>\n#if UINTPTR_MAX == 0xffffffff\n#define PXT32 1\n#elif UINTPTR_MAX == 0xffffffffffffffff\n#define PXT64 1\n#else\n#error \"UINTPTR_MAX has invalid value\"\n#endif\n#endif\n\n#define intcheck(...) check(__VA_ARGS__)\n//#define intcheck(...) do {} while (0)\n\n#ifdef PXT_USE_FLOAT\n#define NUMBER float\n#else\n#define NUMBER double\n#endif\n\n#include <string.h>\n#include <stdint.h>\n#include <math.h>\n\n#ifdef POKY\nvoid *operator new(size_t size, void *ptr);\nvoid *operator new(size_t size);\n#else\n#include <new>\n#endif\n\n#include \"platform.h\"\n#include \"pxtcore.h\"\n\n#ifndef PXT_REGISTER_RESET\n#define PXT_REGISTER_RESET(fn) ((void)0)\n#endif\n\n#define PXT_REFCNT_FLASH 0xfffe\n\n#define CONCAT_1(a, b) a##b\n#define CONCAT_0(a, b) CONCAT_1(a, b)\n// already provided in some platforms, like mbedos\n#ifndef STATIC_ASSERT\n#define STATIC_ASSERT(e) enum { CONCAT_0(_static_assert_, __LINE__) = 1 / ((e) ? 1 : 0) };\n#endif\n\n#ifndef ramint_t\n// this type limits size of arrays\n#if defined(__linux__) || defined(PXT_VM)\n// TODO fix the inline array accesses to take note of this!\n#define ramint_t uint32_t\n#else\n#define ramint_t uint16_t\n#endif\n#endif\n\n#ifndef PXT_IN_ISR\n#define PXT_IN_ISR() (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk)\n#endif\n\n#ifdef POKY\ninline void *operator new(size_t, void *p) {\n    return p;\n}\ninline void *operator new[](size_t, void *p) {\n    return p;\n}\n#endif\n\nnamespace pxt {\n\ntemplate <typename T> inline const T &max(const T &a, const T &b) {\n    if (a < b)\n        return b;\n    return a;\n}\n\ntemplate <typename T> inline const T &min(const T &a, const T &b) {\n    if (a < b)\n        return a;\n    return b;\n}\n\ntemplate <typename T> inline void swap(T &a, T &b) {\n    T tmp = a;\n    a = b;\n    b = tmp;\n}\n\n//\n// Tagged values (assume 4 bytes for now, Cortex-M0)\n//\nstruct TValueStruct {};\ntypedef TValueStruct *TValue;\n\ntypedef TValue TNumber;\ntypedef TValue Action;\ntypedef TValue ImageLiteral;\n\n// To be implemented by the target\nextern \"C\" void target_panic(int error_code);\nextern \"C\" void target_reset();\nvoid sleep_ms(unsigned ms);\nvoid sleep_us(uint64_t us);\nvoid releaseFiber();\nuint64_t current_time_us();\nint current_time_ms();\nvoid initRuntime();\nvoid initSystemTimer();\nvoid sendSerial(const char *data, int len);\nvoid setSendToUART(void (*f)(const char *, int));\nuint64_t getLongSerialNumber();\nvoid registerWithDal(int id, int event, Action a, int flags = 16); // EVENT_LISTENER_DEFAULT_FLAGS\nvoid runInParallel(Action a);\nvoid runForever(Action a);\nvoid waitForEvent(int id, int event);\n//%\nunsigned afterProgramPage();\n//%\nvoid dumpDmesg();\nuint32_t hash_fnv1(const void *data, unsigned len);\n\n// also defined DMESG macro\n// end\n\n#define TAGGED_SPECIAL(n) (TValue)(void *)((n << 2) | 2)\n#define TAG_FALSE TAGGED_SPECIAL(2) // 10\n#define TAG_TRUE TAGGED_SPECIAL(16) // 66\n#define TAG_UNDEFINED (TValue)0\n#define TAG_NULL TAGGED_SPECIAL(1) // 6\n#define TAG_NAN TAGGED_SPECIAL(3)  // 14\n#define TAG_NUMBER(n) (TNumber)(void *)(((uintptr_t)(uint32_t)(n) << 1) | 1)\n#define TAG_NON_VALUE TAGGED_SPECIAL(4) // 18; doesn't represent any JS value\n\n#ifdef PXT_VM\ninline bool isEncodedDouble(uint64_t v) {\n    return (v >> 48) != 0;\n}\n#endif\n\ninline bool isDouble(TValue v) {\n#ifdef PXT64\n    return ((uintptr_t)v >> 48) != 0;\n#else\n    (void)v;\n    return false;\n#endif\n}\n\ninline bool isPointer(TValue v) {\n    return !isDouble(v) && v != 0 && ((intptr_t)v & 3) == 0;\n}\n\ninline bool isTagged(TValue v) {\n    return (!isDouble(v) && ((intptr_t)v & 3)) || !v;\n}\n\ninline bool isInt(TValue v) {\n    return !isDouble(v) && ((intptr_t)v & 1);\n}\n\ninline bool isSpecial(TValue v) {\n    return !isDouble(v) && ((intptr_t)v & 2);\n}\n\ninline bool bothNumbers(TValue a, TValue b) {\n    return !isDouble(a) && !isDouble(b) && ((intptr_t)a & (intptr_t)b & 1);\n}\n\ninline int numValue(TValue n) {\n    return (int)((intptr_t)n >> 1);\n}\n\ninline bool canBeTagged(int v) {\n    (void)v;\n#ifdef PXT_BOX_DEBUG\n    return false;\n#elif defined(PXT64)\n    return true;\n#else\n    return (v << 1) >> 1 == v;\n#endif\n}\n\n// see https://anniecherkaev.com/the-secret-life-of-nan\n\n#define NanBoxingOffset 0x1000000000000LL\n\ntemplate <typename TO, typename FROM> TO bitwise_cast(FROM in) {\n    STATIC_ASSERT(sizeof(TO) == sizeof(FROM));\n    union {\n        FROM from;\n        TO to;\n    } u;\n    u.from = in;\n    return u.to;\n}\n\ninline double decodeDouble(uint64_t v) {\n    return bitwise_cast<double>(v - NanBoxingOffset);\n}\n\n#ifdef PXT64\nSTATIC_ASSERT(sizeof(void *) == 8);\ninline double doubleVal(TValue v) {\n    return bitwise_cast<double>((uint64_t)v - NanBoxingOffset);\n}\n\ninline TValue tvalueFromDouble(double d) {\n    return (TValue)(bitwise_cast<uint64_t>(d) + NanBoxingOffset);\n}\n#else\nSTATIC_ASSERT(sizeof(void *) == 4);\n#endif\n\n// keep in sym with sim/control.ts\ntypedef enum {\n    PANIC_CODAL_OOM = 20,\n    PANIC_GC_OOM = 21,\n    PANIC_GC_TOO_BIG_ALLOCATION = 22,\n    PANIC_CODAL_HEAP_ERROR = 30,\n    PANIC_CODAL_NULL_DEREFERENCE = 40,\n    PANIC_CODAL_USB_ERROR = 50,\n    PANIC_CODAL_HARDWARE_CONFIGURATION_ERROR = 90,\n\n    PANIC_INVALID_BINARY_HEADER = 901,\n    PANIC_OUT_OF_BOUNDS = 902,\n    PANIC_REF_DELETED = 903,\n    PANIC_SIZE = 904,\n    PANIC_INVALID_VTABLE = 905,\n    PANIC_INTERNAL_ERROR = 906,\n    PANIC_NO_SUCH_CONFIG = 907,\n    PANIC_NO_SUCH_PIN = 908,\n    PANIC_INVALID_ARGUMENT = 909,\n    PANIC_MEMORY_LIMIT_EXCEEDED = 910,\n    PANIC_SCREEN_ERROR = 911,\n    PANIC_MISSING_PROPERTY = 912,\n    PANIC_INVALID_IMAGE = 913,\n    PANIC_CALLED_FROM_ISR = 914,\n    PANIC_HEAP_DUMPED = 915,\n    PANIC_STACK_OVERFLOW = 916,\n    PANIC_BLOCKING_TO_STRING = 917,\n    PANIC_VM_ERROR = 918,\n    PANIC_SETTINGS_CLEARED = 920,\n    PANIC_SETTINGS_OVERLOAD = 921,\n    PANIC_SETTINGS_SECRET_MISSING = 922,\n    PANIC_DELETE_ON_CLASS = 923,\n    PANIC_OUT_OF_TIMERS = 924,\n    PANIC_JACDAC = 925,\n    PANIC_MICROPHONE_MISSING = 926,\n    PANIC_VARIANT_NOT_SUPPORTED = 927,\n\n    PANIC_CAST_FIRST = 980,\n    PANIC_CAST_FROM_UNDEFINED = 980,\n    PANIC_CAST_FROM_BOOLEAN = 981,\n    PANIC_CAST_FROM_NUMBER = 982,\n    PANIC_CAST_FROM_STRING = 983,\n    PANIC_CAST_FROM_OBJECT = 984,\n    PANIC_CAST_FROM_FUNCTION = 985,\n    PANIC_CAST_FROM_NULL = 989,\n\n    PANIC_UNHANDLED_EXCEPTION = 999,\n\n} PXT_PANIC;\n\nextern const uintptr_t functionsAndBytecode[];\nextern TValue *globals;\nextern uint16_t *bytecode;\nclass RefRecord;\n\n// Utility functions\n\ntypedef TValue (*RunActionType)(Action a, TValue arg0, TValue arg1, TValue arg2);\n\n#define asmRunAction3 ((RunActionType)(((uintptr_t *)bytecode)[12]))\n\nstatic inline TValue runAction3(Action a, TValue arg0, TValue arg1, TValue arg2) {\n    return asmRunAction3(a, arg0, arg1, 0);\n}\nstatic inline TValue runAction2(Action a, TValue arg0, TValue arg1) {\n    return asmRunAction3(a, arg0, arg1, 0);\n}\nstatic inline TValue runAction1(Action a, TValue arg0) {\n    return asmRunAction3(a, arg0, 0, 0);\n}\nstatic inline TValue runAction0(Action a) {\n    return asmRunAction3(a, 0, 0, 0);\n}\n\nclass RefAction;\nclass BoxedString;\nstruct VTable;\n\n//%\nAction mkAction(int totallen, RefAction *act);\n//% expose\nint templateHash();\n//% expose\nint programHash();\n//% expose\nBoxedString *programName();\n//% expose\nunsigned programSize();\n//%\nint getNumGlobals();\n//%\nRefRecord *mkClassInstance(VTable *vt);\n//%\nvoid debugMemLeaks();\n//%\nvoid anyPrint(TValue v);\n\n//%\nint getConfig(int key, int defl = -1);\n\n//%\nint toInt(TNumber v);\n//%\nunsigned toUInt(TNumber v);\n//%\nNUMBER toDouble(TNumber v);\n//%\nfloat toFloat(TNumber v);\n//%\nTNumber fromDouble(NUMBER r);\n//%\nTNumber fromFloat(float r);\n\n//%\nTNumber fromInt(int v);\n//%\nTNumber fromUInt(unsigned v);\n//%\nTValue fromBool(bool v);\n//%\nbool eq_bool(TValue a, TValue b);\n//%\nbool eqq_bool(TValue a, TValue b);\n\n//%\nvoid failedCast(TValue v, void *addr = NULL);\n//%\nvoid missingProperty(TValue v);\n\nvoid error(PXT_PANIC code, int subcode = 0);\nvoid exec_binary(unsigned *pc);\nvoid start();\n\nstruct HandlerBinding {\n    HandlerBinding *next;\n    int source;\n    int value;\n    Action action;\n};\nHandlerBinding *findBinding(int source, int value);\nHandlerBinding *nextBinding(HandlerBinding *curr, int source, int value);\nvoid setBinding(int source, int value, Action act);\n\n// Legacy stuff; should no longer be used\n//%\nTValue incr(TValue e);\n//%\nvoid decr(TValue e);\n\ninline TValue incr(TValue e) {\n    return e;\n}\ninline void decr(TValue e) {}\n\nclass RefObject;\n\nstatic inline RefObject *incrRC(RefObject *r) {\n    return r;\n}\nstatic inline void decrRC(RefObject *) {\n}\n\ninline void *ptrOfLiteral(int offset) {\n    return &bytecode[offset];\n}\n\n// Checks if object is ref-counted, and has a custom PXT vtable in front\n// TODO\ninline bool isRefCounted(TValue e) {\n    return isPointer(e);\n}\n\ninline void check(int cond, PXT_PANIC code, int subcode = 0) {\n    if (!cond)\n        error(code, subcode);\n}\n\ninline void oops(int subcode = 0) {\n    target_panic(800 + subcode);\n}\n\nclass RefObject;\n\ntypedef void (*RefObjectMethod)(RefObject *self);\ntypedef unsigned (*RefObjectSizeMethod)(RefObject *self);\ntypedef void *PVoid;\ntypedef void **PPVoid;\n\ntypedef void *Object_;\n\n#define VTABLE_MAGIC 0xF9\n\nenum class ValType : uint8_t {\n    Undefined,\n    Boolean,\n    Number,\n    String,\n    Object,\n    Function,\n};\n\n// keep in sync with pxt-core (search for the type name)\nenum class BuiltInType : uint16_t {\n    BoxedString = 1,\n    BoxedNumber = 2,\n    BoxedBuffer = 3,\n    RefAction = 4,\n    RefImage = 5,\n    RefCollection = 6,\n    RefRefLocal = 7,\n    RefMap = 8,\n    RefMImage = 9,\n    MMap = 10, // linux, mostly ev3\n    User0 = 16,\n};\n\nstruct VTable {\n    uint16_t numbytes;\n    ValType objectType;\n    uint8_t magic;\n#ifdef PXT_VM\n    uint16_t ifaceHashEntries;\n    BuiltInType lastClassNo;\n#else\n    PVoid *ifaceTable;\n#endif\n    BuiltInType classNo;\n    uint16_t reserved;\n    uint32_t ifaceHashMult;\n\n    // we only use the first few methods here; pxt will generate more\n    PVoid methods[8];\n};\n\n//%\nextern const VTable string_inline_ascii_vt;\n#if PXT_UTF8\n//%\nextern const VTable string_inline_utf8_vt;\n//%\nextern const VTable string_cons_vt;\n//%\nextern const VTable string_skiplist16_vt;\n#endif\n//%\nextern const VTable buffer_vt;\n//%\nextern const VTable number_vt;\n//%\nextern const VTable RefAction_vtable;\n\n#define PXT_VTABLE_TO_INT(vt) ((uintptr_t)(vt))\n\n// allocate 1M of heap on VM\n#define PXT_VM_HEAP_ALLOC_BITS 20\n\n#ifdef PXT_VM\nextern uint8_t *gcBase;\n#endif\n\ninline bool isReadOnly(TValue v) {\n#ifdef PXT_VM\n    return !isPointer(v) || (((uintptr_t)v - (uintptr_t)gcBase) >> PXT_VM_HEAP_ALLOC_BITS) != 0;\n#else\n    return isTagged(v) || !((uintptr_t)v >> 28);\n#endif\n}\n\n// A base abstract class for ref-counted objects.\nclass RefObject {\n  public:\n    uintptr_t vtable;\n\n    RefObject(const VTable *vt) {\n#if defined(PXT32) && defined(PXT_VM)\n        if ((uint32_t)vt & 0xf0000000)\n            target_panic(PANIC_INVALID_VTABLE);\n#endif\n        vtable = PXT_VTABLE_TO_INT(vt);\n    }\n\n    void destroyVT();\n    void printVT();\n\n    inline void ref() {}\n    inline void unref() {}\n    inline bool isReadOnly() { return pxt::isReadOnly((TValue)this); }\n};\n\nclass Segment {\n  private:\n    TValue *data;\n    ramint_t length;\n    ramint_t size;\n\n    // this just gives max value of ramint_t\n    void growByMin(ramint_t minSize);\n    void ensure(ramint_t newSize);\n\n  public:\n    static constexpr ramint_t MaxSize = (((1U << (8 * sizeof(ramint_t) - 1)) - 1) << 1) + 1;\n    static constexpr TValue DefaultValue = TAG_UNDEFINED; // == NULL\n\n    Segment() : data(nullptr), length(0), size(0) {}\n\n    TValue get(unsigned i) { return i < length ? data[i] : NULL; }\n    void set(unsigned i, TValue value);\n\n    unsigned getLength() { return length; };\n    void setLength(unsigned newLength);\n\n    void push(TValue value) { set(length, value); }\n    TValue pop();\n\n    TValue remove(unsigned i);\n    void insert(unsigned i, TValue value);\n\n    void destroy();\n\n    void print();\n\n    TValue *getData() { return data; }\n};\n\n// Low-Level segment using system malloc\nclass LLSegment {\n  private:\n    TValue *data;\n    ramint_t length;\n    ramint_t size;\n\n  public:\n    LLSegment() : data(nullptr), length(0), size(0) {}\n\n    void set(unsigned idx, TValue v);\n    void push(TValue value) { set(length, value); }\n    TValue pop();\n    void destroy();\n    void setLength(unsigned newLen);\n\n    TValue get(unsigned i) { return i < length ? data[i] : NULL; }\n    unsigned getLength() { return length; };\n    TValue *getData() { return data; }\n};\n\n// A ref-counted collection of either primitive or ref-counted objects (String, Image,\n// user-defined record, another collection)\nclass RefCollection : public RefObject {\n  public:\n    Segment head;\n\n    RefCollection();\n\n    static void destroy(RefCollection *coll);\n    static void scan(RefCollection *coll);\n    static unsigned gcsize(RefCollection *coll);\n    static void print(RefCollection *coll);\n\n    unsigned length() { return head.getLength(); }\n    void setLength(unsigned newLength) { head.setLength(newLength); }\n    TValue getAt(int i) { return head.get(i); }\n    TValue *getData() { return head.getData(); }\n};\n\nclass RefMap : public RefObject {\n  public:\n    Segment keys;\n    Segment values;\n\n    RefMap();\n    static void destroy(RefMap *map);\n    static void scan(RefMap *map);\n    static unsigned gcsize(RefMap *coll);\n    static void print(RefMap *map);\n    int findIdx(BoxedString *key);\n};\n\n// A ref-counted, user-defined JS object.\nclass RefRecord : public RefObject {\n  public:\n    // The object is allocated, so that there is space at the end for the fields.\n    TValue fields[];\n\n    RefRecord(VTable *v) : RefObject(v) {}\n\n    TValue ld(int idx);\n    TValue ldref(int idx);\n    void st(int idx, TValue v);\n    void stref(int idx, TValue v);\n};\n\nstatic inline VTable *getVTable(RefObject *r) {\n    return (VTable *)(r->vtable & ~1);\n}\n\nstatic inline VTable *getAnyVTable(TValue v) {\n    if (!isRefCounted(v))\n        return NULL;\n    auto vt = getVTable((RefObject *)v);\n    if (vt->magic == VTABLE_MAGIC)\n        return vt;\n    return NULL;\n}\n\n// these are needed when constructing vtables for user-defined classes\n//%\nvoid RefRecord_destroy(RefRecord *r);\n//%\nvoid RefRecord_print(RefRecord *r);\n//%\nvoid RefRecord_scan(RefRecord *r);\n//%\nunsigned RefRecord_gcsize(RefRecord *r);\n\ntypedef TValue (*ActionCB)(TValue *captured, TValue arg0, TValue arg1, TValue arg2);\n\n// Ref-counted function pointer.\nclass RefAction : public RefObject {\n  public:\n#if defined(PXT_VM) && defined(PXT32)\n    uint32_t _padding; // match binary format in .pxt64 files\n#endif\n    uint16_t len;\n    uint16_t numArgs;\n#ifdef PXT_VM\n    uint16_t initialLen;\n    uint16_t flags;\n#endif\n    ActionCB func; // The function pointer\n    // fields[] contain captured locals\n    TValue fields[];\n\n    static void destroy(RefAction *act);\n    static void scan(RefAction *act);\n    static unsigned gcsize(RefAction *coll);\n    static void print(RefAction *act);\n\n    RefAction();\n\n    inline void stCore(int idx, TValue v) {\n        // DMESG(\"ST [%d] = %d \", idx, v); this->print();\n        intcheck(0 <= idx && idx < len, PANIC_OUT_OF_BOUNDS, 10);\n        intcheck(fields[idx] == 0, PANIC_OUT_OF_BOUNDS, 11); // only one assignment permitted\n        fields[idx] = v;\n    }\n};\n\n// These two are used to represent locals written from inside inline functions\nclass RefRefLocal : public RefObject {\n  public:\n    TValue v;\n    static void destroy(RefRefLocal *l);\n    static void scan(RefRefLocal *l);\n    static unsigned gcsize(RefRefLocal *l);\n    static void print(RefRefLocal *l);\n    RefRefLocal();\n};\n\ntypedef int color;\n\n// note: this is hardcoded in PXT (hexfile.ts)\n\nclass BoxedNumber : public RefObject {\n  public:\n    NUMBER num;\n    BoxedNumber() : RefObject(&number_vt) {}\n} __attribute__((packed));\n\nclass BoxedString : public RefObject {\n  public:\n    union {\n        struct {\n            uint16_t length;\n            char data[0];\n        } ascii;\n#if PXT_UTF8\n        struct {\n            uint16_t length;\n            char data[0];\n        } utf8;\n        struct {\n            BoxedString *left;\n            BoxedString *right;\n        } cons;\n        struct {\n            uint16_t size;\n            uint16_t length;\n            uint16_t *list;\n        } skip;\n#endif\n    };\n\n#if PXT_UTF8\n    uintptr_t runMethod(int idx) {\n        return ((uintptr_t(*)(BoxedString *))((VTable *)this->vtable)->methods[idx])(this);\n    }\n    const char *getUTF8Data() { return (const char *)runMethod(4); }\n    uint32_t getUTF8Size() { return (uint32_t)runMethod(5); }\n    // in characters\n    uint32_t getLength() { return (uint32_t)runMethod(6); }\n    const char *getUTF8DataAt(uint32_t pos) {\n        auto meth =\n            ((const char *(*)(BoxedString *, uint32_t))((VTable *)this->vtable)->methods[7]);\n        return meth(this, pos);\n    }\n#else\n    const char *getUTF8Data() { return ascii.data; }\n    uint32_t getUTF8Size() { return ascii.length; }\n    uint32_t getLength() { return ascii.length; }\n    const char *getUTF8DataAt(uint32_t pos) { return pos < ascii.length ? ascii.data + pos : NULL; }\n#endif\n\n    TNumber charCodeAt(int pos);\n\n    BoxedString(const VTable *vt) : RefObject(vt) {}\n};\n\n// cross version compatible way of accessing string data\n#ifndef PXT_STRING_DATA\n#define PXT_STRING_DATA(str) str->getUTF8Data()\n#endif\n\n// cross version compatible way of accessing string length\n#ifndef PXT_STRING_DATA_LENGTH\n#define PXT_STRING_DATA_LENGTH(str) str->getUTF8Size()\n#endif\n\nclass BoxedBuffer : public RefObject {\n  public:\n    // data needs to be word-aligned, so we use 32 bits for length\n    int length;\n#ifdef PXT_VM\n    // VM can be 64 bit and it compiles as such\n    int32_t _padding;\n#endif\n    uint8_t data[0];\n    BoxedBuffer() : RefObject(&buffer_vt) {}\n};\n\n// cross version compatible way of access data field\n#ifndef PXT_BUFFER_DATA\n#define PXT_BUFFER_DATA(buffer) buffer->data\n#endif\n\n// cross version compatible way of access data length\n#ifndef PXT_BUFFER_LENGTH\n#define PXT_BUFFER_LENGTH(buffer) buffer->length\n#endif\n\n#ifndef PXT_CREATE_BUFFER\n#define PXT_CREATE_BUFFER(data, len) pxt::mkBuffer(data, len)\n#endif\n\n// Legacy format:\n// the first byte of data indicates the format - currently 0xE1 or 0xE4 to 1 or 4 bit bitmaps\n// second byte indicates width in pixels\n// third byte indicates the height (which should also match the size of the buffer)\n// just like ordinary buffers, these can be layed out in flash\n\n// Current format:\n// 87 BB WW WW HH HH 00 00 DATA\n// that is: 0x87, 0x01 or 0x04 - bpp, width in little endian, height, 0x00, 0x00 followed by data\n// for 4 bpp images, rows are word-aligned (as in legacy)\n\n#define IMAGE_HEADER_MAGIC 0x87\n\nstruct ImageHeader {\n    uint8_t magic;\n    uint8_t bpp;\n    uint16_t width;\n    uint16_t height;\n    uint16_t padding;\n    uint8_t pixels[0];\n};\n\nclass RefImage : public RefObject {\n  public:\n    BoxedBuffer *buffer;\n\n    RefImage(BoxedBuffer *buf);\n    RefImage(uint32_t sz);\n\n    void setBuffer(BoxedBuffer *b);\n\n    uint8_t *data() { return buffer->data; }\n    int length() { return (int)buffer->length; }\n\n    ImageHeader *header() { return (ImageHeader *)buffer->data; }\n    int pixLength() { return length() - sizeof(ImageHeader); }\n\n    int width() { return header()->width; }\n    int height() { return header()->height; }\n    int wordHeight();\n    int bpp() { return header()->bpp; }\n\n    bool hasPadding() { return (height() & 0x7) != 0; }\n\n    uint8_t *pix() { return header()->pixels; }\n\n    int byteHeight() {\n        if (bpp() == 1)\n            return (height() + 7) >> 3;\n        else if (bpp() == 4)\n            return ((height() * 4 + 31) >> 5) << 2;\n        else {\n            oops(21);\n            return -1;\n        }\n    }\n\n    uint8_t *pix(int x, int y) {\n        uint8_t *d = &pix()[byteHeight() * x];\n        if (y) {\n            if (bpp() == 1)\n                d += y >> 3;\n            else if (bpp() == 4)\n                d += y >> 1;\n        }\n        return d;\n    }\n\n    uint8_t fillMask(color c);\n    bool inRange(int x, int y);\n    void clamp(int *x, int *y);\n    void makeWritable();\n\n    static void destroy(RefImage *t);\n    static void scan(RefImage *t);\n    static unsigned gcsize(RefImage *t);\n    static void print(RefImage *t);\n};\n\nRefImage *mkImage(int w, int h, int bpp);\n\ntypedef BoxedBuffer *Buffer;\ntypedef BoxedString *String;\ntypedef RefImage *Image_;\n\nuint32_t toRealUTF8(String str, uint8_t *dst);\n\n// keep in sync with github/pxt/pxtsim/libgeneric.ts\nenum class NumberFormat {\n    Int8LE = 1,\n    UInt8LE,\n    Int16LE,\n    UInt16LE,\n    Int32LE,\n    Int8BE,\n    UInt8BE,\n    Int16BE,\n    UInt16BE,\n    Int32BE,\n\n    UInt32LE,\n    UInt32BE,\n    Float32LE,\n    Float64LE,\n    Float32BE,\n    Float64BE,\n};\n\n// this will, unlike mkStringCore, UTF8-canonicalize the data\nString mkString(const char *data, int len = -1);\n// data can be NULL in both cases\nBuffer mkBuffer(const void *data, int len);\nString mkStringCore(const char *data, int len = -1);\n\nTNumber getNumberCore(uint8_t *buf, int size, NumberFormat format);\nvoid setNumberCore(uint8_t *buf, int size, NumberFormat format, TNumber value);\n\nvoid seedRandom(unsigned seed);\nvoid seedAddRandom(unsigned seed);\n// max is inclusive\nunsigned getRandom(unsigned max);\n\nValType valType(TValue v);\n\n// this is equivalent to JS `throw v`; it will leave\n// the current function(s), all the way until the nearest try block and\n// ignore all destructors (think longjmp())\nvoid throwValue(TValue v);\n\nvoid registerGC(TValue *root, int numwords = 1);\nvoid unregisterGC(TValue *root, int numwords = 1);\nvoid registerGCPtr(TValue ptr);\nvoid unregisterGCPtr(TValue ptr);\nstatic inline void registerGCObj(RefObject *ptr) {\n    registerGCPtr((TValue)ptr);\n}\nstatic inline void unregisterGCObj(RefObject *ptr) {\n    unregisterGCPtr((TValue)ptr);\n}\nvoid gc(int flags);\n\nstruct StackSegment {\n    void *top;\n    void *bottom;\n    StackSegment *next;\n};\n\n#define NUM_TRY_FRAME_REGS 3\nstruct TryFrame {\n    TryFrame *parent;\n    uintptr_t registers[NUM_TRY_FRAME_REGS];\n};\n\nstruct ThreadContext {\n    TValue *globals;\n    StackSegment stack;\n    TryFrame *tryFrame;\n    TValue thrownValue;\n#ifdef PXT_GC_THREAD_LIST\n    ThreadContext *next;\n    ThreadContext *prev;\n#endif\n};\n\n#ifdef PXT_GC_THREAD_LIST\nextern ThreadContext *threadContexts;\nvoid *threadAddressFor(ThreadContext *, void *sp);\n#endif\n\nvoid releaseThreadContext(ThreadContext *ctx);\nThreadContext *getThreadContext();\nvoid setThreadContext(ThreadContext *ctx);\n\n#ifndef PXT_GC_THREAD_LIST\nvoid gcProcessStacks(int flags);\n#endif\n\nvoid gcProcess(TValue v);\nvoid gcFreeze();\n#ifdef PXT_VM\nvoid gcStartup();\nvoid gcPreStartup();\nvoid *gcPrealloc(int numbytes);\nbool inGCPrealloc();\n#else\nstatic inline bool inGCPrealloc() {\n    return false;\n}\n#endif\n\nvoid coreReset();\nvoid gcReset();\nvoid systemReset();\n\nvoid *gcAllocate(int numbytes);\nvoid *gcAllocateArray(int numbytes);\nextern \"C\" void *app_alloc(int numbytes);\nextern \"C\" void *app_free(void *ptr);\nextern \"C\" void *app_alloc_at(void *at, int numbytes);\nvoid gcPreAllocateBlock(uint32_t sz);\n\nint redirectSamples(int16_t *dst, int numsamples, int samplerate);\n\n#ifdef PXT64\n#define TOWORDS(bytes) (((bytes) + 7) >> 3)\n#else\n#define TOWORDS(bytes) (((bytes) + 3) >> 2)\n#endif\n\n#ifndef PXT_VM\n#define soft_panic target_panic\n#endif\n\nextern int debugFlags;\n\nenum class PerfCounters {\n    GC,\n};\n\n#ifdef PXT_PROFILE\n#ifndef PERF_NOW\n#error \"missing platform timer support\"\n#endif\n\nstruct PerfCounter {\n    uint32_t value;\n    uint32_t numstops;\n    uint32_t start;\n};\n\nextern struct PerfCounter *perfCounters;\n\nvoid initPerfCounters();\n//%\nvoid dumpPerfCounters();\n//%\nvoid startPerfCounter(PerfCounters n);\n//%\nvoid stopPerfCounter(PerfCounters n);\n#else\ninline void startPerfCounter(PerfCounters n) {}\ninline void stopPerfCounter(PerfCounters n) {}\ninline void initPerfCounters() {}\ninline void dumpPerfCounters() {}\n#endif\n\n#ifdef PXT_VM\nString mkInternalString(const char *str);\n#define PXT_DEF_STRING(name, val) String name = mkInternalString(val);\n#else\n#define PXT_DEF_STRING(name, val)                                                                  \\\n    static const char name[] __attribute__((aligned(4))) = \"@PXT@:\" val;\n#endif\n\n} // namespace pxt\n\nusing namespace pxt;\n\nnamespace numops {\n//%\nString toString(TValue v);\n//%\nint toBool(TValue v);\n//%\nint toBoolDecr(TValue v);\n} // namespace numops\n\nnamespace pxt {\ninline bool toBoolQuick(TValue v) {\n    if (v == TAG_TRUE)\n        return true;\n    if (v == TAG_FALSE || v == TAG_UNDEFINED || v == TAG_NULL)\n        return false;\n    return numops::toBool(v);\n}\n} // namespace pxt\n\nnamespace pxtrt {\n//%\nRefMap *mkMap();\n//%\nTValue mapGetByString(RefMap *map, String key);\n//%\nint lookupMapKey(String key);\n//%\nTValue mapGet(RefMap *map, unsigned key);\n//% expose\nvoid mapSetByString(RefMap *map, String key, TValue val);\n//%\nvoid mapSet(RefMap *map, unsigned key, TValue val);\n} // namespace pxtrt\n\nnamespace pins {\nBuffer createBuffer(int size);\n}\n\nnamespace String_ {\n//%\nint compare(String a, String b);\n} // namespace String_\n\nnamespace Array_ {\n//%\nRefCollection *mk();\n//%\nint length(RefCollection *c);\n//%\nvoid setLength(RefCollection *c, int newLength);\n//%\nvoid push(RefCollection *c, TValue x);\n//%\nTValue pop(RefCollection *c);\n//%\nTValue getAt(RefCollection *c, int x);\n//%\nvoid setAt(RefCollection *c, int x, TValue y);\n//%\nTValue removeAt(RefCollection *c, int x);\n//%\nvoid insertAt(RefCollection *c, int x, TValue value);\n//%\nint indexOf(RefCollection *c, TValue x, int start);\n//%\nbool removeElement(RefCollection *c, TValue x);\n} // namespace Array_\n\n#define NEW_GC(T, ...) new (gcAllocate(sizeof(T))) T(__VA_ARGS__)\n\n// The ARM Thumb generator in the JavaScript code is parsing\n// the hex file and looks for the magic numbers as present here.\n//\n// Then it fetches function pointer addresses from there.\n//\n// The vtable pointers are there, so that the ::emptyData for various types\n// can be patched with the right vtable.\n//\n#define PXT_SHIMS_BEGIN                                                                            \\\n    namespace pxt {                                                                                \\\n    const uintptr_t functionsAndBytecode[]                                                         \\\n        __attribute__((aligned(0x20))) = {0x08010801, 0x42424242, 0x08010801, 0x8de9d83e,\n\n#define PXT_SHIMS_END                                                                              \\\n    }                                                                                              \\\n    ;                                                                                              \\\n    }\n\n#if !defined(X86_64) && !defined(PXT_VM)\n#pragma GCC diagnostic ignored \"-Wpmf-conversions\"\n#endif\n\n#ifdef PXT_VM\n#define DEF_VTABLE(name, tp, valtype, ...)                                                         \\\n    const VTable name = {sizeof(tp), valtype, VTABLE_MAGIC, 0, BuiltInType::tp, BuiltInType::tp,   \\\n                         0,          0,       {__VA_ARGS__}};\n#else\n#define DEF_VTABLE(name, tp, valtype, ...)                                                         \\\n    const VTable name = {sizeof(tp), valtype, VTABLE_MAGIC, 0, BuiltInType::tp,                    \\\n                         0,          0,       {__VA_ARGS__}};\n#endif\n\n#define PXT_VTABLE(classname, valtp)                                                               \\\n    DEF_VTABLE(classname##_vtable, classname, valtp, (void *)&classname::destroy,                  \\\n               (void *)&classname::print, (void *)&classname::scan, (void *)&classname::gcsize)\n\n#define PXT_VTABLE_INIT(classname) RefObject(&classname##_vtable)\n\n#define PXT_VTABLE_CTOR(classname)                                                                 \\\n    PXT_VTABLE(classname, ValType::Object)                                                         \\\n    classname::classname() : PXT_VTABLE_INIT(classname)\n\n#define PXT_MAIN                                                                                   \\\n    int main() {                                                                                   \\\n        pxt::start();                                                                              \\\n        return 0;                                                                                  \\\n    }\n\n#define PXT_FNPTR(x) (uintptr_t)(void *)(x)\n\n#define PXT_ABI(...)\n\n#define JOIN(a, b) a##b\n/// Defines getClassName() function to fetch the singleton\n#define SINGLETON(ClassName)                                                                       \\\n    static ClassName *JOIN(inst, ClassName);                                                       \\\n    ClassName *JOIN(get, ClassName)() {                                                            \\\n        if (!JOIN(inst, ClassName))                                                                \\\n            JOIN(inst, ClassName) = new ClassName();                                               \\\n        return JOIN(inst, ClassName);                                                              \\\n    }\n\n/// Defines getClassName() function to fetch the singleton if PIN present\n#define SINGLETON_IF_PIN(ClassName, pin)                                                           \\\n    static ClassName *JOIN(inst, ClassName);                                                       \\\n    ClassName *JOIN(get, ClassName)() {                                                            \\\n        if (!JOIN(inst, ClassName) && LOOKUP_PIN(pin))                                             \\\n            JOIN(inst, ClassName) = new ClassName();                                               \\\n        return JOIN(inst, ClassName);                                                              \\\n    }\n\n#ifdef PXT_VM\n#include \"vm.h\"\n#endif\n\n#endif\n",
            "scheduling.ts": "/**\n * Calls a function with a fixed time delay between each call to that function.\n * @param func \n * @param delay \n */\n//%\nfunction setInterval(func: () => void, delay: number): number {\n    delay = Math.max(10, delay | 0);\n    return control.setInterval(func, delay, control.IntervalMode.Interval);\n}\n\n/**\n * Cancels repeated action which was set up using setInterval().\n * @param intervalId \n */\n//%\nfunction clearInterval(intervalId: number) {\n    control.clearInterval(intervalId, control.IntervalMode.Interval);\n}\n\n/**\n * Calls a function after specified delay.\n * @param func \n * @param delay \n */\n//%\nfunction setTimeout(func: () => void, delay: number): number {\n    return control.setInterval(func, delay, control.IntervalMode.Timeout);\n}\n\n/**\n * Clears the delay set by setTimeout().\n * @param intervalId \n */\n//%\nfunction clearTimeout(intervalId: number) {\n    control.clearInterval(intervalId, control.IntervalMode.Timeout);\n}\n\n/**\n * Calls a function as soon as possible.\n * @param func \n */\n//%\nfunction setImmediate(func: () => void): number {\n    return control.setInterval(func, 0, control.IntervalMode.Immediate);\n}\n\n/**\n * Cancels the immediate actions.\n * @param intervalId \n */\n//%\nfunction clearImmediate(intervalId: number) {\n    control.clearInterval(intervalId, control.IntervalMode.Immediate);\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\n\n    //% indexerGet=BufferMethods::getByte indexerSet=BufferMethods::setByte\ndeclare interface Buffer {\n    /**\n     * Reads an unsigned byte at a particular location\n     */\n    //% shim=BufferMethods::getUint8\n    getUint8(off: int32): int32;\n\n    /**\n     * Returns false when the buffer can be written to.\n     */\n    //% shim=BufferMethods::isReadOnly\n    isReadOnly(): boolean;\n\n    /**\n     * Writes an unsigned byte at a particular location\n     */\n    //% shim=BufferMethods::setUint8\n    setUint8(off: int32, v: int32): void;\n\n    /**\n     * Write a number in specified format in the buffer.\n     */\n    //% shim=BufferMethods::setNumber\n    setNumber(format: NumberFormat, offset: int32, value: number): void;\n\n    /**\n     * Read a number in specified format from the buffer.\n     */\n    //% shim=BufferMethods::getNumber\n    getNumber(format: NumberFormat, offset: int32): number;\n\n    /** Returns the length of a Buffer object. */\n    //% property shim=BufferMethods::length\n    length: int32;\n\n    /**\n     * Fill (a fragment) of the buffer with given value.\n     */\n    //% offset.defl=0 length.defl=-1 shim=BufferMethods::fill\n    fill(value: int32, offset?: int32, length?: int32): void;\n\n    /**\n     * Return a copy of a fragment of a buffer.\n     */\n    //% offset.defl=0 length.defl=-1 shim=BufferMethods::slice\n    slice(offset?: int32, length?: int32): Buffer;\n\n    /**\n     * Shift buffer left in place, with zero padding.\n     * @param offset number of bytes to shift; use negative value to shift right\n     * @param start start offset in buffer. Default is 0.\n     * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n     * start. eg: -1\n     */\n    //% start.defl=0 length.defl=-1 shim=BufferMethods::shift\n    shift(offset: int32, start?: int32, length?: int32): void;\n\n    /**\n     * Convert a buffer to string assuming UTF8 encoding\n     */\n    //% shim=BufferMethods::toString\n    toString(): string;\n\n    /**\n     * Convert a buffer to its hexadecimal representation.\n     */\n    //% shim=BufferMethods::toHex\n    toHex(): string;\n\n    /**\n     * Rotate buffer left in place.\n     * @param offset number of bytes to shift; use negative value to shift right\n     * @param start start offset in buffer. Default is 0.\n     * @param length number of elements in buffer. If negative, length is set as the buffer length minus\n     * start. eg: -1\n     */\n    //% start.defl=0 length.defl=-1 shim=BufferMethods::rotate\n    rotate(offset: int32, start?: int32, length?: int32): void;\n\n    /**\n     * Write contents of `src` at `dstOffset` in current buffer.\n     */\n    //% shim=BufferMethods::write\n    write(dstOffset: int32, src: Buffer): void;\n\n    /**\n     * Compute k-bit FNV-1 non-cryptographic hash of the buffer.\n     */\n    //% shim=BufferMethods::hash\n    hash(bits: int32): uint32;\n}\ndeclare namespace control {\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% deprecated=1 shim=control::createBuffer\n    function createBuffer(size: int32): Buffer;\n\n    /**\n     * Create a new buffer with UTF8-encoded string\n     * @param str the string to put in the buffer\n     */\n    //% deprecated=1 shim=control::createBufferFromUTF8\n    function createBufferFromUTF8(str: string): Buffer;\n}\ndeclare namespace loops {\n\n    /**\n     * Repeats the code forever in the background. On each iteration, allows other codes to run.\n     * @param body code to execute\n     */\n    //% help=loops/forever weight=100 afterOnStart=true deprecated=true\n    //% blockId=forever_deprecated block=\"forever\" blockAllowMultiple=1 shim=loops::forever\n    function forever(a: () => void): void;\n\n    /**\n     * Pause for the specified time in milliseconds\n     * @param ms how long to pause for, eg: 100, 200, 500, 1000, 2000\n     */\n    //% help=loops/pause weight=99 deprecated=true\n    //% async block=\"pause %pause=timePicker|ms\"\n    //% blockId=device_pause_deprecated shim=loops::pause\n    function pause(ms: int32): void;\n}\ndeclare namespace control {\n\n    /**\n     * Gets the number of milliseconds elapsed since power on.\n     */\n    //% help=control/millis weight=50\n    //% blockId=control_running_time block=\"millis (ms)\" shim=control::millis\n    function millis(): int32;\n\n    /**\n     * Gets current time in microseconds. Overflows every ~18 minutes.\n     */\n    //% shim=control::micros\n    function micros(): int32;\n\n    /**\n     * Used internally\n     */\n    //% flags.defl=16 shim=control::internalOnEvent\n    function internalOnEvent(src: int32, value: int32, handler: () => void, flags?: int32): void;\n\n    /**\n     * Reset the device.\n     */\n    //% weight=30 async help=control/reset blockGap=8\n    //% blockId=\"control_reset\" block=\"reset\" shim=control::reset\n    function reset(): void;\n\n    /**\n     * Block the current fiber for the given microseconds\n     * @param micros number of micro-seconds to wait. eg: 4\n     */\n    //% help=control/wait-micros weight=29 async\n    //% blockId=\"control_wait_us\" block=\"wait (s)%micros\" shim=control::waitMicros\n    function waitMicros(micros: int32): void;\n\n    /**\n     * Run other code in the parallel.\n     */\n    //% help=control/run-in-parallel handlerStatement=1\n    //% blockId=\"control_run_in_parallel\" block=\"run in parallel\" blockGap=8 shim=control::runInParallel\n    function runInParallel(a: () => void): void;\n\n    /**\n     * Blocks the calling thread until the specified event is raised.\n     */\n    //% help=control/wait-for-event async\n    //% blockId=control_wait_for_event block=\"wait for event|from %src|with value %value\" shim=control::waitForEvent\n    function waitForEvent(src: int32, value: int32): void;\n\n    /**\n     * Derive a unique, consistent serial number of this device from internal data.\n     */\n    //% blockId=\"control_device_serial_number\" block=\"device serial number\" weight=9\n    //% help=control/device-serial-number shim=control::deviceSerialNumber\n    function deviceSerialNumber(): int32;\n\n    /**\n     * Derive a unique, consistent 64-bit serial number of this device from internal data.\n     */\n    //% blockId=\"control_device_long_serial_number\" block=\"device long serial number\" weight=9\n    //% help=control/device-long-serial-number shim=control::deviceLongSerialNumber\n    function deviceLongSerialNumber(): Buffer;\n\n    /**\n     *\n     */\n    //% shim=control::__log\n    function __log(prority: int32, text: string): void;\n\n    /**\n     * Dump internal information about a value.\n     */\n    //% shim=control::dmesgValue\n    function dmesgValue(v: any): void;\n\n    /**\n     * Force GC and dump basic information about heap.\n     */\n    //% shim=control::gc\n    function gc(): void;\n\n    /**\n     * Force GC and halt waiting for debugger to do a full heap dump.\n     */\n    //% shim=control::heapDump\n    function heapDump(): void;\n\n    /**\n     * Set flags used when connecting an external debugger.\n     */\n    //% shim=control::setDebugFlags\n    function setDebugFlags(flags: int32): void;\n\n    /**\n     * Record a heap snapshot to debug memory leaks.\n     */\n    //% shim=control::heapSnapshot\n    function heapSnapshot(): void;\n\n    /**\n     * Return true if profiling is enabled in the current build.\n     */\n    //% shim=control::profilingEnabled\n    function profilingEnabled(): boolean;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "templates.ts": "/**\n * Tagged hex literal converter\n */\n//% shim=@hex\nfunction hex(lits: any, ...args: any[]): Buffer { return null }\n",
            "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\n\nfunction check(cond:boolean) { control.assert(cond, 108) }\n\ncheck(Buffer.pack(\"<2h\", [0x3412, 0x7856]).toHex() == \"12345678\")\ncheck(Buffer.pack(\">hh\", [0x3412, 0x7856]).toHex() == \"34127856\")\ncheck(Buffer.fromHex(\"F00d\").toHex() == \"f00d\")",
            "trig.cpp": "#include \"pxtbase.h\"\n#include <limits.h>\n#include <stdlib.h>\n\nusing namespace std;\n\nnamespace Math_ {\n\n#define SINGLE(op) return fromDouble(::op(toDouble(x)));\n\n//%\nTNumber atan2(TNumber y, TNumber x) {\n    return fromDouble(::atan2(toDouble(y), toDouble(x)));\n}\n\n//%\nTNumber tan(TNumber x){SINGLE(tan)}\n\n//%\nTNumber sin(TNumber x){SINGLE(sin)}\n\n//%\nTNumber cos(TNumber x){SINGLE(cos)}\n\n//%\nTNumber atan(TNumber x){SINGLE(atan)}\n\n//%\nTNumber asin(TNumber x){SINGLE(asin)}\n\n//%\nTNumber acos(TNumber x){SINGLE(acos)}\n\n//%\nTNumber sqrt(TNumber x){SINGLE(sqrt)}\n\n}",
            "utfdecoder.ts": "class UTF8Decoder {\n    private buf: Buffer;\n\n    constructor() {\n        this.buf = undefined;\n    }\n\n    add(buf: Buffer) {\n        if (!buf || !buf.length) return;\n\n        if (!this.buf)\n            this.buf = buf;\n        else {\n            const b = control.createBuffer(this.buf.length + buf.length);\n            b.write(0, this.buf);\n            b.write(this.buf.length, buf);\n            this.buf = b;\n        }\n    }\n\n    decodeUntil(delimiter: number): string {\n        if (!this.buf) return undefined;\n        delimiter = delimiter | 0;\n        let i = 0;\n        for (; i < this.buf.length; ++i) {\n            const c = this.buf[i];\n            // skip multi-chars\n            if ((c & 0xe0) == 0xc0)\n                i += 1;\n            else if ((c & 0xf0) == 0xe0)\n                i += 2;\n            else if (c == delimiter) {\n                // found it\n                break;\n            }\n        }\n\n        if (i >= this.buf.length)\n            return undefined;\n        else {\n            const s = this.buf.slice(0, i).toString();\n            if (i + 1 == this.buf.length)\n                this.buf = undefined;\n            else\n                this.buf = this.buf.slice(i + 1);\n            return s;\n        }\n    }\n\n    decode(): string {\n        if (!this.buf) return \"\";\n\n        // scan the end of the buffer for partial characters\n        let length = 0;\n        for (let i = this.buf.length - 1; i >= 0; i--) {\n            const c = this.buf[i];\n            if ((c & 0x80) == 0) {\n                length = i + 1;\n                break;\n            }\n            else if ((c & 0xe0) == 0xc0) {\n                length = i + 2;\n                break;\n            }\n            else if ((c & 0xf0) == 0xe0) {\n                length = i + 3;\n                break;\n            }\n        }\n        // is last beyond the end?\n        if (length == this.buf.length) {\n            const s = this.buf.toString();\n            this.buf = undefined;\n            return s;\n        } else if (length == 0) { // data yet\n            return \"\";\n        } else {\n            const s = this.buf.slice(0, length).toString();\n            this.buf = this.buf.slice(length);\n            return s;\n        }\n    }\n}"
        },
        "core": {
            "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
            "codal.cpp": "#include \"pxt.h\"\n#include \"LowLevelTimer.h\"\nusing namespace codal;\n\nvoid cpu_clock_init(void);\n\nPXT_ABI(__aeabi_dadd)\nPXT_ABI(__aeabi_dcmplt)\nPXT_ABI(__aeabi_dcmpgt)\nPXT_ABI(__aeabi_dsub)\nPXT_ABI(__aeabi_ddiv)\nPXT_ABI(__aeabi_dmul)\n\n#ifdef DEVICE_GET_FIBER_LIST_AVAILABLE\n// newer codal-core has get_fiber_list() but not list_fibers()\nnamespace codal {\n/*\n * Return all current fibers.\n *\n * @param dest If non-null, it points to an array of pointers to fibers to store results in.\n *\n * @return the number of fibers (potentially) stored\n */\nint list_fibers(Fiber **dest) {\n    int i = 0;\n    for (Fiber *fib = codal::get_fiber_list(); fib; fib = fib->next) {\n        if (dest)\n            dest[i] = fib;\n        i++;\n    }\n    return i;\n}\n\n} // namespace codal\n#endif\n\nnamespace pxt {\n\nvoid platform_init();\nvoid usb_init();\n\n// The first two word are used to tell the bootloader that a single reset should start the\n// bootloader and the MSD device, not us.\n// The rest is reserved for partial flashing checksums.\n__attribute__((section(\".binmeta\"))) __attribute__((used)) const uint32_t pxt_binmeta[] = {\n    0x87eeb07c, 0x87eeb07c, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n    0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n};\n\nEvent lastEvent;\nMessageBus devMessageBus;\ncodal::CodalDevice device;\n\nstruct FreeList {\n    FreeList *next;\n};\n\nstatic void commInit() {\n    int commSize = bytecode[20];\n    if (!commSize)\n        return;\n\n    void *r = app_alloc_at((void *)PXT_COMM_BASE, commSize);\n    DMESG(\"comm %d -> %p\", commSize, r);\n    if (!r)\n        target_panic(20);\n}\n\nstatic void initCodal() {\n    cpu_clock_init();\n\n    commInit();\n\n    // Bring up fiber scheduler.\n    scheduler_init(devMessageBus);\n\n    // We probably don't need that - components are initialized when one obtains\n    // the reference to it.\n    // devMessageBus.listen(DEVICE_ID_MESSAGE_BUS_LISTENER, DEVICE_EVT_ANY, this,\n    // &CircuitPlayground::onListenerRegisteredEvent);\n\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; i++) {\n        if (CodalComponent::components[i])\n            CodalComponent::components[i]->init();\n    }\n\n    usb_init();\n\n    auto led = LOOKUP_PIN(LED);\n    if (led) {\n        led->setDigitalValue(0);\n    }\n}\n\n// ---------------------------------------------------------------------------\n// An adapter for the API expected by the run-time.\n// ---------------------------------------------------------------------------\n\n// We have the invariant that if [dispatchEvent] is registered against the DAL\n// for a given event, then [handlersMap] contains a valid entry for that\n// event.\nvoid dispatchEvent(Event e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    auto value = fromInt(e.value);\n    while (curr) {\n        runAction1(curr->action, value);\n        curr = nextBinding(curr->next, e.source, e.value);\n    }\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // first time?\n    if (!findBinding(id, event)) {\n        devMessageBus.listen(id, event, dispatchEvent, flags);\n        if (event == 0) {\n            // we're registering for all events on given ID\n            // need to remove old listeners for specific events\n            auto curr = findBinding(id, -1);\n            while (curr) {\n                devMessageBus.ignore(id, curr->value, dispatchEvent);\n                curr = nextBinding(curr->next, id, -1);\n            }\n        }\n    }\n    setBinding(id, event, a);\n}\n\nvoid fiberDone(void *a) {\n    unregisterGCPtr((Action)a);\n    release_fiber();\n}\n\nvoid releaseFiber() {\n    release_fiber();\n}\n\nvoid sleep_ms(unsigned ms) {\n    fiber_sleep(ms);\n}\n\nvoid sleep_us(uint64_t us) {\n    target_wait_us(us);\n}\n\nvoid forever_stub(void *a) {\n    while (true) {\n        runAction0((Action)a);\n        fiber_sleep(20);\n    }\n}\n\nvoid runForever(Action a) {\n    if (a != 0) {\n        registerGCPtr(a);\n        create_fiber(forever_stub, (void *)a);\n    }\n}\n\nvoid runInParallel(Action a) {\n    if (a != 0) {\n        registerGCPtr(a);\n        create_fiber((void (*)(void *))(void*)runAction0, (void *)a, fiberDone);\n    }\n}\n\nvoid waitForEvent(int id, int event) {\n    fiber_wait_for_event(id, event);\n}\n\nvoid initRuntime() {\n    initSystemTimer();\n    initCodal();\n    platform_init();\n}\n\n//%\nunsigned afterProgramPage() {\n    unsigned ptr = (unsigned)&bytecode[0];\n    ptr += programSize();\n    ptr = (ptr + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n    return ptr;\n}\n\nuint64_t getLongSerialNumber() {\n    return device.getSerialNumber();\n}\n\nint current_time_ms() {\n    return system_timer_current_time();\n}\n\nuint64_t current_time_us() {\n    return system_timer_current_time_us();\n}\n\nThreadContext *getThreadContext() {\n    if (!currentFiber)\n        return NULL;\n    return (ThreadContext *)currentFiber->user_data;\n}\n\nvoid setThreadContext(ThreadContext *ctx) {\n    currentFiber->user_data = ctx;\n}\n\nstatic void *threadAddressFor(codal::Fiber *fib, void *sp) {\n    if (fib == currentFiber)\n        return sp;\n    return (uint8_t *)sp + ((uint8_t *)fib->stack_top - (uint8_t *)tcb_get_stack_base(fib->tcb));\n}\n\nvoid gcProcessStacks(int flags) {\n    // check scheduler is initialized\n    if (!currentFiber) {\n        // make sure we allocate something to at least initalize the memory allocator\n        void *volatile p = xmalloc(1);\n        xfree(p);\n        return;\n    }\n\n    int numFibers = codal::list_fibers(NULL);\n    codal::Fiber **fibers = (codal::Fiber **)xmalloc(sizeof(codal::Fiber *) * numFibers);\n    int num2 = codal::list_fibers(fibers);\n    if (numFibers != num2)\n        oops(12);\n    int cnt = 0;\n\n    for (int i = 0; i < numFibers; ++i) {\n        auto fib = fibers[i];\n        auto ctx = (ThreadContext *)fib->user_data;\n        if (!ctx)\n            continue;\n        gcProcess(ctx->thrownValue);\n        for (auto seg = &ctx->stack; seg; seg = seg->next) {\n            auto ptr = (TValue *)threadAddressFor(fib, seg->top);\n            auto end = (TValue *)threadAddressFor(fib, seg->bottom);\n            if (flags & 2)\n                DMESG(\"RS%d:%p/%d\", cnt++, ptr, end - ptr);\n            // VLOG(\"mark: %p - %p\", ptr, end);\n            while (ptr < end) {\n                gcProcess(*ptr++);\n            }\n        }\n    }\n    xfree(fibers);\n}\n\nLowLevelTimer *getJACDACTimer() {\n    static LowLevelTimer *jacdacTimer;\n    if (!jacdacTimer) {\n        jacdacTimer = allocateTimer();\n        jacdacTimer->setIRQPriority(1);\n    }\n    return jacdacTimer;\n}\nvoid initSystemTimer() {\n    new CODAL_TIMER(*allocateTimer());\n}\n\n} // namespace pxt\n",
            "control.cpp": "#include \"pxt.h\"\n\n#if defined(NRF52_SERIES)\n#define _estack __StackTop \n#endif\nextern uint32_t _estack;\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the MicroBit Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% help=control/raise-event\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\nvoid raiseEvent(int src, int value) {\n    Event evt(src, value);\n}\n\n/**\n* Determine the version of system software currently running.\n*/\n//% blockId=\"control_device_dal_version\" block=\"device dal version\"\n//% help=control/device-dal-version\nString deviceDalVersion() {\n    return mkString(device.getVersion());\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return ::allocateNotifyEvent();\n}\n\n/** Write a message to DMESG debugging buffer. */\n//%\nvoid dmesg(String s) {\n    DMESG(\"# %s\", s->getUTF8Data());\n}\n\n/** Write a message and value (pointer) to DMESG debugging buffer. */\n//%\nvoid dmesgPtr(String str, Object_ ptr) {\n    DMESG(\"# %s: %p\", str->getUTF8Data(), ptr);\n}\n\n//%\nuint32_t _ramSize()\n{\n    return (uint32_t)&_estack & 0x1fffffff;\n}\n\n}\n",
            "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // /libraries/codal-core/inc/JACDAC/JACDAC.h\n    JD_VERSION = 5,\n    JD_SERIAL_MAX_BUFFERS = 10,\n    JD_SERIAL_RECEIVING = 2,\n    JD_SERIAL_TRANSMITTING = 4,\n    JD_SERIAL_TX_DRAIN_ENABLE = 8,\n    JD_SERIAL_BUS_RISE = 16,\n    JD_SERIAL_EVT_DATA_READY = 1,\n    JD_SERIAL_EVT_BUS_ERROR = 2,\n    JD_SERIAL_EVT_DRAIN = 3,\n    JD_SERIAL_EVT_RX_TIMEOUT = 4,\n    JD_SERIAL_EVT_BUS_CONNECTED = 5,\n    JD_SERIAL_EVT_BUS_DISCONNECTED = 6,\n    JD_SERIAL_HEADER_SIZE = 4,\n    JD_SERIAL_DATA_SIZE = 32,\n    JD_SERIAL_PACKET_SIZE = 36,\n    JD_SERIAL_MAXIMUM_BUFFERS = 10,\n    JD_SERIAL_DMA_TIMEOUT = 2,\n    JD_SERIAL_MAX_BAUD = 1000000,\n    JD_SERIAL_TX_MAX_BACKOFF = 4000,\n    JD_SERIAL_TX_MIN_BACKOFF = 1000,\n    Receiving = 0,\n    Transmitting = 1,\n    High = 2,\n    Low = 3,\n    Baud1M = 1,\n    Baud500K = 2,\n    Baud250K = 4,\n    Baud125K = 8,\n    // /libraries/codal-core/inc/JACDAC/JDAccelerometerDriver.h\n    JD_ACCEL_EVT_SEND_DATA = 1,\n    // /libraries/codal-core/inc/JACDAC/JDBridgeDriver.h\n    JD_BRIDGE_HISTORY_SIZE = 8,\n    // /libraries/codal-core/inc/JACDAC/JDClasses.h\n    STATIC_CLASS_START = 0,\n    STATIC_CLASS_END = 16777215,\n    DYNAMIC_CLASS_END = 4294967295,\n    JD_DRIVER_CLASS_CODAL_START = 0,\n    JD_DRIVER_CLASS_CODAL_END = 2000,\n    JD_DRIVER_CLASS_MAKECODE_START = 2000,\n    JD_DRIVER_CLASS_MAKECODE_END = 4000,\n    JD_DRIVER_CLASS_CONTROL = 0,\n    JD_DRIVER_CLASS_JOYSTICK = 1,\n    JD_DRIVER_CLASS_MESSAGE_BUS = 2,\n    JD_DRIVER_CLASS_BRIDGE = 3,\n    JD_DRIVER_CLASS_BUTTON = 4,\n    JD_DRIVER_CLASS_PIN = 5,\n    JD_DRIVER_CLASS_RELIABILITY_TESTER = 6,\n    JD_DRIVER_CLASS_ACCELEROMETER = 7,\n    JD_DRIVER_CLASS_CAPTOUCH_BUTTON = 8,\n    // /libraries/codal-core/inc/JACDAC/JDMessageBusDriver.h\n    JD_MESSAGEBUS_TYPE_EVENT = 1,\n    JD_MESSAGEBUS_TYPE_LISTEN = 2,\n    // /libraries/codal-core/inc/JACDAC/JDPinDriver.h\n    SetDigital = 0,\n    SetAnalog = 1,\n    SetServo = 2,\n    // /libraries/codal-core/inc/JACDAC/JDProtocol.h\n    JD_DRIVER_EVT_CONNECTED = 65520,\n    JD_DRIVER_EVT_DISCONNECTED = 65521,\n    JD_DRIVER_EVT_PAIRED = 65522,\n    JD_DRIVER_EVT_UNPAIRED = 65523,\n    JD_DRIVER_EVT_PAIR_REJECTED = 65524,\n    JD_DRIVER_EVT_PAIRING_RESPONSE = 65525,\n    JD_DRIVER_EVT_ERROR = 65526,\n    JD_DEVICE_FLAGS_LOCAL = 32768,\n    JD_DEVICE_FLAGS_REMOTE = 16384,\n    JD_DEVICE_FLAGS_BROADCAST = 8192,\n    JD_DEVICE_FLAGS_PAIR = 4096,\n    JD_DEVICE_DRIVER_MODE_MSK = 61440,\n    JD_DEVICE_FLAGS_PAIRABLE = 2048,\n    JD_DEVICE_FLAGS_PAIRED = 1024,\n    JD_DEVICE_FLAGS_PAIRING = 512,\n    JD_DEVICE_FLAGS_INITIALISED = 128,\n    JD_DEVICE_FLAGS_INITIALISING = 64,\n    JD_DEVICE_FLAGS_CP_SEEN = 32,\n    JD_DEVICE_ERROR_MSK = 15,\n    JD_LOGIC_DRIVER_MAX_FILTERS = 20,\n    JD_LOGIC_DRIVER_TIMEOUT = 254,\n    JD_LOGIC_ADDRESS_ALLOC_TIME = 254,\n    JD_LOGIC_DRIVER_CTRLPACKET_TIME = 112,\n    JD_LOGIC_DRIVER_EVT_CHANGED = 2,\n    CONTROL_JD_FLAGS_RESERVED = 32768,\n    CONTROL_JD_FLAGS_PAIRING_MODE = 16384,\n    CONTROL_JD_FLAGS_PAIRABLE = 8192,\n    CONTROL_JD_FLAGS_PAIRED = 4096,\n    CONTROL_JD_FLAGS_CONFLICT = 2048,\n    CONTROL_JD_FLAGS_UNCERTAIN = 1024,\n    CONTROL_JD_FLAGS_NACK = 512,\n    CONTROL_JD_FLAGS_ACK = 256,\n    CONTROL_JD_TYPE_HELLO = 1,\n    CONTROL_JD_TYPE_PAIRING_REQUEST = 2,\n    CONTROL_JD_TYPE_ERROR = 3,\n    CONTROL_JD_TYPE_PANIC = 255,\n    JD_PROTOCOL_EVT_SEND_CONTROL = 1,\n    JD_PROTOCOL_DRIVER_ARRAY_SIZE = 20,\n    CONTROL_PACKET_ERROR_NAME_LENGTH = 6,\n    VirtualDriver = 16384,\n    PairedDriver = 12288,\n    HostDriver = 32768,\n    PairableHostDriver = 34816,\n    BroadcastDriver = 40960,\n    SnifferDriver = 24576,\n    DRIVER_OK = 0,\n    DRIVER_CALIBRATION_IN_PROGRESS = 1,\n    DRIVER_CALIBRATION_REQUIRED = 2,\n    DRIVER_NO_RESOURCES = 3,\n    DRIVER_BUSY = 4,\n    DRIVER_COMMS_ERROR = 5,\n    DRIVER_INVALID_STATE = 6,\n    DRIVER_PERIPHERAL_MALFUNCTION = 7,\n    // /libraries/codal-core/inc/JACDAC/JDReliabilityTester.h\n    RELIABILITY_TEST_FINISHED = 7,\n    RELIABILITY_STATUS_TEST_IN_PROGRESS = 2,\n    RELIABILITY_STATUS_TEST_READY = 4,\n    RELIABILITY_STATUS_TEST_FINISHED = 8,\n    // /libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_A = 1,\n    DEVICE_ID_BUTTON_B = 2,\n    DEVICE_ID_BUTTON_AB = 3,\n    DEVICE_ID_BUTTON_RESET = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR_SPL = 22,\n    DEVICE_ID_MSC = 23,\n    DEVICE_ID_SPI = 24,\n    DEVICE_ID_DISTANCE = 25,\n    DEVICE_ID_GYROSCOPE = 26,\n    DEVICE_ID_HUMIDITY = 27,\n    DEVICE_ID_PRESSURE = 28,\n    DEVICE_ID_JACDAC0 = 29,\n    DEVICE_ID_JACDAC1 = 30,\n    DEVICE_ID_JACDAC_PROTOCOL = 31,\n    DEVICE_ID_JACKROUTER = 32,\n    DEVICE_ID_GAME_ENGINE = 33,\n    DEVICE_ID_GAME_STATE_MANAGER = 34,\n    DEVICE_ID_SPRITE = 35,\n    DEVICE_ID_SINGLE_WIRE_SERIAL = 36,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_ID_BUTTON_UP = 2000,\n    DEVICE_ID_BUTTON_DOWN = 2001,\n    DEVICE_ID_BUTTON_LEFT = 2002,\n    DEVICE_ID_BUTTON_RIGHT = 2003,\n    DEVICE_ID_JD_DYNAMIC_ID = 3000,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // /libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // /libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // /libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_SPI_ERROR = -1014,\n    DEVICE_INVALID_STATE = -1015,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    DEVICE_HARDWARE_CONFIGURATION_ERROR = 90,\n    // /libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    ARCADE_PLAYER_JOIN_RESULT = 4,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // /libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // /libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_EVT_2G = 12,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_2G_TOLERANCE = 2048,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // /libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // /libraries/codal-core/inc/driver-models/Gyroscope.h\n    GYROSCOPE_IMU_DATA_VALID = 2,\n    GYROSCOPE_EVT_DATA_UPDATE = 1,\n    // /libraries/codal-core/inc/driver-models/LowLevelTimer.h\n    TimerModeTimer = 0,\n    TimerModeCounter = 1,\n    TimerModeAlternateFunction = 2,\n    BitMode8 = 0,\n    BitMode16 = 1,\n    BitMode24 = 2,\n    BitMode32 = 3,\n    // /libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // /libraries/codal-core/inc/driver-models/Radio.h\n    RADIO_EVT_DATA_READY = 2,\n    // /libraries/codal-core/inc/driver-models/SPIFlash.h\n    SPIFLASH_PAGE_SIZE = 256,\n    SPIFLASH_SMALL_ROW_PAGES = 16,\n    SPIFLASH_BIG_ROW_PAGES = 256,\n    // /libraries/codal-core/inc/driver-models/Sensor.h\n    SENSOR_THRESHOLD_LOW = 1,\n    SENSOR_THRESHOLD_HIGH = 2,\n    SENSOR_UPDATE_NEEDED = 3,\n    SENSOR_INITIALISED = 1,\n    SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    SENSOR_LOW_THRESHOLD_PASSED = 4,\n    SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    SENSOR_DEFAULT_SENSITIVITY = 868,\n    SENSOR_DEFAULT_SAMPLE_PERIOD = 500,\n    // /libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_EVT_DATA_RECEIVED = 4,\n    CODAL_SERIAL_STATUS_RX_IN_USE = 1,\n    CODAL_SERIAL_STATUS_TX_IN_USE = 2,\n    CODAL_SERIAL_STATUS_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_STATUS_TX_BUFF_INIT = 8,\n    CODAL_SERIAL_STATUS_RXD = 16,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // /libraries/codal-core/inc/driver-models/SingleWireSerial.h\n    SWS_EVT_DATA_RECEIVED = 1,\n    SWS_EVT_DATA_SENT = 2,\n    SWS_EVT_ERROR = 3,\n    SWS_EVT_DATA_DROPPED = 4,\n    SingleWireRx = 0,\n    SingleWireTx = 1,\n    SingleWireDisconnected = 2,\n    // /libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // /libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // /libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // /libraries/codal-core/inc/drivers/FAT.h\n    FAT_RESERVED_SECTORS = 1,\n    FAT_ROOT_DIR_SECTORS = 4,\n    // /libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // /libraries/codal-core/inc/drivers/HIDKeyboard.h\n    HID_KEYBOARD_NUM_REPORTS = 3,\n    HID_KEYBOARD_REPORT_GENERIC = 1,\n    HID_KEYBOARD_REPORT_CONSUMER = 2,\n    HID_KEYBOARD_KEYSTATE_SIZE_GENERIC = 8,\n    HID_KEYBOARD_KEYSTATE_SIZE_CONSUMER = 2,\n    HID_KEYBOARD_MODIFIER_OFFSET = 2,\n    HID_KEYBOARD_DELAY_DEFAULT = 10,\n    PressKey = 0,\n    ReleaseKey = 1,\n    // /libraries/codal-core/inc/drivers/JackRouter.h\n    AllDown = 1,\n    HeadPhones = 2,\n    Buzzer = 3,\n    BuzzerAndSerial = 4,\n    // /libraries/codal-core/inc/drivers/KeyMap.h\n    KEYMAP_ALL_KEYS_UP_Val = 1,\n    KEYMAP_ALL_KEYS_UP_POS = 28,\n    KEYMAP_NORMAL_KEY_Val = 0,\n    KEYMAP_MODIFIER_KEY_Val = 1,\n    KEYMAP_MODIFIER_POS = 29,\n    KEYMAP_MEDIA_KEY_Val = 1,\n    KEYMAP_MEDIA_POS = 30,\n    KEYMAP_KEY_UP_Val = 0,\n    KEYMAP_KEY_DOWN_Val = 1,\n    KEYMAP_KEY_DOWN_POS = 31,\n    // /libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // /libraries/codal-core/inc/drivers/MAG3110.h\n    MAG3110_DEFAULT_ADDR = 29,\n    MAG_DR_STATUS = 0,\n    MAG_OUT_X_MSB = 1,\n    MAG_OUT_X_LSB = 2,\n    MAG_OUT_Y_MSB = 3,\n    MAG_OUT_Y_LSB = 4,\n    MAG_OUT_Z_MSB = 5,\n    MAG_OUT_Z_LSB = 6,\n    MAG_WHOAMI = 7,\n    MAG_SYSMOD = 8,\n    MAG_OFF_X_MSB = 9,\n    MAG_OFF_X_LSB = 10,\n    MAG_OFF_Y_MSB = 11,\n    MAG_OFF_Y_LSB = 12,\n    MAG_OFF_Z_MSB = 13,\n    MAG_OFF_Z_LSB = 14,\n    MAG_DIE_TEMP = 15,\n    MAG_CTRL_REG1 = 16,\n    MAG_CTRL_REG2 = 17,\n    MAG3110_SAMPLE_RATES = 11,\n    MAG3110_WHOAMI_VAL = 196,\n    // /libraries/codal-core/inc/drivers/MMA8453.h\n    MMA8453_DEFAULT_ADDR = 56,\n    MMA8453_WHOAMI_VAL = 58,\n    // /libraries/codal-core/inc/drivers/MMA8653.h\n    MICROBIT_ACCEL_PITCH_ROLL_VALID = 2,\n    MICROBIT_ACCEL_ADDED_TO_IDLE = 4,\n    MMA8653_DEFAULT_ADDR = 58,\n    MMA8653_STATUS = 0,\n    MMA8653_OUT_X_MSB = 1,\n    MMA8653_WHOAMI = 13,\n    MMA8653_XYZ_DATA_CFG = 14,\n    MMA8653_CTRL_REG1 = 42,\n    MMA8653_CTRL_REG2 = 43,\n    MMA8653_CTRL_REG3 = 44,\n    MMA8653_CTRL_REG4 = 45,\n    MMA8653_CTRL_REG5 = 46,\n    MMA8653_WHOAMI_VAL = 90,\n    MMA8653_SAMPLE_RANGES = 3,\n    MMA8653_SAMPLE_RATES = 8,\n    // /libraries/codal-core/inc/drivers/MPU6050.h\n    MPU6050_DEFAULT_ADDR = 104,\n    MPU6050_WHOAMI = 117,\n    MPU6050_WHOAMI_VAL = 52,\n    // /libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // /libraries/codal-core/inc/drivers/ST7735.h\n    MADCTL_MY = 128,\n    MADCTL_MX = 64,\n    MADCTL_MV = 32,\n    MADCTL_ML = 16,\n    MADCTL_RGB = 0,\n    MADCTL_BGR = 8,\n    MADCTL_MH = 4,\n    // /libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // /libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // /libraries/codal-core/inc/drivers/USB_HID_Keys.h\n    KEY_MOD_LCTRL = 1,\n    KEY_MOD_LSHIFT = 2,\n    KEY_MOD_LALT = 4,\n    KEY_MOD_LMETA = 8,\n    KEY_MOD_RCTRL = 16,\n    KEY_MOD_RSHIFT = 32,\n    KEY_MOD_RALT = 64,\n    KEY_MOD_RMETA = 128,\n    KEY_NONE = 0,\n    KEY_ERR_OVF = 1,\n    KEY_A = 4,\n    KEY_B = 5,\n    KEY_C = 6,\n    KEY_D = 7,\n    KEY_E = 8,\n    KEY_F = 9,\n    KEY_G = 10,\n    KEY_H = 11,\n    KEY_I = 12,\n    KEY_J = 13,\n    KEY_K = 14,\n    KEY_L = 15,\n    KEY_M = 16,\n    KEY_N = 17,\n    KEY_O = 18,\n    KEY_P = 19,\n    KEY_Q = 20,\n    KEY_R = 21,\n    KEY_S = 22,\n    KEY_T = 23,\n    KEY_U = 24,\n    KEY_V = 25,\n    KEY_W = 26,\n    KEY_X = 27,\n    KEY_Y = 28,\n    KEY_Z = 29,\n    KEY_1 = 30,\n    KEY_2 = 31,\n    KEY_3 = 32,\n    KEY_4 = 33,\n    KEY_5 = 34,\n    KEY_6 = 35,\n    KEY_7 = 36,\n    KEY_8 = 37,\n    KEY_9 = 38,\n    KEY_0 = 39,\n    KEY_ENTER = 40,\n    KEY_ESC = 41,\n    KEY_BACKSPACE = 42,\n    KEY_TAB = 43,\n    KEY_SPACE = 44,\n    KEY_MINUS = 45,\n    KEY_EQUAL = 46,\n    KEY_LEFTBRACE = 47,\n    KEY_RIGHTBRACE = 48,\n    KEY_BACKSLASH = 49,\n    KEY_HASHTILDE = 50,\n    KEY_SEMICOLON = 51,\n    KEY_APOSTROPHE = 52,\n    KEY_GRAVE = 53,\n    KEY_COMMA = 54,\n    KEY_DOT = 55,\n    KEY_SLASH = 56,\n    KEY_CAPSLOCK = 57,\n    KEY_F1 = 58,\n    KEY_F2 = 59,\n    KEY_F3 = 60,\n    KEY_F4 = 61,\n    KEY_F5 = 62,\n    KEY_F6 = 63,\n    KEY_F7 = 64,\n    KEY_F8 = 65,\n    KEY_F9 = 66,\n    KEY_F10 = 67,\n    KEY_F11 = 68,\n    KEY_F12 = 69,\n    KEY_SYSRQ = 70,\n    KEY_SCROLLLOCK = 71,\n    KEY_PAUSE = 72,\n    KEY_INSERT = 73,\n    KEY_HOME = 74,\n    KEY_PAGEUP = 75,\n    KEY_DELETE = 76,\n    KEY_END = 77,\n    KEY_PAGEDOWN = 78,\n    KEY_RIGHT = 79,\n    KEY_LEFT = 80,\n    KEY_DOWN = 81,\n    KEY_UP = 82,\n    KEY_NUMLOCK = 83,\n    KEY_KPSLASH = 84,\n    KEY_KPASTERISK = 85,\n    KEY_KPMINUS = 86,\n    KEY_KPPLUS = 87,\n    KEY_KPENTER = 88,\n    KEY_KP1 = 89,\n    KEY_KP2 = 90,\n    KEY_KP3 = 91,\n    KEY_KP4 = 92,\n    KEY_KP5 = 93,\n    KEY_KP6 = 94,\n    KEY_KP7 = 95,\n    KEY_KP8 = 96,\n    KEY_KP9 = 97,\n    KEY_KP0 = 98,\n    KEY_KPDOT = 99,\n    KEY_102ND = 100,\n    KEY_COMPOSE = 101,\n    KEY_POWER = 102,\n    KEY_KPEQUAL = 103,\n    KEY_F13 = 104,\n    KEY_F14 = 105,\n    KEY_F15 = 106,\n    KEY_F16 = 107,\n    KEY_F17 = 108,\n    KEY_F18 = 109,\n    KEY_F19 = 110,\n    KEY_F20 = 111,\n    KEY_F21 = 112,\n    KEY_F22 = 113,\n    KEY_F23 = 114,\n    KEY_F24 = 115,\n    KEY_OPEN = 116,\n    KEY_HELP = 117,\n    KEY_PROPS = 118,\n    KEY_FRONT = 119,\n    KEY_STOP = 120,\n    KEY_AGAIN = 121,\n    KEY_UNDO = 122,\n    KEY_CUT = 123,\n    KEY_COPY = 124,\n    KEY_PASTE = 125,\n    KEY_FIND = 126,\n    KEY_MUTE = 127,\n    KEY_VOLUMEUP = 128,\n    KEY_VOLUMEDOWN = 129,\n    KEY_KPCOMMA = 133,\n    KEY_RO = 135,\n    KEY_KATAKANAHIRAGANA = 136,\n    KEY_YEN = 137,\n    KEY_HENKAN = 138,\n    KEY_MUHENKAN = 139,\n    KEY_KPJPCOMMA = 140,\n    KEY_HANGEUL = 144,\n    KEY_HANJA = 145,\n    KEY_KATAKANA = 146,\n    KEY_HIRAGANA = 147,\n    KEY_ZENKAKUHANKAKU = 148,\n    KEY_KPLEFTPAREN = 182,\n    KEY_KPRIGHTPAREN = 183,\n    KEY_LEFTCTRL = 224,\n    KEY_LEFTSHIFT = 225,\n    KEY_LEFTALT = 226,\n    KEY_LEFTMETA = 227,\n    KEY_RIGHTCTRL = 228,\n    KEY_RIGHTSHIFT = 229,\n    KEY_RIGHTALT = 230,\n    KEY_RIGHTMETA = 231,\n    KEY_MEDIA_PLAYPAUSE = 232,\n    KEY_MEDIA_STOPCD = 233,\n    KEY_MEDIA_PREVIOUSSONG = 234,\n    KEY_MEDIA_NEXTSONG = 235,\n    KEY_MEDIA_EJECTCD = 236,\n    KEY_MEDIA_VOLUMEUP = 237,\n    KEY_MEDIA_VOLUMEDOWN = 238,\n    KEY_MEDIA_MUTE = 239,\n    KEY_MEDIA_WWW = 240,\n    KEY_MEDIA_BACK = 241,\n    KEY_MEDIA_FORWARD = 242,\n    KEY_MEDIA_STOP = 243,\n    KEY_MEDIA_FIND = 244,\n    KEY_MEDIA_SCROLLUP = 245,\n    KEY_MEDIA_SCROLLDOWN = 246,\n    KEY_MEDIA_EDIT = 247,\n    KEY_MEDIA_SLEEP = 248,\n    KEY_MEDIA_COFFEE = 249,\n    KEY_MEDIA_REFRESH = 250,\n    KEY_MEDIA_CALC = 251,\n    // /libraries/codal-core/inc/drivers/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // /libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // /libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // /libraries/codal-core/inc/streams/LevelDetectorSPL.h\n    LEVEL_DETECTOR_SPL_INITIALISED = 1,\n    LEVEL_DETECTOR_SPL_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_SPL_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_SPL_DEFAULT_WINDOW_SIZE = 128,\n    // /libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // /libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // /libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // /libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // /libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // /pxtapp/accelerometer/axis.h\n    ACC_SYSTEM = 3,\n    ACC_ROTATION = 0,\n    // /pxtapp/configkeys.h\n    CFG_PIN_NAME_MSK = 65535,\n    CFG_PIN_CONFIG_MSK = 4294901760,\n    CFG_PIN_CONFIG_ACTIVE_LO = 65536,\n    CFG_MAGIC0 = 513675505,\n    CFG_MAGIC1 = 539130489,\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_DISPLAY_SCK = 32,\n    CFG_PIN_DISPLAY_MISO = 33,\n    CFG_PIN_DISPLAY_MOSI = 34,\n    CFG_PIN_DISPLAY_CS = 35,\n    CFG_PIN_DISPLAY_DC = 36,\n    CFG_DISPLAY_WIDTH = 37,\n    CFG_DISPLAY_HEIGHT = 38,\n    CFG_DISPLAY_CFG0 = 39,\n    CFG_DISPLAY_CFG1 = 40,\n    CFG_DISPLAY_CFG2 = 41,\n    CFG_DISPLAY_CFG3 = 42,\n    CFG_PIN_DISPLAY_RST = 43,\n    CFG_PIN_DISPLAY_BL = 44,\n    CFG_PIN_SERVO_1 = 45,\n    CFG_PIN_SERVO_2 = 46,\n    CFG_PIN_BTN_LEFT = 47,\n    CFG_PIN_BTN_RIGHT = 48,\n    CFG_PIN_BTN_UP = 49,\n    CFG_PIN_BTN_DOWN = 50,\n    CFG_PIN_BTN_MENU = 51,\n    CFG_PIN_LED_R = 52,\n    CFG_PIN_LED_G = 53,\n    CFG_PIN_LED_B = 54,\n    CFG_PIN_LED1 = 55,\n    CFG_PIN_LED2 = 56,\n    CFG_PIN_LED3 = 57,\n    CFG_PIN_LED4 = 58,\n    CFG_SPEAKER_VOLUME = 59,\n    CFG_PIN_JACK_TX = 60,\n    CFG_PIN_JACK_SENSE = 61,\n    CFG_PIN_JACK_HPEN = 62,\n    CFG_PIN_JACK_BZEN = 63,\n    CFG_PIN_JACK_PWREN = 64,\n    CFG_PIN_JACK_SND = 65,\n    CFG_PIN_JACK_BUSLED = 66,\n    CFG_PIN_JACK_COMMLED = 67,\n    CFG_PIN_BTN_SOFT_RESET = 69,\n    CFG_ACCELEROMETER_TYPE = 70,\n    CFG_PIN_BTNMX_LATCH = 71,\n    CFG_PIN_BTNMX_CLOCK = 72,\n    CFG_PIN_BTNMX_DATA = 73,\n    CFG_PIN_BTN_MENU2 = 74,\n    CFG_PIN_BATTSENSE = 75,\n    CFG_PIN_VIBRATION = 76,\n    CFG_PIN_PWREN = 77,\n    ACCELEROMETER_TYPE_LIS3DH = 50,\n    ACCELEROMETER_TYPE_MMA8453 = 56,\n    ACCELEROMETER_TYPE_FXOS8700 = 60,\n    ACCELEROMETER_TYPE_MMA8653 = 58,\n    ACCELEROMETER_TYPE_MSA300 = 76,\n    ACCELEROMETER_TYPE_MPU6050 = 104,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_A16 = 116,\n    CFG_PIN_A17 = 117,\n    CFG_PIN_A18 = 118,\n    CFG_PIN_A19 = 119,\n    CFG_PIN_A20 = 120,\n    CFG_PIN_A21 = 121,\n    CFG_PIN_A22 = 122,\n    CFG_PIN_A23 = 123,\n    CFG_PIN_A24 = 124,\n    CFG_PIN_A25 = 125,\n    CFG_PIN_A26 = 126,\n    CFG_PIN_A27 = 127,\n    CFG_PIN_A28 = 128,\n    CFG_PIN_A29 = 129,\n    CFG_PIN_A30 = 130,\n    CFG_PIN_A31 = 131,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_PIN_D16 = 166,\n    CFG_PIN_D17 = 167,\n    CFG_PIN_D18 = 168,\n    CFG_PIN_D19 = 169,\n    CFG_PIN_D20 = 170,\n    CFG_PIN_D21 = 171,\n    CFG_PIN_D22 = 172,\n    CFG_PIN_D23 = 173,\n    CFG_PIN_D24 = 174,\n    CFG_PIN_D25 = 175,\n    CFG_PIN_D26 = 176,\n    CFG_PIN_D27 = 177,\n    CFG_PIN_D28 = 178,\n    CFG_PIN_D29 = 179,\n    CFG_PIN_D30 = 180,\n    CFG_PIN_D31 = 181,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    CFG_FLASH_BYTES = 204,\n    CFG_RAM_BYTES = 205,\n    CFG_SYSTEM_HEAP_BYTES = 206,\n    CFG_LOW_MEM_SIMULATION_KB = 207,\n    CFG_BOOTLOADER_BOARD_ID = 208,\n    CFG_UF2_FAMILY = 209,\n    CFG_PINS_PORT_SIZE = 210,\n    CFG_BOOTLOADER_PROTECTION = 211,\n    CFG_POWER_DEEPSLEEP_TIMEOUT = 212,\n    CFG_ANALOG_BUTTON_THRESHOLD = 213,\n    CFG_PIN_B0 = 300,\n    CFG_PIN_B1 = 301,\n    CFG_PIN_B2 = 302,\n    CFG_PIN_B3 = 303,\n    CFG_PIN_B4 = 304,\n    CFG_PIN_B5 = 305,\n    CFG_PIN_B6 = 306,\n    CFG_PIN_B7 = 307,\n    CFG_PIN_B8 = 308,\n    CFG_PIN_B9 = 309,\n    CFG_PIN_B10 = 310,\n    CFG_PIN_B11 = 311,\n    CFG_PIN_B12 = 312,\n    CFG_PIN_B13 = 313,\n    CFG_PIN_B14 = 314,\n    CFG_PIN_B15 = 315,\n    CFG_PIN_B16 = 316,\n    CFG_PIN_B17 = 317,\n    CFG_PIN_B18 = 318,\n    CFG_PIN_B19 = 319,\n    CFG_PIN_B20 = 320,\n    CFG_PIN_B21 = 321,\n    CFG_PIN_B22 = 322,\n    CFG_PIN_B23 = 323,\n    CFG_PIN_B24 = 324,\n    CFG_PIN_B25 = 325,\n    CFG_PIN_B26 = 326,\n    CFG_PIN_B27 = 327,\n    CFG_PIN_B28 = 328,\n    CFG_PIN_B29 = 329,\n    CFG_PIN_B30 = 330,\n    CFG_PIN_B31 = 331,\n    CFG_PIN_C0 = 350,\n    CFG_PIN_C1 = 351,\n    CFG_PIN_C2 = 352,\n    CFG_PIN_C3 = 353,\n    CFG_PIN_C4 = 354,\n    CFG_PIN_C5 = 355,\n    CFG_PIN_C6 = 356,\n    CFG_PIN_C7 = 357,\n    CFG_PIN_C8 = 358,\n    CFG_PIN_C9 = 359,\n    CFG_PIN_C10 = 360,\n    CFG_PIN_C11 = 361,\n    CFG_PIN_C12 = 362,\n    CFG_PIN_C13 = 363,\n    CFG_PIN_C14 = 364,\n    CFG_PIN_C15 = 365,\n    CFG_PIN_C16 = 366,\n    CFG_PIN_C17 = 367,\n    CFG_PIN_C18 = 368,\n    CFG_PIN_C19 = 369,\n    CFG_PIN_C20 = 370,\n    CFG_PIN_C21 = 371,\n    CFG_PIN_C22 = 372,\n    CFG_PIN_C23 = 373,\n    CFG_PIN_C24 = 374,\n    CFG_PIN_C25 = 375,\n    CFG_PIN_C26 = 376,\n    CFG_PIN_C27 = 377,\n    CFG_PIN_C28 = 378,\n    CFG_PIN_C29 = 379,\n    CFG_PIN_C30 = 380,\n    CFG_PIN_C31 = 381,\n    CFG_PIN_P0 = 400,\n    CFG_PIN_P1 = 401,\n    CFG_PIN_P2 = 402,\n    CFG_PIN_P3 = 403,\n    CFG_PIN_P4 = 404,\n    CFG_PIN_P5 = 405,\n    CFG_PIN_P6 = 406,\n    CFG_PIN_P7 = 407,\n    CFG_PIN_P8 = 408,\n    CFG_PIN_P9 = 409,\n    CFG_PIN_P10 = 410,\n    CFG_PIN_P11 = 411,\n    CFG_PIN_P12 = 412,\n    CFG_PIN_P13 = 413,\n    CFG_PIN_P14 = 414,\n    CFG_PIN_P15 = 415,\n    CFG_PIN_P16 = 416,\n    CFG_PIN_P17 = 417,\n    CFG_PIN_P18 = 418,\n    CFG_PIN_P19 = 419,\n    CFG_PIN_P20 = 420,\n    CFG_PIN_LORA_MISO = 1001,\n    CFG_PIN_LORA_MOSI = 1002,\n    CFG_PIN_LORA_SCK = 1003,\n    CFG_PIN_LORA_CS = 1004,\n    CFG_PIN_LORA_BOOT = 1005,\n    CFG_PIN_LORA_RESET = 1006,\n    CFG_PIN_IRRXLED = 1007,\n    CFG_PIN_IRTXLED = 1008,\n    CFG_PIN_LCD_RESET = 1009,\n    CFG_PIN_LCD_ENABLE = 1010,\n    CFG_PIN_LCD_DATALINE4 = 1011,\n    CFG_PIN_LCD_DATALINE5 = 1012,\n    CFG_PIN_LCD_DATALINE6 = 1013,\n    CFG_PIN_LCD_DATALINE7 = 1014,\n    CFG_NUM_LCD_COLUMNS = 1015,\n    CFG_NUM_LCD_ROWS = 1016,\n    // /pxtapp/hf2dbg.h\n    HF2DBG_H = 1,\n    // /pxtapp/mixer---samd/melody.h\n    SW_TRIANGLE = 1,\n    SW_SAWTOOTH = 2,\n    SW_SINE = 3,\n    SW_NOISE = 4,\n    SW_REAL_NOISE = 5,\n    SW_SQUARE_10 = 11,\n    SW_SQUARE_50 = 15,\n    CODAL = 1,\n    MAX_SOUNDS = 5,\n    Waiting = 0,\n    Playing = 1,\n    Done = 2,\n    // /pxtapp/pins.h\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    // /pxtapp/platform.h\n    PAGE_SIZE = 512,\n    DEV_NUM_PINS = 64,\n    PXT_74HC165 = 1,\n    IMAGE_BITS = 4,\n    PA00 = 0,\n    PA01 = 1,\n    PA02 = 2,\n    PA03 = 3,\n    PA04 = 4,\n    PA05 = 5,\n    PA06 = 6,\n    PA07 = 7,\n    PA08 = 8,\n    PA09 = 9,\n    PA10 = 10,\n    PA11 = 11,\n    PA12 = 12,\n    PA13 = 13,\n    PA14 = 14,\n    PA15 = 15,\n    PA16 = 16,\n    PA17 = 17,\n    PA18 = 18,\n    PA19 = 19,\n    PA20 = 20,\n    PA21 = 21,\n    PA22 = 22,\n    PA23 = 23,\n    PA24 = 24,\n    PA25 = 25,\n    PA26 = 26,\n    PA27 = 27,\n    PA28 = 28,\n    PA29 = 29,\n    PA30 = 30,\n    PA31 = 31,\n    PB00 = 32,\n    PB01 = 33,\n    PB02 = 34,\n    PB03 = 35,\n    PB04 = 36,\n    PB05 = 37,\n    PB06 = 38,\n    PB07 = 39,\n    PB08 = 40,\n    PB09 = 41,\n    PB10 = 42,\n    PB11 = 43,\n    PB12 = 44,\n    PB13 = 45,\n    PB14 = 46,\n    PB15 = 47,\n    PB16 = 48,\n    PB17 = 49,\n    PB18 = 50,\n    PB19 = 51,\n    PB20 = 52,\n    PB21 = 53,\n    PB22 = 54,\n    PB23 = 55,\n    PB24 = 56,\n    PB25 = 57,\n    PB26 = 58,\n    PB27 = 59,\n    PB28 = 60,\n    PB29 = 61,\n    PB30 = 62,\n    PB31 = 63,\n    // /pxtapp/pxt.h\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    // /pxtapp/pxtbase.h\n    PXT_REFCNT_FLASH = 65534,\n    VTABLE_MAGIC = 249,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    BoxedString = 1,\n    BoxedNumber = 2,\n    BoxedBuffer = 3,\n    RefAction = 4,\n    RefImage = 5,\n    RefCollection = 6,\n    RefRefLocal = 7,\n    RefMap = 8,\n    RefMImage = 9,\n    User0 = 16,\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    GC = 0,\n    // /pxtapp/pxtconfig.h\n    PXT_GC = 1,\n    PXT_UF2_FAMILY = 1760373640,\n    // /pxtapp/storage/SNORFS.h\n    DEVICE_FLASH_ERROR = 950,\n    // /pxtapp/thermometer/target_temperature.h\n    TEMPERATURE_NOMINAL_VALUE = 25,\n    TEMPERATURE_NOMINAL_READING = 10000,\n    TEMPERATURE_BETA = 3380,\n    TEMPERATURE_SERIES_RESISTOR = 10000,\n    // /pxtapp/uf2format.h\n    BOOTLOADER_START = 0,\n    // /pxtapp/uf2hid.h\n    UF2_HID_H = 1,\n}\n",
            "dmac.cpp": "#include \"dmac.h\"\n\nnamespace pxt {\n\n#ifdef CODAL_DMAC\nSINGLETON(WDMAC);\n#endif\n\n}",
            "dmac.h": "#ifndef __DMAC_H\n#define __DMAC_H\n\n#include \"pxt.h\"\n\nnamespace pxt {\n\n#ifdef CODAL_DMAC\nclass WDMAC {\n  public:\n    CODAL_DMAC dmac;\n\n    WDMAC() {}\n};\n\nWDMAC* getWDMAC();\n#endif\n\n}\n\n#endif",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=\"pulse low\"\n    PulseLow = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    //% block=\"rise\"\n    Rise = 2,  // DEVICE_PIN_EVT_RISE\n    //% block=\"fall\"\n    Fall = 3,  // DEVICE_PIN_EVT_FALL\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "hf2.cpp": "#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#ifndef USB_HANDOVER\n#define USB_HANDOVER 1\n#endif\n\n#if USB_HANDOVER\n#define UF2_DEFINE_HANDOVER 1\n#endif\n\n#include \"uf2format.h\"\n\nstatic void *stackCopy;\nstatic uint32_t stackSize;\n\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\nstatic volatile bool resume = false;\n\nusing namespace codal;\n\n#ifdef HF2_HID\nstatic const char hidDescriptor[] = {\n    0x06, 0x97, 0xFF, // usage page vendor 0x97 (usage 0xff97 0x0001)\n    0x09, 0x01,       // usage 1\n    0xA1, 0x01,       // collection - application\n    0x15, 0x00,       // logical min 0\n    0x26, 0xFF, 0x00, // logical max 255\n    0x75, 8,          // report size 8\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x81, 0x02,       // input: data, variable, absolute\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x91, 0x02,       // output: data, variable, absolute\n    0x95, 1,          // report count 1\n    0x09, 0x01,       // usage 1\n    0xB1, 0x02,       // feature: data, variable, absolute\n    0xC0,             // end\n};\n\nstatic const HIDReportDescriptor reportDesc = {\n    9,\n    0x21,                  // HID\n    0x100,                 // hidbcd 1.00\n    0x00,                  // country code\n    0x01,                  // num desc\n    0x22,                  // report desc type\n    sizeof(hidDescriptor), // size of 0x22\n};\n\nstatic const InterfaceInfo ifaceInfoHID = {\n    &reportDesc,\n    sizeof(reportDesc),\n    1,\n    {\n        2,    // numEndpoints\n        0x03, /// class code - HID\n        0x00, // subclass\n        0x00, // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n#endif\n\nstatic const InterfaceInfo ifaceInfoEP = {\n    NULL,\n    0,\n    2,\n    {\n        2,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        42,   // subclass\n        1,    // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {USB_EP_TYPE_BULK, 0},\n    {USB_EP_TYPE_BULK, 0},\n};\n\nint HF2::stdRequest(UsbEndpointIn &ctrl, USBSetup &setup) {\n#ifdef HF2_HID\n    if (!useHID)\n        return DEVICE_NOT_SUPPORTED;\n    if (setup.bRequest == USB_REQ_GET_DESCRIPTOR) {\n        if (setup.wValueH == 0x21) {\n            InterfaceDescriptor tmp;\n            fillInterfaceInfo(&tmp);\n            return ctrl.write(&tmp, sizeof(tmp));\n        } else if (setup.wValueH == 0x22) {\n            return ctrl.write(hidDescriptor, sizeof(hidDescriptor));\n        }\n    }\n#endif\n    return DEVICE_NOT_SUPPORTED;\n}\n\n// same as in microbit\n#define CTRL_GET_REPORT 0x01\n#define CTRL_SET_REPORT 0x09\n#define CTRL_OUT_REPORT_H 0x2\n#define CTRL_IN_REPORT_H 0x1\n\nvoid HF2::sendBuffer(uint8_t flag, const void *data, unsigned size, uint32_t prepend) {\n    if (!CodalUSB::usbInstance->isInitialised())\n        return;\n\n    uint32_t buf[64 / 4]; // aligned\n\n    if (prepend + 1)\n        size += 4;\n\n    target_disable_irq();\n    while (size > 0) {\n        memset(buf + 1, 0, 60);\n        int s = 63;\n        if (size <= 63) {\n            s = size;\n            buf[0] = flag;\n        } else {\n            buf[0] = flag == HF2_FLAG_CMDPKT_LAST ? HF2_FLAG_CMDPKT_BODY : flag;\n        }\n        buf[0] |= s;\n        uint8_t *dst = (uint8_t *)buf;\n        dst++;\n        if (prepend + 1) {\n            memcpy(dst, &prepend, 4);\n            prepend = -1;\n            dst += 4;\n            s -= 4;\n            size -= 4;\n        }\n        memcpy(dst, data, s);\n        data = (const uint8_t *)data + s;\n        size -= s;\n\n        in->write(buf, sizeof(buf));\n    }\n    target_enable_irq();\n}\n\nconst InterfaceInfo *HF2::getInterfaceInfo() {\n#ifdef HF2_HID\n    if (useHID)\n        return &ifaceInfoHID;\n#endif\n    return &ifaceInfoEP;\n}\n\nint HF2::sendEvent(uint32_t evId, const void *data, int size) {\n    sendBuffer(HF2_FLAG_CMDPKT_LAST, data, size, evId);\n    return 0;\n}\n\nint HF2::sendSerial(const void *data, int size, int isError) {\n    if (!gotSomePacket)\n        return DEVICE_OK;\n\n    sendBuffer(isError ? HF2_FLAG_SERIAL_ERR : HF2_FLAG_SERIAL_OUT, data, size);\n\n    return 0;\n}\n\n// Receive HF2 message\n// Does not block. Will store intermediate data in pkt.\n// `serial` flag is cleared if we got a command message.\nint HF2::recv() {\n    uint8_t buf[64];\n\n    int len = out->read(buf, sizeof(buf));\n    // DMESG(\"HF2 read: %d\", len);\n\n    if (len <= 0)\n        return len;\n\n    uint8_t tag = buf[0];\n    // serial packets not allowed when in middle of command packet\n    usb_assert(pkt.size == 0 || !(tag & HF2_FLAG_SERIAL_OUT));\n    int size = tag & HF2_SIZE_MASK;\n    usb_assert(pkt.size + size <= (int)sizeof(pkt.buf));\n    memcpy(pkt.buf + pkt.size, buf + 1, size);\n    pkt.size += size;\n    tag &= HF2_FLAG_MASK;\n    if (tag != HF2_FLAG_CMDPKT_BODY) {\n        if (tag == HF2_FLAG_CMDPKT_LAST)\n            pkt.serial = 0;\n        else if (tag == HF2_FLAG_SERIAL_OUT)\n            pkt.serial = 1;\n        else\n            pkt.serial = 2;\n        int sz = pkt.size;\n        pkt.size = 0;\n        return sz;\n    }\n    return 0;\n}\n\nint HF2::sendResponse(int size) {\n    sendBuffer(HF2_FLAG_CMDPKT_LAST, pkt.buf, 4 + size);\n    return 0;\n}\n\nint HF2::sendResponseWithData(const void *data, int size) {\n    if (size <= (int)sizeof(pkt.buf) - 4) {\n        memcpy(pkt.resp.data8, data, size);\n        return sendResponse(size);\n    } else {\n        sendBuffer(HF2_FLAG_CMDPKT_LAST, data, size, pkt.resp.eventId);\n        return 0;\n    }\n}\n\nstatic void copy_words(void *dst0, const void *src0, uint32_t n_words) {\n    uint32_t *dst = (uint32_t *)dst0;\n    const uint32_t *src = (const uint32_t *)src0;\n    while (n_words--)\n        *dst++ = *src++;\n}\n\n#ifndef QUICK_BOOT\n#ifdef SAMD21\n#define DBL_TAP_PTR ((volatile uint32_t *)(HMCRAMC0_ADDR + HMCRAMC0_SIZE - 4))\n#endif\n#ifdef SAMD51\n#define DBL_TAP_PTR ((volatile uint32_t *)(HSRAM_ADDR + HSRAM_SIZE - 4))\n#endif\n#define DBL_TAP_MAGIC_QUICK_BOOT 0xf02669ef\n#define QUICK_BOOT(v) *DBL_TAP_PTR = v ? DBL_TAP_MAGIC_QUICK_BOOT : 0\n#endif\n\nstatic HF2 *jdLogger;\nstatic void jdLog(const uint8_t *frame) {\n    jdLogger->sendEvent(HF2_EV_JDS_PACKET, frame, frame[2] + 12);\n}\n\nint HF2::endpointRequest() {\n    int sz = recv();\n\n    if (!sz)\n        return 0;\n\n    uint32_t tmp;\n\n    if (pkt.serial) {\n        // TODO raise some event?\n        return 0;\n    }\n\n    LOG(\"HF2 sz=%d CMD=%x\", sz, pkt.buf32[0]);\n\n    // one has to be careful dealing with these, as they share memory\n    HF2_Command *cmd = &pkt.cmd;\n    HF2_Response *resp = &pkt.resp;\n\n    uint32_t cmdId = cmd->command_id;\n    resp->tag = cmd->tag;\n    resp->status16 = HF2_STATUS_OK;\n\n#define checkDataSize(str, add) usb_assert(sz == 8 + (int)sizeof(cmd->str) + (int)(add))\n\n    lastExchange = current_time_ms();\n    gotSomePacket = true;\n\n    switch (cmdId) {\n    case HF2_CMD_INFO:\n        return sendResponseWithData(uf2_info(), strlen(uf2_info()));\n\n    case HF2_CMD_BININFO:\n        resp->bininfo.mode = HF2_MODE_USERSPACE;\n        resp->bininfo.flash_page_size = 0;\n        resp->bininfo.flash_num_pages = 0;\n        resp->bininfo.max_message_size = sizeof(pkt.buf);\n        resp->bininfo.uf2_family = PXT_UF2_FAMILY;\n        return sendResponse(sizeof(resp->bininfo));\n\n    case HF2_DBG_RESTART:\n        *HF2_DBG_MAGIC_PTR = HF2_DBG_MAGIC_START;\n        target_reset();\n        break;\n\n    case HF2_CMD_RESET_INTO_APP:\n        QUICK_BOOT(1);\n        NVIC_SystemReset();\n        break;\n    case HF2_CMD_RESET_INTO_BOOTLOADER:\n        QUICK_BOOT(0);\n        NVIC_SystemReset();\n        break;\n\n#if USB_HANDOVER\n    case HF2_CMD_START_FLASH:\n        sendResponse(0);\n        hf2_handover(in->ep);\n        usb_assert(0); // should not be reached\n        break;\n#endif\n\n    case HF2_CMD_WRITE_WORDS:\n        checkDataSize(write_words, cmd->write_words.num_words << 2);\n        copy_words((void *)cmd->write_words.target_addr, cmd->write_words.words,\n                   cmd->write_words.num_words);\n        break;\n\n    case HF2_CMD_READ_WORDS:\n        checkDataSize(read_words, 0);\n        tmp = cmd->read_words.num_words;\n        usb_assert(tmp <= sizeof(pkt.buf) / 4 - 1);\n        copy_words(resp->data32, (void *)cmd->read_words.target_addr, tmp);\n        return sendResponse(tmp << 2);\n\n    case HF2_CMD_DMESG:\n#if DEVICE_DMESG_BUFFER_SIZE > 0\n        return sendResponseWithData(codalLogStore.buffer, codalLogStore.ptr);\n#else\n        break;\n#endif\n\n    case HF2_DBG_GET_GLOBAL_STATE: {\n        HF2_GLOBAL_STATE_Result gstate = {\n            .num_globals = (uint32_t)getNumGlobals(), //\n            .globals_addr = (uint32_t)globals,\n        };\n        return sendResponseWithData(&gstate, sizeof(gstate));\n    }\n\n    case HF2_DBG_RESUME:\n        globals[0] = (TValue)cmd->data32[0];\n        resume = true;\n        return sendResponse(0);\n\n    case HF2_DBG_GET_STACK:\n        return sendResponseWithData(stackCopy, stackSize);\n\n    case HF2_CMD_JDS_CONFIG:\n        if (cmd->data8[0]) {\n            jdLogger = this;\n            pxt::logJDFrame = jdLog;\n        } else {\n            pxt::logJDFrame = NULL;\n        }\n        return sendResponse(0);\n\n    case HF2_CMD_JDS_SEND:\n        if (pxt::sendJDFrame) {\n            pxt::sendJDFrame(cmd->data8);\n            return sendResponse(0);\n        } else {\n            resp->status16 = HF2_STATUS_INVALID_STATE;\n            return sendResponse(0);\n        }\n\n    default:\n        // command not understood\n        resp->status16 = HF2_STATUS_INVALID_CMD;\n        break;\n    }\n\n    return sendResponse(0);\n}\n\nHF2::HF2(HF2_Buffer &p) : gotSomePacket(false), ctrlWaiting(false), pkt(p), useHID(false) {\n    lastExchange = 0;\n}\n\nstatic const InterfaceInfo dummyIfaceInfo = {\n    NULL,\n    0,\n    0,\n    {\n        0,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        0xff, // subclass\n        0xff, // protocol\n        0x00, // string\n        0x00, // alt\n    },\n    {0, 0},\n    {0, 0},\n};\n\nconst InterfaceInfo *DummyIface::getInterfaceInfo() {\n    return &dummyIfaceInfo;\n}\n\n//\n//\n// Debugger\n//\n//\n\nstruct ExceptionContext {\n    uint32_t excReturn; // 0xFFFFFFF9\n    uint32_t r0;\n    uint32_t r1;\n    uint32_t r2;\n    uint32_t r3;\n    uint32_t r12;\n    uint32_t lr;\n    uint32_t faultInstrAddr;\n    uint32_t psr;\n};\n\nstruct Paused_Data {\n    uint32_t pc;\n};\nstatic Paused_Data pausedData;\n\nvoid bkptPaused() {\n\n// waiting for https://github.com/lancaster-university/codal/pull/14\n#ifdef DEVICE_GROUP_ID_USER\n    // the loop below counts as \"system\" task, and we don't want to pause ourselves\n    fiber_set_group(DEVICE_GROUP_ID_SYSTEM);\n    // pause everyone else\n    fiber_pause_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    while (!resume) {\n        // DMESG(\"BKPT\");\n        hf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        hf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        // TODO use an event\n        for (int i = 0; i < 20; ++i) {\n            if (resume)\n                break;\n            fiber_sleep(50);\n        }\n    }\n\n    if (stackCopy) {\n        xfree(stackCopy);\n        stackCopy = NULL;\n    }\n\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_resume_group(DEVICE_GROUP_ID_USER);\n    // go back to user mode\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    resume = false;\n}\n\nextern \"C\" void handleHardFault(ExceptionContext *ectx) {\n    auto instr = (uint16_t *)ectx->faultInstrAddr;\n\n    DMESG(\"FLT %p\", instr);\n\n    if (ectx->faultInstrAddr & 0x80000000) {\n        ectx->faultInstrAddr &= ~0x80000000;\n        // switch to step-over mode\n        globals[0] = (TValue)3;\n        return;\n    }\n\n    DMESG(\"BB %p %p %p lr=%p r0=%p\", instr[-1], instr[0], instr[1], ectx->lr, ectx->r0);\n\n    if (instr[0] == 0x6840) {\n        // ldr r0, [r0, #4] -- entry breakpoint\n        ectx->faultInstrAddr += 2;\n        // we're being ask for step-over mode\n        if (ectx->r0 == 3) {\n            // switch to debugger-attached-no-stepping mode\n            globals[0] = (TValue)0;\n            ectx->lr |= 0x80000000;\n        }\n        return;\n    }\n\n    if (instr[0] == 0x6800) {\n        // ldr r0, [r0, #0]\n        ectx->lr = ectx->faultInstrAddr + 3; // next instruction + thumb mode\n        pausedData.pc = ectx->faultInstrAddr + 2;\n        void *ssp = (void *)(ectx + 1);\n        stackSize = DEVICE_STACK_BASE - (uint32_t)ssp;\n        if (stackCopy)\n            xfree(stackCopy);\n        stackCopy = xmalloc(stackSize);\n        memcpy(stackCopy, ssp, stackSize);\n        ectx->faultInstrAddr = ((uint32_t)(&bkptPaused) & (~1U));\n        return;\n    }\n\n    while (1) {\n    }\n}\n\nextern \"C\" void HardFault_Handler(void) {\n    asm(\"push {lr}; mov r0, sp; bl handleHardFault; pop {pc}\");\n}\n\n#endif",
            "hf2.h": "#ifndef DEVICE_HF2_H\n#define DEVICE_HF2_H\n\n#if CONFIG_ENABLED(DEVICE_USB)\n\n#include \"HID.h\"\n#include \"uf2hid.h\"\n\n// 260 bytes needed for biggest JD packets (with overheads)\n#define HF2_BUF_SIZE 260\n\ntypedef struct {\n    uint16_t size;\n    uint8_t serial;\n    union {\n        uint8_t buf[HF2_BUF_SIZE];\n        uint32_t buf32[HF2_BUF_SIZE / 4];\n        uint16_t buf16[HF2_BUF_SIZE / 2];\n        HF2_Command cmd;\n        HF2_Response resp;\n    };\n} HF2_Buffer;\n\nclass HF2 : public CodalUSBInterface {\n    bool gotSomePacket;\n    bool ctrlWaiting;\n    uint32_t lastExchange;\n\n  public:\n    HF2_Buffer &pkt;\n\n    bool useHID;\n\n    int sendResponse(int size);\n    int recv();\n    int sendResponseWithData(const void *data, int size);\n    int sendEvent(uint32_t evId, const void *data, int size);\n    void sendBuffer(uint8_t flag, const void *data, unsigned size, uint32_t prepend = -1);\n\n    HF2(HF2_Buffer &pkt);\n    virtual int endpointRequest();\n    virtual int stdRequest(UsbEndpointIn &ctrl, USBSetup &setup);\n    virtual const InterfaceInfo *getInterfaceInfo();\n    int sendSerial(const void *data, int size, int isError = 0);\n\n    virtual bool enableWebUSB() { return !useHID; }\n};\n\nclass DummyIface : public CodalUSBInterface {\n  public:\n    virtual const InterfaceInfo *getInterfaceInfo();\n};\n\n#endif\n\n#endif\n",
            "hf2dbg.h": "#ifndef HF2DBG_H\n#define HF2DBG_H 1\n\n// we use a location at the top of the stack to store a magic value\n// which causes us to stop at the very first break point in the program\n#define HF2_DBG_MAGIC_PTR ((uint32_t *)(DEVICE_STACK_BASE - (DEVICE_STACK_SIZE - 4)))\n#define HF2_DBG_MAGIC_START 0xf0ebac7f\n\n#define HF2_DBG_GET_GLOBAL_STATE 0x53fc66e0\nstruct HF2_GLOBAL_STATE_Result {\n    uint32_t num_globals;\n    uint32_t globals_addr;\n};\n\n#define HF2_DBG_RESTART 0x1120bd93\n#define HF2_DBG_RESUME 0x27a55931\n#define HF2_EV_DBG_PAUSED 0x3692f9fd\n#define HF2_DBG_GET_STACK 0x70901510\n\n#endif\n",
            "i2c.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n#include \"CodalDmesg.h\"\n#include \"configkeys.h\"\n\n#ifdef CODAL_I2C\n\nnamespace pins {\n\nclass CodalI2CProxy {\nprivate:\n  DevicePin* sda;\n  DevicePin* scl;\n  CODAL_I2C i2c;\npublic:\n  CodalI2CProxy* next;\npublic:\n  CodalI2CProxy(DevicePin* _sda, DevicePin* _scl)\n    : sda(_sda)\n    , scl(_scl)\n    , i2c(*_sda, *_scl) \n    , next(NULL)\n  {\n\n  }\n\n  CODAL_I2C* getI2C() {\n    return &(this->i2c);\n  }\n  \n  bool matchPins(DevicePin* sda, DevicePin* scl) {\n      return this->sda == sda && this->scl == scl;\n  }\n\n  Buffer readBuffer(int address, int size, bool repeat = false)\n  {\n    Buffer buf = mkBuffer(NULL, size);\n    registerGCObj(buf);\n    int status = this->i2c.read(address << 1, buf->data, size, repeat);\n    unregisterGCObj(buf);\n    if (status != ErrorCode::DEVICE_OK) {\n      buf = 0;\n    }\n    return buf;\n  }\n\n  int writeBuffer(int address, Buffer buf, bool repeat = false)\n  {\n    return this->i2c.write(address << 1, buf->data, buf->length, repeat);\n  }\n};\n\n}\n\nnamespace I2CMethods {\n/**\n  * Read `size` bytes from a 7-bit I2C `address`.\n  */\n//%\nBuffer readBuffer(I2C_ i2c, int address, int size, bool repeat = false)\n{\n  return i2c->readBuffer(address, size, repeat);\n}\n\n/**\n  * Write bytes to a 7-bit I2C `address`.\n  */\n//%\nint writeBuffer(I2C_ i2c, int address, Buffer buf, bool repeat = false)\n{\n  return i2c->writeBuffer(address, buf, repeat);\n}\n\n}\n\nnamespace pins {\n\nstatic I2C_ i2cs(NULL);\n/**\n* Opens a Serial communication driver\n*/\n//% help=pins/create-i2c\n//% parts=i2c\nI2C_ createI2C(DigitalInOutPin sda, DigitalInOutPin scl) {\n  // pick up defaults\n  if (!sda || !scl) {\n    DMESG(\"i2c: lookup default pins\");\n    sda = LOOKUP_PIN(SDA);\n    scl = LOOKUP_PIN(SCL);\n  }\n\n  // lookup existing devices\n  auto dev = i2cs;\n  while(dev) {\n    if (dev->matchPins(sda, scl)) {\n      DMESG(\"i2c: found existing i2c\");\n      return dev;\n    }\n    dev = dev->next;\n  }\n\n  // allocate new one\n  DMESG(\"i2c: mounting on new device\");\n  auto ser = new CodalI2CProxy(sda, scl);\n  // push in list\n  ser->next = i2cs;\n  i2cs = ser;\n  return ser;\n}\n\n}\n\nnamespace pxt {\n  CODAL_I2C* getI2C(DigitalInOutPin sda, DigitalInOutPin scl) {\n    auto i2c = pins::createI2C(sda, scl);\n    return i2c->getI2C();\n  }\n}\n\n#endif",
            "i2c.ts": "namespace pins {\n    /**\n     * Read one number from an I2C address.\n     */\n    //% help=pins/i2c-read-number weight=5 group=\"i2c\" inlineInputMode=\"external\"\n    //% blockId=pins_i2c_readnumber block=\"i2c read number at address %address|of format %format|repeated %repeated\"\n    export function i2cReadNumber(address: number, format: NumberFormat, repeated?: boolean): number {\n        const buf = pins.i2cReadBuffer(address, pins.sizeOf(format), repeated)\n        if (!buf)\n            return undefined\n        return buf.getNumber(format, 0)\n    }\n\n    /**\n     * Write one number to an I2C address.\n     */\n    //% help=pins/i2c-write-number weight=4 group=\"i2c\"\n    //% blockId=i2c_writenumber block=\"i2c write number|at address %address|with value %value|of format %format|repeated %repeated\"\n    export function i2cWriteNumber(address: number, value: number, format?: NumberFormat, repeated?: boolean): void {\n        if (format == undefined)\n            format = NumberFormat.UInt8LE;\n        const buf = control.createBuffer(pins.sizeOf(format))\n        buf.setNumber(format, 0, value)\n        pins.i2cWriteBuffer(address, buf, repeated)\n    }\n\n    /**\n     * Write a value in a I2C register.\n     * @param address I2c address of the device\n     * @param register register index\n     * @param value value to write\n     * @param valueFormat format of the value, default is UInt8LE\n     */\n    //% weight=3 group=\"i2c\"\n    //% help=pins/i2c-write-register\n    //% blockId=i2c_writereg block=\"i2c write register|at address $address|at register $register|value $value\"\n    export function i2cWriteRegister(address: number, register: number, value: number, valueFormat?: NumberFormat): void {\n        if (valueFormat === undefined)\n            valueFormat = NumberFormat.UInt8LE;\n        const valueSize = pins.sizeOf(valueFormat);\n        const buf = control.createBuffer(1 + valueSize);\n        buf.setNumber(NumberFormat.UInt8LE, 0, register);\n        buf.setNumber(valueFormat, 1, value);\n        pins.i2cWriteBuffer(address, buf);\n    }\n\n    /**\n     * Read the value from a I2C register.\n     * @param address I2c address of the device\n     * @param register register index\n     * @param valueFormat format of the value, default is UInt8LE\n     */\n    //% weight=3 group=\"i2c\"\n    //% help=pins/i2c-read-register\n    //% blockId=i2c_readreg block=\"i2c read register|at address $address|at register $register\"\n    export function i2cReadRegister(address: number, register: number, valueFormat?: NumberFormat): number {\n        if (valueFormat === undefined)\n            valueFormat = NumberFormat.UInt8LE;\n        pins.i2cWriteNumber(address, register, NumberFormat.UInt8LE);\n        return pins.i2cReadNumber(address, valueFormat);\n    }\n\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //%\n    export function i2cReadBuffer(address: number, size: number, repeat: boolean = false): Buffer {\n        return pins.i2c().readBuffer(address, size, repeat);\n    }\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //%\n    export function i2cWriteBuffer(address: number, buf: Buffer, repeat: boolean = false): number {\n        return pins.i2c().writeBuffer(address, buf, repeat);\n    }\n\n    let _i2c: I2C;\n    /**\n     * Gets the default I2C bus\n     */\n    //%\n    export function i2c(): I2C {\n        if (!_i2c) {\n            const sda = pins.pinByCfg(DAL.CFG_PIN_SDA);\n            const scl = pins.pinByCfg(DAL.CFG_PIN_SCL);\n            _i2c = pins.createI2C(sda, scl);    \n        }\n        return _i2c;        \n    }\n\n    export class I2CDevice {\n        public address: number;\n        public bus: I2C;\n        private _hasError: boolean;\n        constructor(address: number, bus?: I2C) {\n            this.address = address;\n            this.bus = bus || i2c();\n        }\n        public readInto(buf: Buffer, repeat = false, start = 0, end: number = null) {\n            if (end === null)\n                end = buf.length\n            if (start >= end)\n                return\n            let res = this.bus.readBuffer(this.address, end - start, repeat)\n            if (!res) {\n                this._hasError = true\n                return\n            }\n            buf.write(start, res)\n        }\n        public write(buf: Buffer, repeat = false) {\n            let res = this.bus.writeBuffer(this.address, buf, repeat)\n            if (res) {\n                this._hasError = true\n            }\n        }\n        public begin(): I2CDevice {\n            this._hasError = false;\n            return this;\n        }\n        public end() {\n        }\n        public ok() {\n            return !this._hasError\n        }\n\n        public transfer(command: Buffer, response: Buffer, responseStart?: number, responseEnd?: number) {\n            this.begin();\n            if (command)\n                this.write(command);\n            if (response)\n                this.readInto(response, false, responseStart, responseEnd);\n            this.end();\n        }    \n    }\n}\n",
            "keyvaluestorage.cpp": "#include \"pxt.h\"\n#include \"KeyValueStorage.h\"\n\nnamespace pxt {\n\nclass WKeyValueStorage {\n#ifdef CODAL_NVMCONTROLLER\n    CODAL_NVMCONTROLLER controller;\n#else\n    NVMController controller;\n#endif\n    KeyValueStorage storage;\n  public:\n\n    WKeyValueStorage()\n    : controller()\n    , storage(controller) {\n    }\n\n    bool isSupported() {\n#ifdef CODAL_NVMCONTROLLER\n      return true;\n#else\n      return false;\n#endif\n    }\n\n    int put(String key, Buffer data) {\n#ifdef CODAL_NVMCONTROLLER\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        return storage.put(mkey, data->data, data->length);\n#else\n        return -1;\n#endif\n    }\n\n    Buffer get(String key) {\n#ifdef CODAL_NVMCONTROLLER\n        Buffer buf = NULL;\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        auto entry = storage.get(mkey);\n        if (entry) {\n          buf = mkBuffer(entry->value, sizeof(entry->value));\n          free(entry);\n        }\n        return buf;\n#else\n        return NULL;\n#endif\n    }\n\n    void remove(String key) {\n#ifdef CODAL_NVMCONTROLLER\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        storage.remove(mkey);\n#endif\n    }\n\n    void clear() {\n#ifdef CODAL_NVMCONTROLLER\n        storage.wipe();\n#endif\n    }\n};\nSINGLETON(WKeyValueStorage);\n\n}\n\nnamespace configStorage {\n  /**\n  * Puts an entry in the device storage. Key may have up to 16 characters (bytes).\n  * @param key the identifier (max 16 characters)\n  * @param value the data (max 32 characters)\n  */\n  //%\n  void setBuffer(String key, Buffer value) {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->put(key, value);\n  }\n\n  /**\n  * Gets an entry from the device storage. Key may have up to 16 characters (bytes).\n  * @param key the identifier (max 16 characters)\n  */\n  //%\n  Buffer getBuffer(String key) {\n    auto kvm = pxt::getWKeyValueStorage();\n    return kvm->get(key);\n  }\n\n  /**\n  * Removes the key from local storage\n  * @param key the identifier (max 16 characters)\n  */\n  //%\n  void removeItem(String key) {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->remove(key);\n  }\n\n  /**\n  * Clears the local storage\n  */\n  //%\n  void clear() {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->clear();\n  }\n}\n",
            "keyvaluestorage.ts": "namespace configStorage {\n    /**\n     * Stores the value at the key entry\n     * @param key identifier of the key (max 16 characters)\n     * @param value identifier of the value (max 32 characters)\n     */\n    export function setItem(key: string, value: string) {\n        if (value == null)\n            configStorage.removeItem(key);\n        else\n        {\n            let idx = 0;\n            let buf = control.createBuffer(value.length + 1);\n            buf[idx++] = value.length;\n            let valBuf = control.createBufferFromUTF8(value);\n\n            for (let i = 0; i < valBuf.length; i++)\n                buf[idx++] = valBuf[i];\n\n            configStorage.setBuffer(key, buf);\n        }\n    }\n\n    /**\n     * Retrieves the value at the key entry\n     * @param key identifier of the key (max 16 characters)\n     */\n    export function getItem(key: string): string {\n        const buf = configStorage.getBuffer(key);\n\n        if (!buf)\n            return undefined;\n\n        let idx = 0;\n        let count = buf[idx++];\n        const retBuf = control.createBuffer(count);\n\n        for (let i = 0; i < count; i++)\n            retBuf[i] = buf[idx++];\n\n        return retBuf.toString();\n    }\n}\n",
            "leveldetector.ts": "namespace pins {\n    export class LevelDetector {\n        public id: number;\n        public min: number;\n        public max: number;\n        public lowThreshold: number;\n        public highThreshold: number;\n        private transition: number;\n        private transitionMs: number;\n        private _level: number;\n        private _state: number;\n        public onHigh: () => void;\n        public onLow: () => void;\n        public onNeutral: () => void;\n        public transitionWindow: number;\n        // minimum duration (ms) between events\n        public transitionInterval: number;\n\n        static LEVEL_THRESHOLD_NEUTRAL = 0;\n\n        constructor(id: number,\n            min: number, max: number,\n            lowThreshold: number, highThreshold: number) {\n            this.id = id;\n            this.min = min;\n            this.max = max;\n            this.lowThreshold = lowThreshold;\n            this.highThreshold = highThreshold;\n            this.transitionWindow = 4;\n            this.transitionInterval = 0;\n\n            this.onHigh = () => control.raiseEvent(this.id, DAL.LEVEL_THRESHOLD_HIGH);\n            this.onLow = () => control.raiseEvent(this.id, DAL.LEVEL_THRESHOLD_LOW);\n            this.onNeutral = undefined;\n\n            this.reset();\n        }\n\n        reset() {\n            this.transition = 0;\n            this.transitionMs = 0;\n            this._level = Math.ceil((this.highThreshold - this.lowThreshold) / 2);\n            this._state = LevelDetector.LEVEL_THRESHOLD_NEUTRAL;\n        }\n\n        get level(): number {\n            return this._level;\n        }\n\n        set level(level: number) {\n            this._level = this.clampValue(level);\n\n            if (this._level >= this.highThreshold) {\n                this.setState(DAL.LEVEL_THRESHOLD_HIGH);\n            }\n            else if (this._level <= this.lowThreshold) {\n                this.setState(DAL.LEVEL_THRESHOLD_LOW);\n            }\n            else {\n                this.setState(LevelDetector.LEVEL_THRESHOLD_NEUTRAL);\n            }\n        }\n\n        public setLowThreshold(value: number) {\n            this.lowThreshold = this.clampValue(value);\n            this.reset();\n        }\n\n        public setHighThreshold(value: number) {\n            this.highThreshold = this.clampValue(value);\n            this.reset();\n        }\n\n        private clampValue(value: number) {\n            if (value < this.min) {\n                return this.min;\n            }\n            else if (value > this.max) {\n                return this.max;\n            }\n            return value;\n        }\n\n        private setState(state: number) {\n            // not enough samples to change\n            if (this._state === state \n                || (this.transition++ < this.transitionWindow)\n                || (control.millis() - this.transitionMs) < this.transitionInterval) {\n                return;\n            }\n\n            this.transition = 0;\n            this.transitionMs = control.millis();\n            this._state = state;\n            switch (state) {\n                case DAL.LEVEL_THRESHOLD_HIGH:\n                    if (this.onHigh) this.onHigh();\n                    break;\n                case DAL.LEVEL_THRESHOLD_LOW:\n                    if (this.onLow) this.onLow();\n                    break;\n                case LevelDetector.LEVEL_THRESHOLD_NEUTRAL:\n                    if (this.onNeutral) this.onNeutral();\n                    break;\n            }\n        }\n    }\n}",
            "light.cpp": "#include \"light.h\"\n\n// WS2812B timings, datasheet v1\n// 0 - 0.25-0.55us hi 0.70-1.00us low\n// 1 - 0.65-0.95us hi 0.30-0.60us low\n// datasheet v5\n// 0 - 0.22-0.38us hi 0.58-1.00us low 1-3\n// 1 - 0.58-1.00us hi 0.58-1.00us low 3-2\n\n#define SPI_SUPPORTED 1\n\n#if defined(NRF52_SERIES)\n#define BIT_EXPANSION 5\n#define SPI_FREQ 4000000\n#else\n#define BIT_EXPANSION 3\n#define SPI_FREQ 2400000\n#endif\n\n#if defined(SAMD21) || defined(SAMD51) || defined(STM32F4) || defined(NRF52_SERIES)\n#include \"neopixel.h\"\n#define BITBANG_SUPPORTED 1\n#else\n#define BITBANG_SUPPORTED 0\n#endif\n\n#define NEOPIXEL_MIN_LENGTH_FOR_SPI 24\n#define DOTSTAR_MIN_LENGTH_FOR_SPI 24\n\n#define LIGHTMODE_RGB 1\n#define LIGHTMODE_RGBW 2\n#define LIGHTMODE_RGB_RGB 3\n#define LIGHTMODE_DOTSTAR 4\n\nnamespace light {\nbool isValidMOSIPin(DigitalInOutPin pin) {\n    if (!pin)\n        return false;\n\n#if SAMD51\n    return ZSPI::isValidMOSIPin(*pin);\n#elif defined(NRF52_SERIES)\n    return true;\n#else\n    // TODO: support for SPI neopixels\n    // default SPI pins supported for now\n    return pin == LOOKUP_PIN(MOSI);\n#endif\n}\n\n// SPI\nvoid spiNeopixelSendBuffer(DevicePin *pin, const uint8_t *data, unsigned size) {\n    int32_t iptr = 0, optr = 120;\n    uint32_t len = optr + size * BIT_EXPANSION + 120;\n    uint8_t *expBuf = new uint8_t[len];\n    memset(expBuf, 0, len);\n    uint8_t imask = 0x80;\n    uint8_t omask = 0x80;\n\n#define WR(k)                                                                                      \\\n    if (k)                                                                                         \\\n        expBuf[optr] |= omask;                                                                     \\\n    omask >>= 1;                                                                                   \\\n    if (!omask) {                                                                                  \\\n        omask = 0x80;                                                                              \\\n        optr++;                                                                                    \\\n    }\n\n    while (iptr < (int)size) {\n#if BIT_EXPANSION == 3\n        WR(1);\n        WR(data[iptr] & imask);\n        WR(0);\n#elif BIT_EXPANSION == 5\n        WR(1);\n        if (data[iptr] & imask) {\n            WR(1);\n            WR(1);\n        } else {\n            WR(0);\n        }\n        WR(0);\n        WR(0);\n#else\n#error \"invalid BIT_EXPANSION\"\n#endif\n\n        imask >>= 1;\n        if (!imask) {\n            imask = 0x80;\n            iptr++;\n        }\n    }\n\n    auto spi = pxt::getSPI(pin, NULL, NULL);\n    spi->setFrequency(SPI_FREQ);\n    spi->transfer(expBuf, len, NULL, 0);\n    delete expBuf;\n}\n\nvoid neopixelSendData(DevicePin *pin, int mode, const uint8_t *data, unsigned length) {\n    if (!pin || !length)\n        return;\n\n#if BITBANG_SUPPORTED\n    if (SPI_SUPPORTED && length > NEOPIXEL_MIN_LENGTH_FOR_SPI && isValidMOSIPin(pin))\n        spiNeopixelSendBuffer(pin, data, length);\n    else\n        neopixel_send_buffer(*pin, data, length);\n#else\n    if (isValidMOSIPin(pin)) {\n        spiNeopixelSendBuffer(pin, data, length);\n    }\n#endif\n}\n\nvoid bitBangDotStarSendData(DevicePin *data, DevicePin *clk, int mode, const uint8_t *buf,\n                            unsigned length) {\n    // first frame of zeroes\n    data->setDigitalValue(0);\n    for (unsigned i = 0; i < 32; ++i) {\n        clk->setDigitalValue(1);\n        clk->setDigitalValue(0);\n    }\n\n    // data stream\n    for (unsigned i = 0; i < length; ++i) {\n        auto x = buf[i];\n        for (uint8_t j = 0x80; j != 0; j >>= 1) {\n            data->setDigitalValue(x & j ? 1 : 0);\n            clk->setDigitalValue(1);\n            clk->setDigitalValue(0);\n        }\n    }\n    // https://cpldcpu.wordpress.com/2016/12/13/sk9822-a-clone-of-the-apa102/\n    // reset frame\n    // data->setDigitalValue(0);\n    // for (unsigned i = 0; i < 32 ; ++i) {\n    //    clk->setDigitalValue(1);\n    //    clk->setDigitalValue(0);\n    //}\n\n    // https://cpldcpu.wordpress.com/2014/11/30/understanding-the-apa102-superled/\n    data->setDigitalValue(1);\n    unsigned n = 32;\n    for (unsigned i = 0; i < n; ++i) {\n        clk->setDigitalValue(1);\n        clk->setDigitalValue(0);\n    }\n}\n\nstatic uint8_t ZERO_FRAME[4];\nstatic uint8_t ONE_FRAME[] = {1, 1, 1, 1};\nvoid spiDotStarSendData(DevicePin *data, DevicePin *clk, int mode, const uint8_t *buf,\n                        unsigned length) {\n    auto spi = pxt::getSPI(data, NULL, clk);\n\n    spi->transfer(ZERO_FRAME, sizeof(ZERO_FRAME), NULL, 0); // initial frame\n    spi->transfer(buf, length, NULL, 0);\n    spi->transfer(ZERO_FRAME, sizeof(ZERO_FRAME), NULL, 0); // reset frame\n    for (unsigned i = 0; i < (length >> 3); i += 32)\n        spi->transfer(ONE_FRAME, sizeof(ONE_FRAME), NULL, 0); // final frame\n}\n\nvoid dotStarSendData(DevicePin *data, DevicePin *clk, int mode, const uint8_t *buf,\n                     unsigned length) {\n    if (!data || !clk || !buf || !length)\n        return;\n\n    if (length > DOTSTAR_MIN_LENGTH_FOR_SPI && isValidMOSIPin(data))\n        spiDotStarSendData(data, clk, mode, buf, length);\n    else\n        bitBangDotStarSendData(data, clk, mode, buf, length);\n}\n\nvoid sendBuffer(DevicePin *data, DevicePin *clk, int mode, Buffer buf) {\n    if (!data || !buf || !buf->length)\n        return;\n\n    if (mode == LIGHTMODE_DOTSTAR)\n        light::dotStarSendData(data, clk, mode, buf->data, buf->length);\n    else\n        light::neopixelSendData(data, mode, buf->data, buf->length);\n}\n\nvoid clear() {\n    auto neopix = LOOKUP_PIN(NEOPIXEL);\n    auto neonum = getConfig(CFG_NUM_NEOPIXELS, 0);\n    if (neopix && neonum >= 0) {\n        auto n = 3 * neonum;\n        uint8_t off[n];\n        memset(off, 0, sizeof(off));\n        light::neopixelSendData(neopix, 0x100, off, sizeof(off));\n    }\n\n    auto data = LOOKUP_PIN(DOTSTAR_DATA);\n    auto clk = LOOKUP_PIN(DOTSTAR_CLOCK);\n    auto dsnum = getConfig(CFG_NUM_DOTSTARS, 0);\n    if (data && clk && dsnum > 0) {\n        auto n = 4 * dsnum;\n        uint8_t off[n];\n        memset(off, 0, sizeof(off));\n        for (int i = 0; i < n; i += 4)\n            off[i] = 0xe0;\n        bitBangDotStarSendData(data, clk, 0x100, off, sizeof(off));\n    }\n}\n\n} // namespace light\n",
            "light.h": "#ifndef __PXT_LIGHT_H\n#define __PXT_LIGHT_H\n\n#include \"pxt.h\"\n\nnamespace light {\n    /**\n    * Clear onboard neopixels\n    */\n    void clear();\n\n    /**\n    * Send a programmable light buffer to the specified digital pin\n    * @param data The pin that the lights are connected to\n    * @param clk the clock line if any\n    * @param mode the color encoding mode\n    * @param buf The buffer to send to the pin\n    */\n    //%\n    void sendBuffer(DigitalInOutPin data, DigitalInOutPin clk, int mode, Buffer buf);\n\n    void neopixelSendData(DevicePin* pin, int mode, const uint8_t* data, unsigned length);\n}\n\n#endif",
            "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}\n\n/**\n * Servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n\n}\n\n/**\n * A Joint Asynchronous Communications, Device Agnostic Control.\n */\n//% color=\"#E79251\" weight=1 icon=\"\\uf185\"\n//% groups='[\"Broadcast\", \"Console\", \"Control\"]'\n//% blockGap=8\nnamespace jacdac {\n\n}",
            "pins.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\nstatic DevicePin **pinPtrs;\nstatic uint8_t numPinPtrs;\nstatic uint8_t pinPos[DEV_NUM_PINS];\n\n//%\nDevicePin *getPin(int id) {\n\n    id &= CFG_PIN_NAME_MSK;\n\n    if (id >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n\n    // we could use lookupComponent() here - it would be slightly slower\n\n    int ptr = pinPos[id];\n    if (ptr == 0) {\n        pinPtrs = (DevicePin **)realloc(pinPtrs, (numPinPtrs + 1) * sizeof(void *));\n        bool isAnalog = IS_ANALOG_PIN(id);\n        // GCTODO\n        pinPtrs[numPinPtrs++] =\n            new DevicePin(DEVICE_ID_IO_P0 + id, (PinName)id,\n                          isAnalog ? PIN_CAPABILITY_AD : PIN_CAPABILITY_DIGITAL);\n        ptr = numPinPtrs;\n        pinPos[id] = ptr;\n    }\n    return pinPtrs[ptr - 1];\n}\n\n//%\nDevicePin *getPinCfg(int key) {\n    int p = getConfig(key, -1);\n    if (p == -1)\n        DMESG(\"no pin cfg: %d\", key);\n    return getPin(p);\n}\n\nvoid linkPin(int from, int to) {\n    if (from < 0 || from >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n    getPin(to);\n    pinPos[from] = pinPos[to];\n}\n\n//%\nDevicePin *lookupPin(int pinName) {\n    if (pinName < 0 || pinName == 0xff)\n        return NULL;\n    pinName &= CFG_PIN_NAME_MSK;\n    return getPin(pinName);\n}\n\n//%\nDevicePin *lookupPinCfg(int key) {\n    return lookupPin(getConfig(key));\n}\n\nCodalComponent *lookupComponent(int id) {\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; ++i) {\n        if (CodalComponent::components[i] && CodalComponent::components[i]->id == id)\n            return CodalComponent::components[i];\n    }\n    return NULL;\n}\n\n} // namespace pxt\n\nnamespace pins {\n/**\n* Get a pin by configuration id (DAL.CFG_PIN...)\n*/\n//%\nDigitalInOutPin pinByCfg(int key) {\n    return pxt::lookupPinCfg(key);\n}\n\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//%\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n\n/**\n * Get the duration of the last pulse in microseconds. This function should be called from a\n * ``onPulsed`` handler.\n */\n//% help=pins/pulse-duration blockGap=8\n//% blockId=pins_pulse_duration block=\"pulse duration (s)\"\n//% weight=19\nint pulseDuration() {\n    return pxt::lastEvent.timestamp;\n}\n} // namespace pins\n",
            "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// these can be overridden in platform.h\n#ifndef CODAL_PIN\n#define CODAL_PIN CODAL_MBED::Pin\n#endif\n\n#ifndef CODAL_TIMER\n#define CODAL_TIMER CODAL_MBED::Timer\n#endif\n\n#ifndef CODAL_SPI\n#define CODAL_SPI CODAL_MBED::SPI\n#endif\n\n#ifndef CODAL_SERIAL\n#define CODAL_SERIAL CODAL_MBED::Serial\n#endif\n\n#ifndef IS_ANALOG_PIN\n#define IS_ANALOG_PIN(id) ((DEV_ANALOG_PINS >> (id)) & 1)\n#endif\n\ntypedef CODAL_PIN DevicePin;\n\ntypedef DevicePin *DigitalInOutPin;\ntypedef DevicePin *AnalogInOutPin;\ntypedef DevicePin *AnalogInPin;\ntypedef DevicePin *AnalogOutPin;\ntypedef DevicePin *PwmPin;\ntypedef DevicePin *PwmOnlyPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *getPinCfg(int key);\nDevicePin *lookupPin(int pinName);\nDevicePin *lookupPinCfg(int key);\nvoid linkPin(int from, int to);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
            "pins.ts": "//% noRefCounting fixedInstances\ninterface DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogOutPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInOutPin extends AnalogInPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmOnlyPin extends DigitalInOutPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmPin extends PwmOnlyPin, AnalogInOutPin {\n}\n\n/**\n * Control currents in Pins for analog/digital signals, servos, i2c, ...\n */\n//% color=#A80000 weight=85 icon=\"\\uf140\" advanced=true\n//% groups='[\"other\", \"Servo\", \"i2c\"]'\nnamespace pins {\n}",
            "pinsAnalog.cpp": "#include \"pxt.h\"\n\nnamespace AnalogInPinMethods {\n\n/**\n * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n * @param name pin to write to\n */\n//% help=pins/analog-read weight=53\n//% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nint analogRead(AnalogInPin name) {\n    return PINOP(getAnalogValue());\n}\n}\n\nnamespace AnalogOutPinMethods {\nvoid analogWrite(AnalogOutPin name, int value) __attribute__ ((weak));\n\n/**\n * Set the connector value as analog. Value must be comprised between 0 and 1023.\n * @param name pin name to write to\n * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n */\n//% help=pins/analog-write weight=52\n//% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.min=0 value.max=1023\nvoid analogWrite(AnalogOutPin name, int value) {\n    PINOP(setAnalogValue(value));\n}\n}",
            "pinsDigital.cpp": "#include \"pxt.h\"\n\nenum class PulseValue {\n    //% block=high\n    High = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=low\n    Low = DEVICE_PIN_EVT_PULSE_LO\n};\n\nenum class PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=\"pulse low\"\n    PulseLow = DEVICE_PIN_EVT_PULSE_LO,\n    //% block=\"rise\"\n    Rise = DEVICE_PIN_EVT_RISE,\n    //% block=\"fall\"\n    Fall = DEVICE_PIN_EVT_FALL,\n};\n\nenum class PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2\n};\n\nnamespace DigitalInOutPinMethods {\n/**\n * Read a pin or connector as either 0 or 1\n * @param name pin to read from\n */\n//% help=pins/digital-read weight=61\n//% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nbool digitalRead(DigitalInOutPin name) {\n    return PINOP(getDigitalValue()) != 0;\n}\n\n/**\n     * Set a pin or connector value to either 0 or 1.\n    * @param name pin to write to\n    * @param value value to set on the pin\n    */\n//% help=pins/digital-write weight=60\n//% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid digitalWrite(DigitalInOutPin name, bool value) {\n    PINOP(setDigitalValue(value));\n}\n\n/**\n* Make this pin a digital input, and create events where the timestamp is the duration\n* that this pin was either ``high`` or ``low``.\n*/\n//% help=pins/on-pulsed weight=16 blockGap=8\n//% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% deprecated=1 hidden=1\nvoid onPulsed(DigitalInOutPin pin, PulseValue pulse, Action body) {\n    pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n    registerWithDal(pin->id, (int)pulse, body);\n}\n\n/**\n* Register code to run when a pin event occurs. \n*/\n//% help=pins/on-event weight=20 blockGap=8\n//% blockId=pinsonevent block=\"on|pin %pin|%event\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nvoid onEvent(DigitalInOutPin pin, PinEvent event, Action body) {\n    switch(event) {\n        case PinEvent::PulseHigh:\n        case PinEvent::PulseLow:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n            registerWithDal(pin->id, (int)event, body);\n            break;\n        case PinEvent::Rise:\n        case PinEvent::Fall:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_EDGE);\n            registerWithDal(pin->id, (int)event, body);\n            break;    \n    }    \n}\n\n/**\n* Return the duration of a pulse in microseconds\n* @param name the pin which measures the pulse\n* @param value the value of the pulse (default high)\n* @param maximum duration in micro-seconds\n*/\n//% blockId=\"pins_pulse_in\" block=\"pulse in (s)|pin %name|pulsed %high||timeout %maxDuration (s)\"\n//% weight=18 blockGap=8\n//% help=\"pins/pulse-in\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nint pulseIn(DigitalInOutPin pin, PulseValue value, int maxDuration = 2000000) {\n    int pulse = PulseValue::High == value ? 1 : 0;\n    uint64_t tick = system_timer_current_time_us();\n    uint64_t maxd = (uint64_t)maxDuration;\n    while (pin->getDigitalValue() != pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n\n    uint64_t start = system_timer_current_time_us();\n    while (pin->getDigitalValue() == pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n    uint64_t end = system_timer_current_time_us();\n    return end - start;\n}\n\n/**\n* Set the pull direction of this pin.\n* @param name pin to set the pull mode on\n* @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n*/\n//% help=pins/set-pull weight=17 blockGap=8\n//% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid setPull(DigitalInOutPin name, PinPullMode pull) {\n    PullMode m = pull == PinPullMode::PullDown ? PullMode::Down : pull == PinPullMode::PullUp\n                                                                        ? PullMode::Up\n                                                                        : PullMode::None;\n    PINOP(setPull(m));\n}\n\n}\n\nnamespace pxt {\n\nstatic void waitABit() {\n    // for (int i = 0; i < 10; ++i)\n    //    asm volatile(\"nop\");\n}\n\nclass ButtonMultiplexer : public CodalComponent {\n  public:\n    Pin &latch;\n    Pin &clock;\n    Pin &data;\n    uint32_t state;\n    uint32_t invMask;\n    uint16_t buttonIdPerBit[8];\n    bool enabled;\n\n    ButtonMultiplexer(uint16_t id)\n        : latch(*LOOKUP_PIN(BTNMX_LATCH)), clock(*LOOKUP_PIN(BTNMX_CLOCK)),\n          data(*LOOKUP_PIN(BTNMX_DATA)) {\n        this->id = id;\n        this->status |= DEVICE_COMPONENT_STATUS_SYSTEM_TICK;\n\n        state = 0;\n        invMask = 0;\n        enabled = true;\n\n        memset(buttonIdPerBit, 0, sizeof(buttonIdPerBit));\n\n        data.getDigitalValue(PullMode::Down);\n        latch.setDigitalValue(1);\n        clock.setDigitalValue(1);\n    }\n\n    void disable() {\n        data.getDigitalValue(PullMode::None);\n        latch.getDigitalValue(PullMode::None);\n        clock.getDigitalValue(PullMode::None);\n        enabled = false;\n    }\n\n    bool isButtonPressed(int id) {\n        for (int i = 0; i < 8; ++i) {\n            if (buttonIdPerBit[i] == id)\n                return (state & (1 << i)) != 0;\n        }\n        return false;\n    }\n\n    uint32_t readBits(int bits) {\n        latch.setDigitalValue(0);\n        waitABit();\n        latch.setDigitalValue(1);\n        waitABit();\n\n        uint32_t state = 0;\n        for (int i = 0; i < bits; i++) {\n            state <<= 1;\n            if (data.getDigitalValue(PullMode::Down))\n                state |= 1;\n\n            clock.setDigitalValue(0);\n            waitABit();\n            clock.setDigitalValue(1);\n            waitABit();\n        }\n\n        return state;\n    }\n\n    virtual void periodicCallback() override {\n        if (!enabled)\n            return;\n\n        uint32_t newState = readBits(8);\n        newState ^= invMask;\n        if (newState == state)\n            return;\n\n        for (int i = 0; i < 8; ++i) {\n            uint32_t mask = 1 << i;\n            if (!buttonIdPerBit[i])\n                continue;\n            int ev = 0;\n            if (!(state & mask) && (newState & mask))\n                ev = PXT_INTERNAL_KEY_DOWN;\n            else if ((state & mask) && !(newState & mask))\n                ev = PXT_INTERNAL_KEY_UP;\n            if (ev) {\n                Event(ev, buttonIdPerBit[i]);\n                Event(ev, 0); // any key\n            }\n        }\n\n        state = newState;\n    }\n};\n\nstatic ButtonMultiplexer *btnMultiplexer;\nButtonMultiplexer *getMultiplexer() {\n    if (!btnMultiplexer)\n        btnMultiplexer = new ButtonMultiplexer(DEVICE_ID_FIRST_BUTTON);\n    return btnMultiplexer;\n}\n\nint registerMultiplexedButton(int pin, int buttonId) {\n    if (1050 <= pin && pin < 1058) {\n        pin -= 50;\n        getMultiplexer()->invMask |= 1 << (pin - 1000);\n    }\n    if (1000 <= pin && pin < 1008) {\n        getMultiplexer()->buttonIdPerBit[pin - 1000] = buttonId;\n        return 1;\n    }\n    return 0;\n}\n\nint multiplexedButtonIsPressed(int btnId) {\n    if (btnMultiplexer)\n        return btnMultiplexer->isButtonPressed(btnId) ? 512 : 0;\n    return 0;\n}\n\n//% expose\nuint32_t readButtonMultiplexer(int bits) {\n    if (!LOOKUP_PIN(BTNMX_CLOCK))\n        return 0;\n    return getMultiplexer()->readBits(bits);\n}\n\nvoid disableButtonMultiplexer() {\n    if (LOOKUP_PIN(BTNMX_CLOCK)) {\n        getMultiplexer()->disable();\n    }\n}\n\n}",
            "pinsPWM.cpp": "#include \"pxt.h\"\n\nnamespace PwmPinMethods {\n}\n\nnamespace PwmOnlyPinMethods {\n\n/**\n * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n * **microseconds** or `1/1000` milliseconds.\n * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n * no effect.\n * @param name analog pin to set period to\n * @param micros period in micro seconds. eg:20000\n */\n//% help=pins/analog-set-period weight=51\n//% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (s)%period\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid analogSetPeriod(PwmOnlyPin name, int period) {\n    PINOP(setAnalogPeriodUs(period));\n}\n\n/**\n * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n * @param name pin to write to\n * @param value angle or rotation speed\n */\n//% help=pins/servo-write weight=41 group=\"Servo\"\n//% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n//% parts=microservo trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.defl=90\nvoid servoWrite(PwmOnlyPin name, int value) {\n    PINOP(setServoValue(value));\n}\n\n/**\n * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n * @param name pin name\n * @param duration pulse duration in micro seconds, eg:1500\n */\n//% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n//% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (s) %duration\"\n//% parts=microservo blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid servoSetPulse(PwmOnlyPin name, int duration) {\n    PINOP(setServoPulseUs(duration));\n}\n\n/**\n* Indicates if the servo is running continuously\n*/\n//% blockHidden=1\nvoid servoSetContinuous(PwmOnlyPin name, bool continuous) {\n    // used by simulator\n}\n\n}",
            "pinscompat.ts": "// filled in by microbit",
            "platform.cpp": "#include \"pxt.h\"\n#include \"light.h\"\n\nnamespace pxt {\n\nCODAL_TIMER devTimer;\n\nstatic void initRandomSeed() {\n    int seed = 0xC0DA1;\n    auto pinTemp = LOOKUP_PIN(TEMPERATURE);\n    if (pinTemp)\n        seed *= pinTemp->getAnalogValue();\n    auto pinLight = LOOKUP_PIN(LIGHT);\n    if (pinLight)\n        seed *= pinLight->getAnalogValue();\n    seedRandom(seed);\n}\n\nstatic void remapSwdPin(int pinCfg, int fallback) {\n    int pinName = getConfig(pinCfg);\n    if (pinName == PA30 || pinName == PA31) {\n        if (getConfig(CFG_SWD_ENABLED, 0)) {\n            linkPin(pinName, fallback);\n        } else {\n            PORT->Group[pinName / 32].PINCFG[pinName % 32].reg = (uint8_t)PORT_PINCFG_INEN;\n        }\n    }\n}\n\nstatic void initSwdPins() {\n    remapSwdPin(CFG_PIN_NEOPIXEL, PIN(D0));\n    remapSwdPin(CFG_PIN_RXLED, PIN(D1));\n    remapSwdPin(CFG_PIN_SPEAKER_AMP, PIN(D2));\n}\n\nvoid platform_init() {\n    initSwdPins();\n    initRandomSeed();\n    light::clear();\n\n    if (*HF2_DBG_MAGIC_PTR == HF2_DBG_MAGIC_START) {\n        *HF2_DBG_MAGIC_PTR = 0;\n        // this will cause alignment fault at the first breakpoint\n        globals[0] = (TValue)1;\n    }\n}\n\n} // namespace pxt\n",
            "platform.h": "#ifndef __PXT_PLATFORM_H\n#define __PXT_PLATFORM_H\n\n// This is specific for SAMD21, to be replaced in other Codal targets.\n\n#include \"CapTouchButton.h\"\n#include \"Image.h\"\n#include \"MbedTimer.h\"\n#include \"MbedI2C.h\"\n#include \"MbedPin.h\"\n#include \"MbedSPI.h\"\n#include \"MbedSerial.h\"\n#include \"MultiButton.h\"\n#include \"CPlayI2C.h\"\n\n#include \"SAMD21DMAC.h\"\n\n// Analog Pins, all SAMD21: PA02-PA11 PB00-PB09 (some pins not connected)\n// 2 ports times 32 pins in each\n#define DEV_NUM_PINS 64\n// pins marked with AIN and PTC in the data sheet\n#define DEV_ANALOG_PINS 0x3ff00000ffcULL\n\n#define PAGE_SIZE 256\n\n#define CODAL_DMAC SAMD21DMAC\n\n// this is codal::_mbed for both mbed and mbedos now\n#define CODAL_MBED codal::_mbed\n\n#define CODAL_I2C codal::CPlayI2C\n\n#ifndef IMAGE_BITS\n#define IMAGE_BITS 1\n#endif\n\n#ifdef JUST_FOR_DAL_D_TS_CPP_WILL_IGNORE\n#define PA00 0\n#define PA01 1\n#define PA02 2\n#define PA03 3\n#define PA04 4\n#define PA05 5\n#define PA06 6\n#define PA07 7\n#define PA08 8\n#define PA09 9\n#define PA10 10\n#define PA11 11\n#define PA12 12\n#define PA13 13\n#define PA14 14\n#define PA15 15\n#define PA16 16\n#define PA17 17\n#define PA18 18\n#define PA19 19\n#define PA20 20\n#define PA21 21\n#define PA22 22\n#define PA23 23\n#define PA24 24\n#define PA25 25\n#define PA26 26\n#define PA27 27\n#define PA28 28\n#define PA29 29\n#define PA30 30\n#define PA31 31\n#define PB00 32\n#define PB01 33\n#define PB02 34\n#define PB03 35\n#define PB04 36\n#define PB05 37\n#define PB06 38\n#define PB07 39\n#define PB08 40\n#define PB09 41\n#define PB10 42\n#define PB11 43\n#define PB12 44\n#define PB13 45\n#define PB14 46\n#define PB15 47\n#define PB16 48\n#define PB17 49\n#define PB18 50\n#define PB19 51\n#define PB20 52\n#define PB21 53\n#define PB22 54\n#define PB23 55\n#define PB24 56\n#define PB25 57\n#define PB26 58\n#define PB27 59\n#define PB28 60\n#define PB29 61\n#define PB30 62\n#define PB31 63\n#endif\n\n#endif\n",
            "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n\n#include \"CodalConfig.h\"\n#include \"CodalHeapAllocator.h\"\n#include \"CodalDevice.h\"\n#include \"CodalDmesg.h\"\n#include \"ErrorNo.h\"\n#include \"Timer.h\"\n#include \"Matrix4.h\"\n#include \"CodalCompat.h\"\n#include \"CodalComponent.h\"\n#include \"ManagedType.h\"\n#include \"Event.h\"\n#include \"NotifyEvents.h\"\n#include \"Button.h\"\n#include \"CodalFiber.h\"\n#include \"MessageBus.h\"\n\nusing namespace codal;\n\n// codal::ManagedString compat\n#define MSTR(s) codal::ManagedString((s)->data, (s)->length)\n#define PSTR(s) mkString((s).toCharArray(), (s).length())\n\n#include \"pins.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"hf2.h\"\n#include \"hf2dbg.h\"\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n#include \"HIDMouse.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n#include \"HIDKeyboard.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n#include \"HIDJoystick.h\"\n#endif\n#endif\n\n#define PXT_COMM_BASE 0x20002000 // 8k in\n\nnamespace pxt {\n\n#if CONFIG_ENABLED(DEVICE_USB)\nextern CodalUSB usb;\nextern HF2 hf2;\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nextern USBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nextern USBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nextern USBHIDJoystick joystick;\n#endif\n#endif\n\n// Utility functions\nextern Event lastEvent;\nextern CODAL_TIMER devTimer;\nextern MessageBus devMessageBus;\nextern codal::CodalDevice device;\n\nvoid set_usb_strings(const char *uf2_info);\nextern void (*logJDFrame)(const uint8_t *data);\nextern void (*sendJDFrame)(const uint8_t *data);\n\n\n} // namespace pxt\n\nnamespace pins {\nclass CodalSPIProxy;\nclass CodalI2CProxy;\n} // namespace pins\n\ntypedef pins::CodalI2CProxy* I2C_;\ntypedef pins::CodalSPIProxy* SPI_;\n\nnamespace pxt {\ncodal::LowLevelTimer *allocateTimer();\n\n#ifdef CODAL_I2C\nCODAL_I2C* getI2C(DigitalInOutPin sda, DigitalInOutPin scl);\n#endif\nCODAL_SPI* getSPI(DigitalInOutPin mosi, DigitalInOutPin miso, DigitalInOutPin sck);\n#ifdef CODAL_JACDAC_WIRE_SERIAL\nLowLevelTimer* getJACDACTimer();\n#endif\nclass PressureButton;\nuint32_t readButtonMultiplexer(int bits);\nvoid disableButtonMultiplexer();\n}\n\nnamespace serial {\nclass CodalSerialDeviceProxy;\n}\n\ntypedef serial::CodalSerialDeviceProxy* SerialDevice;\n\nnamespace jacdac {\nclass JDProxyDriver;\n} // namespace network\n\ntypedef jacdac::JDProxyDriver* JacDacDriverStatus;\n\n#define DEVICE_ID_BUTTON_SLIDE 3000\n#define DEVICE_ID_MICROPHONE 3001\n#define DEVICE_ID_FIRST_BUTTON 4000\n#define DEVICE_ID_FIRST_TOUCHBUTTON 4100\n\n#define PXT_INTERNAL_KEY_UP 2050\n#define PXT_INTERNAL_KEY_DOWN 2051\n\n#endif\n",
            "pxt.json": "{\n    \"name\": \"core\",\n    \"description\": \"The core library for Codal-based targets\",\n    \"dependencies\": {\n        \"base\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"dal.d.ts\",\n        \"codal.cpp\",\n        \"usb.cpp\",\n        \"pxt.h\",\n        \"platform.h\",\n        \"platform.cpp\",\n        \"pxtcore.h\",\n        \"pins.h\",\n        \"pins.cpp\",\n        \"pinsAnalog.cpp\",\n        \"pinsDigital.cpp\",\n        \"pinsPWM.cpp\",\n        \"pins.ts\",\n        \"pinscompat.ts\",\n        \"control.cpp\",\n        \"i2c.cpp\",\n        \"i2c.ts\",\n        \"spi.cpp\",\n        \"spi.ts\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"hf2.cpp\",\n        \"hf2.h\",\n        \"hf2dbg.h\",\n        \"uf2format.h\",\n        \"uf2hid.h\",\n        \"ns.ts\",\n        \"dmac.cpp\",\n        \"dmac.h\",\n        \"timer.ts\",\n        \"light.cpp\",\n        \"light.h\",\n        \"keyvaluestorage.cpp\",\n        \"keyvaluestorage.ts\",\n        \"leveldetector.ts\",\n        \"pxtparts.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"yotta\": {\n        \"config\": {\n            \"codal\": {\n                \"component_count\": 64,\n                \"dmesg_buffer_size\": 1024\n            }\n        }\n    },\n    \"dalDTS\": {\n        \"includeDirs\": [\n            \"libraries/codal-core/inc\",\n            \"pxtapp\"\n        ],\n        \"excludePrefix\": [\n            \"JD_\",\n            \"USB_\",\n            \"REQUEST_\",\n            \"LIS3DH_\",\n            \"FXOS8700_\",\n            \"HF2_\",\n            \"PXT_REF_TAG_\",\n            \"MS_\",\n            \"SCSI_\",\n            \"MAG_\",\n            \"MAG3\",\n            \"MPU6\",\n            \"MADCTL\",\n            \"MMA8\"\n        ]\n    }\n}\n",
            "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\n#include \"CodalDmesg.h\"\n#include \"CodalHeapAllocator.h\"\n\n#define itoa(a, b) codal::itoa(a, b)\n\n#define GC_GET_HEAP_SIZE() device_heap_size(0)\n#define GC_STACK_BASE DEVICE_STACK_BASE\n#define xmalloc device_malloc\n#define xfree device_free\n\n// on most devices we allocate the entire heap at once, so large allocs should work\n// if they don't you just get the regular out of memory instead of alloc too large\n#define GC_MAX_ALLOC_SIZE (128 * 1024)\n\n#endif\n",
            "pxtparts.json": "{\n    \"neopixel\": {\n        \"simulationBehavior\": \"neopixel\",\n        \"visual\": {\n            \"builtIn\": \"neopixel\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 19,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 28,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createStrip,light.createNeoPixelStrip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"dotstar\": {\n        \"simulationBehavior\": \"dotstar\",\n        \"visual\": {\n            \"builtIn\": \"dotstar\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 1\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createAPA102Strip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"dataPin\"\n                },\n                {\n                    \"pinInstantiationIdx\": 1,\n                    \"partParameter\": \"clkPin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },\n    \"pixels\": {\n        \"simulationBehavior\": \"pixels\",\n        \"visual\": { \n            \"builtIn\": \"pixels\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"MOSI\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"SCK\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },    \n    \"buttons\": {\n        \"simulationBehavior\": \"buttons\",\n        \"visual\": {\n            \"builtIn\": \"buttons\",\n            \"width\": 75,\n            \"height\": 45,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 30,\n                    \"y\": 45\n                }\n            ]\n        },\n        \"numberOfPins\": 2,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"Button.onEvent,Button.isPressed,Button.wasPressed\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"button\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"slideswitch\": {\n        \"numberOfPins\": 3,\n        \"simulationBehavior\": \"slideswitch\",\n        \"visual\": {\n            \"builtIn\": \"slideswitch\",\n            \"width\": 100,\n            \"height\": 100,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalRead,DigitalInOutPin.onPulsed,DigitalInOutPin.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"microservo\": {\n        \"simulationBehavior\": \"microservo\",\n        \"visual\": {\n            \"builtIn\": \"microservo\",\n            \"width\": 74.85,\n            \"height\": 200,\n            \"pinDistance\": 10,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 37,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 5\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"PwmOnlyPin.servoWrite,servos.Servo.setAngle,servos.Servo.run,servos.Servo.setPulse\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"led\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"analogled\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogOutPin.analogWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"photocell\": {\n        \"numberOfPins\": 3,\n        \"visual\": {\n            \"builtIn\": \"photocell\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 15,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"photocell\",\n        \"pinDefinitions\": [\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogInPin.analogRead\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace light {\n\n    /**\n     * Send a programmable light buffer to the specified digital pin\n     * @param data The pin that the lights are connected to\n     * @param clk the clock line if any\n     * @param mode the color encoding mode\n     * @param buf The buffer to send to the pin\n     */\n    //% shim=light::sendBuffer\n    function sendBuffer(data: DigitalInOutPin, clk: DigitalInOutPin, mode: int32, buf: Buffer): void;\n}\ndeclare namespace control {\n\n    /**\n     * Determines if the USB has been enumerated.\n     */\n    //% shim=control::isUSBInitialized\n    function isUSBInitialized(): boolean;\n}\ndeclare namespace pins {\n\n    /**\n     * Get a pin by configuration id (DAL.CFG_PIN...)\n     */\n    //% shim=pins::pinByCfg\n    function pinByCfg(key: int32): DigitalInOutPin;\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=pins::createBuffer\n    function createBuffer(size: int32): Buffer;\n\n    /**\n     * Get the duration of the last pulse in microseconds. This function should be called from a\n     * ``onPulsed`` handler.\n     */\n    //% help=pins/pulse-duration blockGap=8\n    //% blockId=pins_pulse_duration block=\"pulse duration (s)\"\n    //% weight=19 shim=pins::pulseDuration\n    function pulseDuration(): int32;\n}\n\n\ndeclare interface AnalogInPin {\n    /**\n     * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n     * @param name pin to write to\n     */\n    //% help=pins/analog-read weight=53\n    //% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=AnalogInPinMethods::analogRead\n    analogRead(): int32;\n}\n\n\ndeclare interface AnalogOutPin {\n    /**\n     * Set the connector value as analog. Value must be comprised between 0 and 1023.\n     * @param name pin name to write to\n     * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n     */\n    //% help=pins/analog-write weight=52\n    //% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.min=0 value.max=1023 shim=AnalogOutPinMethods::analogWrite\n    analogWrite(value: int32): void;\n}\n\n\ndeclare interface DigitalInOutPin {\n    /**\n     * Read a pin or connector as either 0 or 1\n     * @param name pin to read from\n     */\n    //% help=pins/digital-read weight=61\n    //% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalRead\n    digitalRead(): boolean;\n\n    /**\n     * Set a pin or connector value to either 0 or 1.\n     * @param name pin to write to\n     * @param value value to set on the pin\n     */\n    //% help=pins/digital-write weight=60\n    //% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalWrite\n    digitalWrite(value: boolean): void;\n\n    /**\n     * Make this pin a digital input, and create events where the timestamp is the duration\n     * that this pin was either ``high`` or ``low``.\n     */\n    //% help=pins/on-pulsed weight=16 blockGap=8\n    //% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% deprecated=1 hidden=1 shim=DigitalInOutPinMethods::onPulsed\n    onPulsed(pulse: PulseValue, body: () => void): void;\n\n    /**\n     * Register code to run when a pin event occurs. \n     */\n    //% help=pins/on-event weight=20 blockGap=8\n    //% blockId=pinsonevent block=\"on|pin %pin|%event\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 shim=DigitalInOutPinMethods::onEvent\n    onEvent(event: PinEvent, body: () => void): void;\n\n    /**\n     * Return the duration of a pulse in microseconds\n     * @param name the pin which measures the pulse\n     * @param value the value of the pulse (default high)\n     * @param maximum duration in micro-seconds\n     */\n    //% blockId=\"pins_pulse_in\" block=\"pulse in (s)|pin %name|pulsed %high||timeout %maxDuration (s)\"\n    //% weight=18 blockGap=8\n    //% help=\"pins/pulse-in\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 maxDuration.defl=2000000 shim=DigitalInOutPinMethods::pulseIn\n    pulseIn(value: PulseValue, maxDuration?: int32): int32;\n\n    /**\n     * Set the pull direction of this pin.\n     * @param name pin to set the pull mode on\n     * @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n     */\n    //% help=pins/set-pull weight=17 blockGap=8\n    //% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::setPull\n    setPull(pull: PinPullMode): void;\n}\n\n\ndeclare interface PwmPin {}\n\n\ndeclare interface PwmOnlyPin {\n    /**\n     * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n     * **microseconds** or `1/1000` milliseconds.\n     * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n     * no effect.\n     * @param name analog pin to set period to\n     * @param micros period in micro seconds. eg:20000\n     */\n    //% help=pins/analog-set-period weight=51\n    //% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (s)%period\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::analogSetPeriod\n    analogSetPeriod(period: int32): void;\n\n    /**\n     * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n     * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n     * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n     * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n     * @param name pin to write to\n     * @param value angle or rotation speed\n     */\n    //% help=pins/servo-write weight=41 group=\"Servo\"\n    //% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n    //% parts=microservo trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.defl=90 shim=PwmOnlyPinMethods::servoWrite\n    servoWrite(value?: int32): void;\n\n    /**\n     * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n     * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n     * @param name pin name\n     * @param duration pulse duration in micro seconds, eg:1500\n     */\n    //% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n    //% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (s) %duration\"\n    //% parts=microservo blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::servoSetPulse\n    servoSetPulse(duration: int32): void;\n\n    /**\n     * Indicates if the servo is running continuously\n     */\n    //% blockHidden=1 shim=PwmOnlyPinMethods::servoSetContinuous\n    servoSetContinuous(continuous: boolean): void;\n}\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the MicroBit Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% help=control/raise-event\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1 shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Determine the version of system software currently running.\n     */\n    //% blockId=\"control_device_dal_version\" block=\"device dal version\"\n    //% help=control/device-dal-version shim=control::deviceDalVersion\n    function deviceDalVersion(): string;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n\n    /** Write a message to DMESG debugging buffer. */\n    //% shim=control::dmesg\n    function dmesg(s: string): void;\n\n    /** Write a message and value (pointer) to DMESG debugging buffer. */\n    //% shim=control::dmesgPtr\n    function dmesgPtr(str: string, ptr: Object): void;\n}\n\n\ndeclare interface I2C {\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=I2CMethods::readBuffer\n    readBuffer(address: int32, size: int32, repeat?: boolean): Buffer;\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=I2CMethods::writeBuffer\n    writeBuffer(address: int32, buf: Buffer, repeat?: boolean): int32;\n}\ndeclare namespace pins {\n\n    /**\n     * Opens a Serial communication driver\n     */\n    //% help=pins/create-i2c\n    //% parts=i2c shim=pins::createI2C\n    function createI2C(sda: DigitalInOutPin, scl: DigitalInOutPin): I2C;\n}\ndeclare namespace pins {\n\n    /**\n     * Opens a SPI driver\n     */\n    //% help=pins/create-spi\n    //% parts=spi shim=pins::createSPI\n    function createSPI(mosiPin: DigitalInOutPin, misoPin: DigitalInOutPin, sckPin: DigitalInOutPin): SPI;\n\n    /**\n     * Opens a slave SPI driver\n     */\n    //% parts=spi shim=pins::createSlaveSPI\n    function createSlaveSPI(mosiPin: DigitalInOutPin, misoPin: DigitalInOutPin, sckPin: DigitalInOutPin, csPin: DigitalInOutPin): SPI;\n}\n\n\ndeclare interface SPI {\n    /**\n     * Write to the SPI bus\n     */\n    //% shim=SPIMethods::write\n    write(value: int32): int32;\n\n    /**\n     * Transfer buffers over the SPI bus\n     */\n    //% argsNullable shim=SPIMethods::transfer\n    transfer(command: Buffer, response: Buffer): void;\n\n    /**\n     * Sets the SPI clock frequency\n     */\n    //% shim=SPIMethods::setFrequency\n    setFrequency(frequency: int32): void;\n\n    /**\n     * Sets the SPI bus mode\n     */\n    //% shim=SPIMethods::setMode\n    setMode(mode: int32): void;\n}\ndeclare namespace configStorage {\n\n    /**\n     * Puts an entry in the device storage. Key may have up to 16 characters (bytes).\n     * @param key the identifier (max 16 characters)\n     * @param value the data (max 32 characters)\n     */\n    //% shim=configStorage::setBuffer\n    function setBuffer(key: string, value: Buffer): void;\n\n    /**\n     * Gets an entry from the device storage. Key may have up to 16 characters (bytes).\n     * @param key the identifier (max 16 characters)\n     */\n    //% shim=configStorage::getBuffer\n    function getBuffer(key: string): Buffer;\n\n    /**\n     * Removes the key from local storage\n     * @param key the identifier (max 16 characters)\n     */\n    //% shim=configStorage::removeItem\n    function removeItem(key: string): void;\n\n    /**\n     * Clears the local storage\n     */\n    //% shim=configStorage::clear\n    function clear(): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "spi.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n\nnamespace pins {\n\nclass CodalSPIProxy {\nprivate:\n    DevicePin* mosi; \n    DevicePin* miso; \n    DevicePin* sck;\n    CODAL_SPI spi;\npublic:\n    CodalSPIProxy* next;\n\npublic:\n    CodalSPIProxy(DevicePin* _mosi, DevicePin* _miso, DevicePin* _sck)\n        : mosi(_mosi)\n        , miso(_miso)\n        , sck(_sck)\n        , spi(*_mosi, *_miso, *_sck) \n        , next(NULL)\n    {\n    }\n\n#ifdef CODAL_SPI_SLAVE_SUPPORTED\n    CodalSPIProxy(DevicePin* _mosi, DevicePin* _miso, DevicePin* _sck, DevicePin* _cs)\n        : mosi(_mosi)\n        , miso(_miso)\n        , sck(_sck)\n        , spi(*_mosi, *_miso, *_sck, _cs) \n        , next(NULL)\n    {\n    }\n#endif\n\n    CODAL_SPI* getSPI() {\n        return &spi;\n    }\n\n    bool matchPins(DevicePin* mosi, DevicePin* miso, DevicePin* sck) {\n        return this->mosi == mosi && this->miso == miso && this->sck == sck;\n    }\n\n    int write(int value) {\n        return spi.write(value);\n    }\n\n    void transfer(Buffer command, Buffer response) {\n        auto cdata = NULL == command ? NULL : command->data;\n        auto clength = NULL == command ? 0 : command->length;\n        auto rdata = NULL == response ? NULL : response->data;\n        auto rlength = NULL == response ? 0 : response->length;\n        spi.transfer(cdata, clength, rdata, rlength);\n    }\n\n    void setFrequency(int frequency) {\n        spi.setFrequency(frequency);\n    }\n\n    void setMode(int mode) {\n        spi.setMode(mode);\n    }\n};\n\nSPI_ spis(NULL);\n\n/**\n* Opens a SPI driver\n*/\n//% help=pins/create-spi\n//% parts=spi\nSPI_ createSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin) {\n  auto dev = spis;\n  while(dev) {\n    if (dev->matchPins(mosiPin, misoPin, sckPin))\n      return dev;\n    dev = dev->next;\n  }\n\n  auto ser = new CodalSPIProxy(mosiPin, misoPin, sckPin);\n  ser->next = spis;\n  spis = ser;\n  return ser;\n}\n\n/**\n* Opens a slave SPI driver\n*/\n//% parts=spi\nSPI_ createSlaveSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin, DigitalInOutPin csPin) {\n#ifdef CODAL_SPI_SLAVE_SUPPORTED\n  auto dev = spis;\n  if (!csPin)\n    target_panic(PANIC_CODAL_HARDWARE_CONFIGURATION_ERROR);\n  while(dev) {\n    if (dev->matchPins(mosiPin, misoPin, sckPin))\n      return dev;\n    dev = dev->next;\n  }\n\n  auto ser = new CodalSPIProxy(mosiPin, misoPin, sckPin, csPin);\n  ser->next = spis;\n  spis = ser;\n  return ser;\n#else\n  target_panic(PANIC_CODAL_HARDWARE_CONFIGURATION_ERROR);\n  return NULL;\n#endif\n}\n\n}\n\nnamespace pxt {\n\nCODAL_SPI* getSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin) {\n    auto spi = pins::createSPI(mosiPin, misoPin, sckPin);\n    return spi->getSPI();\n}\n\n}\n\nnamespace SPIMethods {\n\n/**\n* Write to the SPI bus\n*/\n//%\nint write(SPI_ device, int value) {\n    return device->write(value);\n}\n\n/**\n* Transfer buffers over the SPI bus\n*/\n//% argsNullable\nvoid transfer(SPI_ device, Buffer command, Buffer response) {\n    if (!device)\n        target_panic(PANIC_CAST_FROM_NULL);\n    if (!command && !response)\n        return;\n    device->transfer(command, response);\n}\n\n/**\n* Sets the SPI clock frequency\n*/\n//%\nvoid setFrequency(SPI_ device, int frequency) {\n    device->setFrequency(frequency);\n}\n\n/**\n* Sets the SPI bus mode\n*/\n//%\nvoid setMode(SPI_ device, int mode) {\n    device->setMode(mode);\n}\n\n}\n",
            "spi.ts": "namespace pins {\n\n    let _spi: SPI;\n    /**\n    * Gets the default SPI driver\n    */\n    //%\n    export function spi() {\n        if (!_spi) {\n            const mosi = pins.pinByCfg(DAL.CFG_PIN_MOSI);\n            const miso = pins.pinByCfg(DAL.CFG_PIN_MISO);\n            const sck = pins.pinByCfg(DAL.CFG_PIN_SCK);\n            _spi = pins.createSPI(mosi, miso, sck);\n        }\n        return _spi;\n    }\n\n    /**\n     * Write to the SPI slave and return the response\n     * @param value Data to be sent to the SPI slave\n     */\n    //% help=pins/spi-write weight=5 advanced=true\n    //% blockId=spi_write block=\"spi write %value\"\n    export function spiWrite(value: number) {\n        return spi().write(value);\n    }\n\n    /**\n     * Write a given command to SPI bus, and at the same time read the response.\n     */\n    //% help=pins/spi-transfer weight=4 advanced=true\n    //% blockId=spi_transfer block=\"spi transfer %command into %response\"\n    export function spiTransfer(command: Buffer, response: Buffer) {\n        spi().transfer(command, response);\n    }\n\n    /**\n     * Set the SPI frequency\n     * @param frequency the clock frequency, eg: 1000000\n     */\n    //% help=pins/spi-frequency weight=4 advanced=true\n    //% blockId=spi_frequency block=\"spi frequency %frequency\"\n    export function spiFrequency(frequency: number) {\n        spi().setFrequency(frequency);\n    }\n\n    /**\n     * Set the SPI signal mode\n     * @param mode the mode, eg: 3\n     */\n    //% help=pins/spi-mode weight=3 advanced=true\n    //% blockId=spi_mode block=\"spi mode %mode\"\n    export function spiMode(mode: number) {\n        spi().setMode(mode);\n    }\n}",
            "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\n",
            "timer.ts": "namespace control {\n    /**\n     * A timer\n     */\n    //% fixedInstances\n    export class Timer {\n        start: number;\n\n        constructor() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Gets the elapsed time in millis since the last reset\n         */\n        //% blockId=timerMillis block=\"%timer|millis\"\n        millis(): number {\n            return control.millis() - this.start;\n        }\n\n        /**\n         * Gets the elapsed time in seconds since the last reset\n         */\n        //% blockId=timerSeconds block=\"%timer|seconds\"\n        seconds(): number {\n            return this.millis() / 1000;\n        }\n\n        /**\n         * Resets the timer\n         */\n        //% blockId=timerRest block=\"%timer|reset\"\n        reset() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Pauses until the timer reaches the given amount of milliseconds\n         * @param ms how long to pause for, eg: 5, 100, 200, 500, 1000, 2000\n         */\n        //% blockId=timerPauseUntil block=\"%timer|pause until (ms) %ms\"\n        pauseUntil(ms: number) {\n            const remaining = this.millis() - ms;\n            pause(Math.max(0, remaining));\n        }\n    }\n\n    //% whenUsed fixedInstance block=\"timer 1\"\n    export const timer1 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 2\"\n    export const timer2 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 3\"\n    export const timer3 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 4\"\n    export const timer4 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 5\"\n    export const timer5 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 6\"\n    export const timer6 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 7\"\n    export const timer7 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 8\"\n    export const timer8 = new Timer();\n}",
            "uf2format.h": "#ifndef UF2FORMAT_H\n#define UF2FORMAT_H 1\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// All entries are little endian.\n\n#ifndef BOOTLOADER_START\n#define BOOTLOADER_START 0x0\n#endif\n\n#ifndef BOOTLOADER_END\n#define BOOTLOADER_END 0x2000\n#endif\n\n#ifndef UF2_BINFO\n#define UF2_BINFO ((UF2_BInfo *)(BOOTLOADER_END - sizeof(UF2_BInfo)))\n#endif\n\n#ifndef UF2_INFO_TXT\n#define UF2_INFO_TXT UF2_BINFO->info_uf2\n#endif\n\n\n#define UF2_MAGIC_START0 0x0A324655UL // \"UF2\\n\"\n#define UF2_MAGIC_START1 0x9E5D5157UL // Randomly selected\n#define UF2_MAGIC_END 0x0AB16F30UL    // Ditto\n\n// If set, the block is \"comment\" and should not be flashed to the device\n#define UF2_FLAG_NOFLASH 0x00000001\n\ntypedef struct {\n    // 32 byte header\n    uint32_t magicStart0;\n    uint32_t magicStart1;\n    uint32_t flags;\n    uint32_t targetAddr;\n    uint32_t payloadSize;\n    uint32_t blockNo;\n    uint32_t numBlocks;\n    uint32_t reserved;\n\n    // raw data;\n    uint8_t data[476];\n\n    // store magic also at the end to limit damage from partial block reads\n    uint32_t magicEnd;\n} UF2_Block;\n\ntypedef struct {\n    uint8_t version;\n    uint8_t ep_in;\n    uint8_t ep_out;\n    uint8_t reserved0;\n    uint32_t cbw_tag;\n    uint32_t blocks_remaining;\n    uint8_t *buffer;\n} UF2_HandoverArgs;\n\ntypedef void (*UF2_MSC_Handover_Handler)(UF2_HandoverArgs *handover);\ntypedef void (*UF2_HID_Handover_Handler)(int ep);\n\n// this is required to be exactly 16 bytes long by the linker script\ntypedef struct {\n    void *reserved0;\n    UF2_HID_Handover_Handler handoverHID;\n    UF2_MSC_Handover_Handler handoverMSC;\n    const char *info_uf2;\n} UF2_BInfo;\n\nstatic inline bool is_uf2_block(void *data) {\n    UF2_Block *bl = (UF2_Block *)data;\n    return bl->magicStart0 == UF2_MAGIC_START0 && bl->magicStart1 == UF2_MAGIC_START1 &&\n           bl->magicEnd == UF2_MAGIC_END;\n}\n\nstatic inline bool in_uf2_bootloader_space(const void *addr) {\n    return (BOOTLOADER_START + 0x100) <= (uint32_t)addr && (uint32_t)addr < (BOOTLOADER_END);\n}\n\nstatic inline const char *uf2_info(void) {\n    if (in_uf2_bootloader_space(UF2_INFO_TXT))\n        return UF2_INFO_TXT;\n    return \"N/A\";\n}\n\n#ifdef UF2_DEFINE_HANDOVER\nstatic inline void hf2_handover(uint8_t ep) {\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_HID_Handover_Handler fn = UF2_BINFO->handoverHID;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        // Pass control to bootloader; never returns\n        fn(ep & 0xf);\n    }\n}\n\nstatic inline void check_uf2_handover(uint8_t *buffer, uint32_t blocks_remaining, uint8_t ep_in,\n                                      uint8_t ep_out, uint32_t cbw_tag) {\n    if (!is_uf2_block(buffer))\n        return;\n\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_MSC_Handover_Handler fn = UF2_BINFO->handoverMSC;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        UF2_HandoverArgs hand = {\n            1, ep_in, ep_out, 0, cbw_tag, blocks_remaining, buffer,\n        };\n        // Pass control to bootloader; never returns\n        fn(&hand);\n    }\n}\n#endif\n\n#endif\n",
            "uf2hid.h": "#ifndef UF2_HID_H\n#define UF2_HID_H 1\n\n#define HF2_CMD_BININFO 0x0001\n// no arguments\n#define HF2_MODE_BOOTLOADER 0x01\n#define HF2_MODE_USERSPACE 0x02\nstruct HF2_BININFO_Result {\n    uint32_t mode;\n    uint32_t flash_page_size;\n    uint32_t flash_num_pages;\n    uint32_t max_message_size;\n    uint32_t uf2_family;\n};\n\n#define HF2_CMD_INFO 0x0002\n// no arguments\n// results is utf8 character array\n\n#define HF2_CMD_RESET_INTO_APP 0x0003\n// no arguments, no result\n\n#define HF2_CMD_RESET_INTO_BOOTLOADER 0x0004\n// no arguments, no result\n\n#define HF2_CMD_START_FLASH 0x0005\n// no arguments, no result\n\n#define HF2_CMD_WRITE_FLASH_PAGE 0x0006\nstruct HF2_WRITE_FLASH_PAGE_Command {\n    uint32_t target_addr;\n    uint32_t data[0];\n};\n// no result\n\n#define HF2_CMD_CHKSUM_PAGES 0x0007\nstruct HF2_CHKSUM_PAGES_Command {\n    uint32_t target_addr;\n    uint32_t num_pages;\n};\nstruct HF2_CHKSUM_PAGES_Result {\n    uint16_t chksums[0 /* num_pages */];\n};\n\n#define HF2_CMD_READ_WORDS 0x0008\nstruct HF2_READ_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n};\nstruct HF2_READ_WORDS_Result {\n    uint32_t words[0 /* num_words */];\n};\n\n#define HF2_CMD_WRITE_WORDS 0x0009\nstruct HF2_WRITE_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n    uint32_t words[0 /* num_words */];\n};\n// no result\n\n#define HF2_CMD_DMESG 0x0010\n// no arguments\n// results is utf8 character array\n\n#define HF2_EV_MASK 0x800000\n\n#define HF2_CMD_JDS_CONFIG 0x0020\n#define HF2_CMD_JDS_SEND 0x0021\n#define HF2_EV_JDS_PACKET 0x800020\n\ntypedef struct {\n    uint32_t command_id;\n    uint16_t tag;\n    uint8_t reserved0;\n    uint8_t reserved1;\n\n    union {\n        struct HF2_WRITE_FLASH_PAGE_Command write_flash_page;\n        struct HF2_WRITE_WORDS_Command write_words;\n        struct HF2_READ_WORDS_Command read_words;\n        struct HF2_CHKSUM_PAGES_Command chksum_pages;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Command;\n\ntypedef struct {\n    union {\n        uint32_t eventId;\n        struct {\n            uint16_t tag;\n            union {\n                struct {\n                    uint8_t status;\n                    uint8_t status_info;\n                };\n                uint16_t status16;\n            };\n        };\n    };\n    union {\n        struct HF2_BININFO_Result bininfo;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Response;\n\n#define HF2_FLAG_SERIAL_OUT 0x80\n#define HF2_FLAG_SERIAL_ERR 0xC0\n#define HF2_FLAG_CMDPKT_LAST 0x40\n#define HF2_FLAG_CMDPKT_BODY 0x00\n#define HF2_FLAG_MASK 0xC0\n#define HF2_SIZE_MASK 63\n\n#define HF2_STATUS_OK 0x00\n#define HF2_STATUS_INVALID_CMD 0x01\n#define HF2_STATUS_INVALID_STATE 0x02\n\n#endif\n",
            "usb.cpp": "#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"uf2format.h\"\n\nnamespace pxt {\nCodalUSB usb;\n\n// share the buffer; we will crash anyway if someone talks to us over both at the same time\nHF2_Buffer hf2buf;\nHF2 hf2(hf2buf);\n#ifdef HF2_HID\nHF2 hf2hid(hf2buf);\n#endif\nDummyIface dummyIface;\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nUSBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nUSBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nUSBHIDJoystick joystick;\n#endif\n\nstatic const DeviceDescriptor device_desc = {\n    0x12,   // bLength\n    0x01,   // bDescriptorType\n    0x0210, // bcdUSBL\n\n    // Class etc specified per-interface\n    0x00, 0x00, 0x00,\n\n    0x40, // bMaxPacketSize0\n    USB_DEFAULT_VID, USB_DEFAULT_PID,\n    0x4202, // bcdDevice - leave unchanged for the HF2 to work\n    0x01,   // iManufacturer\n    0x02,   // iProduct\n    0x03,   // SerialNumber\n    0x01    // bNumConfigs\n};\n\nstatic void start_usb() {\n    // start USB with a delay, so that user code can add new interfaces if needed\n    // (eg USB HID keyboard, or MSC)\n    fiber_sleep(500);\n    usb.start();\n}\n\nvoid platform_usb_init() __attribute__((weak));\nvoid platform_usb_init() {}\n\nvoid set_usb_strings(const char *uf2_info) {\n    static const char *string_descriptors[3];\n    static char serial[12];\n    itoa(target_get_serial() & 0x7fffffff, serial);\n\n    auto model = strstr(uf2_info, \"Model: \");\n    if (model) {\n        model += 7;\n        auto end = model;\n        while (*end && *end != '\\n' && *end != '\\r')\n            end++;\n        auto len = end - model;\n        auto dev = (char *)app_alloc(len + 10);\n        memcpy(dev, model, len);\n        strcpy(dev + len, \" (app)\");\n        // try to split into manufacturer and\n        auto sep = strstr(dev, \" / \");\n        if (sep) {\n            *sep = '\\0';\n            string_descriptors[0] = dev;\n            string_descriptors[1] = sep + 3;\n        } else {\n            string_descriptors[0] = dev;\n            string_descriptors[1] = dev;\n        }\n    }\n\n    string_descriptors[2] = serial;\n    usb.stringDescriptors = string_descriptors;\n}\n\nvoid usb_init() {\n    usb.deviceDescriptor = &device_desc;\n    set_usb_strings(UF2_INFO_TXT);\n\n    platform_usb_init();\n\n    usb.add(hf2);\n\n#ifdef HF2_HID\n    hf2hid.useHID = true;\n    usb.add(hf2hid);\n#else\n    // the WINUSB descriptors don't seem to work if there's only one interface\n    // so we add a dummy interface\n    usb.add(dummyIface);\n#endif\n\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n    usb.add(mouse);\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n    usb.add(keyboard);\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n    usb.add(joystick);\n#endif\n\n    create_fiber(start_usb);\n}\n\n} // namespace pxt\n\n#else\nnamespace pxt {\nvoid usb_init() {}\n} // namespace pxt\n#endif\n\nnamespace control {\n/**\n * Determines if the USB has been enumerated.\n */\n//%\nbool isUSBInitialized() {\n#if CONFIG_ENABLED(DEVICE_USB)\n    return pxt::usb.isInitialised();\n#else\n    return false;\n#endif\n}\n}\n\nnamespace pxt {\nstatic void (*pSendToUART)(const char *data, int len) = NULL;\nvoid setSendToUART(void (*f)(const char *, int)) {\n    pSendToUART = f;\n}\n\nvoid sendSerial(const char *data, int len) {\n#if CONFIG_ENABLED(DEVICE_USB)\n    hf2.sendSerial(data, len);\n#if HF2_HID\n    hf2hid.sendSerial(data, len);\n#endif\n#endif\n    if (pSendToUART)\n        pSendToUART(data, len);\n}\n\nvoid dumpDmesg() {\n    sendSerial(\"\\nDMESG:\\n\", 8);\n    sendSerial(codalLogStore.buffer, codalLogStore.ptr);\n    sendSerial(\"\\n\\n\", 2);\n}\n\nvoid (*logJDFrame)(const uint8_t *data);\nvoid (*sendJDFrame)(const uint8_t *data);\n\n} // namespace pxt\n"
        },
        "core---samd": {
            "README.md": "# core\n\nThe core library for Codal-based targets.\n\n",
            "codal.cpp": "#include \"pxt.h\"\n#include \"LowLevelTimer.h\"\nusing namespace codal;\n\nvoid cpu_clock_init(void);\n\nPXT_ABI(__aeabi_dadd)\nPXT_ABI(__aeabi_dcmplt)\nPXT_ABI(__aeabi_dcmpgt)\nPXT_ABI(__aeabi_dsub)\nPXT_ABI(__aeabi_ddiv)\nPXT_ABI(__aeabi_dmul)\n\n#ifdef DEVICE_GET_FIBER_LIST_AVAILABLE\n// newer codal-core has get_fiber_list() but not list_fibers()\nnamespace codal {\n/*\n * Return all current fibers.\n *\n * @param dest If non-null, it points to an array of pointers to fibers to store results in.\n *\n * @return the number of fibers (potentially) stored\n */\nint list_fibers(Fiber **dest) {\n    int i = 0;\n    for (Fiber *fib = codal::get_fiber_list(); fib; fib = fib->next) {\n        if (dest)\n            dest[i] = fib;\n        i++;\n    }\n    return i;\n}\n\n} // namespace codal\n#endif\n\nnamespace pxt {\n\nvoid platform_init();\nvoid usb_init();\n\n// The first two word are used to tell the bootloader that a single reset should start the\n// bootloader and the MSD device, not us.\n// The rest is reserved for partial flashing checksums.\n__attribute__((section(\".binmeta\"))) __attribute__((used)) const uint32_t pxt_binmeta[] = {\n    0x87eeb07c, 0x87eeb07c, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n    0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff, 0x00ff00ff,\n};\n\nEvent lastEvent;\nMessageBus devMessageBus;\ncodal::CodalDevice device;\n\nstruct FreeList {\n    FreeList *next;\n};\n\nstatic void commInit() {\n    int commSize = bytecode[20];\n    if (!commSize)\n        return;\n\n    void *r = app_alloc_at((void *)PXT_COMM_BASE, commSize);\n    DMESG(\"comm %d -> %p\", commSize, r);\n    if (!r)\n        target_panic(20);\n}\n\nstatic void initCodal() {\n    cpu_clock_init();\n\n    commInit();\n\n    // Bring up fiber scheduler.\n    scheduler_init(devMessageBus);\n\n    // We probably don't need that - components are initialized when one obtains\n    // the reference to it.\n    // devMessageBus.listen(DEVICE_ID_MESSAGE_BUS_LISTENER, DEVICE_EVT_ANY, this,\n    // &CircuitPlayground::onListenerRegisteredEvent);\n\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; i++) {\n        if (CodalComponent::components[i])\n            CodalComponent::components[i]->init();\n    }\n\n    usb_init();\n\n    auto led = LOOKUP_PIN(LED);\n    if (led) {\n        led->setDigitalValue(0);\n    }\n}\n\n// ---------------------------------------------------------------------------\n// An adapter for the API expected by the run-time.\n// ---------------------------------------------------------------------------\n\n// We have the invariant that if [dispatchEvent] is registered against the DAL\n// for a given event, then [handlersMap] contains a valid entry for that\n// event.\nvoid dispatchEvent(Event e) {\n    lastEvent = e;\n\n    auto curr = findBinding(e.source, e.value);\n    auto value = fromInt(e.value);\n    while (curr) {\n        runAction1(curr->action, value);\n        curr = nextBinding(curr->next, e.source, e.value);\n    }\n}\n\nvoid registerWithDal(int id, int event, Action a, int flags) {\n    // first time?\n    if (!findBinding(id, event)) {\n        devMessageBus.listen(id, event, dispatchEvent, flags);\n        if (event == 0) {\n            // we're registering for all events on given ID\n            // need to remove old listeners for specific events\n            auto curr = findBinding(id, -1);\n            while (curr) {\n                devMessageBus.ignore(id, curr->value, dispatchEvent);\n                curr = nextBinding(curr->next, id, -1);\n            }\n        }\n    }\n    setBinding(id, event, a);\n}\n\nvoid fiberDone(void *a) {\n    unregisterGCPtr((Action)a);\n    release_fiber();\n}\n\nvoid releaseFiber() {\n    release_fiber();\n}\n\nvoid sleep_ms(unsigned ms) {\n    fiber_sleep(ms);\n}\n\nvoid sleep_us(uint64_t us) {\n    target_wait_us(us);\n}\n\nvoid forever_stub(void *a) {\n    while (true) {\n        runAction0((Action)a);\n        fiber_sleep(20);\n    }\n}\n\nvoid runForever(Action a) {\n    if (a != 0) {\n        registerGCPtr(a);\n        create_fiber(forever_stub, (void *)a);\n    }\n}\n\nvoid runInParallel(Action a) {\n    if (a != 0) {\n        registerGCPtr(a);\n        create_fiber((void (*)(void *))(void*)runAction0, (void *)a, fiberDone);\n    }\n}\n\nvoid waitForEvent(int id, int event) {\n    fiber_wait_for_event(id, event);\n}\n\nvoid initRuntime() {\n    initSystemTimer();\n    initCodal();\n    platform_init();\n}\n\n//%\nunsigned afterProgramPage() {\n    unsigned ptr = (unsigned)&bytecode[0];\n    ptr += programSize();\n    ptr = (ptr + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1);\n    return ptr;\n}\n\nuint64_t getLongSerialNumber() {\n    return device.getSerialNumber();\n}\n\nint current_time_ms() {\n    return system_timer_current_time();\n}\n\nuint64_t current_time_us() {\n    return system_timer_current_time_us();\n}\n\nThreadContext *getThreadContext() {\n    if (!currentFiber)\n        return NULL;\n    return (ThreadContext *)currentFiber->user_data;\n}\n\nvoid setThreadContext(ThreadContext *ctx) {\n    currentFiber->user_data = ctx;\n}\n\nstatic void *threadAddressFor(codal::Fiber *fib, void *sp) {\n    if (fib == currentFiber)\n        return sp;\n    return (uint8_t *)sp + ((uint8_t *)fib->stack_top - (uint8_t *)tcb_get_stack_base(fib->tcb));\n}\n\nvoid gcProcessStacks(int flags) {\n    // check scheduler is initialized\n    if (!currentFiber) {\n        // make sure we allocate something to at least initalize the memory allocator\n        void *volatile p = xmalloc(1);\n        xfree(p);\n        return;\n    }\n\n    int numFibers = codal::list_fibers(NULL);\n    codal::Fiber **fibers = (codal::Fiber **)xmalloc(sizeof(codal::Fiber *) * numFibers);\n    int num2 = codal::list_fibers(fibers);\n    if (numFibers != num2)\n        oops(12);\n    int cnt = 0;\n\n    for (int i = 0; i < numFibers; ++i) {\n        auto fib = fibers[i];\n        auto ctx = (ThreadContext *)fib->user_data;\n        if (!ctx)\n            continue;\n        gcProcess(ctx->thrownValue);\n        for (auto seg = &ctx->stack; seg; seg = seg->next) {\n            auto ptr = (TValue *)threadAddressFor(fib, seg->top);\n            auto end = (TValue *)threadAddressFor(fib, seg->bottom);\n            if (flags & 2)\n                DMESG(\"RS%d:%p/%d\", cnt++, ptr, end - ptr);\n            // VLOG(\"mark: %p - %p\", ptr, end);\n            while (ptr < end) {\n                gcProcess(*ptr++);\n            }\n        }\n    }\n    xfree(fibers);\n}\n\nLowLevelTimer *getJACDACTimer() {\n    static LowLevelTimer *jacdacTimer;\n    if (!jacdacTimer) {\n        jacdacTimer = allocateTimer();\n        jacdacTimer->setIRQPriority(1);\n    }\n    return jacdacTimer;\n}\nvoid initSystemTimer() {\n    new CODAL_TIMER(*allocateTimer());\n}\n\n} // namespace pxt\n",
            "control.cpp": "#include \"pxt.h\"\n\n#if defined(NRF52_SERIES)\n#define _estack __StackTop \n#endif\nextern uint32_t _estack;\n\nnamespace control {\n\n/**\n * Announce that an event happened to registered handlers.\n * @param src ID of the MicroBit Component that generated the event\n * @param value Component specific code indicating the cause of the event.\n */\n//% weight=21 blockGap=12 blockId=\"control_raise_event\"\n//% help=control/raise-event\n//% block=\"raise event|from %src|with value %value\" blockExternalInputs=1\nvoid raiseEvent(int src, int value) {\n    Event evt(src, value);\n}\n\n/**\n* Determine the version of system software currently running.\n*/\n//% blockId=\"control_device_dal_version\" block=\"device dal version\"\n//% help=control/device-dal-version\nString deviceDalVersion() {\n    return mkString(device.getVersion());\n}\n\n/**\n* Allocates the next user notification event\n*/\n//% help=control/allocate-notify-event\nint allocateNotifyEvent() {\n    return ::allocateNotifyEvent();\n}\n\n/** Write a message to DMESG debugging buffer. */\n//%\nvoid dmesg(String s) {\n    DMESG(\"# %s\", s->getUTF8Data());\n}\n\n/** Write a message and value (pointer) to DMESG debugging buffer. */\n//%\nvoid dmesgPtr(String str, Object_ ptr) {\n    DMESG(\"# %s: %p\", str->getUTF8Data(), ptr);\n}\n\n//%\nuint32_t _ramSize()\n{\n    return (uint32_t)&_estack & 0x1fffffff;\n}\n\n}\n",
            "dal.d.ts": "// Auto-generated. Do not edit.\ndeclare const enum DAL {\n    // /libraries/codal-core/inc/JACDAC/JACDAC.h\n    JD_VERSION = 5,\n    JD_SERIAL_MAX_BUFFERS = 10,\n    JD_SERIAL_RECEIVING = 2,\n    JD_SERIAL_TRANSMITTING = 4,\n    JD_SERIAL_TX_DRAIN_ENABLE = 8,\n    JD_SERIAL_BUS_RISE = 16,\n    JD_SERIAL_EVT_DATA_READY = 1,\n    JD_SERIAL_EVT_BUS_ERROR = 2,\n    JD_SERIAL_EVT_DRAIN = 3,\n    JD_SERIAL_EVT_RX_TIMEOUT = 4,\n    JD_SERIAL_EVT_BUS_CONNECTED = 5,\n    JD_SERIAL_EVT_BUS_DISCONNECTED = 6,\n    JD_SERIAL_HEADER_SIZE = 4,\n    JD_SERIAL_DATA_SIZE = 32,\n    JD_SERIAL_PACKET_SIZE = 36,\n    JD_SERIAL_MAXIMUM_BUFFERS = 10,\n    JD_SERIAL_DMA_TIMEOUT = 2,\n    JD_SERIAL_MAX_BAUD = 1000000,\n    JD_SERIAL_TX_MAX_BACKOFF = 4000,\n    JD_SERIAL_TX_MIN_BACKOFF = 1000,\n    Receiving = 0,\n    Transmitting = 1,\n    High = 2,\n    Low = 3,\n    Baud1M = 1,\n    Baud500K = 2,\n    Baud250K = 4,\n    Baud125K = 8,\n    // /libraries/codal-core/inc/JACDAC/JDAccelerometerDriver.h\n    JD_ACCEL_EVT_SEND_DATA = 1,\n    // /libraries/codal-core/inc/JACDAC/JDBridgeDriver.h\n    JD_BRIDGE_HISTORY_SIZE = 8,\n    // /libraries/codal-core/inc/JACDAC/JDClasses.h\n    STATIC_CLASS_START = 0,\n    STATIC_CLASS_END = 16777215,\n    DYNAMIC_CLASS_END = 4294967295,\n    JD_DRIVER_CLASS_CODAL_START = 0,\n    JD_DRIVER_CLASS_CODAL_END = 2000,\n    JD_DRIVER_CLASS_MAKECODE_START = 2000,\n    JD_DRIVER_CLASS_MAKECODE_END = 4000,\n    JD_DRIVER_CLASS_CONTROL = 0,\n    JD_DRIVER_CLASS_JOYSTICK = 1,\n    JD_DRIVER_CLASS_MESSAGE_BUS = 2,\n    JD_DRIVER_CLASS_BRIDGE = 3,\n    JD_DRIVER_CLASS_BUTTON = 4,\n    JD_DRIVER_CLASS_PIN = 5,\n    JD_DRIVER_CLASS_RELIABILITY_TESTER = 6,\n    JD_DRIVER_CLASS_ACCELEROMETER = 7,\n    JD_DRIVER_CLASS_CAPTOUCH_BUTTON = 8,\n    // /libraries/codal-core/inc/JACDAC/JDMessageBusDriver.h\n    JD_MESSAGEBUS_TYPE_EVENT = 1,\n    JD_MESSAGEBUS_TYPE_LISTEN = 2,\n    // /libraries/codal-core/inc/JACDAC/JDPinDriver.h\n    SetDigital = 0,\n    SetAnalog = 1,\n    SetServo = 2,\n    // /libraries/codal-core/inc/JACDAC/JDProtocol.h\n    JD_DRIVER_EVT_CONNECTED = 65520,\n    JD_DRIVER_EVT_DISCONNECTED = 65521,\n    JD_DRIVER_EVT_PAIRED = 65522,\n    JD_DRIVER_EVT_UNPAIRED = 65523,\n    JD_DRIVER_EVT_PAIR_REJECTED = 65524,\n    JD_DRIVER_EVT_PAIRING_RESPONSE = 65525,\n    JD_DRIVER_EVT_ERROR = 65526,\n    JD_DEVICE_FLAGS_LOCAL = 32768,\n    JD_DEVICE_FLAGS_REMOTE = 16384,\n    JD_DEVICE_FLAGS_BROADCAST = 8192,\n    JD_DEVICE_FLAGS_PAIR = 4096,\n    JD_DEVICE_DRIVER_MODE_MSK = 61440,\n    JD_DEVICE_FLAGS_PAIRABLE = 2048,\n    JD_DEVICE_FLAGS_PAIRED = 1024,\n    JD_DEVICE_FLAGS_PAIRING = 512,\n    JD_DEVICE_FLAGS_INITIALISED = 128,\n    JD_DEVICE_FLAGS_INITIALISING = 64,\n    JD_DEVICE_FLAGS_CP_SEEN = 32,\n    JD_DEVICE_ERROR_MSK = 15,\n    JD_LOGIC_DRIVER_MAX_FILTERS = 20,\n    JD_LOGIC_DRIVER_TIMEOUT = 254,\n    JD_LOGIC_ADDRESS_ALLOC_TIME = 254,\n    JD_LOGIC_DRIVER_CTRLPACKET_TIME = 112,\n    JD_LOGIC_DRIVER_EVT_CHANGED = 2,\n    CONTROL_JD_FLAGS_RESERVED = 32768,\n    CONTROL_JD_FLAGS_PAIRING_MODE = 16384,\n    CONTROL_JD_FLAGS_PAIRABLE = 8192,\n    CONTROL_JD_FLAGS_PAIRED = 4096,\n    CONTROL_JD_FLAGS_CONFLICT = 2048,\n    CONTROL_JD_FLAGS_UNCERTAIN = 1024,\n    CONTROL_JD_FLAGS_NACK = 512,\n    CONTROL_JD_FLAGS_ACK = 256,\n    CONTROL_JD_TYPE_HELLO = 1,\n    CONTROL_JD_TYPE_PAIRING_REQUEST = 2,\n    CONTROL_JD_TYPE_ERROR = 3,\n    CONTROL_JD_TYPE_PANIC = 255,\n    JD_PROTOCOL_EVT_SEND_CONTROL = 1,\n    JD_PROTOCOL_DRIVER_ARRAY_SIZE = 20,\n    CONTROL_PACKET_ERROR_NAME_LENGTH = 6,\n    VirtualDriver = 16384,\n    PairedDriver = 12288,\n    HostDriver = 32768,\n    PairableHostDriver = 34816,\n    BroadcastDriver = 40960,\n    SnifferDriver = 24576,\n    DRIVER_OK = 0,\n    DRIVER_CALIBRATION_IN_PROGRESS = 1,\n    DRIVER_CALIBRATION_REQUIRED = 2,\n    DRIVER_NO_RESOURCES = 3,\n    DRIVER_BUSY = 4,\n    DRIVER_COMMS_ERROR = 5,\n    DRIVER_INVALID_STATE = 6,\n    DRIVER_PERIPHERAL_MALFUNCTION = 7,\n    // /libraries/codal-core/inc/JACDAC/JDReliabilityTester.h\n    RELIABILITY_TEST_FINISHED = 7,\n    RELIABILITY_STATUS_TEST_IN_PROGRESS = 2,\n    RELIABILITY_STATUS_TEST_READY = 4,\n    RELIABILITY_STATUS_TEST_FINISHED = 8,\n    // /libraries/codal-core/inc/core/CodalComponent.h\n    DEVICE_ID_BUTTON_A = 1,\n    DEVICE_ID_BUTTON_B = 2,\n    DEVICE_ID_BUTTON_AB = 3,\n    DEVICE_ID_BUTTON_RESET = 4,\n    DEVICE_ID_ACCELEROMETER = 5,\n    DEVICE_ID_COMPASS = 6,\n    DEVICE_ID_DISPLAY = 7,\n    DEVICE_ID_THERMOMETER = 8,\n    DEVICE_ID_RADIO = 9,\n    DEVICE_ID_RADIO_DATA_READY = 10,\n    DEVICE_ID_MULTIBUTTON_ATTACH = 11,\n    DEVICE_ID_SERIAL = 12,\n    DEVICE_ID_GESTURE = 13,\n    DEVICE_ID_SYSTEM_TIMER = 14,\n    DEVICE_ID_SCHEDULER = 15,\n    DEVICE_ID_COMPONENT = 16,\n    DEVICE_ID_LIGHT_SENSOR = 17,\n    DEVICE_ID_TOUCH_SENSOR = 18,\n    DEVICE_ID_SYSTEM_DAC = 19,\n    DEVICE_ID_SYSTEM_MICROPHONE = 20,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR = 21,\n    DEVICE_ID_SYSTEM_LEVEL_DETECTOR_SPL = 22,\n    DEVICE_ID_MSC = 23,\n    DEVICE_ID_SPI = 24,\n    DEVICE_ID_DISTANCE = 25,\n    DEVICE_ID_GYROSCOPE = 26,\n    DEVICE_ID_HUMIDITY = 27,\n    DEVICE_ID_PRESSURE = 28,\n    DEVICE_ID_JACDAC0 = 29,\n    DEVICE_ID_JACDAC1 = 30,\n    DEVICE_ID_JACDAC_PROTOCOL = 31,\n    DEVICE_ID_JACKROUTER = 32,\n    DEVICE_ID_GAME_ENGINE = 33,\n    DEVICE_ID_GAME_STATE_MANAGER = 34,\n    DEVICE_ID_SPRITE = 35,\n    DEVICE_ID_SINGLE_WIRE_SERIAL = 36,\n    DEVICE_ID_IO_P0 = 100,\n    DEVICE_ID_MESSAGE_BUS_LISTENER = 1021,\n    DEVICE_ID_NOTIFY_ONE = 1022,\n    DEVICE_ID_NOTIFY = 1023,\n    DEVICE_ID_BUTTON_UP = 2000,\n    DEVICE_ID_BUTTON_DOWN = 2001,\n    DEVICE_ID_BUTTON_LEFT = 2002,\n    DEVICE_ID_BUTTON_RIGHT = 2003,\n    DEVICE_ID_JD_DYNAMIC_ID = 3000,\n    DEVICE_COMPONENT_RUNNING = 4096,\n    DEVICE_COMPONENT_STATUS_SYSTEM_TICK = 8192,\n    DEVICE_COMPONENT_STATUS_IDLE_TICK = 16384,\n    DEVICE_COMPONENT_LISTENERS_CONFIGURED = 1,\n    DEVICE_COMPONENT_EVT_SYSTEM_TICK = 1,\n    // /libraries/codal-core/inc/core/CodalFiber.h\n    DEVICE_SCHEDULER_RUNNING = 1,\n    DEVICE_SCHEDULER_IDLE = 2,\n    DEVICE_FIBER_FLAG_FOB = 1,\n    DEVICE_FIBER_FLAG_PARENT = 2,\n    DEVICE_FIBER_FLAG_CHILD = 4,\n    DEVICE_FIBER_FLAG_DO_NOT_PAGE = 8,\n    DEVICE_SCHEDULER_EVT_TICK = 1,\n    DEVICE_SCHEDULER_EVT_IDLE = 2,\n    // /libraries/codal-core/inc/core/CodalListener.h\n    MESSAGE_BUS_LISTENER_PARAMETERISED = 1,\n    MESSAGE_BUS_LISTENER_METHOD = 2,\n    MESSAGE_BUS_LISTENER_BUSY = 4,\n    MESSAGE_BUS_LISTENER_REENTRANT = 8,\n    MESSAGE_BUS_LISTENER_QUEUE_IF_BUSY = 16,\n    MESSAGE_BUS_LISTENER_DROP_IF_BUSY = 32,\n    MESSAGE_BUS_LISTENER_NONBLOCKING = 64,\n    MESSAGE_BUS_LISTENER_URGENT = 128,\n    MESSAGE_BUS_LISTENER_DELETING = 32768,\n    MESSAGE_BUS_LISTENER_IMMEDIATE = 192,\n    // /libraries/codal-core/inc/core/ErrorNo.h\n    DEVICE_OK = 0,\n    DEVICE_INVALID_PARAMETER = -1001,\n    DEVICE_NOT_SUPPORTED = -1002,\n    DEVICE_CALIBRATION_IN_PROGRESS = -1003,\n    DEVICE_CALIBRATION_REQUIRED = -1004,\n    DEVICE_NO_RESOURCES = -1005,\n    DEVICE_BUSY = -1006,\n    DEVICE_CANCELLED = -1007,\n    DEVICE_I2C_ERROR = -1010,\n    DEVICE_SERIAL_IN_USE = -1011,\n    DEVICE_NO_DATA = -1012,\n    DEVICE_NOT_IMPLEMENTED = -1013,\n    DEVICE_SPI_ERROR = -1014,\n    DEVICE_INVALID_STATE = -1015,\n    DEVICE_OOM = 20,\n    DEVICE_HEAP_ERROR = 30,\n    DEVICE_NULL_DEREFERENCE = 40,\n    DEVICE_USB_ERROR = 50,\n    DEVICE_HARDWARE_CONFIGURATION_ERROR = 90,\n    // /libraries/codal-core/inc/core/NotifyEvents.h\n    DISPLAY_EVT_FREE = 1,\n    CODAL_SERIAL_EVT_TX_EMPTY = 2,\n    BLE_EVT_SERIAL_TX_EMPTY = 3,\n    ARCADE_PLAYER_JOIN_RESULT = 4,\n    DEVICE_NOTIFY_USER_EVENT_BASE = 1024,\n    // /libraries/codal-core/inc/driver-models/AbstractButton.h\n    DEVICE_BUTTON_EVT_DOWN = 1,\n    DEVICE_BUTTON_EVT_UP = 2,\n    DEVICE_BUTTON_EVT_CLICK = 3,\n    DEVICE_BUTTON_EVT_LONG_CLICK = 4,\n    DEVICE_BUTTON_EVT_HOLD = 5,\n    DEVICE_BUTTON_EVT_DOUBLE_CLICK = 6,\n    DEVICE_BUTTON_LONG_CLICK_TIME = 1000,\n    DEVICE_BUTTON_HOLD_TIME = 1500,\n    DEVICE_BUTTON_STATE = 1,\n    DEVICE_BUTTON_STATE_HOLD_TRIGGERED = 2,\n    DEVICE_BUTTON_STATE_CLICK = 4,\n    DEVICE_BUTTON_STATE_LONG_CLICK = 8,\n    DEVICE_BUTTON_SIGMA_MIN = 0,\n    DEVICE_BUTTON_SIGMA_MAX = 12,\n    DEVICE_BUTTON_SIGMA_THRESH_HI = 8,\n    DEVICE_BUTTON_SIGMA_THRESH_LO = 2,\n    DEVICE_BUTTON_DOUBLE_CLICK_THRESH = 50,\n    DEVICE_BUTTON_SIMPLE_EVENTS = 0,\n    DEVICE_BUTTON_ALL_EVENTS = 1,\n    ACTIVE_LOW = 0,\n    ACTIVE_HIGH = 1,\n    // /libraries/codal-core/inc/driver-models/Accelerometer.h\n    ACCELEROMETER_IMU_DATA_VALID = 2,\n    ACCELEROMETER_EVT_DATA_UPDATE = 1,\n    ACCELEROMETER_EVT_NONE = 0,\n    ACCELEROMETER_EVT_TILT_UP = 1,\n    ACCELEROMETER_EVT_TILT_DOWN = 2,\n    ACCELEROMETER_EVT_TILT_LEFT = 3,\n    ACCELEROMETER_EVT_TILT_RIGHT = 4,\n    ACCELEROMETER_EVT_FACE_UP = 5,\n    ACCELEROMETER_EVT_FACE_DOWN = 6,\n    ACCELEROMETER_EVT_FREEFALL = 7,\n    ACCELEROMETER_EVT_3G = 8,\n    ACCELEROMETER_EVT_6G = 9,\n    ACCELEROMETER_EVT_8G = 10,\n    ACCELEROMETER_EVT_SHAKE = 11,\n    ACCELEROMETER_EVT_2G = 12,\n    ACCELEROMETER_REST_TOLERANCE = 200,\n    ACCELEROMETER_TILT_TOLERANCE = 200,\n    ACCELEROMETER_FREEFALL_TOLERANCE = 400,\n    ACCELEROMETER_SHAKE_TOLERANCE = 400,\n    ACCELEROMETER_2G_TOLERANCE = 2048,\n    ACCELEROMETER_3G_TOLERANCE = 3072,\n    ACCELEROMETER_6G_TOLERANCE = 6144,\n    ACCELEROMETER_8G_TOLERANCE = 8192,\n    ACCELEROMETER_GESTURE_DAMPING = 5,\n    ACCELEROMETER_SHAKE_DAMPING = 10,\n    ACCELEROMETER_SHAKE_RTX = 30,\n    ACCELEROMETER_SHAKE_COUNT_THRESHOLD = 4,\n    // /libraries/codal-core/inc/driver-models/Compass.h\n    COMPASS_STATUS_RUNNING = 1,\n    COMPASS_STATUS_CALIBRATED = 2,\n    COMPASS_STATUS_CALIBRATING = 4,\n    COMPASS_STATUS_ADDED_TO_IDLE = 8,\n    COMPASS_EVT_DATA_UPDATE = 1,\n    COMPASS_EVT_CONFIG_NEEDED = 2,\n    COMPASS_EVT_CALIBRATE = 3,\n    COMPASS_EVT_CALIBRATION_NEEDED = 4,\n    // /libraries/codal-core/inc/driver-models/Gyroscope.h\n    GYROSCOPE_IMU_DATA_VALID = 2,\n    GYROSCOPE_EVT_DATA_UPDATE = 1,\n    // /libraries/codal-core/inc/driver-models/LowLevelTimer.h\n    TimerModeTimer = 0,\n    TimerModeCounter = 1,\n    TimerModeAlternateFunction = 2,\n    BitMode8 = 0,\n    BitMode16 = 1,\n    BitMode24 = 2,\n    BitMode32 = 3,\n    // /libraries/codal-core/inc/driver-models/Pin.h\n    IO_STATUS_DIGITAL_IN = 1,\n    IO_STATUS_DIGITAL_OUT = 2,\n    IO_STATUS_ANALOG_IN = 4,\n    IO_STATUS_ANALOG_OUT = 8,\n    IO_STATUS_TOUCH_IN = 16,\n    IO_STATUS_EVENT_ON_EDGE = 32,\n    IO_STATUS_EVENT_PULSE_ON_EDGE = 64,\n    DEVICE_PIN_MAX_OUTPUT = 1023,\n    DEVICE_PIN_MAX_SERVO_RANGE = 180,\n    DEVICE_PIN_DEFAULT_SERVO_RANGE = 2000,\n    DEVICE_PIN_DEFAULT_SERVO_CENTER = 1500,\n    DEVICE_PIN_EVENT_NONE = 0,\n    DEVICE_PIN_EVENT_ON_EDGE = 1,\n    DEVICE_PIN_EVENT_ON_PULSE = 2,\n    DEVICE_PIN_EVENT_ON_TOUCH = 3,\n    DEVICE_PIN_EVT_RISE = 2,\n    DEVICE_PIN_EVT_FALL = 3,\n    DEVICE_PIN_EVT_PULSE_HI = 4,\n    DEVICE_PIN_EVT_PULSE_LO = 5,\n    PIN_CAPABILITY_DIGITAL = 1,\n    PIN_CAPABILITY_ANALOG = 2,\n    PIN_CAPABILITY_AD = 3,\n    PIN_CAPABILITY_ALL = 3,\n    None = 0,\n    Down = 1,\n    Up = 2,\n    // /libraries/codal-core/inc/driver-models/Radio.h\n    RADIO_EVT_DATA_READY = 2,\n    // /libraries/codal-core/inc/driver-models/SPIFlash.h\n    SPIFLASH_PAGE_SIZE = 256,\n    SPIFLASH_SMALL_ROW_PAGES = 16,\n    SPIFLASH_BIG_ROW_PAGES = 256,\n    // /libraries/codal-core/inc/driver-models/Sensor.h\n    SENSOR_THRESHOLD_LOW = 1,\n    SENSOR_THRESHOLD_HIGH = 2,\n    SENSOR_UPDATE_NEEDED = 3,\n    SENSOR_INITIALISED = 1,\n    SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    SENSOR_LOW_THRESHOLD_PASSED = 4,\n    SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    SENSOR_DEFAULT_SENSITIVITY = 868,\n    SENSOR_DEFAULT_SAMPLE_PERIOD = 500,\n    // /libraries/codal-core/inc/driver-models/Serial.h\n    CODAL_SERIAL_DEFAULT_BAUD_RATE = 115200,\n    CODAL_SERIAL_DEFAULT_BUFFER_SIZE = 20,\n    CODAL_SERIAL_EVT_DELIM_MATCH = 1,\n    CODAL_SERIAL_EVT_HEAD_MATCH = 2,\n    CODAL_SERIAL_EVT_RX_FULL = 3,\n    CODAL_SERIAL_EVT_DATA_RECEIVED = 4,\n    CODAL_SERIAL_STATUS_RX_IN_USE = 1,\n    CODAL_SERIAL_STATUS_TX_IN_USE = 2,\n    CODAL_SERIAL_STATUS_RX_BUFF_INIT = 4,\n    CODAL_SERIAL_STATUS_TX_BUFF_INIT = 8,\n    CODAL_SERIAL_STATUS_RXD = 16,\n    ASYNC = 0,\n    SYNC_SPINWAIT = 1,\n    SYNC_SLEEP = 2,\n    RxInterrupt = 0,\n    TxInterrupt = 1,\n    // /libraries/codal-core/inc/driver-models/SingleWireSerial.h\n    SWS_EVT_DATA_RECEIVED = 1,\n    SWS_EVT_DATA_SENT = 2,\n    SWS_EVT_ERROR = 3,\n    SWS_EVT_DATA_DROPPED = 4,\n    SingleWireRx = 0,\n    SingleWireTx = 1,\n    SingleWireDisconnected = 2,\n    // /libraries/codal-core/inc/driver-models/Timer.h\n    CODAL_TIMER_DEFAULT_EVENT_LIST_SIZE = 10,\n    // /libraries/codal-core/inc/drivers/AnalogSensor.h\n    ANALOG_THRESHOLD_LOW = 1,\n    ANALOG_THRESHOLD_HIGH = 2,\n    ANALOG_SENSOR_UPDATE_NEEDED = 3,\n    ANALOG_SENSOR_INITIALISED = 1,\n    ANALOG_SENSOR_HIGH_THRESHOLD_PASSED = 2,\n    ANALOG_SENSOR_LOW_THRESHOLD_PASSED = 4,\n    ANALOG_SENSOR_LOW_THRESHOLD_ENABLED = 8,\n    ANALOG_SENSOR_HIGH_THRESHOLD_ENABLED = 16,\n    // /libraries/codal-core/inc/drivers/AnimatedDisplay.h\n    DISPLAY_EVT_ANIMATION_COMPLETE = 1,\n    DISPLAY_DEFAULT_AUTOCLEAR = 1,\n    DISPLAY_SPACING = 1,\n    DISPLAY_ANIMATE_DEFAULT_POS = -255,\n    DISPLAY_DEFAULT_SCROLL_SPEED = 120,\n    DISPLAY_DEFAULT_SCROLL_STRIDE = -1,\n    DISPLAY_DEFAULT_PRINT_SPEED = 400,\n    ANIMATION_MODE_NONE = 0,\n    ANIMATION_MODE_STOPPED = 1,\n    ANIMATION_MODE_SCROLL_TEXT = 2,\n    ANIMATION_MODE_PRINT_TEXT = 3,\n    ANIMATION_MODE_SCROLL_IMAGE = 4,\n    ANIMATION_MODE_ANIMATE_IMAGE = 5,\n    ANIMATION_MODE_ANIMATE_IMAGE_WITH_CLEAR = 6,\n    ANIMATION_MODE_PRINT_CHARACTER = 7,\n    // /libraries/codal-core/inc/drivers/FAT.h\n    FAT_RESERVED_SECTORS = 1,\n    FAT_ROOT_DIR_SECTORS = 4,\n    // /libraries/codal-core/inc/drivers/HID.h\n    HID_REQUEST_GET_REPORT = 1,\n    HID_REQUEST_GET_IDLE = 2,\n    HID_REQUEST_GET_PROTOCOL = 3,\n    HID_REQUEST_SET_REPORT = 9,\n    HID_REQUEST_SET_IDLE = 10,\n    HID_REQUEST_SET_PROTOCOL = 11,\n    // /libraries/codal-core/inc/drivers/HIDKeyboard.h\n    HID_KEYBOARD_NUM_REPORTS = 3,\n    HID_KEYBOARD_REPORT_GENERIC = 1,\n    HID_KEYBOARD_REPORT_CONSUMER = 2,\n    HID_KEYBOARD_KEYSTATE_SIZE_GENERIC = 8,\n    HID_KEYBOARD_KEYSTATE_SIZE_CONSUMER = 2,\n    HID_KEYBOARD_MODIFIER_OFFSET = 2,\n    HID_KEYBOARD_DELAY_DEFAULT = 10,\n    PressKey = 0,\n    ReleaseKey = 1,\n    // /libraries/codal-core/inc/drivers/JackRouter.h\n    AllDown = 1,\n    HeadPhones = 2,\n    Buzzer = 3,\n    BuzzerAndSerial = 4,\n    // /libraries/codal-core/inc/drivers/KeyMap.h\n    KEYMAP_ALL_KEYS_UP_Val = 1,\n    KEYMAP_ALL_KEYS_UP_POS = 28,\n    KEYMAP_NORMAL_KEY_Val = 0,\n    KEYMAP_MODIFIER_KEY_Val = 1,\n    KEYMAP_MODIFIER_POS = 29,\n    KEYMAP_MEDIA_KEY_Val = 1,\n    KEYMAP_MEDIA_POS = 30,\n    KEYMAP_KEY_UP_Val = 0,\n    KEYMAP_KEY_DOWN_Val = 1,\n    KEYMAP_KEY_DOWN_POS = 31,\n    // /libraries/codal-core/inc/drivers/LEDMatrix.h\n    LED_MATRIX_GREYSCALE_BIT_DEPTH = 8,\n    LED_MATRIX_EVT_LIGHT_SENSE = 2,\n    LED_MATRIX_EVT_FRAME_TIMEOUT = 3,\n    LED_MATRIX_MINIMUM_BRIGHTNESS = 1,\n    LED_MATRIX_MAXIMUM_BRIGHTNESS = 255,\n    LED_MATRIX_DEFAULT_BRIGHTNESS = 255,\n    DISPLAY_MODE_BLACK_AND_WHITE = 0,\n    DISPLAY_MODE_GREYSCALE = 1,\n    DISPLAY_MODE_BLACK_AND_WHITE_LIGHT_SENSE = 2,\n    MATRIX_DISPLAY_ROTATION_0 = 0,\n    MATRIX_DISPLAY_ROTATION_90 = 1,\n    MATRIX_DISPLAY_ROTATION_180 = 2,\n    MATRIX_DISPLAY_ROTATION_270 = 3,\n    NO_CONN = 0,\n    // /libraries/codal-core/inc/drivers/MAG3110.h\n    MAG3110_DEFAULT_ADDR = 29,\n    MAG_DR_STATUS = 0,\n    MAG_OUT_X_MSB = 1,\n    MAG_OUT_X_LSB = 2,\n    MAG_OUT_Y_MSB = 3,\n    MAG_OUT_Y_LSB = 4,\n    MAG_OUT_Z_MSB = 5,\n    MAG_OUT_Z_LSB = 6,\n    MAG_WHOAMI = 7,\n    MAG_SYSMOD = 8,\n    MAG_OFF_X_MSB = 9,\n    MAG_OFF_X_LSB = 10,\n    MAG_OFF_Y_MSB = 11,\n    MAG_OFF_Y_LSB = 12,\n    MAG_OFF_Z_MSB = 13,\n    MAG_OFF_Z_LSB = 14,\n    MAG_DIE_TEMP = 15,\n    MAG_CTRL_REG1 = 16,\n    MAG_CTRL_REG2 = 17,\n    MAG3110_SAMPLE_RATES = 11,\n    MAG3110_WHOAMI_VAL = 196,\n    // /libraries/codal-core/inc/drivers/MMA8453.h\n    MMA8453_DEFAULT_ADDR = 56,\n    MMA8453_WHOAMI_VAL = 58,\n    // /libraries/codal-core/inc/drivers/MMA8653.h\n    MICROBIT_ACCEL_PITCH_ROLL_VALID = 2,\n    MICROBIT_ACCEL_ADDED_TO_IDLE = 4,\n    MMA8653_DEFAULT_ADDR = 58,\n    MMA8653_STATUS = 0,\n    MMA8653_OUT_X_MSB = 1,\n    MMA8653_WHOAMI = 13,\n    MMA8653_XYZ_DATA_CFG = 14,\n    MMA8653_CTRL_REG1 = 42,\n    MMA8653_CTRL_REG2 = 43,\n    MMA8653_CTRL_REG3 = 44,\n    MMA8653_CTRL_REG4 = 45,\n    MMA8653_CTRL_REG5 = 46,\n    MMA8653_WHOAMI_VAL = 90,\n    MMA8653_SAMPLE_RANGES = 3,\n    MMA8653_SAMPLE_RATES = 8,\n    // /libraries/codal-core/inc/drivers/MPU6050.h\n    MPU6050_DEFAULT_ADDR = 104,\n    MPU6050_WHOAMI = 117,\n    MPU6050_WHOAMI_VAL = 52,\n    // /libraries/codal-core/inc/drivers/MultiButton.h\n    MULTI_BUTTON_STATE_1 = 1,\n    MULTI_BUTTON_STATE_2 = 2,\n    MULTI_BUTTON_HOLD_TRIGGERED_1 = 4,\n    MULTI_BUTTON_HOLD_TRIGGERED_2 = 8,\n    MULTI_BUTTON_SUPRESSED_1 = 16,\n    MULTI_BUTTON_SUPRESSED_2 = 32,\n    MULTI_BUTTON_ATTACHED = 64,\n    // /libraries/codal-core/inc/drivers/ST7735.h\n    MADCTL_MY = 128,\n    MADCTL_MX = 64,\n    MADCTL_MV = 32,\n    MADCTL_ML = 16,\n    MADCTL_RGB = 0,\n    MADCTL_BGR = 8,\n    MADCTL_MH = 4,\n    // /libraries/codal-core/inc/drivers/TouchButton.h\n    TOUCH_BUTTON_CALIBRATION_PERIOD = 10,\n    TOUCH_BUTTON_CALIBRATION_LINEAR_OFFSET = 2,\n    TOUCH_BUTTON_CALIBRATION_PERCENTAGE_OFFSET = 5,\n    TOUCH_BUTTON_CALIBRATING = 16,\n    // /libraries/codal-core/inc/drivers/TouchSensor.h\n    TOUCH_SENSOR_MAX_BUTTONS = 10,\n    TOUCH_SENSOR_SAMPLE_PERIOD = 50,\n    TOUCH_SENSE_SAMPLE_MAX = 1000,\n    TOUCH_SENSOR_UPDATE_NEEDED = 1,\n    // /libraries/codal-core/inc/drivers/USB_HID_Keys.h\n    KEY_MOD_LCTRL = 1,\n    KEY_MOD_LSHIFT = 2,\n    KEY_MOD_LALT = 4,\n    KEY_MOD_LMETA = 8,\n    KEY_MOD_RCTRL = 16,\n    KEY_MOD_RSHIFT = 32,\n    KEY_MOD_RALT = 64,\n    KEY_MOD_RMETA = 128,\n    KEY_NONE = 0,\n    KEY_ERR_OVF = 1,\n    KEY_A = 4,\n    KEY_B = 5,\n    KEY_C = 6,\n    KEY_D = 7,\n    KEY_E = 8,\n    KEY_F = 9,\n    KEY_G = 10,\n    KEY_H = 11,\n    KEY_I = 12,\n    KEY_J = 13,\n    KEY_K = 14,\n    KEY_L = 15,\n    KEY_M = 16,\n    KEY_N = 17,\n    KEY_O = 18,\n    KEY_P = 19,\n    KEY_Q = 20,\n    KEY_R = 21,\n    KEY_S = 22,\n    KEY_T = 23,\n    KEY_U = 24,\n    KEY_V = 25,\n    KEY_W = 26,\n    KEY_X = 27,\n    KEY_Y = 28,\n    KEY_Z = 29,\n    KEY_1 = 30,\n    KEY_2 = 31,\n    KEY_3 = 32,\n    KEY_4 = 33,\n    KEY_5 = 34,\n    KEY_6 = 35,\n    KEY_7 = 36,\n    KEY_8 = 37,\n    KEY_9 = 38,\n    KEY_0 = 39,\n    KEY_ENTER = 40,\n    KEY_ESC = 41,\n    KEY_BACKSPACE = 42,\n    KEY_TAB = 43,\n    KEY_SPACE = 44,\n    KEY_MINUS = 45,\n    KEY_EQUAL = 46,\n    KEY_LEFTBRACE = 47,\n    KEY_RIGHTBRACE = 48,\n    KEY_BACKSLASH = 49,\n    KEY_HASHTILDE = 50,\n    KEY_SEMICOLON = 51,\n    KEY_APOSTROPHE = 52,\n    KEY_GRAVE = 53,\n    KEY_COMMA = 54,\n    KEY_DOT = 55,\n    KEY_SLASH = 56,\n    KEY_CAPSLOCK = 57,\n    KEY_F1 = 58,\n    KEY_F2 = 59,\n    KEY_F3 = 60,\n    KEY_F4 = 61,\n    KEY_F5 = 62,\n    KEY_F6 = 63,\n    KEY_F7 = 64,\n    KEY_F8 = 65,\n    KEY_F9 = 66,\n    KEY_F10 = 67,\n    KEY_F11 = 68,\n    KEY_F12 = 69,\n    KEY_SYSRQ = 70,\n    KEY_SCROLLLOCK = 71,\n    KEY_PAUSE = 72,\n    KEY_INSERT = 73,\n    KEY_HOME = 74,\n    KEY_PAGEUP = 75,\n    KEY_DELETE = 76,\n    KEY_END = 77,\n    KEY_PAGEDOWN = 78,\n    KEY_RIGHT = 79,\n    KEY_LEFT = 80,\n    KEY_DOWN = 81,\n    KEY_UP = 82,\n    KEY_NUMLOCK = 83,\n    KEY_KPSLASH = 84,\n    KEY_KPASTERISK = 85,\n    KEY_KPMINUS = 86,\n    KEY_KPPLUS = 87,\n    KEY_KPENTER = 88,\n    KEY_KP1 = 89,\n    KEY_KP2 = 90,\n    KEY_KP3 = 91,\n    KEY_KP4 = 92,\n    KEY_KP5 = 93,\n    KEY_KP6 = 94,\n    KEY_KP7 = 95,\n    KEY_KP8 = 96,\n    KEY_KP9 = 97,\n    KEY_KP0 = 98,\n    KEY_KPDOT = 99,\n    KEY_102ND = 100,\n    KEY_COMPOSE = 101,\n    KEY_POWER = 102,\n    KEY_KPEQUAL = 103,\n    KEY_F13 = 104,\n    KEY_F14 = 105,\n    KEY_F15 = 106,\n    KEY_F16 = 107,\n    KEY_F17 = 108,\n    KEY_F18 = 109,\n    KEY_F19 = 110,\n    KEY_F20 = 111,\n    KEY_F21 = 112,\n    KEY_F22 = 113,\n    KEY_F23 = 114,\n    KEY_F24 = 115,\n    KEY_OPEN = 116,\n    KEY_HELP = 117,\n    KEY_PROPS = 118,\n    KEY_FRONT = 119,\n    KEY_STOP = 120,\n    KEY_AGAIN = 121,\n    KEY_UNDO = 122,\n    KEY_CUT = 123,\n    KEY_COPY = 124,\n    KEY_PASTE = 125,\n    KEY_FIND = 126,\n    KEY_MUTE = 127,\n    KEY_VOLUMEUP = 128,\n    KEY_VOLUMEDOWN = 129,\n    KEY_KPCOMMA = 133,\n    KEY_RO = 135,\n    KEY_KATAKANAHIRAGANA = 136,\n    KEY_YEN = 137,\n    KEY_HENKAN = 138,\n    KEY_MUHENKAN = 139,\n    KEY_KPJPCOMMA = 140,\n    KEY_HANGEUL = 144,\n    KEY_HANJA = 145,\n    KEY_KATAKANA = 146,\n    KEY_HIRAGANA = 147,\n    KEY_ZENKAKUHANKAKU = 148,\n    KEY_KPLEFTPAREN = 182,\n    KEY_KPRIGHTPAREN = 183,\n    KEY_LEFTCTRL = 224,\n    KEY_LEFTSHIFT = 225,\n    KEY_LEFTALT = 226,\n    KEY_LEFTMETA = 227,\n    KEY_RIGHTCTRL = 228,\n    KEY_RIGHTSHIFT = 229,\n    KEY_RIGHTALT = 230,\n    KEY_RIGHTMETA = 231,\n    KEY_MEDIA_PLAYPAUSE = 232,\n    KEY_MEDIA_STOPCD = 233,\n    KEY_MEDIA_PREVIOUSSONG = 234,\n    KEY_MEDIA_NEXTSONG = 235,\n    KEY_MEDIA_EJECTCD = 236,\n    KEY_MEDIA_VOLUMEUP = 237,\n    KEY_MEDIA_VOLUMEDOWN = 238,\n    KEY_MEDIA_MUTE = 239,\n    KEY_MEDIA_WWW = 240,\n    KEY_MEDIA_BACK = 241,\n    KEY_MEDIA_FORWARD = 242,\n    KEY_MEDIA_STOP = 243,\n    KEY_MEDIA_FIND = 244,\n    KEY_MEDIA_SCROLLUP = 245,\n    KEY_MEDIA_SCROLLDOWN = 246,\n    KEY_MEDIA_EDIT = 247,\n    KEY_MEDIA_SLEEP = 248,\n    KEY_MEDIA_COFFEE = 249,\n    KEY_MEDIA_REFRESH = 250,\n    KEY_MEDIA_CALC = 251,\n    // /libraries/codal-core/inc/drivers/uf2format.h\n    UF2FORMAT_H = 1,\n    APP_START_ADDRESS = 8192,\n    UF2_FLAG_NOFLASH = 1,\n    // /libraries/codal-core/inc/streams/DataStream.h\n    DATASTREAM_MAXIMUM_BUFFERS = 1,\n    // /libraries/codal-core/inc/streams/LevelDetector.h\n    LEVEL_THRESHOLD_LOW = 1,\n    LEVEL_THRESHOLD_HIGH = 2,\n    LEVEL_DETECTOR_INITIALISED = 1,\n    LEVEL_DETECTOR_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_DEFAULT_WINDOW_SIZE = 128,\n    // /libraries/codal-core/inc/streams/LevelDetectorSPL.h\n    LEVEL_DETECTOR_SPL_INITIALISED = 1,\n    LEVEL_DETECTOR_SPL_HIGH_THRESHOLD_PASSED = 2,\n    LEVEL_DETECTOR_SPL_LOW_THRESHOLD_PASSED = 4,\n    LEVEL_DETECTOR_SPL_DEFAULT_WINDOW_SIZE = 128,\n    // /libraries/codal-core/inc/streams/Synthesizer.h\n    SYNTHESIZER_SAMPLE_RATE = 44100,\n    TONE_WIDTH = 1024,\n    // /libraries/codal-core/inc/types/BitmapFont.h\n    BITMAP_FONT_WIDTH = 5,\n    BITMAP_FONT_HEIGHT = 5,\n    BITMAP_FONT_ASCII_START = 32,\n    BITMAP_FONT_ASCII_END = 126,\n    // /libraries/codal-core/inc/types/CoordinateSystem.h\n    COORDINATE_SPACE_ROTATED_0 = 0,\n    COORDINATE_SPACE_ROTATED_90 = 1,\n    COORDINATE_SPACE_ROTATED_180 = 2,\n    COORDINATE_SPACE_ROTATED_270 = 3,\n    RAW = 0,\n    SIMPLE_CARTESIAN = 1,\n    NORTH_EAST_DOWN = 2,\n    NORTH_EAST_UP = 3,\n    // /libraries/codal-core/inc/types/Event.h\n    DEVICE_ID_ANY = 0,\n    DEVICE_EVT_ANY = 0,\n    CREATE_ONLY = 0,\n    CREATE_AND_FIRE = 1,\n    DEVICE_EVENT_DEFAULT_LAUNCH_MODE = 1,\n    // /libraries/codal-core/inc/types/RefCounted.h\n    REF_TAG_STRING = 1,\n    REF_TAG_BUFFER = 2,\n    REF_TAG_IMAGE = 3,\n    REF_TAG_USER = 32,\n    // /pxtapp/accelerometer/axis.h\n    ACC_SYSTEM = 3,\n    ACC_ROTATION = 0,\n    // /pxtapp/configkeys.h\n    CFG_PIN_NAME_MSK = 65535,\n    CFG_PIN_CONFIG_MSK = 4294901760,\n    CFG_PIN_CONFIG_ACTIVE_LO = 65536,\n    CFG_MAGIC0 = 513675505,\n    CFG_MAGIC1 = 539130489,\n    CFG_PIN_ACCELEROMETER_INT = 1,\n    CFG_PIN_ACCELEROMETER_SCL = 2,\n    CFG_PIN_ACCELEROMETER_SDA = 3,\n    CFG_PIN_BTN_A = 4,\n    CFG_PIN_BTN_B = 5,\n    CFG_PIN_BTN_SLIDE = 6,\n    CFG_PIN_DOTSTAR_CLOCK = 7,\n    CFG_PIN_DOTSTAR_DATA = 8,\n    CFG_PIN_FLASH_CS = 9,\n    CFG_PIN_FLASH_MISO = 10,\n    CFG_PIN_FLASH_MOSI = 11,\n    CFG_PIN_FLASH_SCK = 12,\n    CFG_PIN_LED = 13,\n    CFG_PIN_LIGHT = 14,\n    CFG_PIN_MICROPHONE = 15,\n    CFG_PIN_MIC_CLOCK = 16,\n    CFG_PIN_MIC_DATA = 17,\n    CFG_PIN_MISO = 18,\n    CFG_PIN_MOSI = 19,\n    CFG_PIN_NEOPIXEL = 20,\n    CFG_PIN_RX = 21,\n    CFG_PIN_RXLED = 22,\n    CFG_PIN_SCK = 23,\n    CFG_PIN_SCL = 24,\n    CFG_PIN_SDA = 25,\n    CFG_PIN_SPEAKER_AMP = 26,\n    CFG_PIN_TEMPERATURE = 27,\n    CFG_PIN_TX = 28,\n    CFG_PIN_TXLED = 29,\n    CFG_PIN_IR_OUT = 30,\n    CFG_PIN_IR_IN = 31,\n    CFG_PIN_DISPLAY_SCK = 32,\n    CFG_PIN_DISPLAY_MISO = 33,\n    CFG_PIN_DISPLAY_MOSI = 34,\n    CFG_PIN_DISPLAY_CS = 35,\n    CFG_PIN_DISPLAY_DC = 36,\n    CFG_DISPLAY_WIDTH = 37,\n    CFG_DISPLAY_HEIGHT = 38,\n    CFG_DISPLAY_CFG0 = 39,\n    CFG_DISPLAY_CFG1 = 40,\n    CFG_DISPLAY_CFG2 = 41,\n    CFG_DISPLAY_CFG3 = 42,\n    CFG_PIN_DISPLAY_RST = 43,\n    CFG_PIN_DISPLAY_BL = 44,\n    CFG_PIN_SERVO_1 = 45,\n    CFG_PIN_SERVO_2 = 46,\n    CFG_PIN_BTN_LEFT = 47,\n    CFG_PIN_BTN_RIGHT = 48,\n    CFG_PIN_BTN_UP = 49,\n    CFG_PIN_BTN_DOWN = 50,\n    CFG_PIN_BTN_MENU = 51,\n    CFG_PIN_LED_R = 52,\n    CFG_PIN_LED_G = 53,\n    CFG_PIN_LED_B = 54,\n    CFG_PIN_LED1 = 55,\n    CFG_PIN_LED2 = 56,\n    CFG_PIN_LED3 = 57,\n    CFG_PIN_LED4 = 58,\n    CFG_SPEAKER_VOLUME = 59,\n    CFG_PIN_JACK_TX = 60,\n    CFG_PIN_JACK_SENSE = 61,\n    CFG_PIN_JACK_HPEN = 62,\n    CFG_PIN_JACK_BZEN = 63,\n    CFG_PIN_JACK_PWREN = 64,\n    CFG_PIN_JACK_SND = 65,\n    CFG_PIN_JACK_BUSLED = 66,\n    CFG_PIN_JACK_COMMLED = 67,\n    CFG_PIN_BTN_SOFT_RESET = 69,\n    CFG_ACCELEROMETER_TYPE = 70,\n    CFG_PIN_BTNMX_LATCH = 71,\n    CFG_PIN_BTNMX_CLOCK = 72,\n    CFG_PIN_BTNMX_DATA = 73,\n    CFG_PIN_BTN_MENU2 = 74,\n    CFG_PIN_BATTSENSE = 75,\n    CFG_PIN_VIBRATION = 76,\n    CFG_PIN_PWREN = 77,\n    ACCELEROMETER_TYPE_LIS3DH = 50,\n    ACCELEROMETER_TYPE_MMA8453 = 56,\n    ACCELEROMETER_TYPE_FXOS8700 = 60,\n    ACCELEROMETER_TYPE_MMA8653 = 58,\n    ACCELEROMETER_TYPE_MSA300 = 76,\n    ACCELEROMETER_TYPE_MPU6050 = 104,\n    CFG_PIN_A0 = 100,\n    CFG_PIN_A1 = 101,\n    CFG_PIN_A2 = 102,\n    CFG_PIN_A3 = 103,\n    CFG_PIN_A4 = 104,\n    CFG_PIN_A5 = 105,\n    CFG_PIN_A6 = 106,\n    CFG_PIN_A7 = 107,\n    CFG_PIN_A8 = 108,\n    CFG_PIN_A9 = 109,\n    CFG_PIN_A10 = 110,\n    CFG_PIN_A11 = 111,\n    CFG_PIN_A12 = 112,\n    CFG_PIN_A13 = 113,\n    CFG_PIN_A14 = 114,\n    CFG_PIN_A15 = 115,\n    CFG_PIN_A16 = 116,\n    CFG_PIN_A17 = 117,\n    CFG_PIN_A18 = 118,\n    CFG_PIN_A19 = 119,\n    CFG_PIN_A20 = 120,\n    CFG_PIN_A21 = 121,\n    CFG_PIN_A22 = 122,\n    CFG_PIN_A23 = 123,\n    CFG_PIN_A24 = 124,\n    CFG_PIN_A25 = 125,\n    CFG_PIN_A26 = 126,\n    CFG_PIN_A27 = 127,\n    CFG_PIN_A28 = 128,\n    CFG_PIN_A29 = 129,\n    CFG_PIN_A30 = 130,\n    CFG_PIN_A31 = 131,\n    CFG_PIN_D0 = 150,\n    CFG_PIN_D1 = 151,\n    CFG_PIN_D2 = 152,\n    CFG_PIN_D3 = 153,\n    CFG_PIN_D4 = 154,\n    CFG_PIN_D5 = 155,\n    CFG_PIN_D6 = 156,\n    CFG_PIN_D7 = 157,\n    CFG_PIN_D8 = 158,\n    CFG_PIN_D9 = 159,\n    CFG_PIN_D10 = 160,\n    CFG_PIN_D11 = 161,\n    CFG_PIN_D12 = 162,\n    CFG_PIN_D13 = 163,\n    CFG_PIN_D14 = 164,\n    CFG_PIN_D15 = 165,\n    CFG_PIN_D16 = 166,\n    CFG_PIN_D17 = 167,\n    CFG_PIN_D18 = 168,\n    CFG_PIN_D19 = 169,\n    CFG_PIN_D20 = 170,\n    CFG_PIN_D21 = 171,\n    CFG_PIN_D22 = 172,\n    CFG_PIN_D23 = 173,\n    CFG_PIN_D24 = 174,\n    CFG_PIN_D25 = 175,\n    CFG_PIN_D26 = 176,\n    CFG_PIN_D27 = 177,\n    CFG_PIN_D28 = 178,\n    CFG_PIN_D29 = 179,\n    CFG_PIN_D30 = 180,\n    CFG_PIN_D31 = 181,\n    CFG_NUM_NEOPIXELS = 200,\n    CFG_NUM_DOTSTARS = 201,\n    CFG_DEFAULT_BUTTON_MODE = 202,\n    CFG_SWD_ENABLED = 203,\n    CFG_FLASH_BYTES = 204,\n    CFG_RAM_BYTES = 205,\n    CFG_SYSTEM_HEAP_BYTES = 206,\n    CFG_LOW_MEM_SIMULATION_KB = 207,\n    CFG_BOOTLOADER_BOARD_ID = 208,\n    CFG_UF2_FAMILY = 209,\n    CFG_PINS_PORT_SIZE = 210,\n    CFG_BOOTLOADER_PROTECTION = 211,\n    CFG_POWER_DEEPSLEEP_TIMEOUT = 212,\n    CFG_ANALOG_BUTTON_THRESHOLD = 213,\n    CFG_PIN_B0 = 300,\n    CFG_PIN_B1 = 301,\n    CFG_PIN_B2 = 302,\n    CFG_PIN_B3 = 303,\n    CFG_PIN_B4 = 304,\n    CFG_PIN_B5 = 305,\n    CFG_PIN_B6 = 306,\n    CFG_PIN_B7 = 307,\n    CFG_PIN_B8 = 308,\n    CFG_PIN_B9 = 309,\n    CFG_PIN_B10 = 310,\n    CFG_PIN_B11 = 311,\n    CFG_PIN_B12 = 312,\n    CFG_PIN_B13 = 313,\n    CFG_PIN_B14 = 314,\n    CFG_PIN_B15 = 315,\n    CFG_PIN_B16 = 316,\n    CFG_PIN_B17 = 317,\n    CFG_PIN_B18 = 318,\n    CFG_PIN_B19 = 319,\n    CFG_PIN_B20 = 320,\n    CFG_PIN_B21 = 321,\n    CFG_PIN_B22 = 322,\n    CFG_PIN_B23 = 323,\n    CFG_PIN_B24 = 324,\n    CFG_PIN_B25 = 325,\n    CFG_PIN_B26 = 326,\n    CFG_PIN_B27 = 327,\n    CFG_PIN_B28 = 328,\n    CFG_PIN_B29 = 329,\n    CFG_PIN_B30 = 330,\n    CFG_PIN_B31 = 331,\n    CFG_PIN_C0 = 350,\n    CFG_PIN_C1 = 351,\n    CFG_PIN_C2 = 352,\n    CFG_PIN_C3 = 353,\n    CFG_PIN_C4 = 354,\n    CFG_PIN_C5 = 355,\n    CFG_PIN_C6 = 356,\n    CFG_PIN_C7 = 357,\n    CFG_PIN_C8 = 358,\n    CFG_PIN_C9 = 359,\n    CFG_PIN_C10 = 360,\n    CFG_PIN_C11 = 361,\n    CFG_PIN_C12 = 362,\n    CFG_PIN_C13 = 363,\n    CFG_PIN_C14 = 364,\n    CFG_PIN_C15 = 365,\n    CFG_PIN_C16 = 366,\n    CFG_PIN_C17 = 367,\n    CFG_PIN_C18 = 368,\n    CFG_PIN_C19 = 369,\n    CFG_PIN_C20 = 370,\n    CFG_PIN_C21 = 371,\n    CFG_PIN_C22 = 372,\n    CFG_PIN_C23 = 373,\n    CFG_PIN_C24 = 374,\n    CFG_PIN_C25 = 375,\n    CFG_PIN_C26 = 376,\n    CFG_PIN_C27 = 377,\n    CFG_PIN_C28 = 378,\n    CFG_PIN_C29 = 379,\n    CFG_PIN_C30 = 380,\n    CFG_PIN_C31 = 381,\n    CFG_PIN_P0 = 400,\n    CFG_PIN_P1 = 401,\n    CFG_PIN_P2 = 402,\n    CFG_PIN_P3 = 403,\n    CFG_PIN_P4 = 404,\n    CFG_PIN_P5 = 405,\n    CFG_PIN_P6 = 406,\n    CFG_PIN_P7 = 407,\n    CFG_PIN_P8 = 408,\n    CFG_PIN_P9 = 409,\n    CFG_PIN_P10 = 410,\n    CFG_PIN_P11 = 411,\n    CFG_PIN_P12 = 412,\n    CFG_PIN_P13 = 413,\n    CFG_PIN_P14 = 414,\n    CFG_PIN_P15 = 415,\n    CFG_PIN_P16 = 416,\n    CFG_PIN_P17 = 417,\n    CFG_PIN_P18 = 418,\n    CFG_PIN_P19 = 419,\n    CFG_PIN_P20 = 420,\n    CFG_PIN_LORA_MISO = 1001,\n    CFG_PIN_LORA_MOSI = 1002,\n    CFG_PIN_LORA_SCK = 1003,\n    CFG_PIN_LORA_CS = 1004,\n    CFG_PIN_LORA_BOOT = 1005,\n    CFG_PIN_LORA_RESET = 1006,\n    CFG_PIN_IRRXLED = 1007,\n    CFG_PIN_IRTXLED = 1008,\n    CFG_PIN_LCD_RESET = 1009,\n    CFG_PIN_LCD_ENABLE = 1010,\n    CFG_PIN_LCD_DATALINE4 = 1011,\n    CFG_PIN_LCD_DATALINE5 = 1012,\n    CFG_PIN_LCD_DATALINE6 = 1013,\n    CFG_PIN_LCD_DATALINE7 = 1014,\n    CFG_NUM_LCD_COLUMNS = 1015,\n    CFG_NUM_LCD_ROWS = 1016,\n    // /pxtapp/hf2dbg.h\n    HF2DBG_H = 1,\n    // /pxtapp/mixer---samd/melody.h\n    SW_TRIANGLE = 1,\n    SW_SAWTOOTH = 2,\n    SW_SINE = 3,\n    SW_NOISE = 4,\n    SW_REAL_NOISE = 5,\n    SW_SQUARE_10 = 11,\n    SW_SQUARE_50 = 15,\n    CODAL = 1,\n    MAX_SOUNDS = 5,\n    Waiting = 0,\n    Playing = 1,\n    Done = 2,\n    // /pxtapp/pins.h\n    BUTTON_ACTIVE_HIGH_PULL_DOWN = 17,\n    BUTTON_ACTIVE_HIGH_PULL_UP = 33,\n    BUTTON_ACTIVE_HIGH_PULL_NONE = 49,\n    BUTTON_ACTIVE_LOW_PULL_DOWN = 16,\n    BUTTON_ACTIVE_LOW_PULL_UP = 32,\n    BUTTON_ACTIVE_LOW_PULL_NONE = 48,\n    // /pxtapp/platform.h\n    PAGE_SIZE = 512,\n    DEV_NUM_PINS = 64,\n    PXT_74HC165 = 1,\n    IMAGE_BITS = 4,\n    PA00 = 0,\n    PA01 = 1,\n    PA02 = 2,\n    PA03 = 3,\n    PA04 = 4,\n    PA05 = 5,\n    PA06 = 6,\n    PA07 = 7,\n    PA08 = 8,\n    PA09 = 9,\n    PA10 = 10,\n    PA11 = 11,\n    PA12 = 12,\n    PA13 = 13,\n    PA14 = 14,\n    PA15 = 15,\n    PA16 = 16,\n    PA17 = 17,\n    PA18 = 18,\n    PA19 = 19,\n    PA20 = 20,\n    PA21 = 21,\n    PA22 = 22,\n    PA23 = 23,\n    PA24 = 24,\n    PA25 = 25,\n    PA26 = 26,\n    PA27 = 27,\n    PA28 = 28,\n    PA29 = 29,\n    PA30 = 30,\n    PA31 = 31,\n    PB00 = 32,\n    PB01 = 33,\n    PB02 = 34,\n    PB03 = 35,\n    PB04 = 36,\n    PB05 = 37,\n    PB06 = 38,\n    PB07 = 39,\n    PB08 = 40,\n    PB09 = 41,\n    PB10 = 42,\n    PB11 = 43,\n    PB12 = 44,\n    PB13 = 45,\n    PB14 = 46,\n    PB15 = 47,\n    PB16 = 48,\n    PB17 = 49,\n    PB18 = 50,\n    PB19 = 51,\n    PB20 = 52,\n    PB21 = 53,\n    PB22 = 54,\n    PB23 = 55,\n    PB24 = 56,\n    PB25 = 57,\n    PB26 = 58,\n    PB27 = 59,\n    PB28 = 60,\n    PB29 = 61,\n    PB30 = 62,\n    PB31 = 63,\n    // /pxtapp/pxt.h\n    DEVICE_ID_BUTTON_SLIDE = 3000,\n    DEVICE_ID_MICROPHONE = 3001,\n    DEVICE_ID_FIRST_BUTTON = 4000,\n    DEVICE_ID_FIRST_TOUCHBUTTON = 4100,\n    // /pxtapp/pxtbase.h\n    PXT_REFCNT_FLASH = 65534,\n    VTABLE_MAGIC = 249,\n    Undefined = 0,\n    Boolean = 1,\n    Number = 2,\n    String = 3,\n    Object = 4,\n    Function = 5,\n    BoxedString = 1,\n    BoxedNumber = 2,\n    BoxedBuffer = 3,\n    RefAction = 4,\n    RefImage = 5,\n    RefCollection = 6,\n    RefRefLocal = 7,\n    RefMap = 8,\n    RefMImage = 9,\n    User0 = 16,\n    Int8LE = 1,\n    UInt8LE = 2,\n    Int16LE = 3,\n    UInt16LE = 4,\n    Int32LE = 5,\n    Int8BE = 6,\n    UInt8BE = 7,\n    Int16BE = 8,\n    UInt16BE = 9,\n    Int32BE = 10,\n    UInt32LE = 11,\n    UInt32BE = 12,\n    Float32LE = 13,\n    Float64LE = 14,\n    Float32BE = 15,\n    Float64BE = 16,\n    GC = 0,\n    // /pxtapp/pxtconfig.h\n    PXT_GC = 1,\n    PXT_UF2_FAMILY = 1760373640,\n    // /pxtapp/storage/SNORFS.h\n    DEVICE_FLASH_ERROR = 950,\n    // /pxtapp/thermometer/target_temperature.h\n    TEMPERATURE_NOMINAL_VALUE = 25,\n    TEMPERATURE_NOMINAL_READING = 10000,\n    TEMPERATURE_BETA = 3380,\n    TEMPERATURE_SERIES_RESISTOR = 10000,\n    // /pxtapp/uf2format.h\n    BOOTLOADER_START = 0,\n    // /pxtapp/uf2hid.h\n    UF2_HID_H = 1,\n}\n",
            "dmac.cpp": "#include \"dmac.h\"\n\nnamespace pxt {\n\n#ifdef CODAL_DMAC\nSINGLETON(WDMAC);\n#endif\n\n}",
            "dmac.h": "#ifndef __DMAC_H\n#define __DMAC_H\n\n#include \"pxt.h\"\n\nnamespace pxt {\n\n#ifdef CODAL_DMAC\nclass WDMAC {\n  public:\n    CODAL_DMAC dmac;\n\n    WDMAC() {}\n};\n\nWDMAC* getWDMAC();\n#endif\n\n}\n\n#endif",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum PulseValue {\n    //% block=high\n    High = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=low\n    Low = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    }\n\n\n    declare const enum PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = 4,  // DEVICE_PIN_EVT_PULSE_HI\n    //% block=\"pulse low\"\n    PulseLow = 5,  // DEVICE_PIN_EVT_PULSE_LO\n    //% block=\"rise\"\n    Rise = 2,  // DEVICE_PIN_EVT_RISE\n    //% block=\"fall\"\n    Fall = 3,  // DEVICE_PIN_EVT_FALL\n    }\n\n\n    declare const enum PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "hf2.cpp": "#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#ifndef USB_HANDOVER\n#define USB_HANDOVER 1\n#endif\n\n#if USB_HANDOVER\n#define UF2_DEFINE_HANDOVER 1\n#endif\n\n#include \"uf2format.h\"\n\nstatic void *stackCopy;\nstatic uint32_t stackSize;\n\n//#define LOG DMESG\n#define LOG(...) ((void)0)\n\nstatic volatile bool resume = false;\n\nusing namespace codal;\n\n#ifdef HF2_HID\nstatic const char hidDescriptor[] = {\n    0x06, 0x97, 0xFF, // usage page vendor 0x97 (usage 0xff97 0x0001)\n    0x09, 0x01,       // usage 1\n    0xA1, 0x01,       // collection - application\n    0x15, 0x00,       // logical min 0\n    0x26, 0xFF, 0x00, // logical max 255\n    0x75, 8,          // report size 8\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x81, 0x02,       // input: data, variable, absolute\n    0x95, 64,         // report count 64\n    0x09, 0x01,       // usage 1\n    0x91, 0x02,       // output: data, variable, absolute\n    0x95, 1,          // report count 1\n    0x09, 0x01,       // usage 1\n    0xB1, 0x02,       // feature: data, variable, absolute\n    0xC0,             // end\n};\n\nstatic const HIDReportDescriptor reportDesc = {\n    9,\n    0x21,                  // HID\n    0x100,                 // hidbcd 1.00\n    0x00,                  // country code\n    0x01,                  // num desc\n    0x22,                  // report desc type\n    sizeof(hidDescriptor), // size of 0x22\n};\n\nstatic const InterfaceInfo ifaceInfoHID = {\n    &reportDesc,\n    sizeof(reportDesc),\n    1,\n    {\n        2,    // numEndpoints\n        0x03, /// class code - HID\n        0x00, // subclass\n        0x00, // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {USB_EP_TYPE_INTERRUPT, 1},\n    {USB_EP_TYPE_INTERRUPT, 1},\n};\n#endif\n\nstatic const InterfaceInfo ifaceInfoEP = {\n    NULL,\n    0,\n    2,\n    {\n        2,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        42,   // subclass\n        1,    // protocol\n        0x02, // string\n        0x00, // alt\n    },\n    {USB_EP_TYPE_BULK, 0},\n    {USB_EP_TYPE_BULK, 0},\n};\n\nint HF2::stdRequest(UsbEndpointIn &ctrl, USBSetup &setup) {\n#ifdef HF2_HID\n    if (!useHID)\n        return DEVICE_NOT_SUPPORTED;\n    if (setup.bRequest == USB_REQ_GET_DESCRIPTOR) {\n        if (setup.wValueH == 0x21) {\n            InterfaceDescriptor tmp;\n            fillInterfaceInfo(&tmp);\n            return ctrl.write(&tmp, sizeof(tmp));\n        } else if (setup.wValueH == 0x22) {\n            return ctrl.write(hidDescriptor, sizeof(hidDescriptor));\n        }\n    }\n#endif\n    return DEVICE_NOT_SUPPORTED;\n}\n\n// same as in microbit\n#define CTRL_GET_REPORT 0x01\n#define CTRL_SET_REPORT 0x09\n#define CTRL_OUT_REPORT_H 0x2\n#define CTRL_IN_REPORT_H 0x1\n\nvoid HF2::sendBuffer(uint8_t flag, const void *data, unsigned size, uint32_t prepend) {\n    if (!CodalUSB::usbInstance->isInitialised())\n        return;\n\n    uint32_t buf[64 / 4]; // aligned\n\n    if (prepend + 1)\n        size += 4;\n\n    target_disable_irq();\n    while (size > 0) {\n        memset(buf + 1, 0, 60);\n        int s = 63;\n        if (size <= 63) {\n            s = size;\n            buf[0] = flag;\n        } else {\n            buf[0] = flag == HF2_FLAG_CMDPKT_LAST ? HF2_FLAG_CMDPKT_BODY : flag;\n        }\n        buf[0] |= s;\n        uint8_t *dst = (uint8_t *)buf;\n        dst++;\n        if (prepend + 1) {\n            memcpy(dst, &prepend, 4);\n            prepend = -1;\n            dst += 4;\n            s -= 4;\n            size -= 4;\n        }\n        memcpy(dst, data, s);\n        data = (const uint8_t *)data + s;\n        size -= s;\n\n        in->write(buf, sizeof(buf));\n    }\n    target_enable_irq();\n}\n\nconst InterfaceInfo *HF2::getInterfaceInfo() {\n#ifdef HF2_HID\n    if (useHID)\n        return &ifaceInfoHID;\n#endif\n    return &ifaceInfoEP;\n}\n\nint HF2::sendEvent(uint32_t evId, const void *data, int size) {\n    sendBuffer(HF2_FLAG_CMDPKT_LAST, data, size, evId);\n    return 0;\n}\n\nint HF2::sendSerial(const void *data, int size, int isError) {\n    if (!gotSomePacket)\n        return DEVICE_OK;\n\n    sendBuffer(isError ? HF2_FLAG_SERIAL_ERR : HF2_FLAG_SERIAL_OUT, data, size);\n\n    return 0;\n}\n\n// Receive HF2 message\n// Does not block. Will store intermediate data in pkt.\n// `serial` flag is cleared if we got a command message.\nint HF2::recv() {\n    uint8_t buf[64];\n\n    int len = out->read(buf, sizeof(buf));\n    // DMESG(\"HF2 read: %d\", len);\n\n    if (len <= 0)\n        return len;\n\n    uint8_t tag = buf[0];\n    // serial packets not allowed when in middle of command packet\n    usb_assert(pkt.size == 0 || !(tag & HF2_FLAG_SERIAL_OUT));\n    int size = tag & HF2_SIZE_MASK;\n    usb_assert(pkt.size + size <= (int)sizeof(pkt.buf));\n    memcpy(pkt.buf + pkt.size, buf + 1, size);\n    pkt.size += size;\n    tag &= HF2_FLAG_MASK;\n    if (tag != HF2_FLAG_CMDPKT_BODY) {\n        if (tag == HF2_FLAG_CMDPKT_LAST)\n            pkt.serial = 0;\n        else if (tag == HF2_FLAG_SERIAL_OUT)\n            pkt.serial = 1;\n        else\n            pkt.serial = 2;\n        int sz = pkt.size;\n        pkt.size = 0;\n        return sz;\n    }\n    return 0;\n}\n\nint HF2::sendResponse(int size) {\n    sendBuffer(HF2_FLAG_CMDPKT_LAST, pkt.buf, 4 + size);\n    return 0;\n}\n\nint HF2::sendResponseWithData(const void *data, int size) {\n    if (size <= (int)sizeof(pkt.buf) - 4) {\n        memcpy(pkt.resp.data8, data, size);\n        return sendResponse(size);\n    } else {\n        sendBuffer(HF2_FLAG_CMDPKT_LAST, data, size, pkt.resp.eventId);\n        return 0;\n    }\n}\n\nstatic void copy_words(void *dst0, const void *src0, uint32_t n_words) {\n    uint32_t *dst = (uint32_t *)dst0;\n    const uint32_t *src = (const uint32_t *)src0;\n    while (n_words--)\n        *dst++ = *src++;\n}\n\n#ifndef QUICK_BOOT\n#ifdef SAMD21\n#define DBL_TAP_PTR ((volatile uint32_t *)(HMCRAMC0_ADDR + HMCRAMC0_SIZE - 4))\n#endif\n#ifdef SAMD51\n#define DBL_TAP_PTR ((volatile uint32_t *)(HSRAM_ADDR + HSRAM_SIZE - 4))\n#endif\n#define DBL_TAP_MAGIC_QUICK_BOOT 0xf02669ef\n#define QUICK_BOOT(v) *DBL_TAP_PTR = v ? DBL_TAP_MAGIC_QUICK_BOOT : 0\n#endif\n\nstatic HF2 *jdLogger;\nstatic void jdLog(const uint8_t *frame) {\n    jdLogger->sendEvent(HF2_EV_JDS_PACKET, frame, frame[2] + 12);\n}\n\nint HF2::endpointRequest() {\n    int sz = recv();\n\n    if (!sz)\n        return 0;\n\n    uint32_t tmp;\n\n    if (pkt.serial) {\n        // TODO raise some event?\n        return 0;\n    }\n\n    LOG(\"HF2 sz=%d CMD=%x\", sz, pkt.buf32[0]);\n\n    // one has to be careful dealing with these, as they share memory\n    HF2_Command *cmd = &pkt.cmd;\n    HF2_Response *resp = &pkt.resp;\n\n    uint32_t cmdId = cmd->command_id;\n    resp->tag = cmd->tag;\n    resp->status16 = HF2_STATUS_OK;\n\n#define checkDataSize(str, add) usb_assert(sz == 8 + (int)sizeof(cmd->str) + (int)(add))\n\n    lastExchange = current_time_ms();\n    gotSomePacket = true;\n\n    switch (cmdId) {\n    case HF2_CMD_INFO:\n        return sendResponseWithData(uf2_info(), strlen(uf2_info()));\n\n    case HF2_CMD_BININFO:\n        resp->bininfo.mode = HF2_MODE_USERSPACE;\n        resp->bininfo.flash_page_size = 0;\n        resp->bininfo.flash_num_pages = 0;\n        resp->bininfo.max_message_size = sizeof(pkt.buf);\n        resp->bininfo.uf2_family = PXT_UF2_FAMILY;\n        return sendResponse(sizeof(resp->bininfo));\n\n    case HF2_DBG_RESTART:\n        *HF2_DBG_MAGIC_PTR = HF2_DBG_MAGIC_START;\n        target_reset();\n        break;\n\n    case HF2_CMD_RESET_INTO_APP:\n        QUICK_BOOT(1);\n        NVIC_SystemReset();\n        break;\n    case HF2_CMD_RESET_INTO_BOOTLOADER:\n        QUICK_BOOT(0);\n        NVIC_SystemReset();\n        break;\n\n#if USB_HANDOVER\n    case HF2_CMD_START_FLASH:\n        sendResponse(0);\n        hf2_handover(in->ep);\n        usb_assert(0); // should not be reached\n        break;\n#endif\n\n    case HF2_CMD_WRITE_WORDS:\n        checkDataSize(write_words, cmd->write_words.num_words << 2);\n        copy_words((void *)cmd->write_words.target_addr, cmd->write_words.words,\n                   cmd->write_words.num_words);\n        break;\n\n    case HF2_CMD_READ_WORDS:\n        checkDataSize(read_words, 0);\n        tmp = cmd->read_words.num_words;\n        usb_assert(tmp <= sizeof(pkt.buf) / 4 - 1);\n        copy_words(resp->data32, (void *)cmd->read_words.target_addr, tmp);\n        return sendResponse(tmp << 2);\n\n    case HF2_CMD_DMESG:\n#if DEVICE_DMESG_BUFFER_SIZE > 0\n        return sendResponseWithData(codalLogStore.buffer, codalLogStore.ptr);\n#else\n        break;\n#endif\n\n    case HF2_DBG_GET_GLOBAL_STATE: {\n        HF2_GLOBAL_STATE_Result gstate = {\n            .num_globals = (uint32_t)getNumGlobals(), //\n            .globals_addr = (uint32_t)globals,\n        };\n        return sendResponseWithData(&gstate, sizeof(gstate));\n    }\n\n    case HF2_DBG_RESUME:\n        globals[0] = (TValue)cmd->data32[0];\n        resume = true;\n        return sendResponse(0);\n\n    case HF2_DBG_GET_STACK:\n        return sendResponseWithData(stackCopy, stackSize);\n\n    case HF2_CMD_JDS_CONFIG:\n        if (cmd->data8[0]) {\n            jdLogger = this;\n            pxt::logJDFrame = jdLog;\n        } else {\n            pxt::logJDFrame = NULL;\n        }\n        return sendResponse(0);\n\n    case HF2_CMD_JDS_SEND:\n        if (pxt::sendJDFrame) {\n            pxt::sendJDFrame(cmd->data8);\n            return sendResponse(0);\n        } else {\n            resp->status16 = HF2_STATUS_INVALID_STATE;\n            return sendResponse(0);\n        }\n\n    default:\n        // command not understood\n        resp->status16 = HF2_STATUS_INVALID_CMD;\n        break;\n    }\n\n    return sendResponse(0);\n}\n\nHF2::HF2(HF2_Buffer &p) : gotSomePacket(false), ctrlWaiting(false), pkt(p), useHID(false) {\n    lastExchange = 0;\n}\n\nstatic const InterfaceInfo dummyIfaceInfo = {\n    NULL,\n    0,\n    0,\n    {\n        0,    // numEndpoints\n        0xff, /// class code - vendor-specific\n        0xff, // subclass\n        0xff, // protocol\n        0x00, // string\n        0x00, // alt\n    },\n    {0, 0},\n    {0, 0},\n};\n\nconst InterfaceInfo *DummyIface::getInterfaceInfo() {\n    return &dummyIfaceInfo;\n}\n\n//\n//\n// Debugger\n//\n//\n\nstruct ExceptionContext {\n    uint32_t excReturn; // 0xFFFFFFF9\n    uint32_t r0;\n    uint32_t r1;\n    uint32_t r2;\n    uint32_t r3;\n    uint32_t r12;\n    uint32_t lr;\n    uint32_t faultInstrAddr;\n    uint32_t psr;\n};\n\nstruct Paused_Data {\n    uint32_t pc;\n};\nstatic Paused_Data pausedData;\n\nvoid bkptPaused() {\n\n// waiting for https://github.com/lancaster-university/codal/pull/14\n#ifdef DEVICE_GROUP_ID_USER\n    // the loop below counts as \"system\" task, and we don't want to pause ourselves\n    fiber_set_group(DEVICE_GROUP_ID_SYSTEM);\n    // pause everyone else\n    fiber_pause_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    while (!resume) {\n        // DMESG(\"BKPT\");\n        hf2.pkt.resp.eventId = HF2_EV_DBG_PAUSED;\n        hf2.sendResponseWithData(&pausedData, sizeof(pausedData));\n        // TODO use an event\n        for (int i = 0; i < 20; ++i) {\n            if (resume)\n                break;\n            fiber_sleep(50);\n        }\n    }\n\n    if (stackCopy) {\n        xfree(stackCopy);\n        stackCopy = NULL;\n    }\n\n#ifdef DEVICE_GROUP_ID_USER\n    fiber_resume_group(DEVICE_GROUP_ID_USER);\n    // go back to user mode\n    fiber_set_group(DEVICE_GROUP_ID_USER);\n#endif\n\n    resume = false;\n}\n\nextern \"C\" void handleHardFault(ExceptionContext *ectx) {\n    auto instr = (uint16_t *)ectx->faultInstrAddr;\n\n    DMESG(\"FLT %p\", instr);\n\n    if (ectx->faultInstrAddr & 0x80000000) {\n        ectx->faultInstrAddr &= ~0x80000000;\n        // switch to step-over mode\n        globals[0] = (TValue)3;\n        return;\n    }\n\n    DMESG(\"BB %p %p %p lr=%p r0=%p\", instr[-1], instr[0], instr[1], ectx->lr, ectx->r0);\n\n    if (instr[0] == 0x6840) {\n        // ldr r0, [r0, #4] -- entry breakpoint\n        ectx->faultInstrAddr += 2;\n        // we're being ask for step-over mode\n        if (ectx->r0 == 3) {\n            // switch to debugger-attached-no-stepping mode\n            globals[0] = (TValue)0;\n            ectx->lr |= 0x80000000;\n        }\n        return;\n    }\n\n    if (instr[0] == 0x6800) {\n        // ldr r0, [r0, #0]\n        ectx->lr = ectx->faultInstrAddr + 3; // next instruction + thumb mode\n        pausedData.pc = ectx->faultInstrAddr + 2;\n        void *ssp = (void *)(ectx + 1);\n        stackSize = DEVICE_STACK_BASE - (uint32_t)ssp;\n        if (stackCopy)\n            xfree(stackCopy);\n        stackCopy = xmalloc(stackSize);\n        memcpy(stackCopy, ssp, stackSize);\n        ectx->faultInstrAddr = ((uint32_t)(&bkptPaused) & (~1U));\n        return;\n    }\n\n    while (1) {\n    }\n}\n\nextern \"C\" void HardFault_Handler(void) {\n    asm(\"push {lr}; mov r0, sp; bl handleHardFault; pop {pc}\");\n}\n\n#endif",
            "hf2.h": "#ifndef DEVICE_HF2_H\n#define DEVICE_HF2_H\n\n#if CONFIG_ENABLED(DEVICE_USB)\n\n#include \"HID.h\"\n#include \"uf2hid.h\"\n\n// 260 bytes needed for biggest JD packets (with overheads)\n#define HF2_BUF_SIZE 260\n\ntypedef struct {\n    uint16_t size;\n    uint8_t serial;\n    union {\n        uint8_t buf[HF2_BUF_SIZE];\n        uint32_t buf32[HF2_BUF_SIZE / 4];\n        uint16_t buf16[HF2_BUF_SIZE / 2];\n        HF2_Command cmd;\n        HF2_Response resp;\n    };\n} HF2_Buffer;\n\nclass HF2 : public CodalUSBInterface {\n    bool gotSomePacket;\n    bool ctrlWaiting;\n    uint32_t lastExchange;\n\n  public:\n    HF2_Buffer &pkt;\n\n    bool useHID;\n\n    int sendResponse(int size);\n    int recv();\n    int sendResponseWithData(const void *data, int size);\n    int sendEvent(uint32_t evId, const void *data, int size);\n    void sendBuffer(uint8_t flag, const void *data, unsigned size, uint32_t prepend = -1);\n\n    HF2(HF2_Buffer &pkt);\n    virtual int endpointRequest();\n    virtual int stdRequest(UsbEndpointIn &ctrl, USBSetup &setup);\n    virtual const InterfaceInfo *getInterfaceInfo();\n    int sendSerial(const void *data, int size, int isError = 0);\n\n    virtual bool enableWebUSB() { return !useHID; }\n};\n\nclass DummyIface : public CodalUSBInterface {\n  public:\n    virtual const InterfaceInfo *getInterfaceInfo();\n};\n\n#endif\n\n#endif\n",
            "hf2dbg.h": "#ifndef HF2DBG_H\n#define HF2DBG_H 1\n\n// we use a location at the top of the stack to store a magic value\n// which causes us to stop at the very first break point in the program\n#define HF2_DBG_MAGIC_PTR ((uint32_t *)(DEVICE_STACK_BASE - (DEVICE_STACK_SIZE - 4)))\n#define HF2_DBG_MAGIC_START 0xf0ebac7f\n\n#define HF2_DBG_GET_GLOBAL_STATE 0x53fc66e0\nstruct HF2_GLOBAL_STATE_Result {\n    uint32_t num_globals;\n    uint32_t globals_addr;\n};\n\n#define HF2_DBG_RESTART 0x1120bd93\n#define HF2_DBG_RESUME 0x27a55931\n#define HF2_EV_DBG_PAUSED 0x3692f9fd\n#define HF2_DBG_GET_STACK 0x70901510\n\n#endif\n",
            "i2c.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n#include \"CodalDmesg.h\"\n#include \"configkeys.h\"\n\n#ifdef CODAL_I2C\n\nnamespace pins {\n\nclass CodalI2CProxy {\nprivate:\n  DevicePin* sda;\n  DevicePin* scl;\n  CODAL_I2C i2c;\npublic:\n  CodalI2CProxy* next;\npublic:\n  CodalI2CProxy(DevicePin* _sda, DevicePin* _scl)\n    : sda(_sda)\n    , scl(_scl)\n    , i2c(*_sda, *_scl) \n    , next(NULL)\n  {\n\n  }\n\n  CODAL_I2C* getI2C() {\n    return &(this->i2c);\n  }\n  \n  bool matchPins(DevicePin* sda, DevicePin* scl) {\n      return this->sda == sda && this->scl == scl;\n  }\n\n  Buffer readBuffer(int address, int size, bool repeat = false)\n  {\n    Buffer buf = mkBuffer(NULL, size);\n    registerGCObj(buf);\n    int status = this->i2c.read(address << 1, buf->data, size, repeat);\n    unregisterGCObj(buf);\n    if (status != ErrorCode::DEVICE_OK) {\n      buf = 0;\n    }\n    return buf;\n  }\n\n  int writeBuffer(int address, Buffer buf, bool repeat = false)\n  {\n    return this->i2c.write(address << 1, buf->data, buf->length, repeat);\n  }\n};\n\n}\n\nnamespace I2CMethods {\n/**\n  * Read `size` bytes from a 7-bit I2C `address`.\n  */\n//%\nBuffer readBuffer(I2C_ i2c, int address, int size, bool repeat = false)\n{\n  return i2c->readBuffer(address, size, repeat);\n}\n\n/**\n  * Write bytes to a 7-bit I2C `address`.\n  */\n//%\nint writeBuffer(I2C_ i2c, int address, Buffer buf, bool repeat = false)\n{\n  return i2c->writeBuffer(address, buf, repeat);\n}\n\n}\n\nnamespace pins {\n\nstatic I2C_ i2cs(NULL);\n/**\n* Opens a Serial communication driver\n*/\n//% help=pins/create-i2c\n//% parts=i2c\nI2C_ createI2C(DigitalInOutPin sda, DigitalInOutPin scl) {\n  // pick up defaults\n  if (!sda || !scl) {\n    DMESG(\"i2c: lookup default pins\");\n    sda = LOOKUP_PIN(SDA);\n    scl = LOOKUP_PIN(SCL);\n  }\n\n  // lookup existing devices\n  auto dev = i2cs;\n  while(dev) {\n    if (dev->matchPins(sda, scl)) {\n      DMESG(\"i2c: found existing i2c\");\n      return dev;\n    }\n    dev = dev->next;\n  }\n\n  // allocate new one\n  DMESG(\"i2c: mounting on new device\");\n  auto ser = new CodalI2CProxy(sda, scl);\n  // push in list\n  ser->next = i2cs;\n  i2cs = ser;\n  return ser;\n}\n\n}\n\nnamespace pxt {\n  CODAL_I2C* getI2C(DigitalInOutPin sda, DigitalInOutPin scl) {\n    auto i2c = pins::createI2C(sda, scl);\n    return i2c->getI2C();\n  }\n}\n\n#endif",
            "i2c.ts": "namespace pins {\n    /**\n     * Read one number from an I2C address.\n     */\n    //% help=pins/i2c-read-number weight=5 group=\"i2c\" inlineInputMode=\"external\"\n    //% blockId=pins_i2c_readnumber block=\"i2c read number at address %address|of format %format|repeated %repeated\"\n    export function i2cReadNumber(address: number, format: NumberFormat, repeated?: boolean): number {\n        const buf = pins.i2cReadBuffer(address, pins.sizeOf(format), repeated)\n        if (!buf)\n            return undefined\n        return buf.getNumber(format, 0)\n    }\n\n    /**\n     * Write one number to an I2C address.\n     */\n    //% help=pins/i2c-write-number weight=4 group=\"i2c\"\n    //% blockId=i2c_writenumber block=\"i2c write number|at address %address|with value %value|of format %format|repeated %repeated\"\n    export function i2cWriteNumber(address: number, value: number, format?: NumberFormat, repeated?: boolean): void {\n        if (format == undefined)\n            format = NumberFormat.UInt8LE;\n        const buf = control.createBuffer(pins.sizeOf(format))\n        buf.setNumber(format, 0, value)\n        pins.i2cWriteBuffer(address, buf, repeated)\n    }\n\n    /**\n     * Write a value in a I2C register.\n     * @param address I2c address of the device\n     * @param register register index\n     * @param value value to write\n     * @param valueFormat format of the value, default is UInt8LE\n     */\n    //% weight=3 group=\"i2c\"\n    //% help=pins/i2c-write-register\n    //% blockId=i2c_writereg block=\"i2c write register|at address $address|at register $register|value $value\"\n    export function i2cWriteRegister(address: number, register: number, value: number, valueFormat?: NumberFormat): void {\n        if (valueFormat === undefined)\n            valueFormat = NumberFormat.UInt8LE;\n        const valueSize = pins.sizeOf(valueFormat);\n        const buf = control.createBuffer(1 + valueSize);\n        buf.setNumber(NumberFormat.UInt8LE, 0, register);\n        buf.setNumber(valueFormat, 1, value);\n        pins.i2cWriteBuffer(address, buf);\n    }\n\n    /**\n     * Read the value from a I2C register.\n     * @param address I2c address of the device\n     * @param register register index\n     * @param valueFormat format of the value, default is UInt8LE\n     */\n    //% weight=3 group=\"i2c\"\n    //% help=pins/i2c-read-register\n    //% blockId=i2c_readreg block=\"i2c read register|at address $address|at register $register\"\n    export function i2cReadRegister(address: number, register: number, valueFormat?: NumberFormat): number {\n        if (valueFormat === undefined)\n            valueFormat = NumberFormat.UInt8LE;\n        pins.i2cWriteNumber(address, register, NumberFormat.UInt8LE);\n        return pins.i2cReadNumber(address, valueFormat);\n    }\n\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //%\n    export function i2cReadBuffer(address: number, size: number, repeat: boolean = false): Buffer {\n        return pins.i2c().readBuffer(address, size, repeat);\n    }\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //%\n    export function i2cWriteBuffer(address: number, buf: Buffer, repeat: boolean = false): number {\n        return pins.i2c().writeBuffer(address, buf, repeat);\n    }\n\n    let _i2c: I2C;\n    /**\n     * Gets the default I2C bus\n     */\n    //%\n    export function i2c(): I2C {\n        if (!_i2c) {\n            const sda = pins.pinByCfg(DAL.CFG_PIN_SDA);\n            const scl = pins.pinByCfg(DAL.CFG_PIN_SCL);\n            _i2c = pins.createI2C(sda, scl);    \n        }\n        return _i2c;        \n    }\n\n    export class I2CDevice {\n        public address: number;\n        public bus: I2C;\n        private _hasError: boolean;\n        constructor(address: number, bus?: I2C) {\n            this.address = address;\n            this.bus = bus || i2c();\n        }\n        public readInto(buf: Buffer, repeat = false, start = 0, end: number = null) {\n            if (end === null)\n                end = buf.length\n            if (start >= end)\n                return\n            let res = this.bus.readBuffer(this.address, end - start, repeat)\n            if (!res) {\n                this._hasError = true\n                return\n            }\n            buf.write(start, res)\n        }\n        public write(buf: Buffer, repeat = false) {\n            let res = this.bus.writeBuffer(this.address, buf, repeat)\n            if (res) {\n                this._hasError = true\n            }\n        }\n        public begin(): I2CDevice {\n            this._hasError = false;\n            return this;\n        }\n        public end() {\n        }\n        public ok() {\n            return !this._hasError\n        }\n\n        public transfer(command: Buffer, response: Buffer, responseStart?: number, responseEnd?: number) {\n            this.begin();\n            if (command)\n                this.write(command);\n            if (response)\n                this.readInto(response, false, responseStart, responseEnd);\n            this.end();\n        }    \n    }\n}\n",
            "keyvaluestorage.cpp": "#include \"pxt.h\"\n#include \"KeyValueStorage.h\"\n\nnamespace pxt {\n\nclass WKeyValueStorage {\n#ifdef CODAL_NVMCONTROLLER\n    CODAL_NVMCONTROLLER controller;\n#else\n    NVMController controller;\n#endif\n    KeyValueStorage storage;\n  public:\n\n    WKeyValueStorage()\n    : controller()\n    , storage(controller) {\n    }\n\n    bool isSupported() {\n#ifdef CODAL_NVMCONTROLLER\n      return true;\n#else\n      return false;\n#endif\n    }\n\n    int put(String key, Buffer data) {\n#ifdef CODAL_NVMCONTROLLER\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        return storage.put(mkey, data->data, data->length);\n#else\n        return -1;\n#endif\n    }\n\n    Buffer get(String key) {\n#ifdef CODAL_NVMCONTROLLER\n        Buffer buf = NULL;\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        auto entry = storage.get(mkey);\n        if (entry) {\n          buf = mkBuffer(entry->value, sizeof(entry->value));\n          free(entry);\n        }\n        return buf;\n#else\n        return NULL;\n#endif\n    }\n\n    void remove(String key) {\n#ifdef CODAL_NVMCONTROLLER\n        ManagedString mkey(key->getUTF8Data(), key->getUTF8Size());\n        storage.remove(mkey);\n#endif\n    }\n\n    void clear() {\n#ifdef CODAL_NVMCONTROLLER\n        storage.wipe();\n#endif\n    }\n};\nSINGLETON(WKeyValueStorage);\n\n}\n\nnamespace configStorage {\n  /**\n  * Puts an entry in the device storage. Key may have up to 16 characters (bytes).\n  * @param key the identifier (max 16 characters)\n  * @param value the data (max 32 characters)\n  */\n  //%\n  void setBuffer(String key, Buffer value) {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->put(key, value);\n  }\n\n  /**\n  * Gets an entry from the device storage. Key may have up to 16 characters (bytes).\n  * @param key the identifier (max 16 characters)\n  */\n  //%\n  Buffer getBuffer(String key) {\n    auto kvm = pxt::getWKeyValueStorage();\n    return kvm->get(key);\n  }\n\n  /**\n  * Removes the key from local storage\n  * @param key the identifier (max 16 characters)\n  */\n  //%\n  void removeItem(String key) {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->remove(key);\n  }\n\n  /**\n  * Clears the local storage\n  */\n  //%\n  void clear() {\n    auto kvm = pxt::getWKeyValueStorage();\n    kvm->clear();\n  }\n}\n",
            "keyvaluestorage.ts": "namespace configStorage {\n    /**\n     * Stores the value at the key entry\n     * @param key identifier of the key (max 16 characters)\n     * @param value identifier of the value (max 32 characters)\n     */\n    export function setItem(key: string, value: string) {\n        if (value == null)\n            configStorage.removeItem(key);\n        else\n        {\n            let idx = 0;\n            let buf = control.createBuffer(value.length + 1);\n            buf[idx++] = value.length;\n            let valBuf = control.createBufferFromUTF8(value);\n\n            for (let i = 0; i < valBuf.length; i++)\n                buf[idx++] = valBuf[i];\n\n            configStorage.setBuffer(key, buf);\n        }\n    }\n\n    /**\n     * Retrieves the value at the key entry\n     * @param key identifier of the key (max 16 characters)\n     */\n    export function getItem(key: string): string {\n        const buf = configStorage.getBuffer(key);\n\n        if (!buf)\n            return undefined;\n\n        let idx = 0;\n        let count = buf[idx++];\n        const retBuf = control.createBuffer(count);\n\n        for (let i = 0; i < count; i++)\n            retBuf[i] = buf[idx++];\n\n        return retBuf.toString();\n    }\n}\n",
            "leveldetector.ts": "namespace pins {\n    export class LevelDetector {\n        public id: number;\n        public min: number;\n        public max: number;\n        public lowThreshold: number;\n        public highThreshold: number;\n        private transition: number;\n        private transitionMs: number;\n        private _level: number;\n        private _state: number;\n        public onHigh: () => void;\n        public onLow: () => void;\n        public onNeutral: () => void;\n        public transitionWindow: number;\n        // minimum duration (ms) between events\n        public transitionInterval: number;\n\n        static LEVEL_THRESHOLD_NEUTRAL = 0;\n\n        constructor(id: number,\n            min: number, max: number,\n            lowThreshold: number, highThreshold: number) {\n            this.id = id;\n            this.min = min;\n            this.max = max;\n            this.lowThreshold = lowThreshold;\n            this.highThreshold = highThreshold;\n            this.transitionWindow = 4;\n            this.transitionInterval = 0;\n\n            this.onHigh = () => control.raiseEvent(this.id, DAL.LEVEL_THRESHOLD_HIGH);\n            this.onLow = () => control.raiseEvent(this.id, DAL.LEVEL_THRESHOLD_LOW);\n            this.onNeutral = undefined;\n\n            this.reset();\n        }\n\n        reset() {\n            this.transition = 0;\n            this.transitionMs = 0;\n            this._level = Math.ceil((this.highThreshold - this.lowThreshold) / 2);\n            this._state = LevelDetector.LEVEL_THRESHOLD_NEUTRAL;\n        }\n\n        get level(): number {\n            return this._level;\n        }\n\n        set level(level: number) {\n            this._level = this.clampValue(level);\n\n            if (this._level >= this.highThreshold) {\n                this.setState(DAL.LEVEL_THRESHOLD_HIGH);\n            }\n            else if (this._level <= this.lowThreshold) {\n                this.setState(DAL.LEVEL_THRESHOLD_LOW);\n            }\n            else {\n                this.setState(LevelDetector.LEVEL_THRESHOLD_NEUTRAL);\n            }\n        }\n\n        public setLowThreshold(value: number) {\n            this.lowThreshold = this.clampValue(value);\n            this.reset();\n        }\n\n        public setHighThreshold(value: number) {\n            this.highThreshold = this.clampValue(value);\n            this.reset();\n        }\n\n        private clampValue(value: number) {\n            if (value < this.min) {\n                return this.min;\n            }\n            else if (value > this.max) {\n                return this.max;\n            }\n            return value;\n        }\n\n        private setState(state: number) {\n            // not enough samples to change\n            if (this._state === state \n                || (this.transition++ < this.transitionWindow)\n                || (control.millis() - this.transitionMs) < this.transitionInterval) {\n                return;\n            }\n\n            this.transition = 0;\n            this.transitionMs = control.millis();\n            this._state = state;\n            switch (state) {\n                case DAL.LEVEL_THRESHOLD_HIGH:\n                    if (this.onHigh) this.onHigh();\n                    break;\n                case DAL.LEVEL_THRESHOLD_LOW:\n                    if (this.onLow) this.onLow();\n                    break;\n                case LevelDetector.LEVEL_THRESHOLD_NEUTRAL:\n                    if (this.onNeutral) this.onNeutral();\n                    break;\n            }\n        }\n    }\n}",
            "light.cpp": "#include \"light.h\"\n\n// WS2812B timings, datasheet v1\n// 0 - 0.25-0.55us hi 0.70-1.00us low\n// 1 - 0.65-0.95us hi 0.30-0.60us low\n// datasheet v5\n// 0 - 0.22-0.38us hi 0.58-1.00us low 1-3\n// 1 - 0.58-1.00us hi 0.58-1.00us low 3-2\n\n#define SPI_SUPPORTED 1\n\n#if defined(NRF52_SERIES)\n#define BIT_EXPANSION 5\n#define SPI_FREQ 4000000\n#else\n#define BIT_EXPANSION 3\n#define SPI_FREQ 2400000\n#endif\n\n#if defined(SAMD21) || defined(SAMD51) || defined(STM32F4) || defined(NRF52_SERIES)\n#include \"neopixel.h\"\n#define BITBANG_SUPPORTED 1\n#else\n#define BITBANG_SUPPORTED 0\n#endif\n\n#define NEOPIXEL_MIN_LENGTH_FOR_SPI 24\n#define DOTSTAR_MIN_LENGTH_FOR_SPI 24\n\n#define LIGHTMODE_RGB 1\n#define LIGHTMODE_RGBW 2\n#define LIGHTMODE_RGB_RGB 3\n#define LIGHTMODE_DOTSTAR 4\n\nnamespace light {\nbool isValidMOSIPin(DigitalInOutPin pin) {\n    if (!pin)\n        return false;\n\n#if SAMD51\n    return ZSPI::isValidMOSIPin(*pin);\n#elif defined(NRF52_SERIES)\n    return true;\n#else\n    // TODO: support for SPI neopixels\n    // default SPI pins supported for now\n    return pin == LOOKUP_PIN(MOSI);\n#endif\n}\n\n// SPI\nvoid spiNeopixelSendBuffer(DevicePin *pin, const uint8_t *data, unsigned size) {\n    int32_t iptr = 0, optr = 120;\n    uint32_t len = optr + size * BIT_EXPANSION + 120;\n    uint8_t *expBuf = new uint8_t[len];\n    memset(expBuf, 0, len);\n    uint8_t imask = 0x80;\n    uint8_t omask = 0x80;\n\n#define WR(k)                                                                                      \\\n    if (k)                                                                                         \\\n        expBuf[optr] |= omask;                                                                     \\\n    omask >>= 1;                                                                                   \\\n    if (!omask) {                                                                                  \\\n        omask = 0x80;                                                                              \\\n        optr++;                                                                                    \\\n    }\n\n    while (iptr < (int)size) {\n#if BIT_EXPANSION == 3\n        WR(1);\n        WR(data[iptr] & imask);\n        WR(0);\n#elif BIT_EXPANSION == 5\n        WR(1);\n        if (data[iptr] & imask) {\n            WR(1);\n            WR(1);\n        } else {\n            WR(0);\n        }\n        WR(0);\n        WR(0);\n#else\n#error \"invalid BIT_EXPANSION\"\n#endif\n\n        imask >>= 1;\n        if (!imask) {\n            imask = 0x80;\n            iptr++;\n        }\n    }\n\n    auto spi = pxt::getSPI(pin, NULL, NULL);\n    spi->setFrequency(SPI_FREQ);\n    spi->transfer(expBuf, len, NULL, 0);\n    delete expBuf;\n}\n\nvoid neopixelSendData(DevicePin *pin, int mode, const uint8_t *data, unsigned length) {\n    if (!pin || !length)\n        return;\n\n#if BITBANG_SUPPORTED\n    if (SPI_SUPPORTED && length > NEOPIXEL_MIN_LENGTH_FOR_SPI && isValidMOSIPin(pin))\n        spiNeopixelSendBuffer(pin, data, length);\n    else\n        neopixel_send_buffer(*pin, data, length);\n#else\n    if (isValidMOSIPin(pin)) {\n        spiNeopixelSendBuffer(pin, data, length);\n    }\n#endif\n}\n\nvoid bitBangDotStarSendData(DevicePin *data, DevicePin *clk, int mode, const uint8_t *buf,\n                            unsigned length) {\n    // first frame of zeroes\n    data->setDigitalValue(0);\n    for (unsigned i = 0; i < 32; ++i) {\n        clk->setDigitalValue(1);\n        clk->setDigitalValue(0);\n    }\n\n    // data stream\n    for (unsigned i = 0; i < length; ++i) {\n        auto x = buf[i];\n        for (uint8_t j = 0x80; j != 0; j >>= 1) {\n            data->setDigitalValue(x & j ? 1 : 0);\n            clk->setDigitalValue(1);\n            clk->setDigitalValue(0);\n        }\n    }\n    // https://cpldcpu.wordpress.com/2016/12/13/sk9822-a-clone-of-the-apa102/\n    // reset frame\n    // data->setDigitalValue(0);\n    // for (unsigned i = 0; i < 32 ; ++i) {\n    //    clk->setDigitalValue(1);\n    //    clk->setDigitalValue(0);\n    //}\n\n    // https://cpldcpu.wordpress.com/2014/11/30/understanding-the-apa102-superled/\n    data->setDigitalValue(1);\n    unsigned n = 32;\n    for (unsigned i = 0; i < n; ++i) {\n        clk->setDigitalValue(1);\n        clk->setDigitalValue(0);\n    }\n}\n\nstatic uint8_t ZERO_FRAME[4];\nstatic uint8_t ONE_FRAME[] = {1, 1, 1, 1};\nvoid spiDotStarSendData(DevicePin *data, DevicePin *clk, int mode, const uint8_t *buf,\n                        unsigned length) {\n    auto spi = pxt::getSPI(data, NULL, clk);\n\n    spi->transfer(ZERO_FRAME, sizeof(ZERO_FRAME), NULL, 0); // initial frame\n    spi->transfer(buf, length, NULL, 0);\n    spi->transfer(ZERO_FRAME, sizeof(ZERO_FRAME), NULL, 0); // reset frame\n    for (unsigned i = 0; i < (length >> 3); i += 32)\n        spi->transfer(ONE_FRAME, sizeof(ONE_FRAME), NULL, 0); // final frame\n}\n\nvoid dotStarSendData(DevicePin *data, DevicePin *clk, int mode, const uint8_t *buf,\n                     unsigned length) {\n    if (!data || !clk || !buf || !length)\n        return;\n\n    if (length > DOTSTAR_MIN_LENGTH_FOR_SPI && isValidMOSIPin(data))\n        spiDotStarSendData(data, clk, mode, buf, length);\n    else\n        bitBangDotStarSendData(data, clk, mode, buf, length);\n}\n\nvoid sendBuffer(DevicePin *data, DevicePin *clk, int mode, Buffer buf) {\n    if (!data || !buf || !buf->length)\n        return;\n\n    if (mode == LIGHTMODE_DOTSTAR)\n        light::dotStarSendData(data, clk, mode, buf->data, buf->length);\n    else\n        light::neopixelSendData(data, mode, buf->data, buf->length);\n}\n\nvoid clear() {\n    auto neopix = LOOKUP_PIN(NEOPIXEL);\n    auto neonum = getConfig(CFG_NUM_NEOPIXELS, 0);\n    if (neopix && neonum >= 0) {\n        auto n = 3 * neonum;\n        uint8_t off[n];\n        memset(off, 0, sizeof(off));\n        light::neopixelSendData(neopix, 0x100, off, sizeof(off));\n    }\n\n    auto data = LOOKUP_PIN(DOTSTAR_DATA);\n    auto clk = LOOKUP_PIN(DOTSTAR_CLOCK);\n    auto dsnum = getConfig(CFG_NUM_DOTSTARS, 0);\n    if (data && clk && dsnum > 0) {\n        auto n = 4 * dsnum;\n        uint8_t off[n];\n        memset(off, 0, sizeof(off));\n        for (int i = 0; i < n; i += 4)\n            off[i] = 0xe0;\n        bitBangDotStarSendData(data, clk, 0x100, off, sizeof(off));\n    }\n}\n\n} // namespace light\n",
            "light.h": "#ifndef __PXT_LIGHT_H\n#define __PXT_LIGHT_H\n\n#include \"pxt.h\"\n\nnamespace light {\n    /**\n    * Clear onboard neopixels\n    */\n    void clear();\n\n    /**\n    * Send a programmable light buffer to the specified digital pin\n    * @param data The pin that the lights are connected to\n    * @param clk the clock line if any\n    * @param mode the color encoding mode\n    * @param buf The buffer to send to the pin\n    */\n    //%\n    void sendBuffer(DigitalInOutPin data, DigitalInOutPin clk, int mode, Buffer buf);\n\n    void neopixelSendData(DevicePin* pin, int mode, const uint8_t* data, unsigned length);\n}\n\n#endif",
            "ns.ts": "/**\n * Events and data from sensors.\n */\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\n//% groups='[\"other\", \"More\"]'\nnamespace input {\n}\n\n/**\n * Servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n\n}\n\n/**\n * A Joint Asynchronous Communications, Device Agnostic Control.\n */\n//% color=\"#E79251\" weight=1 icon=\"\\uf185\"\n//% groups='[\"Broadcast\", \"Console\", \"Control\"]'\n//% blockGap=8\nnamespace jacdac {\n\n}",
            "pins.cpp": "#include \"pxt.h\"\n\nnamespace pxt {\nstatic DevicePin **pinPtrs;\nstatic uint8_t numPinPtrs;\nstatic uint8_t pinPos[DEV_NUM_PINS];\n\n//%\nDevicePin *getPin(int id) {\n\n    id &= CFG_PIN_NAME_MSK;\n\n    if (id >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n\n    // we could use lookupComponent() here - it would be slightly slower\n\n    int ptr = pinPos[id];\n    if (ptr == 0) {\n        pinPtrs = (DevicePin **)realloc(pinPtrs, (numPinPtrs + 1) * sizeof(void *));\n        bool isAnalog = IS_ANALOG_PIN(id);\n        // GCTODO\n        pinPtrs[numPinPtrs++] =\n            new DevicePin(DEVICE_ID_IO_P0 + id, (PinName)id,\n                          isAnalog ? PIN_CAPABILITY_AD : PIN_CAPABILITY_DIGITAL);\n        ptr = numPinPtrs;\n        pinPos[id] = ptr;\n    }\n    return pinPtrs[ptr - 1];\n}\n\n//%\nDevicePin *getPinCfg(int key) {\n    int p = getConfig(key, -1);\n    if (p == -1)\n        DMESG(\"no pin cfg: %d\", key);\n    return getPin(p);\n}\n\nvoid linkPin(int from, int to) {\n    if (from < 0 || from >= DEV_NUM_PINS)\n        target_panic(PANIC_NO_SUCH_PIN);\n    getPin(to);\n    pinPos[from] = pinPos[to];\n}\n\n//%\nDevicePin *lookupPin(int pinName) {\n    if (pinName < 0 || pinName == 0xff)\n        return NULL;\n    pinName &= CFG_PIN_NAME_MSK;\n    return getPin(pinName);\n}\n\n//%\nDevicePin *lookupPinCfg(int key) {\n    return lookupPin(getConfig(key));\n}\n\nCodalComponent *lookupComponent(int id) {\n    for (int i = 0; i < DEVICE_COMPONENT_COUNT; ++i) {\n        if (CodalComponent::components[i] && CodalComponent::components[i]->id == id)\n            return CodalComponent::components[i];\n    }\n    return NULL;\n}\n\n} // namespace pxt\n\nnamespace pins {\n/**\n* Get a pin by configuration id (DAL.CFG_PIN...)\n*/\n//%\nDigitalInOutPin pinByCfg(int key) {\n    return pxt::lookupPinCfg(key);\n}\n\n/**\n * Create a new zero-initialized buffer.\n * @param size number of bytes in the buffer\n */\n//%\nBuffer createBuffer(int size) {\n    return mkBuffer(NULL, size);\n}\n\n/**\n * Get the duration of the last pulse in microseconds. This function should be called from a\n * ``onPulsed`` handler.\n */\n//% help=pins/pulse-duration blockGap=8\n//% blockId=pins_pulse_duration block=\"pulse duration (s)\"\n//% weight=19\nint pulseDuration() {\n    return pxt::lastEvent.timestamp;\n}\n} // namespace pins\n",
            "pins.h": "#ifndef __PXT_PINS_H\n#define __PXT_PINS_H\n\n#define BUTTON_ACTIVE_HIGH_PULL_DOWN (ACTIVE_HIGH | 0x10)\n#define BUTTON_ACTIVE_HIGH_PULL_UP (ACTIVE_HIGH | 0x20)\n#define BUTTON_ACTIVE_HIGH_PULL_NONE (ACTIVE_HIGH | 0x30)\n#define BUTTON_ACTIVE_LOW_PULL_DOWN (ACTIVE_LOW | 0x10)\n#define BUTTON_ACTIVE_LOW_PULL_UP (ACTIVE_LOW | 0x20)\n#define BUTTON_ACTIVE_LOW_PULL_NONE (ACTIVE_LOW | 0x30)\n\n#define PIN(name) ((PinName)pxt::getConfig(CFG_PIN_##name, -1))\n#define LOOKUP_PIN(name) pxt::lookupPin(PIN(name))\n\n// these can be overridden in platform.h\n#ifndef CODAL_PIN\n#define CODAL_PIN CODAL_MBED::Pin\n#endif\n\n#ifndef CODAL_TIMER\n#define CODAL_TIMER CODAL_MBED::Timer\n#endif\n\n#ifndef CODAL_SPI\n#define CODAL_SPI CODAL_MBED::SPI\n#endif\n\n#ifndef CODAL_SERIAL\n#define CODAL_SERIAL CODAL_MBED::Serial\n#endif\n\n#ifndef IS_ANALOG_PIN\n#define IS_ANALOG_PIN(id) ((DEV_ANALOG_PINS >> (id)) & 1)\n#endif\n\ntypedef CODAL_PIN DevicePin;\n\ntypedef DevicePin *DigitalInOutPin;\ntypedef DevicePin *AnalogInOutPin;\ntypedef DevicePin *AnalogInPin;\ntypedef DevicePin *AnalogOutPin;\ntypedef DevicePin *PwmPin;\ntypedef DevicePin *PwmOnlyPin;\ntypedef Button *Button_;\n\nnamespace pxt {\nDevicePin *getPin(int id);\nDevicePin *getPinCfg(int key);\nDevicePin *lookupPin(int pinName);\nDevicePin *lookupPinCfg(int key);\nvoid linkPin(int from, int to);\nCodalComponent *lookupComponent(int id);\n}\n\n#define PINOP(op) name->op\n\n#endif\n",
            "pins.ts": "//% noRefCounting fixedInstances\ninterface DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogOutPin extends DigitalInOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface AnalogInOutPin extends AnalogInPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmOnlyPin extends DigitalInOutPin, AnalogOutPin {\n    // methods filled from C++\n}\n\n//% noRefCounting fixedInstances\ninterface PwmPin extends PwmOnlyPin, AnalogInOutPin {\n}\n\n/**\n * Control currents in Pins for analog/digital signals, servos, i2c, ...\n */\n//% color=#A80000 weight=85 icon=\"\\uf140\" advanced=true\n//% groups='[\"other\", \"Servo\", \"i2c\"]'\nnamespace pins {\n}",
            "pinsAnalog.cpp": "#include \"pxt.h\"\n\nnamespace AnalogInPinMethods {\n\n/**\n * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n * @param name pin to write to\n */\n//% help=pins/analog-read weight=53\n//% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nint analogRead(AnalogInPin name) {\n    return PINOP(getAnalogValue());\n}\n}\n\nnamespace AnalogOutPinMethods {\nvoid analogWrite(AnalogOutPin name, int value) __attribute__ ((weak));\n\n/**\n * Set the connector value as analog. Value must be comprised between 0 and 1023.\n * @param name pin name to write to\n * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n */\n//% help=pins/analog-write weight=52\n//% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.min=0 value.max=1023\nvoid analogWrite(AnalogOutPin name, int value) {\n    PINOP(setAnalogValue(value));\n}\n}",
            "pinsDigital.cpp": "#include \"pxt.h\"\n\nenum class PulseValue {\n    //% block=high\n    High = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=low\n    Low = DEVICE_PIN_EVT_PULSE_LO\n};\n\nenum class PinEvent {\n    //% block=\"pulse high\"\n    PulseHigh = DEVICE_PIN_EVT_PULSE_HI,\n    //% block=\"pulse low\"\n    PulseLow = DEVICE_PIN_EVT_PULSE_LO,\n    //% block=\"rise\"\n    Rise = DEVICE_PIN_EVT_RISE,\n    //% block=\"fall\"\n    Fall = DEVICE_PIN_EVT_FALL,\n};\n\nenum class PinPullMode {\n    //% block=\"down\"\n    PullDown = 0,\n    //% block=\"up\"\n    PullUp = 1,\n    //% block=\"none\"\n    PullNone = 2\n};\n\nnamespace DigitalInOutPinMethods {\n/**\n * Read a pin or connector as either 0 or 1\n * @param name pin to read from\n */\n//% help=pins/digital-read weight=61\n//% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nbool digitalRead(DigitalInOutPin name) {\n    return PINOP(getDigitalValue()) != 0;\n}\n\n/**\n     * Set a pin or connector value to either 0 or 1.\n    * @param name pin to write to\n    * @param value value to set on the pin\n    */\n//% help=pins/digital-write weight=60\n//% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid digitalWrite(DigitalInOutPin name, bool value) {\n    PINOP(setDigitalValue(value));\n}\n\n/**\n* Make this pin a digital input, and create events where the timestamp is the duration\n* that this pin was either ``high`` or ``low``.\n*/\n//% help=pins/on-pulsed weight=16 blockGap=8\n//% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\n//% deprecated=1 hidden=1\nvoid onPulsed(DigitalInOutPin pin, PulseValue pulse, Action body) {\n    pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n    registerWithDal(pin->id, (int)pulse, body);\n}\n\n/**\n* Register code to run when a pin event occurs. \n*/\n//% help=pins/on-event weight=20 blockGap=8\n//% blockId=pinsonevent block=\"on|pin %pin|%event\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nvoid onEvent(DigitalInOutPin pin, PinEvent event, Action body) {\n    switch(event) {\n        case PinEvent::PulseHigh:\n        case PinEvent::PulseLow:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n            registerWithDal(pin->id, (int)event, body);\n            break;\n        case PinEvent::Rise:\n        case PinEvent::Fall:\n            pin->eventOn(DEVICE_PIN_EVENT_ON_EDGE);\n            registerWithDal(pin->id, (int)event, body);\n            break;    \n    }    \n}\n\n/**\n* Return the duration of a pulse in microseconds\n* @param name the pin which measures the pulse\n* @param value the value of the pulse (default high)\n* @param maximum duration in micro-seconds\n*/\n//% blockId=\"pins_pulse_in\" block=\"pulse in (s)|pin %name|pulsed %high||timeout %maxDuration (s)\"\n//% weight=18 blockGap=8\n//% help=\"pins/pulse-in\"\n//% blockNamespace=pins\n//% pin.fieldEditor=\"gridpicker\"\n//% pin.fieldOptions.width=220\n//% pin.fieldOptions.columns=4\nint pulseIn(DigitalInOutPin pin, PulseValue value, int maxDuration = 2000000) {\n    int pulse = PulseValue::High == value ? 1 : 0;\n    uint64_t tick = system_timer_current_time_us();\n    uint64_t maxd = (uint64_t)maxDuration;\n    while (pin->getDigitalValue() != pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n\n    uint64_t start = system_timer_current_time_us();\n    while (pin->getDigitalValue() == pulse) {\n        if (system_timer_current_time_us() - tick > maxd)\n            return 0;\n    }\n    uint64_t end = system_timer_current_time_us();\n    return end - start;\n}\n\n/**\n* Set the pull direction of this pin.\n* @param name pin to set the pull mode on\n* @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n*/\n//% help=pins/set-pull weight=17 blockGap=8\n//% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid setPull(DigitalInOutPin name, PinPullMode pull) {\n    PullMode m = pull == PinPullMode::PullDown ? PullMode::Down : pull == PinPullMode::PullUp\n                                                                        ? PullMode::Up\n                                                                        : PullMode::None;\n    PINOP(setPull(m));\n}\n\n}\n\nnamespace pxt {\n\nstatic void waitABit() {\n    // for (int i = 0; i < 10; ++i)\n    //    asm volatile(\"nop\");\n}\n\nclass ButtonMultiplexer : public CodalComponent {\n  public:\n    Pin &latch;\n    Pin &clock;\n    Pin &data;\n    uint32_t state;\n    uint32_t invMask;\n    uint16_t buttonIdPerBit[8];\n    bool enabled;\n\n    ButtonMultiplexer(uint16_t id)\n        : latch(*LOOKUP_PIN(BTNMX_LATCH)), clock(*LOOKUP_PIN(BTNMX_CLOCK)),\n          data(*LOOKUP_PIN(BTNMX_DATA)) {\n        this->id = id;\n        this->status |= DEVICE_COMPONENT_STATUS_SYSTEM_TICK;\n\n        state = 0;\n        invMask = 0;\n        enabled = true;\n\n        memset(buttonIdPerBit, 0, sizeof(buttonIdPerBit));\n\n        data.getDigitalValue(PullMode::Down);\n        latch.setDigitalValue(1);\n        clock.setDigitalValue(1);\n    }\n\n    void disable() {\n        data.getDigitalValue(PullMode::None);\n        latch.getDigitalValue(PullMode::None);\n        clock.getDigitalValue(PullMode::None);\n        enabled = false;\n    }\n\n    bool isButtonPressed(int id) {\n        for (int i = 0; i < 8; ++i) {\n            if (buttonIdPerBit[i] == id)\n                return (state & (1 << i)) != 0;\n        }\n        return false;\n    }\n\n    uint32_t readBits(int bits) {\n        latch.setDigitalValue(0);\n        waitABit();\n        latch.setDigitalValue(1);\n        waitABit();\n\n        uint32_t state = 0;\n        for (int i = 0; i < bits; i++) {\n            state <<= 1;\n            if (data.getDigitalValue(PullMode::Down))\n                state |= 1;\n\n            clock.setDigitalValue(0);\n            waitABit();\n            clock.setDigitalValue(1);\n            waitABit();\n        }\n\n        return state;\n    }\n\n    virtual void periodicCallback() override {\n        if (!enabled)\n            return;\n\n        uint32_t newState = readBits(8);\n        newState ^= invMask;\n        if (newState == state)\n            return;\n\n        for (int i = 0; i < 8; ++i) {\n            uint32_t mask = 1 << i;\n            if (!buttonIdPerBit[i])\n                continue;\n            int ev = 0;\n            if (!(state & mask) && (newState & mask))\n                ev = PXT_INTERNAL_KEY_DOWN;\n            else if ((state & mask) && !(newState & mask))\n                ev = PXT_INTERNAL_KEY_UP;\n            if (ev) {\n                Event(ev, buttonIdPerBit[i]);\n                Event(ev, 0); // any key\n            }\n        }\n\n        state = newState;\n    }\n};\n\nstatic ButtonMultiplexer *btnMultiplexer;\nButtonMultiplexer *getMultiplexer() {\n    if (!btnMultiplexer)\n        btnMultiplexer = new ButtonMultiplexer(DEVICE_ID_FIRST_BUTTON);\n    return btnMultiplexer;\n}\n\nint registerMultiplexedButton(int pin, int buttonId) {\n    if (1050 <= pin && pin < 1058) {\n        pin -= 50;\n        getMultiplexer()->invMask |= 1 << (pin - 1000);\n    }\n    if (1000 <= pin && pin < 1008) {\n        getMultiplexer()->buttonIdPerBit[pin - 1000] = buttonId;\n        return 1;\n    }\n    return 0;\n}\n\nint multiplexedButtonIsPressed(int btnId) {\n    if (btnMultiplexer)\n        return btnMultiplexer->isButtonPressed(btnId) ? 512 : 0;\n    return 0;\n}\n\n//% expose\nuint32_t readButtonMultiplexer(int bits) {\n    if (!LOOKUP_PIN(BTNMX_CLOCK))\n        return 0;\n    return getMultiplexer()->readBits(bits);\n}\n\nvoid disableButtonMultiplexer() {\n    if (LOOKUP_PIN(BTNMX_CLOCK)) {\n        getMultiplexer()->disable();\n    }\n}\n\n}",
            "pinsPWM.cpp": "#include \"pxt.h\"\n\nnamespace PwmPinMethods {\n}\n\nnamespace PwmOnlyPinMethods {\n\n/**\n * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n * **microseconds** or `1/1000` milliseconds.\n * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n * no effect.\n * @param name analog pin to set period to\n * @param micros period in micro seconds. eg:20000\n */\n//% help=pins/analog-set-period weight=51\n//% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (s)%period\"\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid analogSetPeriod(PwmOnlyPin name, int period) {\n    PINOP(setAnalogPeriodUs(period));\n}\n\n/**\n * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n * @param name pin to write to\n * @param value angle or rotation speed\n */\n//% help=pins/servo-write weight=41 group=\"Servo\"\n//% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n//% parts=microservo trackArgs=0\n//% blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% value.defl=90\nvoid servoWrite(PwmOnlyPin name, int value) {\n    PINOP(setServoValue(value));\n}\n\n/**\n * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n * @param name pin name\n * @param duration pulse duration in micro seconds, eg:1500\n */\n//% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n//% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (s) %duration\"\n//% parts=microservo blockNamespace=pins\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\nvoid servoSetPulse(PwmOnlyPin name, int duration) {\n    PINOP(setServoPulseUs(duration));\n}\n\n/**\n* Indicates if the servo is running continuously\n*/\n//% blockHidden=1\nvoid servoSetContinuous(PwmOnlyPin name, bool continuous) {\n    // used by simulator\n}\n\n}",
            "pinscompat.ts": "// filled in by microbit",
            "platform.cpp": "#include \"pxt.h\"\n\n#include \"SAMDTCTimer.h\"\n#include \"SAMDTCCTimer.h\"\n#include \"light.h\"\n\nnamespace pxt {\n\nstruct TimerConfig {\n    uint8_t id;\n    uint8_t irq;\n    uint8_t dmaovf;\n    uint32_t addr;\n};\n\n#define DEF_TC(n)                                                                                  \\\n    { 0x10 + n, TC##n##_IRQn, TC##n##_DMAC_ID_OVF, (uint32_t)TC##n }\n#ifdef SAMD21\n#define DEF_TCC(n)                                                                                 \\\n    { 0x20 + n, TCC##n##_IRQn, TCC##n##_DMAC_ID_OVF, (uint32_t)TCC##n }\n#else\n#define DEF_TCC(n)                                                                                 \\\n    { 0x20 + n, TCC##n##_0_IRQn, TCC##n##_DMAC_ID_OVF, (uint32_t)TCC##n }\n#endif\n\nstatic const TimerConfig timers[] = {\n#ifdef TC0\n    DEF_TC(0),\n#endif\n#ifdef TC1\n    DEF_TC(1),\n#endif\n#ifdef TC2\n    DEF_TC(2),\n#endif\n#ifdef TC3\n    DEF_TC(3),\n#endif\n#ifdef TC4\n    DEF_TC(4),\n#endif\n#ifdef TC5\n    DEF_TC(5),\n#endif\n\n#ifdef TCC0\n    DEF_TCC(0),\n#endif\n#ifdef TCC1\n    DEF_TCC(1),\n#endif\n#ifdef TCC2\n    DEF_TCC(2),\n#endif\n\n    {0, 0, 0, 0}};\n\n// Backlight:\n// Kitronik: PA6 TC1 (ch 0)\n// Adafruit: PA1 TC2 (ch 1)\n\n// TC3 is used by DAC on both D21 and D51\n// TCC0 and TC4 is used by IR\n// TCC0, TCC1, TC4 is used by PWM on CPX\n\n#ifdef SAMD21\n#define DEF_TIMERS 0x15222021 // TC5 TCC2 TCC0 TCC1\n#else\n#define DEF_TIMERS 0x10111200 // TC0 TC1 TC2\n#endif\n\nstatic uint32_t usedTimers;\nstatic int timerIdx(uint8_t id) {\n    for (unsigned i = 0; timers[i].id; i++) {\n        if (id == timers[i].id)\n            return i;\n    }\n    return -1;\n}\nLowLevelTimer *allocateTimer() {\n    uint32_t timersToUse = getConfig(CFG_TIMERS_TO_USE, DEF_TIMERS);\n    uint8_t blTC = 0;\n    // DAC hard-wired to TC3 right now\n    uint8_t dacTC = 0x13;\n\n    // if BL is on a known pin, don't use its PWM TC\n    // this is a hack for legacy boards that don't have CFG_TIMERS_TO_USE\n    auto blPin = PIN(DISPLAY_BL);\n    if (blPin == PA01)\n        blTC = 0x12;\n\n    for (int shift = 24; shift >= 0; shift -= 8) {\n        uint8_t tcId = (timersToUse >> shift) & 0xff;\n        if (tcId == 0 || tcId == blTC || tcId == dacTC)\n            continue;\n        int idx = timerIdx(tcId);\n        if (idx < 0 || (usedTimers & (1 << idx)))\n            continue;\n        LowLevelTimer *res;\n        if (idx < 0x20) {\n            Tc *tc = (Tc *)timers[idx].addr;\n            if (tc->COUNT16.CTRLA.bit.ENABLE)\n                continue;\n            DMESG(\"allocate TC%d\", tcId & 0xf);\n            res = new SAMDTCTimer(tc, timers[idx].irq);\n        } else {\n            Tcc *tcc = (Tcc *)timers[idx].addr;\n            if (tcc->CTRLA.bit.ENABLE)\n                continue;\n            DMESG(\"allocate TCC%d\", tcId & 0xf);\n            res = new SAMDTCCTimer(tcc, timers[idx].irq);\n        }\n        usedTimers |= 1 << idx;\n        return res;\n    }\n\n    target_panic(PANIC_OUT_OF_TIMERS);\n    return NULL;\n}\n\nstatic void initRandomSeed() {\n    int seed = 0xC0DA1;\n    // TODO use TRNG\n    seedRandom(seed);\n}\n\nvoid platformSendSerial(const char *data, int len) {}\n\n#ifdef SAMD21\nstatic void remapSwdPin(int pinCfg, int fallback) {\n    int pinName = getConfig(pinCfg);\n    if (pinName == PA30 || pinName == PA31) {\n        if (getConfig(CFG_SWD_ENABLED, 0)) {\n            linkPin(pinName, fallback);\n        } else {\n            PORT->Group[pinName / 32].PINCFG[pinName % 32].reg = (uint8_t)PORT_PINCFG_INEN;\n        }\n    }\n}\n\nstatic void initSwdPins() {\n    remapSwdPin(CFG_PIN_NEOPIXEL, PIN(D0));\n    remapSwdPin(CFG_PIN_RXLED, PIN(D1));\n    remapSwdPin(CFG_PIN_SPEAKER_AMP, PIN(A2));\n}\n#else\nstatic void initSwdPins() {}\n#endif\n\nvoid platform_init() {\n    initSwdPins();\n    initRandomSeed();\n    setSendToUART(platformSendSerial);\n    light::clear();\n\n    /*\n        if (*HF2_DBG_MAGIC_PTR == HF2_DBG_MAGIC_START) {\n            *HF2_DBG_MAGIC_PTR = 0;\n            // this will cause alignment fault at the first breakpoint\n            globals[0] = (TValue)1;\n        }\n    */\n}\n\nint *getBootloaderConfigData() {\n#ifdef SAMD51\n    auto config_data = *(uint32_t *)(BOOTLOADER_END - 4 * 4);\n    if (config_data && (config_data & 3) == 0 && config_data < BOOTLOADER_END) {\n        auto p = (uint32_t *)config_data;\n        if (p[0] == CFG_MAGIC0 && p[1] == CFG_MAGIC1)\n            return (int *)p + 4;\n    }\n#endif\n    return NULL;\n}\n\n} // namespace pxt\n\nvoid cpu_clock_init() {}\n",
            "platform.h": "#ifndef __PXT_PLATFORM_H\n#define __PXT_PLATFORM_H\n\n#include \"Image.h\"\n#include \"MultiButton.h\"\n#include \"ZPin.h\"\n#include \"Timer.h\"\n#include \"SAMDDAC.h\"\n#include \"ZSPI.h\"\n#include \"ZI2C.h\"\n#include \"ZSingleWireSerial.h\"\n#include \"SAMDNVM.h\"\n#include \"SAMDPDM.h\"\n#include \"SAMDSerial.h\"\n\n// cap touch not available on 51 yet\n#ifdef SAMD21\n#include \"CapTouchButton.h\"\n#endif\n\n#define MIC_DEVICE SAMD21PDM\n\n#ifdef SAMD21\n#define OUTPUT_BITS 10\n#else\n#define OUTPUT_BITS 12\n#endif\n\n#include \"pinmap.h\"\n\n#undef min\n#undef max\n\ntypedef int PinName;\n\n#define PAGE_SIZE 512\n\n#define BOOTLOADER_START 0x0\n\n#ifdef SAMD21\n#define BOOTLOADER_END 0x2000\n#endif\n\n#ifdef SAMD51\n#define BOOTLOADER_END 0x4000\n#endif\n\n#define USB_HANDOVER 0\n\n// if we ever want to support 100+ pin packages, need to add PC,PD ports and increase this to 128\n#define DEV_NUM_PINS 64\n\n#define IS_ANALOG_PIN(id) 1\n\n#define CODAL_PIN ZPin\n#define CODAL_TIMER Timer\n#define CODAL_SPI ZSPI\n#define CODAL_I2C ZI2C\n#define CODAL_JACDAC_WIRE_SERIAL codal::ZSingleWireSerial\n#define CODAL_SERIAL codal::SAMDSerial\n#define CODAL_DAC SAMDDAC\n\n#ifdef SAMD21\n#define CODAL_NVMCONTROLLER codal::SAMDNVM\n#endif\n\n#define PXT_74HC165 1\n\n#define IMAGE_BITS 4\n\n// The parameters below needs tuning!\n\n#define PA00 0\n#define PA01 1\n#define PA02 2\n#define PA03 3\n#define PA04 4\n#define PA05 5\n#define PA06 6\n#define PA07 7\n#define PA08 8\n#define PA09 9\n#define PA10 10\n#define PA11 11\n#define PA12 12\n#define PA13 13\n#define PA14 14\n#define PA15 15\n#define PA16 16\n#define PA17 17\n#define PA18 18\n#define PA19 19\n#define PA20 20\n#define PA21 21\n#define PA22 22\n#define PA23 23\n#define PA24 24\n#define PA25 25\n#define PA26 26\n#define PA27 27\n#define PA28 28\n#define PA29 29\n#define PA30 30\n#define PA31 31\n#define PB00 32\n#define PB01 33\n#define PB02 34\n#define PB03 35\n#define PB04 36\n#define PB05 37\n#define PB06 38\n#define PB07 39\n#define PB08 40\n#define PB09 41\n#define PB10 42\n#define PB11 43\n#define PB12 44\n#define PB13 45\n#define PB14 46\n#define PB15 47\n#define PB16 48\n#define PB17 49\n#define PB18 50\n#define PB19 51\n#define PB20 52\n#define PB21 53\n#define PB22 54\n#define PB23 55\n#define PB24 56\n#define PB25 57\n#define PB26 58\n#define PB27 59\n#define PB28 60\n#define PB29 61\n#define PB30 62\n#define PB31 63\n#define PC00  64\n#define PC01  65\n#define PC02  66\n#define PC03  67\n#define PC04  68\n#define PC05  69\n#define PC06  70\n#define PC07  71\n#define PC08  72\n#define PC09  73\n#define PC10  74\n#define PC11  75\n#define PC12  76\n#define PC13  77\n#define PC14  78\n#define PC15  79\n#define PC16  80\n#define PC17  81\n#define PC18  82\n#define PC19  83\n#define PC20  84\n#define PC21  85\n#define PC22  86\n#define PC23  87\n#define PC24  88\n#define PC25  89\n#define PC26  90\n#define PC27  91\n#define PC28  92\n#define PC29  93\n#define PC30  94\n#define PC31  95\n#define PD00  96\n#define PD01  97\n#define PD02  98\n#define PD03  99\n#define PD04  100\n#define PD05  101\n#define PD06  102\n#define PD07  103\n#define PD08  104\n#define PD09  105\n#define PD10  106\n#define PD11  107\n#define PD12  108\n#define PD13  109\n#define PD14  110\n#define PD15  111\n#define PD16  112\n#define PD17  113\n#define PD18  114\n#define PD19  115\n#define PD20  116\n#define PD21  117\n#define PD22  118\n#define PD23  119\n#define PD24  120\n#define PD25  121\n#define PD26  122\n#define PD27  123\n#define PD28  124\n#define PD29  125\n#define PD30  126\n#define PD31  127\n#endif\n",
            "pxt.h": "#ifndef __PXT_H\n#define __PXT_H\n\n#include \"pxtbase.h\"\n\n#include \"CodalConfig.h\"\n#include \"CodalHeapAllocator.h\"\n#include \"CodalDevice.h\"\n#include \"CodalDmesg.h\"\n#include \"ErrorNo.h\"\n#include \"Timer.h\"\n#include \"Matrix4.h\"\n#include \"CodalCompat.h\"\n#include \"CodalComponent.h\"\n#include \"ManagedType.h\"\n#include \"Event.h\"\n#include \"NotifyEvents.h\"\n#include \"Button.h\"\n#include \"CodalFiber.h\"\n#include \"MessageBus.h\"\n\nusing namespace codal;\n\n// codal::ManagedString compat\n#define MSTR(s) codal::ManagedString((s)->data, (s)->length)\n#define PSTR(s) mkString((s).toCharArray(), (s).length())\n\n#include \"pins.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"hf2.h\"\n#include \"hf2dbg.h\"\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n#include \"HIDMouse.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n#include \"HIDKeyboard.h\"\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n#include \"HIDJoystick.h\"\n#endif\n#endif\n\n#define PXT_COMM_BASE 0x20002000 // 8k in\n\nnamespace pxt {\n\n#if CONFIG_ENABLED(DEVICE_USB)\nextern CodalUSB usb;\nextern HF2 hf2;\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nextern USBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nextern USBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nextern USBHIDJoystick joystick;\n#endif\n#endif\n\n// Utility functions\nextern Event lastEvent;\nextern CODAL_TIMER devTimer;\nextern MessageBus devMessageBus;\nextern codal::CodalDevice device;\n\nvoid set_usb_strings(const char *uf2_info);\nextern void (*logJDFrame)(const uint8_t *data);\nextern void (*sendJDFrame)(const uint8_t *data);\n\n\n} // namespace pxt\n\nnamespace pins {\nclass CodalSPIProxy;\nclass CodalI2CProxy;\n} // namespace pins\n\ntypedef pins::CodalI2CProxy* I2C_;\ntypedef pins::CodalSPIProxy* SPI_;\n\nnamespace pxt {\ncodal::LowLevelTimer *allocateTimer();\n\n#ifdef CODAL_I2C\nCODAL_I2C* getI2C(DigitalInOutPin sda, DigitalInOutPin scl);\n#endif\nCODAL_SPI* getSPI(DigitalInOutPin mosi, DigitalInOutPin miso, DigitalInOutPin sck);\n#ifdef CODAL_JACDAC_WIRE_SERIAL\nLowLevelTimer* getJACDACTimer();\n#endif\nclass PressureButton;\nuint32_t readButtonMultiplexer(int bits);\nvoid disableButtonMultiplexer();\n}\n\nnamespace serial {\nclass CodalSerialDeviceProxy;\n}\n\ntypedef serial::CodalSerialDeviceProxy* SerialDevice;\n\nnamespace jacdac {\nclass JDProxyDriver;\n} // namespace network\n\ntypedef jacdac::JDProxyDriver* JacDacDriverStatus;\n\n#define DEVICE_ID_BUTTON_SLIDE 3000\n#define DEVICE_ID_MICROPHONE 3001\n#define DEVICE_ID_FIRST_BUTTON 4000\n#define DEVICE_ID_FIRST_TOUCHBUTTON 4100\n\n#define PXT_INTERNAL_KEY_UP 2050\n#define PXT_INTERNAL_KEY_DOWN 2051\n\n#endif\n",
            "pxt.json": "{\n    \"name\": \"core---samd\",\n    \"description\": \"The core library for Codal-based targets\",\n    \"dependencies\": {\n        \"base\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"dal.d.ts\",\n        \"codal.cpp\",\n        \"usb.cpp\",\n        \"pxt.h\",\n        \"platform.h\",\n        \"platform.cpp\",\n        \"pxtcore.h\",\n        \"pins.h\",\n        \"pins.cpp\",\n        \"pinsAnalog.cpp\",\n        \"pinsDigital.cpp\",\n        \"pinsPWM.cpp\",\n        \"pins.ts\",\n        \"pinscompat.ts\",\n        \"control.cpp\",\n        \"i2c.cpp\",\n        \"i2c.ts\",\n        \"spi.cpp\",\n        \"spi.ts\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"hf2.cpp\",\n        \"hf2.h\",\n        \"hf2dbg.h\",\n        \"uf2format.h\",\n        \"uf2hid.h\",\n        \"ns.ts\",\n        \"dmac.cpp\",\n        \"dmac.h\",\n        \"timer.ts\",\n        \"light.cpp\",\n        \"light.h\",\n        \"keyvaluestorage.cpp\",\n        \"keyvaluestorage.ts\",\n        \"leveldetector.ts\",\n        \"pxtparts.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"yotta\": {\n        \"config\": {\n            \"codal\": {\n                \"component_count\": 64,\n                \"dmesg_buffer_size\": 1024\n            }\n        }\n    },\n    \"dalDTS\": {\n        \"includeDirs\": [\n            \"libraries/codal-core/inc\",\n            \"pxtapp\"\n        ],\n        \"excludePrefix\": [\n            \"JD_\",\n            \"USB_\",\n            \"REQUEST_\",\n            \"LIS3DH_\",\n            \"FXOS8700_\",\n            \"HF2_\",\n            \"PXT_REF_TAG_\",\n            \"MS_\",\n            \"SCSI_\",\n            \"MAG_\",\n            \"MAG3\",\n            \"MPU6\",\n            \"MADCTL\",\n            \"MMA8\"\n        ]\n    }\n}\n",
            "pxtcore.h": "#ifndef __PXTCORE_H\n#define __PXTCORE_H\n\n#include \"CodalDmesg.h\"\n#include \"CodalHeapAllocator.h\"\n\n#define itoa(a, b) codal::itoa(a, b)\n\n#define GC_GET_HEAP_SIZE() device_heap_size(0)\n#define GC_STACK_BASE DEVICE_STACK_BASE\n#define xmalloc device_malloc\n#define xfree device_free\n\n// on most devices we allocate the entire heap at once, so large allocs should work\n// if they don't you just get the regular out of memory instead of alloc too large\n#define GC_MAX_ALLOC_SIZE (128 * 1024)\n\n#endif\n",
            "pxtparts.json": "{\n    \"neopixel\": {\n        \"simulationBehavior\": \"neopixel\",\n        \"visual\": {\n            \"builtIn\": \"neopixel\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 19,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 28,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createStrip,light.createNeoPixelStrip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"dotstar\": {\n        \"simulationBehavior\": \"dotstar\",\n        \"visual\": {\n            \"builtIn\": \"dotstar\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 1\n                },\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"light.createAPA102Strip\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"dataPin\"\n                },\n                {\n                    \"pinInstantiationIdx\": 1,\n                    \"partParameter\": \"clkPin\"\n                },\n                {\n                    \"partParameter\": \"mode\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },\n    \"pixels\": {\n        \"simulationBehavior\": \"pixels\",\n        \"visual\": { \n            \"builtIn\": \"pixels\",\n            \"width\": 58,\n            \"height\": 113,\n            \"pinDistance\": 9,\n            \"pinLocations\": [\n                {\n                    \"x\": 10,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 17,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 24,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 31,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"numberOfPins\": 4,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"MOSI\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"SCK\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"solder\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1, 2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    3\n                ]\n            }\n        ]\n    },    \n    \"buttons\": {\n        \"simulationBehavior\": \"buttons\",\n        \"visual\": {\n            \"builtIn\": \"buttons\",\n            \"width\": 75,\n            \"height\": 45,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 30,\n                    \"y\": 45\n                }\n            ]\n        },\n        \"numberOfPins\": 2,\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"Button.onEvent,Button.isPressed,Button.wasPressed\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"button\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"slideswitch\": {\n        \"numberOfPins\": 3,\n        \"simulationBehavior\": \"slideswitch\",\n        \"visual\": {\n            \"builtIn\": \"slideswitch\",\n            \"width\": 100,\n            \"height\": 100,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalRead,DigitalInOutPin.onPulsed,DigitalInOutPin.onEvent\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"pin\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"microservo\": {\n        \"simulationBehavior\": \"microservo\",\n        \"visual\": {\n            \"builtIn\": \"microservo\",\n            \"width\": 74.85,\n            \"height\": 200,\n            \"pinDistance\": 10,\n            \"pinLocations\": [\n                {\n                    \"x\": 30,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 37,\n                    \"y\": 5\n                },\n                {\n                    \"x\": 45,\n                    \"y\": 5\n                }\n            ]\n        },\n        \"numberOfPins\": 3,\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"+Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"PwmOnlyPin.servoWrite,servos.Servo.setAngle,servos.Servo.run,servos.Servo.setPulse\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    2\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    0,\n                    1\n                ]\n            }\n        ]\n    },\n    \"led\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"DigitalInOutPin.digitalWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"analogled\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"builtIn\": \"led\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"led\",\n        \"pinDefinitions\": [\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogOutPin.analogWrite\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    },\n    \"photocell\": {\n        \"numberOfPins\": 3,\n        \"visual\": {\n            \"builtIn\": \"photocell\",\n            \"width\": 68,\n            \"height\": 180,\n            \"pinDistance\": 15,\n            \"pinLocations\": [\n                {\n                    \"x\": 0,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 15,\n                    \"y\": 0\n                },\n                {\n                    \"x\": 60,\n                    \"y\": 0\n                }\n            ]\n        },\n        \"simulationBehavior\": \"photocell\",\n        \"pinDefinitions\": [\n            {\n                \"target\": \"threeVolt\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": {\n                    \"pinInstantiationIdx\": 0\n                },\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"male\",\n                \"orientation\": \"-Z\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"function\",\n            \"fullyQualifiedName\": \"AnalogInPin.analogRead\",\n            \"argumentRoles\": [\n                {\n                    \"pinInstantiationIdx\": 0,\n                    \"partParameter\": \"name\"\n                }\n            ]\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace light {\n\n    /**\n     * Send a programmable light buffer to the specified digital pin\n     * @param data The pin that the lights are connected to\n     * @param clk the clock line if any\n     * @param mode the color encoding mode\n     * @param buf The buffer to send to the pin\n     */\n    //% shim=light::sendBuffer\n    function sendBuffer(data: DigitalInOutPin, clk: DigitalInOutPin, mode: int32, buf: Buffer): void;\n}\ndeclare namespace control {\n\n    /**\n     * Determines if the USB has been enumerated.\n     */\n    //% shim=control::isUSBInitialized\n    function isUSBInitialized(): boolean;\n}\ndeclare namespace pins {\n\n    /**\n     * Get a pin by configuration id (DAL.CFG_PIN...)\n     */\n    //% shim=pins::pinByCfg\n    function pinByCfg(key: int32): DigitalInOutPin;\n\n    /**\n     * Create a new zero-initialized buffer.\n     * @param size number of bytes in the buffer\n     */\n    //% shim=pins::createBuffer\n    function createBuffer(size: int32): Buffer;\n\n    /**\n     * Get the duration of the last pulse in microseconds. This function should be called from a\n     * ``onPulsed`` handler.\n     */\n    //% help=pins/pulse-duration blockGap=8\n    //% blockId=pins_pulse_duration block=\"pulse duration (s)\"\n    //% weight=19 shim=pins::pulseDuration\n    function pulseDuration(): int32;\n}\n\n\ndeclare interface AnalogInPin {\n    /**\n     * Read the connector value as analog, that is, as a value comprised between 0 and 1023.\n     * @param name pin to write to\n     */\n    //% help=pins/analog-read weight=53\n    //% blockId=device_get_analog_pin block=\"analog read|pin %name\" blockGap=\"8\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=AnalogInPinMethods::analogRead\n    analogRead(): int32;\n}\n\n\ndeclare interface AnalogOutPin {\n    /**\n     * Set the connector value as analog. Value must be comprised between 0 and 1023.\n     * @param name pin name to write to\n     * @param value value to write to the pin between ``0`` and ``1023``. eg:1023,0\n     */\n    //% help=pins/analog-write weight=52\n    //% blockId=device_set_analog_pin block=\"analog write|pin %name|to %value\" blockGap=8\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.min=0 value.max=1023 shim=AnalogOutPinMethods::analogWrite\n    analogWrite(value: int32): void;\n}\n\n\ndeclare interface DigitalInOutPin {\n    /**\n     * Read a pin or connector as either 0 or 1\n     * @param name pin to read from\n     */\n    //% help=pins/digital-read weight=61\n    //% blockId=device_get_digital_pin block=\"digital read|pin %name\" blockGap=8\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalRead\n    digitalRead(): boolean;\n\n    /**\n     * Set a pin or connector value to either 0 or 1.\n     * @param name pin to write to\n     * @param value value to set on the pin\n     */\n    //% help=pins/digital-write weight=60\n    //% blockId=device_set_digital_pin block=\"digital write|pin %name|to %value=toggleHighLow\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::digitalWrite\n    digitalWrite(value: boolean): void;\n\n    /**\n     * Make this pin a digital input, and create events where the timestamp is the duration\n     * that this pin was either ``high`` or ``low``.\n     */\n    //% help=pins/on-pulsed weight=16 blockGap=8\n    //% blockId=pins_on_pulsed block=\"on|pin %pin|pulsed %pulse\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4\n    //% deprecated=1 hidden=1 shim=DigitalInOutPinMethods::onPulsed\n    onPulsed(pulse: PulseValue, body: () => void): void;\n\n    /**\n     * Register code to run when a pin event occurs. \n     */\n    //% help=pins/on-event weight=20 blockGap=8\n    //% blockId=pinsonevent block=\"on|pin %pin|%event\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 shim=DigitalInOutPinMethods::onEvent\n    onEvent(event: PinEvent, body: () => void): void;\n\n    /**\n     * Return the duration of a pulse in microseconds\n     * @param name the pin which measures the pulse\n     * @param value the value of the pulse (default high)\n     * @param maximum duration in micro-seconds\n     */\n    //% blockId=\"pins_pulse_in\" block=\"pulse in (s)|pin %name|pulsed %high||timeout %maxDuration (s)\"\n    //% weight=18 blockGap=8\n    //% help=\"pins/pulse-in\"\n    //% blockNamespace=pins\n    //% pin.fieldEditor=\"gridpicker\"\n    //% pin.fieldOptions.width=220\n    //% pin.fieldOptions.columns=4 maxDuration.defl=2000000 shim=DigitalInOutPinMethods::pulseIn\n    pulseIn(value: PulseValue, maxDuration?: int32): int32;\n\n    /**\n     * Set the pull direction of this pin.\n     * @param name pin to set the pull mode on\n     * @param pull one of the mbed pull configurations: PullUp, PullDown, PullNone\n     */\n    //% help=pins/set-pull weight=17 blockGap=8\n    //% blockId=device_set_pull block=\"set pull|pin %pin|to %pull\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=DigitalInOutPinMethods::setPull\n    setPull(pull: PinPullMode): void;\n}\n\n\ndeclare interface PwmPin {}\n\n\ndeclare interface PwmOnlyPin {\n    /**\n     * Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n     * **microseconds** or `1/1000` milliseconds.\n     * If this pin is not configured as an analog output (using `analog write pin`), the operation has\n     * no effect.\n     * @param name analog pin to set period to\n     * @param micros period in micro seconds. eg:20000\n     */\n    //% help=pins/analog-set-period weight=51\n    //% blockId=device_set_analog_period block=\"analog set period|pin %pin|to (s)%period\"\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::analogSetPeriod\n    analogSetPeriod(period: int32): void;\n\n    /**\n     * Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\n     * set the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\n     * rotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\n     * direction, ``180`` being full speed in the other, and a value near ``90`` being no movement).\n     * @param name pin to write to\n     * @param value angle or rotation speed\n     */\n    //% help=pins/servo-write weight=41 group=\"Servo\"\n    //% blockId=device_set_servo_pin block=\"servo write|pin %name|to %value=protractorPicker\" blockGap=8\n    //% parts=microservo trackArgs=0\n    //% blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% value.defl=90 shim=PwmOnlyPinMethods::servoWrite\n    servoWrite(value?: int32): void;\n\n    /**\n     * Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\n     * The pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.\n     * @param name pin name\n     * @param duration pulse duration in micro seconds, eg:1500\n     */\n    //% help=pins/servo-set-pulse weight=40 group=\"Servo\" blockGap=8\n    //% blockId=device_set_servo_pulse block=\"servo set pulse|pin %value|to (s) %duration\"\n    //% parts=microservo blockNamespace=pins\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4 shim=PwmOnlyPinMethods::servoSetPulse\n    servoSetPulse(duration: int32): void;\n\n    /**\n     * Indicates if the servo is running continuously\n     */\n    //% blockHidden=1 shim=PwmOnlyPinMethods::servoSetContinuous\n    servoSetContinuous(continuous: boolean): void;\n}\ndeclare namespace control {\n\n    /**\n     * Announce that an event happened to registered handlers.\n     * @param src ID of the MicroBit Component that generated the event\n     * @param value Component specific code indicating the cause of the event.\n     */\n    //% weight=21 blockGap=12 blockId=\"control_raise_event\"\n    //% help=control/raise-event\n    //% block=\"raise event|from %src|with value %value\" blockExternalInputs=1 shim=control::raiseEvent\n    function raiseEvent(src: int32, value: int32): void;\n\n    /**\n     * Determine the version of system software currently running.\n     */\n    //% blockId=\"control_device_dal_version\" block=\"device dal version\"\n    //% help=control/device-dal-version shim=control::deviceDalVersion\n    function deviceDalVersion(): string;\n\n    /**\n     * Allocates the next user notification event\n     */\n    //% help=control/allocate-notify-event shim=control::allocateNotifyEvent\n    function allocateNotifyEvent(): int32;\n\n    /** Write a message to DMESG debugging buffer. */\n    //% shim=control::dmesg\n    function dmesg(s: string): void;\n\n    /** Write a message and value (pointer) to DMESG debugging buffer. */\n    //% shim=control::dmesgPtr\n    function dmesgPtr(str: string, ptr: Object): void;\n}\n\n\ndeclare interface I2C {\n    /**\n     * Read `size` bytes from a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=I2CMethods::readBuffer\n    readBuffer(address: int32, size: int32, repeat?: boolean): Buffer;\n\n    /**\n     * Write bytes to a 7-bit I2C `address`.\n     */\n    //% repeat.defl=0 shim=I2CMethods::writeBuffer\n    writeBuffer(address: int32, buf: Buffer, repeat?: boolean): int32;\n}\ndeclare namespace pins {\n\n    /**\n     * Opens a Serial communication driver\n     */\n    //% help=pins/create-i2c\n    //% parts=i2c shim=pins::createI2C\n    function createI2C(sda: DigitalInOutPin, scl: DigitalInOutPin): I2C;\n}\ndeclare namespace pins {\n\n    /**\n     * Opens a SPI driver\n     */\n    //% help=pins/create-spi\n    //% parts=spi shim=pins::createSPI\n    function createSPI(mosiPin: DigitalInOutPin, misoPin: DigitalInOutPin, sckPin: DigitalInOutPin): SPI;\n\n    /**\n     * Opens a slave SPI driver\n     */\n    //% parts=spi shim=pins::createSlaveSPI\n    function createSlaveSPI(mosiPin: DigitalInOutPin, misoPin: DigitalInOutPin, sckPin: DigitalInOutPin, csPin: DigitalInOutPin): SPI;\n}\n\n\ndeclare interface SPI {\n    /**\n     * Write to the SPI bus\n     */\n    //% shim=SPIMethods::write\n    write(value: int32): int32;\n\n    /**\n     * Transfer buffers over the SPI bus\n     */\n    //% argsNullable shim=SPIMethods::transfer\n    transfer(command: Buffer, response: Buffer): void;\n\n    /**\n     * Sets the SPI clock frequency\n     */\n    //% shim=SPIMethods::setFrequency\n    setFrequency(frequency: int32): void;\n\n    /**\n     * Sets the SPI bus mode\n     */\n    //% shim=SPIMethods::setMode\n    setMode(mode: int32): void;\n}\ndeclare namespace configStorage {\n\n    /**\n     * Puts an entry in the device storage. Key may have up to 16 characters (bytes).\n     * @param key the identifier (max 16 characters)\n     * @param value the data (max 32 characters)\n     */\n    //% shim=configStorage::setBuffer\n    function setBuffer(key: string, value: Buffer): void;\n\n    /**\n     * Gets an entry from the device storage. Key may have up to 16 characters (bytes).\n     * @param key the identifier (max 16 characters)\n     */\n    //% shim=configStorage::getBuffer\n    function getBuffer(key: string): Buffer;\n\n    /**\n     * Removes the key from local storage\n     * @param key the identifier (max 16 characters)\n     */\n    //% shim=configStorage::removeItem\n    function removeItem(key: string): void;\n\n    /**\n     * Clears the local storage\n     */\n    //% shim=configStorage::clear\n    function clear(): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "spi.cpp": "#include \"pxt.h\"\n#include \"ErrorNo.h\"\n\nnamespace pins {\n\nclass CodalSPIProxy {\nprivate:\n    DevicePin* mosi; \n    DevicePin* miso; \n    DevicePin* sck;\n    CODAL_SPI spi;\npublic:\n    CodalSPIProxy* next;\n\npublic:\n    CodalSPIProxy(DevicePin* _mosi, DevicePin* _miso, DevicePin* _sck)\n        : mosi(_mosi)\n        , miso(_miso)\n        , sck(_sck)\n        , spi(*_mosi, *_miso, *_sck) \n        , next(NULL)\n    {\n    }\n\n#ifdef CODAL_SPI_SLAVE_SUPPORTED\n    CodalSPIProxy(DevicePin* _mosi, DevicePin* _miso, DevicePin* _sck, DevicePin* _cs)\n        : mosi(_mosi)\n        , miso(_miso)\n        , sck(_sck)\n        , spi(*_mosi, *_miso, *_sck, _cs) \n        , next(NULL)\n    {\n    }\n#endif\n\n    CODAL_SPI* getSPI() {\n        return &spi;\n    }\n\n    bool matchPins(DevicePin* mosi, DevicePin* miso, DevicePin* sck) {\n        return this->mosi == mosi && this->miso == miso && this->sck == sck;\n    }\n\n    int write(int value) {\n        return spi.write(value);\n    }\n\n    void transfer(Buffer command, Buffer response) {\n        auto cdata = NULL == command ? NULL : command->data;\n        auto clength = NULL == command ? 0 : command->length;\n        auto rdata = NULL == response ? NULL : response->data;\n        auto rlength = NULL == response ? 0 : response->length;\n        spi.transfer(cdata, clength, rdata, rlength);\n    }\n\n    void setFrequency(int frequency) {\n        spi.setFrequency(frequency);\n    }\n\n    void setMode(int mode) {\n        spi.setMode(mode);\n    }\n};\n\nSPI_ spis(NULL);\n\n/**\n* Opens a SPI driver\n*/\n//% help=pins/create-spi\n//% parts=spi\nSPI_ createSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin) {\n  auto dev = spis;\n  while(dev) {\n    if (dev->matchPins(mosiPin, misoPin, sckPin))\n      return dev;\n    dev = dev->next;\n  }\n\n  auto ser = new CodalSPIProxy(mosiPin, misoPin, sckPin);\n  ser->next = spis;\n  spis = ser;\n  return ser;\n}\n\n/**\n* Opens a slave SPI driver\n*/\n//% parts=spi\nSPI_ createSlaveSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin, DigitalInOutPin csPin) {\n#ifdef CODAL_SPI_SLAVE_SUPPORTED\n  auto dev = spis;\n  if (!csPin)\n    target_panic(PANIC_CODAL_HARDWARE_CONFIGURATION_ERROR);\n  while(dev) {\n    if (dev->matchPins(mosiPin, misoPin, sckPin))\n      return dev;\n    dev = dev->next;\n  }\n\n  auto ser = new CodalSPIProxy(mosiPin, misoPin, sckPin, csPin);\n  ser->next = spis;\n  spis = ser;\n  return ser;\n#else\n  target_panic(PANIC_CODAL_HARDWARE_CONFIGURATION_ERROR);\n  return NULL;\n#endif\n}\n\n}\n\nnamespace pxt {\n\nCODAL_SPI* getSPI(DigitalInOutPin mosiPin, DigitalInOutPin misoPin, DigitalInOutPin sckPin) {\n    auto spi = pins::createSPI(mosiPin, misoPin, sckPin);\n    return spi->getSPI();\n}\n\n}\n\nnamespace SPIMethods {\n\n/**\n* Write to the SPI bus\n*/\n//%\nint write(SPI_ device, int value) {\n    return device->write(value);\n}\n\n/**\n* Transfer buffers over the SPI bus\n*/\n//% argsNullable\nvoid transfer(SPI_ device, Buffer command, Buffer response) {\n    if (!device)\n        target_panic(PANIC_CAST_FROM_NULL);\n    if (!command && !response)\n        return;\n    device->transfer(command, response);\n}\n\n/**\n* Sets the SPI clock frequency\n*/\n//%\nvoid setFrequency(SPI_ device, int frequency) {\n    device->setFrequency(frequency);\n}\n\n/**\n* Sets the SPI bus mode\n*/\n//%\nvoid setMode(SPI_ device, int mode) {\n    device->setMode(mode);\n}\n\n}\n",
            "spi.ts": "namespace pins {\n\n    let _spi: SPI;\n    /**\n    * Gets the default SPI driver\n    */\n    //%\n    export function spi() {\n        if (!_spi) {\n            const mosi = pins.pinByCfg(DAL.CFG_PIN_MOSI);\n            const miso = pins.pinByCfg(DAL.CFG_PIN_MISO);\n            const sck = pins.pinByCfg(DAL.CFG_PIN_SCK);\n            _spi = pins.createSPI(mosi, miso, sck);\n        }\n        return _spi;\n    }\n\n    /**\n     * Write to the SPI slave and return the response\n     * @param value Data to be sent to the SPI slave\n     */\n    //% help=pins/spi-write weight=5 advanced=true\n    //% blockId=spi_write block=\"spi write %value\"\n    export function spiWrite(value: number) {\n        return spi().write(value);\n    }\n\n    /**\n     * Write a given command to SPI bus, and at the same time read the response.\n     */\n    //% help=pins/spi-transfer weight=4 advanced=true\n    //% blockId=spi_transfer block=\"spi transfer %command into %response\"\n    export function spiTransfer(command: Buffer, response: Buffer) {\n        spi().transfer(command, response);\n    }\n\n    /**\n     * Set the SPI frequency\n     * @param frequency the clock frequency, eg: 1000000\n     */\n    //% help=pins/spi-frequency weight=4 advanced=true\n    //% blockId=spi_frequency block=\"spi frequency %frequency\"\n    export function spiFrequency(frequency: number) {\n        spi().setFrequency(frequency);\n    }\n\n    /**\n     * Set the SPI signal mode\n     * @param mode the mode, eg: 3\n     */\n    //% help=pins/spi-mode weight=3 advanced=true\n    //% blockId=spi_mode block=\"spi mode %mode\"\n    export function spiMode(mode: number) {\n        spi().setMode(mode);\n    }\n}",
            "test.ts": "let i = 1\nlet f = 0.5\nlet plus = i + f\nlet minus = i - f\n\nlet r = Math.random()\nlet ri = Math.randomRange(5, 10)\n\n",
            "timer.ts": "namespace control {\n    /**\n     * A timer\n     */\n    //% fixedInstances\n    export class Timer {\n        start: number;\n\n        constructor() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Gets the elapsed time in millis since the last reset\n         */\n        //% blockId=timerMillis block=\"%timer|millis\"\n        millis(): number {\n            return control.millis() - this.start;\n        }\n\n        /**\n         * Gets the elapsed time in seconds since the last reset\n         */\n        //% blockId=timerSeconds block=\"%timer|seconds\"\n        seconds(): number {\n            return this.millis() / 1000;\n        }\n\n        /**\n         * Resets the timer\n         */\n        //% blockId=timerRest block=\"%timer|reset\"\n        reset() {\n            this.start = control.millis();\n        }\n\n        /**\n         * Pauses until the timer reaches the given amount of milliseconds\n         * @param ms how long to pause for, eg: 5, 100, 200, 500, 1000, 2000\n         */\n        //% blockId=timerPauseUntil block=\"%timer|pause until (ms) %ms\"\n        pauseUntil(ms: number) {\n            const remaining = this.millis() - ms;\n            pause(Math.max(0, remaining));\n        }\n    }\n\n    //% whenUsed fixedInstance block=\"timer 1\"\n    export const timer1 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 2\"\n    export const timer2 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 3\"\n    export const timer3 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 4\"\n    export const timer4 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 5\"\n    export const timer5 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 6\"\n    export const timer6 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 7\"\n    export const timer7 = new Timer();\n    //% whenUsed fixedInstance block=\"timer 8\"\n    export const timer8 = new Timer();\n}",
            "uf2format.h": "#ifndef UF2FORMAT_H\n#define UF2FORMAT_H 1\n\n#include <stdint.h>\n#include <stdbool.h>\n\n// All entries are little endian.\n\n#ifndef BOOTLOADER_START\n#define BOOTLOADER_START 0x0\n#endif\n\n#ifndef BOOTLOADER_END\n#define BOOTLOADER_END 0x2000\n#endif\n\n#ifndef UF2_BINFO\n#define UF2_BINFO ((UF2_BInfo *)(BOOTLOADER_END - sizeof(UF2_BInfo)))\n#endif\n\n#ifndef UF2_INFO_TXT\n#define UF2_INFO_TXT UF2_BINFO->info_uf2\n#endif\n\n\n#define UF2_MAGIC_START0 0x0A324655UL // \"UF2\\n\"\n#define UF2_MAGIC_START1 0x9E5D5157UL // Randomly selected\n#define UF2_MAGIC_END 0x0AB16F30UL    // Ditto\n\n// If set, the block is \"comment\" and should not be flashed to the device\n#define UF2_FLAG_NOFLASH 0x00000001\n\ntypedef struct {\n    // 32 byte header\n    uint32_t magicStart0;\n    uint32_t magicStart1;\n    uint32_t flags;\n    uint32_t targetAddr;\n    uint32_t payloadSize;\n    uint32_t blockNo;\n    uint32_t numBlocks;\n    uint32_t reserved;\n\n    // raw data;\n    uint8_t data[476];\n\n    // store magic also at the end to limit damage from partial block reads\n    uint32_t magicEnd;\n} UF2_Block;\n\ntypedef struct {\n    uint8_t version;\n    uint8_t ep_in;\n    uint8_t ep_out;\n    uint8_t reserved0;\n    uint32_t cbw_tag;\n    uint32_t blocks_remaining;\n    uint8_t *buffer;\n} UF2_HandoverArgs;\n\ntypedef void (*UF2_MSC_Handover_Handler)(UF2_HandoverArgs *handover);\ntypedef void (*UF2_HID_Handover_Handler)(int ep);\n\n// this is required to be exactly 16 bytes long by the linker script\ntypedef struct {\n    void *reserved0;\n    UF2_HID_Handover_Handler handoverHID;\n    UF2_MSC_Handover_Handler handoverMSC;\n    const char *info_uf2;\n} UF2_BInfo;\n\nstatic inline bool is_uf2_block(void *data) {\n    UF2_Block *bl = (UF2_Block *)data;\n    return bl->magicStart0 == UF2_MAGIC_START0 && bl->magicStart1 == UF2_MAGIC_START1 &&\n           bl->magicEnd == UF2_MAGIC_END;\n}\n\nstatic inline bool in_uf2_bootloader_space(const void *addr) {\n    return (BOOTLOADER_START + 0x100) <= (uint32_t)addr && (uint32_t)addr < (BOOTLOADER_END);\n}\n\nstatic inline const char *uf2_info(void) {\n    if (in_uf2_bootloader_space(UF2_INFO_TXT))\n        return UF2_INFO_TXT;\n    return \"N/A\";\n}\n\n#ifdef UF2_DEFINE_HANDOVER\nstatic inline void hf2_handover(uint8_t ep) {\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_HID_Handover_Handler fn = UF2_BINFO->handoverHID;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        // Pass control to bootloader; never returns\n        fn(ep & 0xf);\n    }\n}\n\nstatic inline void check_uf2_handover(uint8_t *buffer, uint32_t blocks_remaining, uint8_t ep_in,\n                                      uint8_t ep_out, uint32_t cbw_tag) {\n    if (!is_uf2_block(buffer))\n        return;\n\n    const char *board_info = UF2_BINFO->info_uf2;\n    UF2_MSC_Handover_Handler fn = UF2_BINFO->handoverMSC;\n\n    if (in_uf2_bootloader_space(board_info) && in_uf2_bootloader_space((const void *)fn) &&\n        ((uint32_t)fn & 1)) {\n        UF2_HandoverArgs hand = {\n            1, ep_in, ep_out, 0, cbw_tag, blocks_remaining, buffer,\n        };\n        // Pass control to bootloader; never returns\n        fn(&hand);\n    }\n}\n#endif\n\n#endif\n",
            "uf2hid.h": "#ifndef UF2_HID_H\n#define UF2_HID_H 1\n\n#define HF2_CMD_BININFO 0x0001\n// no arguments\n#define HF2_MODE_BOOTLOADER 0x01\n#define HF2_MODE_USERSPACE 0x02\nstruct HF2_BININFO_Result {\n    uint32_t mode;\n    uint32_t flash_page_size;\n    uint32_t flash_num_pages;\n    uint32_t max_message_size;\n    uint32_t uf2_family;\n};\n\n#define HF2_CMD_INFO 0x0002\n// no arguments\n// results is utf8 character array\n\n#define HF2_CMD_RESET_INTO_APP 0x0003\n// no arguments, no result\n\n#define HF2_CMD_RESET_INTO_BOOTLOADER 0x0004\n// no arguments, no result\n\n#define HF2_CMD_START_FLASH 0x0005\n// no arguments, no result\n\n#define HF2_CMD_WRITE_FLASH_PAGE 0x0006\nstruct HF2_WRITE_FLASH_PAGE_Command {\n    uint32_t target_addr;\n    uint32_t data[0];\n};\n// no result\n\n#define HF2_CMD_CHKSUM_PAGES 0x0007\nstruct HF2_CHKSUM_PAGES_Command {\n    uint32_t target_addr;\n    uint32_t num_pages;\n};\nstruct HF2_CHKSUM_PAGES_Result {\n    uint16_t chksums[0 /* num_pages */];\n};\n\n#define HF2_CMD_READ_WORDS 0x0008\nstruct HF2_READ_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n};\nstruct HF2_READ_WORDS_Result {\n    uint32_t words[0 /* num_words */];\n};\n\n#define HF2_CMD_WRITE_WORDS 0x0009\nstruct HF2_WRITE_WORDS_Command {\n    uint32_t target_addr;\n    uint32_t num_words;\n    uint32_t words[0 /* num_words */];\n};\n// no result\n\n#define HF2_CMD_DMESG 0x0010\n// no arguments\n// results is utf8 character array\n\n#define HF2_EV_MASK 0x800000\n\n#define HF2_CMD_JDS_CONFIG 0x0020\n#define HF2_CMD_JDS_SEND 0x0021\n#define HF2_EV_JDS_PACKET 0x800020\n\ntypedef struct {\n    uint32_t command_id;\n    uint16_t tag;\n    uint8_t reserved0;\n    uint8_t reserved1;\n\n    union {\n        struct HF2_WRITE_FLASH_PAGE_Command write_flash_page;\n        struct HF2_WRITE_WORDS_Command write_words;\n        struct HF2_READ_WORDS_Command read_words;\n        struct HF2_CHKSUM_PAGES_Command chksum_pages;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Command;\n\ntypedef struct {\n    union {\n        uint32_t eventId;\n        struct {\n            uint16_t tag;\n            union {\n                struct {\n                    uint8_t status;\n                    uint8_t status_info;\n                };\n                uint16_t status16;\n            };\n        };\n    };\n    union {\n        struct HF2_BININFO_Result bininfo;\n        uint8_t data8[0];\n        uint16_t data16[0];\n        uint32_t data32[0];\n    };\n} HF2_Response;\n\n#define HF2_FLAG_SERIAL_OUT 0x80\n#define HF2_FLAG_SERIAL_ERR 0xC0\n#define HF2_FLAG_CMDPKT_LAST 0x40\n#define HF2_FLAG_CMDPKT_BODY 0x00\n#define HF2_FLAG_MASK 0xC0\n#define HF2_SIZE_MASK 63\n\n#define HF2_STATUS_OK 0x00\n#define HF2_STATUS_INVALID_CMD 0x01\n#define HF2_STATUS_INVALID_STATE 0x02\n\n#endif\n",
            "usb.cpp": "#include \"pxt.h\"\n\n#if CONFIG_ENABLED(DEVICE_USB)\n#include \"uf2format.h\"\n\nnamespace pxt {\nCodalUSB usb;\n\n// share the buffer; we will crash anyway if someone talks to us over both at the same time\nHF2_Buffer hf2buf;\nHF2 hf2(hf2buf);\n#ifdef HF2_HID\nHF2 hf2hid(hf2buf);\n#endif\nDummyIface dummyIface;\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\nUSBHIDMouse mouse;\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\nUSBHIDKeyboard keyboard;\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\nUSBHIDJoystick joystick;\n#endif\n\nstatic const DeviceDescriptor device_desc = {\n    0x12,   // bLength\n    0x01,   // bDescriptorType\n    0x0210, // bcdUSBL\n\n    // Class etc specified per-interface\n    0x00, 0x00, 0x00,\n\n    0x40, // bMaxPacketSize0\n    USB_DEFAULT_VID, USB_DEFAULT_PID,\n    0x4202, // bcdDevice - leave unchanged for the HF2 to work\n    0x01,   // iManufacturer\n    0x02,   // iProduct\n    0x03,   // SerialNumber\n    0x01    // bNumConfigs\n};\n\nstatic void start_usb() {\n    // start USB with a delay, so that user code can add new interfaces if needed\n    // (eg USB HID keyboard, or MSC)\n    fiber_sleep(500);\n    usb.start();\n}\n\nvoid platform_usb_init() __attribute__((weak));\nvoid platform_usb_init() {}\n\nvoid set_usb_strings(const char *uf2_info) {\n    static const char *string_descriptors[3];\n    static char serial[12];\n    itoa(target_get_serial() & 0x7fffffff, serial);\n\n    auto model = strstr(uf2_info, \"Model: \");\n    if (model) {\n        model += 7;\n        auto end = model;\n        while (*end && *end != '\\n' && *end != '\\r')\n            end++;\n        auto len = end - model;\n        auto dev = (char *)app_alloc(len + 10);\n        memcpy(dev, model, len);\n        strcpy(dev + len, \" (app)\");\n        // try to split into manufacturer and\n        auto sep = strstr(dev, \" / \");\n        if (sep) {\n            *sep = '\\0';\n            string_descriptors[0] = dev;\n            string_descriptors[1] = sep + 3;\n        } else {\n            string_descriptors[0] = dev;\n            string_descriptors[1] = dev;\n        }\n    }\n\n    string_descriptors[2] = serial;\n    usb.stringDescriptors = string_descriptors;\n}\n\nvoid usb_init() {\n    usb.deviceDescriptor = &device_desc;\n    set_usb_strings(UF2_INFO_TXT);\n\n    platform_usb_init();\n\n    usb.add(hf2);\n\n#ifdef HF2_HID\n    hf2hid.useHID = true;\n    usb.add(hf2hid);\n#else\n    // the WINUSB descriptors don't seem to work if there's only one interface\n    // so we add a dummy interface\n    usb.add(dummyIface);\n#endif\n\n\n#if CONFIG_ENABLED(DEVICE_MOUSE)\n    usb.add(mouse);\n#endif\n#if CONFIG_ENABLED(DEVICE_KEYBOARD)\n    usb.add(keyboard);\n#endif\n#if CONFIG_ENABLED(DEVICE_JOYSTICK)\n    usb.add(joystick);\n#endif\n\n    create_fiber(start_usb);\n}\n\n} // namespace pxt\n\n#else\nnamespace pxt {\nvoid usb_init() {}\n} // namespace pxt\n#endif\n\nnamespace control {\n/**\n * Determines if the USB has been enumerated.\n */\n//%\nbool isUSBInitialized() {\n#if CONFIG_ENABLED(DEVICE_USB)\n    return pxt::usb.isInitialised();\n#else\n    return false;\n#endif\n}\n}\n\nnamespace pxt {\nstatic void (*pSendToUART)(const char *data, int len) = NULL;\nvoid setSendToUART(void (*f)(const char *, int)) {\n    pSendToUART = f;\n}\n\nvoid sendSerial(const char *data, int len) {\n#if CONFIG_ENABLED(DEVICE_USB)\n    hf2.sendSerial(data, len);\n#if HF2_HID\n    hf2hid.sendSerial(data, len);\n#endif\n#endif\n    if (pSendToUART)\n        pSendToUART(data, len);\n}\n\nvoid dumpDmesg() {\n    sendSerial(\"\\nDMESG:\\n\", 8);\n    sendSerial(codalLogStore.buffer, codalLogStore.ptr);\n    sendSerial(\"\\n\\n\", 2);\n}\n\nvoid (*logJDFrame)(const uint8_t *data);\nvoid (*sendJDFrame)(const uint8_t *data);\n\n} // namespace pxt\n"
        },
        "settings": {
            "Flash.h": "#ifndef CODAL_FLASH_H\n#define CODAL_FLASH_H\n\n#include \"CodalDevice.h\"\n\nnamespace codal {\nclass Flash {\n  public:\n    /**\n     * Return page size in bytes at given address (doesn't have to be page-aligned).\n     */\n    virtual int pageSize(uintptr_t address) = 0;\n\n    /**\n     * Erase page at given page-aligned address.\n     */\n    virtual int erasePage(uintptr_t address) = 0;\n\n    /**\n     * Write given number of bytes within one page. Flash has to be erased first.\n     */\n    virtual int writeBytes(uintptr_t dst, const void *src, uint32_t len) = 0;\n\n    /**\n     * Return the total size of flash.\n     */\n    virtual int totalSize();\n};\n\nclass ZFlash : public Flash {\n  public:\n    virtual int pageSize(uintptr_t address);\n    virtual int totalSize();\n    virtual int erasePage(uintptr_t address);\n    virtual int writeBytes(uintptr_t dst, const void *src, uint32_t len);\n};\n\n#define CODAL_FLASH codal::ZFlash\n#define DEVICE_FLASH_ERROR 922\n\n\n} // namespace codal\n\n#endif\n",
            "NRF52Flash.cpp": "#include \"pxt.h\"\n#include \"Flash.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\n#if defined(NRF52_SERIES)\nnamespace codal {\n\n#define waitForLast() while ((NRF_NVMC->READY & NVMC_READY_READY_Msk) == 0);\n\nint ZFlash::pageSize(uintptr_t address) {\n    (void)address;\n#if defined(FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk)\n    return NRF_FICR->INFO.CODEPAGESIZE;\n#else\n    return NRF_FICR->CODEPAGESIZE;\n#endif\n}\n\nint ZFlash::totalSize() {\n#if defined(FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk)\n    return NRF_FICR->INFO.CODESIZE * pageSize(0);\n#else\n    return NRF_FICR->CODESIZE * pageSize(0);\n#endif\n}\n\nint ZFlash::erasePage(uintptr_t address) {\n    if (address & (pageSize(address) - 1))\n        target_panic(DEVICE_FLASH_ERROR);\n\n    NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Een;\n    waitForLast();\n    NRF_NVMC->ERASEPAGE = address;\n    waitForLast();\n    NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren;\n    waitForLast();\n\n    return 0;\n}\n\nint ZFlash::writeBytes(uintptr_t dst, const void *src, uint32_t len) {\n    LOG(\"WR flash at %p len=%d\", (void *)dst, len);\n\n    if ((dst & 3) || ((uintptr_t)src & 3) || (len & 3))\n        return -1;\n\n    for (unsigned i = 0; i < len; ++i)\n        if (((uint8_t *)dst)[i] != 0xff && ((uint8_t *)src)[i] != 0xff)\n            return -3;\n\n    \n    volatile uint32_t *sp = (uint32_t *)src;\n    volatile uint32_t *dp = (uint32_t *)dst;\n\n    len >>= 2;\n\n    NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen;\n    waitForLast();\n\n    while (len-- > 0) {\n        uint32_t v = *sp++;\n        if (v != 0xffffffff) {\n            *dp++ = v;\n            waitForLast();\n        } else {\n            dp++;\n        }\n    }\n    \n    NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren;\n    waitForLast();\n\n    LOG(\"WR flash OK\");\n\n    return 0;\n}\n} // namespace codal\n#endif\n",
            "RAFFS.cpp": "#include \"RAFFS.h\"\n#include \"CodalDmesg.h\"\n#include \"NotifyEvents.h\"\n#include \"MessageBus.h\"\n#include \"Timer.h\"\n#include \"pxtbase.h\"\n\n#include <stddef.h>\n\n#define RAFFS_MAGIC 0x7776e0da\n#define M1 0xffffffffU\n\n#define CHECK\n//#undef CHECK\n\nusing namespace codal;\n\n#define oops() target_panic(DEVICE_FLASH_ERROR)\n\n#define OFF2(v, basePtr) (uint32_t)((uint8_t *)v - (uint8_t *)basePtr)\n#define OFF(v) OFF2(v, basePtr)\n\n#define REAL_OFF(dst) (OFF(dst) <= OFF2(dst, altBasePtr()) ? OFF(dst) : OFF2(dst, altBasePtr()))\n\n#undef NOLOG\n#define NOLOG(...) ((void)0)\n#ifndef RAFFS_TEST\n#define LOG DMESG\n#define LOGV NOLOG\n#endif\n\n#define LOGVV NOLOG\n\n#if 0\n#undef LOGV\n#define LOGV DMESG\n#endif\n\n#if 0\n#undef LOGVV\n#define LOGVV DMESG\n#endif\n\nusing namespace pxt::raffs;\n\nstatic uint16_t raffs_unlocked_event;\n\nstruct FSHeader {\n    uint32_t magic;\n    uint32_t bytes;\n    uint32_t numgc;\n    uint32_t reserved;\n};\n\nstatic uint16_t fnhash(const char *fn) {\n    uint32_t h = hash_fnv1(fn, strlen(fn));\n    return h ^ (h >> 16);\n}\n\nFS::FS(Flash &flash, uintptr_t baseAddr, uint32_t bytes)\n    : flash(flash), baseAddr(baseAddr), bytes(bytes) {\n    locked = false;\n\n    basePtr = NULL;\n    endPtr = NULL;\n    freeDataPtr = NULL;\n    metaPtr = NULL;\n    readDirPtr = NULL;\n    cachedMeta = NULL;\n    flashBufAddr = 0;\n    blocked = NULL;\n    gcHorizon = -10000000;\n    minGCSpacing = 0;\n\n    if (bytes > 0x20000)\n        oops();\n\n    auto page = flash.pageSize(baseAddr);\n    // baseAddr and bytes needs to page-aligned, and we need even number of pages\n    auto numPages = bytes / page;\n    if ((baseAddr & (page - 1)) || bytes % page || numPages < 2 || (numPages & 1))\n        oops();\n\n    if (!raffs_unlocked_event)\n        raffs_unlocked_event = codal::allocateNotifyEvent();\n}\n\nvoid FS::erasePages(uintptr_t addr, uint32_t len) {\n    auto end = addr + len;\n    auto page = flash.pageSize(addr);\n    if (addr & (page - 1))\n        oops();\n    while (addr < end) {\n        if (flash.pageSize(addr) != page)\n            oops();\n        flash.erasePage(addr);\n#ifdef CHECK\n        for (int i = 0; i < page; ++i)\n            if (((uint8_t *)addr)[i] != 0xff)\n                oops();\n#endif\n        addr += page;\n    }\n}\n\nvoid FS::oopsAndClear() {\n    erasePages(baseAddr, bytes);\n    oops();\n}\n\nvoid FS::flushFlash() {\n    if (flashBufAddr) {\n        int r = flash.writeBytes(flashBufAddr, flashBuf, sizeof(flashBuf));\n        if (r)\n            oopsAndClear();\n#ifdef CHECK\n        for (unsigned i = 0; i < sizeof(flashBuf); ++i)\n            if (flashBuf[i] != 0xff && flashBuf[i] != ((uint8_t *)flashBufAddr)[i])\n                oopsAndClear();\n#endif\n        flashBufAddr = 0;\n    }\n}\n\nvoid FS::writeBytes(void *dst, const void *src, uint32_t size) {\n    LOGVV(\"write %x%s %d %x:%x:%x:%x\", REAL_OFF(dst), OFF(dst) == REAL_OFF(dst) ? \"\" : \"*\", size,\n          ((const uint8_t *)src)[0], ((const uint8_t *)src)[1], ((const uint8_t *)src)[2],\n          ((const uint8_t *)src)[3]);\n\n    while (size > 0) {\n        uint32_t off = (uintptr_t)dst & (sizeof(flashBuf) - 1);\n        uintptr_t newaddr = (uintptr_t)dst - off;\n        if (newaddr != flashBufAddr) {\n            flushFlash();\n            memset(flashBuf, 0xff, sizeof(flashBuf));\n            flashBufAddr = newaddr;\n        }\n\n        unsigned n = sizeof(flashBuf) - off;\n        if (n > size)\n            n = size;\n        memcpy(flashBuf + off, src, n);\n        size -= n;\n        src = (const uint8_t *)src + n;\n        dst = (uint8_t *)dst + n;\n    }\n}\n\n#define IS_VALID(hd) ((hd)->magic == RAFFS_MAGIC && (hd)->bytes == bytes)\n\nvoid FS::format() {\n    cachedMeta = NULL;\n    readDirPtr = NULL;\n    clearBlocked();\n\n    LOG(\"formatting...\");\n\n    FSHeader hd;\n    hd.reserved = M1;\n    hd.numgc = 1;\n\n    // in case the secondary header is valid, copy #gc\n    auto hd2 = (FSHeader *)(baseAddr + bytes / 2);\n    if (IS_VALID(hd2)) {\n        hd.numgc = hd2->numgc + 1;\n    }\n\n    // write the primary header\n    erasePages(baseAddr, bytes / 2);\n    hd.magic = RAFFS_MAGIC;\n    hd.bytes = bytes;\n    writeBytes((void *)baseAddr, &hd, sizeof(hd));\n\n    flushFlash();\n}\n\n#define NUMBLOCKED (int)(sizeof(blocked->fnptrs) / sizeof(uint16_t))\n\nbool FS::checkBlocked(MetaEntry *m) {\n    auto fnptr = m->fnptr;\n    for (auto p = blocked; p; p = p->next) {\n        for (int i = 0; i < NUMBLOCKED; ++i)\n            if (p->fnptrs[i] == fnptr) {\n                if (m->isFirst())\n                    p->fnptrs[i] = 0;\n                return true;\n            }\n    }\n    if (!m->isFirst()) {\n        for (auto p = blocked; p; p = p->next) {\n            for (int i = 0; i < NUMBLOCKED; ++i)\n                if (p->fnptrs[i] == 0) {\n                    p->fnptrs[i] = fnptr;\n                    return false;\n                }\n        }\n        auto p = new BlockedEntries;\n        memset(p, 0, sizeof(*p));\n        p->next = blocked;\n        blocked = p;\n        p->fnptrs[0] = fnptr;\n    }\n    return false;\n}\n\nvoid FS::clearBlocked() {\n    while (blocked) {\n        auto p = blocked;\n        blocked = p->next;\n        delete p;\n    }\n}\n\nbool FS::tryMount() {\n    if (basePtr)\n        return true;\n\n    auto hd0 = (FSHeader *)baseAddr;\n    auto hd1 = (FSHeader *)(baseAddr + bytes / 2);\n\n    auto v0 = IS_VALID(hd0);\n    auto v1 = IS_VALID(hd1);\n\n    if (v0 && v1) {\n        // we account for overflows\n        // they should not occur in normal operation though\n        if (hd0->numgc + 1 == hd1->numgc)\n            v0 = false;\n        else if (hd1->numgc + 1 == hd0->numgc || hd1->numgc < hd0->numgc)\n            v1 = false;\n        else\n            v0 = false;\n    }\n\n    uintptr_t addr;\n\n    if (v0)\n        addr = baseAddr;\n    else if (v1)\n        addr = baseAddr + bytes / 2;\n    else\n        return false;\n\n    basePtr = (uint8_t *)addr;\n    endPtr = (MetaEntry *)(addr + bytes / 2);\n\n    auto p = (uint32_t *)endPtr - 2;\n    while (*p != M1)\n        p -= 2;\n    metaPtr = (MetaEntry *)(p + 2);\n\n    p = (uint32_t *)metaPtr - 1;\n    while (*p == M1)\n        p--;\n    freeDataPtr = (uint8_t *)RAFFS_ROUND(p + 1);\n\n    auto fp = (uint32_t *)freeDataPtr;\n    if (fp[0] != M1 || fp[1] != M1)\n        oopsAndClear();\n\n    LOG(\"mounted, end=%x meta=%x free=%x\", OFF(endPtr), OFF(metaPtr), OFF(freeDataPtr));\n\n    return true;\n}\n\nvoid FS::mount() {\n    // if (basePtr) return;\n    if (tryMount())\n        return;\n    format();\n    if (!tryMount())\n        oopsAndClear();\n}\n\nFS::~FS() {}\n\nint FS::write(const char *keyName, const void *data, uint32_t bytes) {\n    auto isDel = data == NULL && bytes == M1;\n    if (!isDel && !data && bytes)\n        oops();\n\n    if (isDel)\n        LOGV(\"del: %s\", keyName);\n    else\n        LOGV(\"write: %s sz=%d\", keyName, bytes);\n\n    lock();\n    uint32_t szneeded = bytes;\n    auto existing = findMetaEntry(keyName);\n    auto prevBase = basePtr;\n\n    cachedMeta = NULL;\n\n    if (!existing) {\n        if (isDel) {\n            unlock();\n            return -1;\n        }\n        szneeded += strlen(keyName) + 1;\n    }\n\n    if (!tryGC(sizeof(MetaEntry) + RAFFS_ROUND(szneeded))) {\n        unlock();\n        return -1;\n    }\n\n    // if the GC happened, find the relocated meta entry\n    if (prevBase != basePtr)\n        existing = findMetaEntry(keyName);\n\n    MetaEntry newMeta;\n    if (existing) {\n        newMeta.fnhash = existing->fnhash;\n        newMeta.fnptr = existing->fnptr;\n    } else {\n        newMeta.fnhash = fnhash(keyName);\n        newMeta.fnptr = writeData(keyName, strlen(keyName) + 1);\n    }\n    newMeta.dataptr = isDel ? 0 : writeData(data, bytes);\n    newMeta._datasize = bytes;\n    if (existing)\n        newMeta._datasize |= RAFFS_FOLLOWING_MASK;\n    finishWrite();\n\n    writeBytes(--metaPtr, &newMeta, sizeof(newMeta));\n    flushFlash();\n\n    unlock();\n    return 0;\n}\n\nint FS::read(const char *keyName, void *data, uint32_t bytes) {\n    lock();\n    int r = -1;\n    MetaEntry *meta;\n    if (keyName) {\n        cachedMeta = meta = findMetaEntry(keyName);\n    } else {\n        meta = cachedMeta;\n    }\n    if (meta != NULL && meta->dataptr) {\n        r = meta->datasize();\n        if (data) {\n            if (bytes > (unsigned)r)\n                bytes = r;\n            memcpy(data, basePtr + meta->dataptr, bytes);\n        }\n    }\n    unlock();\n    return r;\n}\n\nint FS::remove(const char *keyName) {\n    return write(keyName, NULL, M1);\n}\n\nvoid FS::lock() {\n    while (locked)\n        fiber_wait_for_event(DEVICE_ID_NOTIFY, raffs_unlocked_event);\n    locked = true;\n    mount();\n}\n\nvoid FS::unlock() {\n    if (!locked)\n        oops();\n    flushFlash();\n    locked = false;\n#ifndef RAFFS_TEST\n    Event(DEVICE_ID_NOTIFY, raffs_unlocked_event);\n#endif\n}\n\nMetaEntry *FS::findMetaEntry(const char *filename) {\n    uint16_t h = fnhash(filename);\n    uint16_t buflen = strlen(filename) + 1;\n\n    for (auto p = metaPtr; p < endPtr; p++) {\n        // LOGV(\"check at %x %x %x\", OFF(p),p->fnhash,h);\n        if (p->fnhash == h && memcmp(fnptr(p), filename, buflen) == 0)\n            return p;\n    }\n\n    // LOGV(\"fail\");\n\n    return NULL;\n}\n\nvoid FS::forceGC(filename_filter filter) {\n    lock();\n    tryGC(0x7fff0000, filter);\n    unlock();\n}\n\nbool FS::tryGC(int spaceNeeded, filename_filter filter) {\n    int spaceLeft = (intptr_t)metaPtr - (intptr_t)freeDataPtr;\n\n#ifdef RAFFS_TEST\n    for (auto p = (uint32_t *)freeDataPtr; p < (uint32_t *)metaPtr; p++) {\n        if (*p != M1) {\n            LOG(\"value at %x = %x\", OFF(p), *p);\n            oopsAndClear();\n        }\n    }\n#endif\n\n    if (spaceLeft > spaceNeeded + 32)\n        return true;\n    \n    int now = (int)system_timer_current_time();\n    if (minGCSpacing) {\n        gcHorizon += minGCSpacing;\n        int nextGC = now - minGCSpacing * 2;\n        // LOG(\"now=%d n=%d gch=%d\", now, nextGC, gcHorizon);\n        if (nextGC > gcHorizon)\n            gcHorizon = nextGC;\n        if (gcHorizon > now)\n            target_panic(921);\n    }\n\n    LOG(\"running flash FS GC; needed %d, left %d\", spaceNeeded, spaceLeft);\n\n    readDirPtr = NULL;\n    cachedMeta = NULL;\n\n    auto newBase = (uintptr_t)altBasePtr();\n\n    flushFlash();\n\n    erasePages(newBase, bytes / 2);\n\n    auto metaDst = (MetaEntry *)(newBase + bytes / 2);\n    auto newBaseP = (uint8_t *)newBase;\n    freeDataPtr = newBaseP + sizeof(FSHeader);\n\n    for (int iter = 0; iter < 2; ++iter) {\n        clearBlocked();\n        auto offset = sizeof(FSHeader);\n        for (auto p = metaPtr; p < endPtr; p++) {\n            MetaEntry m = *p;\n            const char *fn = fnptr(&m);\n\n            if (filter && !filter(fn))\n                continue;\n\n            if (checkBlocked(&m) || m.dataptr == 0)\n                continue;\n\n            LOGV(\"GC %s sz=%d @%x\", fn, m.datasize(), m.dataptr);\n            auto fnlen = strlen(fn) + 1;\n            auto sz = fnlen + m.datasize();\n\n            if (iter == 0) {\n                auto fd = freeDataPtr;\n                writeData(fn, fnlen);\n                writeData(basePtr + m.dataptr, m.datasize());\n                if (freeDataPtr - fd != (int)sz)\n                    oops();\n            } else {\n                m.fnptr = offset;\n                m.dataptr = offset + fnlen;\n                m._datasize &= ~RAFFS_FOLLOWING_MASK;\n                writeBytes(--metaDst, &m, sizeof(m));\n            }\n            offset += sz;\n        }\n        if (iter == 0)\n            finishWrite();\n    }\n\n    clearBlocked();\n    flushFlash();\n\n    LOG(\"GC done: %d free\", (int)((intptr_t)metaDst - (intptr_t)freeDataPtr));\n\n    FSHeader hd;\n    hd.magic = RAFFS_MAGIC;\n    hd.bytes = bytes;\n    hd.numgc = ((FSHeader*)basePtr)->numgc + 1;\n    hd.reserved = M1;\n    writeBytes(newBaseP, &hd, sizeof(hd));\n    flushFlash();\n\n    basePtr = newBaseP;\n    endPtr = (MetaEntry *)(newBase + bytes / 2);\n    metaPtr = metaDst;\n\n    if ((intptr_t)metaDst - (intptr_t)freeDataPtr <= spaceNeeded + 64) {\n        if (filter != NULL && spaceNeeded != 0x7fff0000) {\n            LOG(\"out of space! needed=%d\", spaceNeeded);\n#ifdef RAFFS_TEST\n            oops();\n#endif\n        }\n        return false;\n    }\n\n    return true;\n}\n\nDirEntry *FS::dirRead() {\n    lock();\n\n    if (readDirPtr == NULL) {\n        readDirPtr = metaPtr;\n        clearBlocked();\n    }\n\n    while (readDirPtr < endPtr) {\n        auto m = *readDirPtr++;\n        if (checkBlocked(&m) || m.dataptr == 0)\n            continue;\n        dirEnt.size = m.datasize();\n        dirEnt.flags = 0;\n        dirEnt.name = fnptr(&m);\n        unlock();\n        return &dirEnt;\n    }\n\n    readDirPtr = NULL;\n    clearBlocked();\n    unlock();\n    return NULL;\n}\n\nuint16_t FS::writeData(const void *data, uint32_t len) {\n    LOGVV(\"writeData: @%x %x:%x sz=%d\", REAL_OFF(freeDataPtr), ((const uint8_t *)data)[0],\n          ((const uint8_t *)data)[1], len);\n    writeBytes(freeDataPtr, data, len);\n    auto r = freeDataPtr - basePtr;\n    freeDataPtr += len;\n    return r;\n}\n\nvoid FS::finishWrite() {\n    auto nfp = RAFFS_ROUND(freeDataPtr);\n    int tailSz = nfp - (uintptr_t)freeDataPtr;\n    uint64_t z = 0;\n    if (tailSz) {\n        writeData(&z, tailSz);\n    } else {\n        if (((uint32_t *)nfp)[-1] == M1)\n            writeData(&z, 8);\n    }\n    flushFlash();\n}\n\nint FS::readFlashBytes(uintptr_t addr, void *buffer, uint32_t len) {\n    lock();\n    memcpy(buffer, (void *)addr, len);\n    unlock();\n    return len;\n}\n\n#ifdef RAFFS_TEST\nvoid FS::dump() {}\n\nvoid FS::debugDump() {\n    // dump();\n}\n#endif",
            "RAFFS.h": "#ifndef CODAL_RAFFS_H\n#define CODAL_RAFFS_H\n\n#include \"Flash.h\"\n\nnamespace pxt {\nnamespace raffs {\n\nstruct DirEntry {\n    uint32_t size;\n    uint16_t flags;\n    const char *name;\n};\n\nstruct BlockedEntries {\n    BlockedEntries *next;\n    uint16_t fnptrs[32];\n};\n\n#define RAFFS_FOLLOWING_MASK 0x8000\n#define RAFFS_FLASH_BUFFER_SIZE 64\n\nstruct MetaEntry {\n    uint16_t fnhash;    // hash of file name\n    uint16_t fnptr;     // offset in bytes; can't be 0xffff\n    uint16_t _datasize; // size in bytes; highest bit is set if this isn't first block\n    uint16_t dataptr;   // offset in bytes; 0x0 - deleted\n\n    uint16_t datasize() { return _datasize & 0x7fff; }\n    bool isFirst() { return (_datasize & RAFFS_FOLLOWING_MASK) == 0; }\n};\n\n#define RAFFS_ROUND(x) ((((uintptr_t)(x) + 7) >> 3) << 3)\n\ntypedef bool (*filename_filter)(const char *);\n\nclass FS {\n    codal::Flash &flash;\n\n    uint8_t *basePtr, *freeDataPtr;\n    MetaEntry *endPtr, *metaPtr, *readDirPtr, *cachedMeta;\n    uintptr_t baseAddr;\n    uint32_t bytes;\n    int32_t gcHorizon;\n    DirEntry dirEnt;\n    uintptr_t flashBufAddr;\n    uint8_t flashBuf[RAFFS_FLASH_BUFFER_SIZE];\n    BlockedEntries *blocked;\n    volatile bool locked;\n\n    void erasePages(uintptr_t addr, uint32_t len);\n    void flushFlash();\n    void writeBytes(void *dst, const void *src, uint32_t size);\n    void mount();\n    void lock();\n    void unlock();\n    MetaEntry *findMetaEntry(const char *filename);\n    bool tryGC(int spaceNeeded, filename_filter filter = NULL);\n\n    bool checkBlocked(MetaEntry *m);\n    void clearBlocked();\n    void oopsAndClear();\n\n    uint16_t writeData(const void *data, uint32_t len);\n    void finishWrite();\n    const char *fnptr(MetaEntry *m) { return (const char *)(basePtr + m->fnptr); }\n\n    uint32_t *altBasePtr() {\n        if ((uintptr_t)basePtr == baseAddr)\n            return (uint32_t *)(baseAddr + bytes / 2);\n        else\n            return (uint32_t *)baseAddr;\n    }\n\n  public:\n    // Minimum time in ms that has to pass between two GCs; we shall panic 920 if GCs happen more often\n    // (avareged over 3x this time).\n    // This is usually set to around 10s (10000), so that if user writes a program that writes to flash in\n    // a loop, it doesn't wear out flash completely.\n    uint16_t minGCSpacing;\n    \n\n    FS(codal::Flash &flash, uintptr_t baseAddr, uint32_t bytes);\n    ~FS();\n\n    // returns 0 for success, negative for error\n    int write(const char *keyName, const void *data, uint32_t bytes);\n    // returns total number of bytes in key's value or -1 when file doesn't exists\n    // if keyName==NULL it will re-use last keyName\n    int read(const char *keyName, void *data, uint32_t bytes);\n    // deletes given key if it exists\n    int remove(const char *keyName);\n\n    void format();\n    bool exists(const char *keyName) { return read(keyName, NULL, 0) >= 0; }\n    uint32_t totalSize() { return bytes / 2; }\n    uint32_t freeSize() { return (uintptr_t)endPtr - (uintptr_t)freeDataPtr; }\n    void forceGC(filename_filter filter = NULL);\n    // this allow raw r/o access; will lock the instance as needed\n    int readFlashBytes(uintptr_t addr, void *buffer, uint32_t len);\n    bool tryMount();\n\n    void dirRewind() { readDirPtr = NULL; }\n    DirEntry *dirRead(); // data is only valid until next call to to any of File or FS function\n\n#ifdef RAFFS_TEST\n    void debugDump();\n    void dump();\n#else\n    void debugDump() {}\n#endif\n};\n\n} // namespace raffs\n} // namespace pxt\n\n#endif\n",
            "README.md": "# Settings store in internal MCU flash\n\nThis packages implements a simple key-value storage, in vein of browser's `localStorage`.\nKeys are strings and values are buffers, but APIs are provided for using strings,\nnumbers and number arrays as values.\n\nKeys with names starting with `#` are _system keys_.\nUser applications should not read or write these directly.\n\nFollowing system keys are used:\n* `#run` - current run number; incremented on each reset; it's also used to seed the\n  random number generator; accessible via `settings.runNumber()`\n* `#volume` - last music volume set explicitly by user using the game menu\n* `#scope` - keeps the name of the program; if the current name of the program\n  doesn't match what is in that key, all non-system keys are cleared;\n  this happens for example when a new game (or rather a game with a new name) \n  is uploaded to a hardware device\n\nThe size of storage is typically limited to 16 kilobytes.\nThis applies in browser and in Arcade devices.\nSmaller MCUs may limit it further (eg., it's 1k on SAMD21 devices).\n\n## Panics 920, 921 and 922\n\nWhen there is no more space to write a key to storage, all non-system keys\nare deleted.\nThen, if more than 25% of space is still occupied (by system keys),\nall keys are deleted.\nFinally, a panic 920 is issued.\nThe user has to reset the device, and hopefully next run will fix things.\n\nAll flash devices have a limited number of erases (at least 10,000),\nbefore they start failing.\nThe settings storage implemented here doesn't erase on every write (typically\nit will erase every hundred writes or so);\nif your program keeps writing in a loop, you will likely\nhit 10,000 erases in about half hour.\n\nFor this reason, if erases happen too often (i.e., you're writing too much),\npanic 921 will be issued.\n\nIf flash memory is found to be inconsistent, panic 922 is issued.\nIn most cases, the entire flash memory is cleared before that, so that\na device reset will hopefully fix things.\n\n## Storage structure\n\nSettings are written using a very simple log file system.\nThe flash is divided in two equal regions.\nOne region is used for writing, and when it fills up, data is compressed\n(garbage collected) into the other region, which is to be used from now\non until next compression\n\nEach region starts with a header, followed by data section containing\nkey names and values.\nData section grows in the positive direction.\nFrom the end of the region, the meta-data section grows in the negative\ndirection.\nMeta-data entries are 8 bytes each and contain hash of key name,\nvalue size, and points to key name and value in the data sections.\nWhen a key value is overwritten, a new meta-data section for it\nis created. When a key is to be found, it is searched for from the most \nrecent meta-data entry.\n",
            "SAMDFlash.cpp": "#include \"pxt.h\"\n#include \"Flash.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\n#if defined(SAMD51) || defined(SAMD21)\nnamespace codal {\n\n#ifdef SAMD51\n#define waitForLast()                                                                              \\\n    while (NVMCTRL->STATUS.bit.READY == 0)                                                         \\\n        ;\n#else\n#define waitForLast()                                                                              \\\n    while (NVMCTRL->INTFLAG.bit.READY == 0)                                                        \\\n        ;\n#endif\n\nstatic void unlock() {\n#ifdef SAMD51\n    // see errata 2.14.1\n    NVMCTRL->CTRLA.bit.CACHEDIS0 = true;\n    NVMCTRL->CTRLA.bit.CACHEDIS1 = true;\n\n    CMCC->CTRL.bit.CEN = 0;\n    while (CMCC->SR.bit.CSTS) {\n    }\n    CMCC->MAINT0.bit.INVALL = 1;\n#endif\n}\n\nstatic void lock() {\n#ifdef SAMD51\n    // re-enable cache\n    NVMCTRL->CTRLA.bit.CACHEDIS0 = false;\n    NVMCTRL->CTRLA.bit.CACHEDIS1 = false;\n\n    // re-enable cortex-m cache - it's a separate one\n    CMCC->CTRL.bit.CEN = 0;\n    while (CMCC->SR.bit.CSTS) {\n    }\n    CMCC->MAINT0.bit.INVALL = 1;\n    CMCC->CTRL.bit.CEN = 1;\n#endif\n}\n\nint ZFlash::totalSize() {\n    return (8 << NVMCTRL->PARAM.bit.PSZ) * NVMCTRL->PARAM.bit.NVMP;\n}\n\n// this returns the size of \"page\" that can be erased (\"row\" in datasheet)\nint ZFlash::pageSize(uintptr_t address) {\n#ifdef SAMD51\n    if (address < (uintptr_t)totalSize())\n        return NVMCTRL_BLOCK_SIZE; // 8k\n#else\n    if (address < (uintptr_t)totalSize())\n        return 256;\n#endif\n    target_panic(DEVICE_FLASH_ERROR);\n    return 0;\n}\n\n#ifdef SAMD51\n#define CMD(D21, D51) NVMCTRL->CTRLB.reg = NVMCTRL_CTRLB_CMDEX_KEY | D51\n#else\n#define CMD(D21, D51) NVMCTRL->CTRLA.reg = NVMCTRL_CTRLA_CMDEX_KEY | D21\n#endif\n\nint ZFlash::erasePage(uintptr_t address) {\n    LOG(\"Erase %x\", address);\n#ifdef SAMD51\n    NVMCTRL->CTRLA.bit.WMODE = NVMCTRL_CTRLA_WMODE_MAN_Val;\n#else\n    NVMCTRL->CTRLB.bit.MANW = 1;\n#endif\n    waitForLast();\n    unlock();\n#ifdef SAMD51\n    NVMCTRL->ADDR.reg = address;\n#else\n    // yeah... /2\n    NVMCTRL->ADDR.reg = address / 2;\n#endif\n    CMD(NVMCTRL_CTRLA_CMD_ER, NVMCTRL_CTRLB_CMD_EB);\n    waitForLast();\n    lock();\n    return 0;\n}\n\n#if 0\n#define CHECK_ECC()                                                                                \\\n    if (NVMCTRL->INTFLAG.bit.ECCSE || NVMCTRL->INTFLAG.bit.ECCDE)                                  \\\n    return -10\n#else\n#define CHECK_ECC() ((void)0)\n#endif\n\nint ZFlash::writeBytes(uintptr_t dst, const void *src, uint32_t len) {\n#ifdef SAMD51\n    CHECK_ECC();\n\n    // only allow writing double word at a time\n    if (len & 7)\n        return -1;\n    if (dst & 7)\n        return -2;\n\n    // every double-word can only be written once, otherwise we get ECC errors\n    // and no, ECC cannot be disabled\n    for (unsigned i = 0; i < (len >> 3); ++i)\n        if (((uint64_t *)dst)[i] != 0xffffffffffffffff &&\n            ((uint64_t *)src)[i] != 0xffffffffffffffff)\n            return -3;\n#define WRITE_SIZE 16\n#else\n    if ((dst & 3) || (len & 3))\n        return -1;\n\n    for (unsigned i = 0; i < len; ++i)\n        if (((uint8_t *)dst)[i] != 0xff && ((uint8_t *)src)[i] != 0xff)\n            return -3;\n#define WRITE_SIZE 64\n#endif\n\n    uint32_t writeBuf[WRITE_SIZE >> 2];\n    uint32_t idx = 0;\n\n    waitForLast();\n    unlock();\n    __DMB();\n\n    while (idx < len) {\n        uint32_t off = dst & (WRITE_SIZE - 1);\n        uint32_t n = WRITE_SIZE - off;\n        if (n > len - idx)\n            n = len - idx;\n        uint32_t *sp;\n        volatile uint32_t *dp;\n        if (n != WRITE_SIZE) {\n            memset(writeBuf, 0xff, WRITE_SIZE);\n            memcpy((uint8_t *)writeBuf + off, src, n);\n            sp = writeBuf;\n            dp = (uint32_t *)(dst - off);\n        } else {\n            sp = (uint32_t *)src;\n            dp = (uint32_t *)dst;\n        }\n\n        bool need = false;\n        for (unsigned i = 0; i < (WRITE_SIZE >> 2); ++i)\n            if (sp[i] != 0xffffffff) {\n                need = true;\n                break;\n            }\n\n        if (need) {\n            CMD(NVMCTRL_CTRLA_CMD_PBC, NVMCTRL_CTRLB_CMD_PBC);\n            waitForLast();\n\n            uint32_t q = WRITE_SIZE >> 2;\n\n            target_disable_irq();\n            while (q--) {\n                auto v = *sp++;\n                *dp = v;\n                dp++;\n            }\n\n            CMD(NVMCTRL_CTRLA_CMD_WP, NVMCTRL_CTRLB_CMD_WQW);\n            target_enable_irq();\n            waitForLast();\n        }\n\n        src = (uint8_t *)src + n;\n        dst += n;\n        idx += n;\n    }\n\n    CHECK_ECC();\n\n    lock();\n\n    return 0;\n}\n} // namespace codal\n#endif\n",
            "STM32Flash.cpp": "#include \"pxt.h\"\n#include \"Flash.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\n#ifdef STM32F4\nnamespace codal {\nstatic void waitForLast() {\n    while ((FLASH->SR & FLASH_SR_BSY) == FLASH_SR_BSY)\n        ;\n}\n\nstatic void unlock() {\n    FLASH->CR |= FLASH_CR_LOCK;\n    FLASH->KEYR = FLASH_KEY1;\n    FLASH->KEYR = FLASH_KEY2;\n}\n\nstatic void lock() {\n    FLASH->CR |= FLASH_CR_LOCK;\n}\n\nint ZFlash::pageSize(uintptr_t address) {\n    address |= 0x08000000;\n    if (address < 0x08010000)\n        return 16 * 1024;\n    if (address < 0x08020000)\n        return 64 * 1024;\n    if (address < 0x08100000)\n        return 128 * 1024;\n    target_panic(DEVICE_FLASH_ERROR);\n    return 0;\n}\n\nint ZFlash::totalSize() {\n    return *((uint16_t *)0x1FFF7A22) * 1024;\n}\n\nint ZFlash::erasePage(uintptr_t address) {\n    waitForLast();\n    unlock();\n\n    address |= 0x08000000;\n    uintptr_t ptr = 0x08000000;\n    int sectNum = 0;\n    while (1) {\n        ptr += pageSize(ptr);\n        if (ptr > address)\n            break;\n        sectNum++;\n    }\n\n    FLASH->CR = FLASH_CR_PSIZE_1 | (sectNum << FLASH_CR_SNB_Pos) | FLASH_CR_SER;\n    FLASH->CR |= FLASH_CR_STRT;\n\n    waitForLast();\n\n    FLASH->CR = FLASH_CR_PSIZE_1;\n    lock();\n\n    // cache flushing only required after erase, not programming (3.5.4)\n    __HAL_FLASH_DATA_CACHE_DISABLE();\n    __HAL_FLASH_DATA_CACHE_RESET();\n    __HAL_FLASH_DATA_CACHE_ENABLE();\n\n    // we skip instruction cache, as we're not expecting to erase that\n\n    return 0;\n}\n\nint ZFlash::writeBytes(uintptr_t dst, const void *src, uint32_t len) {\n    LOG(\"WR flash at %p len=%d\", (void *)dst, len);\n\n    if ((dst & 3) || ((uintptr_t)src & 3) || (len & 3))\n        return -1;\n\n    for (unsigned i = 0; i < len; ++i)\n        if (((uint8_t *)dst)[i] != 0xff && ((uint8_t *)src)[i] != 0xff)\n            return -3;\n\n    waitForLast();\n    unlock();\n\n    dst |= 0x08000000;\n\n    FLASH->CR = FLASH_CR_PSIZE_1 | FLASH_CR_PG;\n\n    volatile uint32_t *sp = (uint32_t *)src;\n    volatile uint32_t *dp = (uint32_t *)dst;\n    len >>= 2;\n\n    while (len-- > 0) {\n        uint32_t v = *sp++;\n        if (v != 0xffffffff) {\n            *dp++ = v;\n            waitForLast();\n        } else {\n            dp++;\n        }\n    }\n\n    FLASH->CR = FLASH_CR_PSIZE_1;\n    lock();\n\n    LOG(\"WR flash OK\");\n\n    return 0;\n}\n} // namespace codal\n#endif\n",
            "pxt.json": "{\n    \"name\": \"settings\",\n    \"description\": \"Settings storage in internal flash\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"RAFFS.cpp\",\n        \"RAFFS.h\",\n        \"Flash.h\",\n        \"STM32Flash.cpp\",\n        \"SAMDFlash.cpp\",\n        \"NRF52Flash.cpp\",\n        \"settings.cpp\",\n        \"settings.ts\",\n        \"shims.d.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "settings.cpp": "\n#include \"pxt.h\"\n#include \"RAFFS.h\"\n#include \"GhostFAT.h\"\n\nusing namespace pxt::raffs;\nusing namespace codal;\n\nnamespace settings {\n\n#if defined(SAMD21)\n#define SETTINGS_SIZE (2 * 1024)\n#else\n#define SETTINGS_SIZE (32 * 1024)\n#endif\n\nclass WStorage {\n  public:\n    CODAL_FLASH flash;\n    FS fs;\n    bool isMounted;\n\n    WStorage()\n        : flash(),\n#if defined(STM32F4)\n          fs(flash, 0x8008000, SETTINGS_SIZE),\n#elif defined(SAMD51)\n          fs(flash, 512 * 1024 - SETTINGS_SIZE, SETTINGS_SIZE),\n#elif defined(SAMD21)\n          fs(flash, 256 * 1024 - SETTINGS_SIZE, SETTINGS_SIZE),\n#elif defined(NRF52_SERIES)\n#define NRF_BOOTLOADER_START *(uint32_t *)0x10001014\n          fs(flash,\n             128 * 1024 < NRF_BOOTLOADER_START && NRF_BOOTLOADER_START < (uint32_t)flash.totalSize()\n                 ? NRF_BOOTLOADER_START - SETTINGS_SIZE\n                 : flash.totalSize() - SETTINGS_SIZE,\n             SETTINGS_SIZE),\n#else\n          fs(flash),\n#endif\n          isMounted(false) {\n        fs.minGCSpacing = 10000;\n    }\n};\nSINGLETON(WStorage);\n\nstatic WStorage *mountedStorage() {\n    auto s = getWStorage();\n    if (s->fs.tryMount())\n        return s;\n    s->fs.exists(\"foobar\"); // forces mount and possibly format\n    return s;\n}\n\n//%\nint _set(String key, Buffer data) {\n    auto s = mountedStorage();\n    return s->fs.write(key->getUTF8Data(), data->data, data->length);\n}\n\n//%\nint _remove(String key) {\n    auto s = mountedStorage();\n    return s->fs.remove(key->getUTF8Data());\n}\n\n//%\nbool _exists(String key) {\n    auto s = mountedStorage();\n    return s->fs.exists(key->getUTF8Data());\n}\n\n//%\nBuffer _get(String key) {\n    auto s = mountedStorage();\n    auto sz = s->fs.read(key->getUTF8Data(), NULL, 0);\n    if (sz < 0)\n        return NULL;\n    auto ret = mkBuffer(NULL, sz);\n    registerGCObj(ret);\n    s->fs.read(NULL, ret->data, ret->length);\n    unregisterGCObj(ret);\n    return ret;\n}\n\nstatic bool isSystem(const char *fn) {\n    return fn[0] == '#';\n}\n\n//%\nvoid _userClean() {\n    auto s = mountedStorage();\n    DMESG(\"clearing user files\");\n    s->fs.forceGC(isSystem);\n    // if system files take more than 25% of storage size, we reformat\n    // it likely means user code has written some 'system' files\n    if (s->fs.freeSize() < 3 * s->fs.totalSize() / 4) {\n        s->fs.format();\n    }\n}\n\n//%\nRefCollection *_list(String prefix) {\n    auto st = mountedStorage();\n    st->fs.dirRewind();\n    auto res = Array_::mk();\n    registerGCObj(res);\n\n    auto prefData = prefix->getUTF8Data();\n    auto prefLen = prefix->getUTF8Size();\n    auto wantsInternal = prefData[0] == '#';\n\n    for (;;) {\n        auto d = st->fs.dirRead();\n        if (!d)\n            break;\n        if (!wantsInternal && d->name[0] == '#')\n            continue;\n        if (memcmp(d->name, prefData, prefLen) != 0)\n            continue;\n        auto str = mkString(d->name, -1);\n        registerGCObj(str);\n        res->head.push((TValue)str);\n        unregisterGCObj(str);\n    }\n    unregisterGCObj(res);\n    return res;\n}\n\n} // namespace settings\n",
            "settings.ts": "namespace settings {\n    const RUN_KEY = \"#run\";\n    const SCOPE_KEY = \"#scope\";\n    const DEVICE_SECRETS_KEY = \"#secrets\";\n    const SECRETS_KEY = \"__secrets\";\n\n    //% shim=pxt::seedAddRandom\n    declare function seedAddRandom(n: number): void;\n\n    //% shim=settings::_set\n    declare function _set(key: string, data: Buffer): int32;\n\n    //% shim=settings::_remove\n    declare function _remove(key: string): int32;\n\n    //% shim=settings::_exists\n    declare function _exists(key: string): boolean;\n\n    //% shim=settings::_get\n    declare function _get(key: string): Buffer;\n\n    //% shim=settings::_userClean\n    declare function _userClean(): void;\n\n    //% shim=settings::_list\n    declare function _list(prefix: string): string[];\n\n    export function runNumber() {\n        return readNumber(RUN_KEY) || 0\n    }\n\n    function setScope(scope: string) {\n        if (!scope || scope.length > 100)\n            control.panic(922)\n        const currScope = readString(SCOPE_KEY)\n        if (currScope != scope) {\n            _userClean()\n            writeString(SCOPE_KEY, scope)\n        }\n    }\n\n    function initScopes() {\n        const rn = runNumber() + 1\n        writeNumber(RUN_KEY, rn)\n\n        seedAddRandom(control.deviceSerialNumber() & 0x7fffffff)\n        seedAddRandom(rn)\n\n        setScope(control.programName())\n    }\n\n    initScopes()\n\n    /** \n     * Delete all non-system settings.\n     */\n    export function clear(): void {\n        _userClean()\n    }\n\n    /**\n     * Set named setting to a given buffer.\n     */\n    export function writeBuffer(key: string, value: Buffer) {\n        if (_set(key, value)) {\n            // if we're out of space, clear user storage\n            _userClean()\n            // and panic - reset should hopefully recreate needed files\n            control.panic(920)\n        }\n    }\n\n    /**\n     * Set named settings to a given string.\n     */\n    export function writeString(key: string, value: string) {\n        writeBuffer(key, control.createBufferFromUTF8(value))\n    }\n\n    /**\n     * Set named settings to a given number.\n     */\n    export function writeNumber(key: string, value: number) {\n        writeBuffer(key, msgpack.packNumberArray([value]))\n    }\n\n    /**\n     * Set named settings to a given array of numbers.\n     */\n    export function writeNumberArray(key: string, value: number[]) {\n        writeBuffer(key, msgpack.packNumberArray(value))\n    }\n\n    /**\n     * Read named setting as a buffer. Returns undefined when setting not found.\n     */\n    export function readBuffer(key: string) {\n        return _get(key)\n    }\n\n    /**\n     * Read named setting as a string.\n     */\n    export function readString(key: string) {\n        const buf = readBuffer(key)\n        if (!buf)\n            return undefined\n        else\n            return buf.toString()\n    }\n\n    /**\n     * Read named setting as a number.\n     */\n    export function readNumber(key: string) {\n        const buf = readBuffer(key)\n        if (!buf)\n            return undefined\n        else {\n            const nums = msgpack.unpackNumberArray(buf)\n            if (nums && nums.length >= 1)\n                return nums[0]\n            return undefined\n        }\n    }\n\n    /**\n     * Read named setting as a number.\n     */\n    export function readNumberArray(key: string) {\n        const buf = readBuffer(key)\n        if (!buf)\n            return undefined\n        else\n            return msgpack.unpackNumberArray(buf)\n    }\n\n    /**\n     * Return a list of settings starting with a given prefix.\n     */\n    export function list(prefix?: string) {\n        if (!prefix) prefix = \"\"\n        return _list(prefix)\n    }\n\n    /**\n     * Remove named setting.\n     */\n    export function remove(key: string) {\n        _remove(key)\n    }\n\n    /**\n     * Check if a named setting exists.\n     */\n    export function exists(key: string) {\n        return _exists(key)\n    }\n\n    function clone(v: any): any {\n        if (v == null) return null\n        return JSON.parse(JSON.stringify(v))\n    }\n\n    function isKV(v: any) {\n        return !!v && typeof v === \"object\" && !Array.isArray(v)\n    }\n\n    function jsonMergeFrom(trg: any, src: any) {\n        if (!src) return;\n        const keys = Object.keys(src)\n        keys.forEach(k => {\n            const srck = src[k];\n            if (isKV(trg[k]) && isKV(srck))\n                jsonMergeFrom(trg[k], srck);\n            else\n                trg[k] = clone(srck);\n        });\n    }\n\n    //% fixedInstances\n    export class SecretStore {\n        constructor(private key: string) { }\n        \n        setSecret(name: string, value: any) {\n            const secrets = this.readSecrets();\n            secrets[name] = value;\n            writeString(this.key, JSON.stringify(secrets));\n        }\n\n        updateSecret(name: string, value: any) {\n            const secrets = this.readSecrets();\n            const secret = secrets[name];\n            if (secret === undefined)\n                secrets[name] = value; \n            else jsonMergeFrom(secret, value);\n            const v = JSON.stringify(secrets);\n            writeString(this.key, v);\n        }\n\n        readSecret(name: string, ensure: boolean = false): any {\n            const secrets = this.readSecrets();\n            const secret = secrets[name];\n            if (ensure && !secret) {\n                control.dmesg(\"missing secret \" + name);\n                control.panic(control.PXT_PANIC.SETTINGS_SECRET_MISSING);\n            }\n            return secret;\n        }\n\n        clearSecrets() {\n            writeString(this.key, \"{}\");\n        }\n\n        readSecrets(): any {\n            try {\n                const src = readString(this.key) || \"{}\";\n                return JSON.parse(src) || {};\n            } catch {\n                control.dmesg(\"invalid secret format\")\n                return {};\n            }\n        }\n    }\n\n    /**\n     * Secrets shared by any program on the device\n     */\n    //% fixedInstance whenUsed block=\"device secrets\"\n    export const deviceSecrets = new SecretStore(DEVICE_SECRETS_KEY);\n\n    /**\n     * Program secrets\n     */\n    //% fixedInstance whenUsed block=\"program secrets\"\n    export const programSecrets = new SecretStore(SECRETS_KEY);\n}\n",
            "shims.d.ts": "\n"
        },
        "buttons": {
            "README.md": "# buttons\n\nA library to handle 2 buttons A and B.\n",
            "buttons.cpp": "#include \"pxt.h\"\n\n/*\n\nThese button events need CODAL work.\n\n    // % block=\"double click\"\n    DoubleClick = DEVICE_BUTTON_EVT_DOUBLE_CLICK,\n\n    // % block=\"hold\"\n    Hold = DEVICE_BUTTON_EVT_HOLD\n\n*/\n\n/**\n * User interaction on buttons\n */\nenum class ButtonEvent {\n    //% block=\"click\"\n    Click = DEVICE_BUTTON_EVT_CLICK,\n    //% block=\"long click\"\n    LongClick = DEVICE_BUTTON_EVT_LONG_CLICK,\n    //% block=\"up\"\n    Up = DEVICE_BUTTON_EVT_UP,\n    //% block=\"down\"\n    Down = DEVICE_BUTTON_EVT_DOWN\n};\n\nnamespace pxt {\n//%\nButton *getButtonByPin(int pin, int flags) {\n    unsigned highflags = (unsigned)pin >> 16;\n    if (highflags & 0xff)\n        flags = highflags & 0xff;\n\n    pin &= 0xffff;\n\n    auto cpid = DEVICE_ID_FIRST_BUTTON + pin;\n    auto btn = (Button *)lookupComponent(cpid);\n    if (btn == NULL) {\n        auto pull = PullMode::None;\n        if ((flags & 0xf0) == 0x10)\n            pull = PullMode::Down;\n        else if ((flags & 0xf0) == 0x20)\n            pull = PullMode::Up;\n        else if ((flags & 0xf0) == 0x30)\n            pull = PullMode::None;\n        else\n            oops(3);\n        // GCTODO\n        btn = new Button(*lookupPin(pin), cpid, DEVICE_BUTTON_ALL_EVENTS,\n                                 (ButtonPolarity)(flags & 0xf), pull);\n    }\n    return btn;\n}\n\n//%\nButton *getButtonByPinCfg(int key, int flags) {\n    int pin = getConfig(key);\n    if (pin == -1)\n        target_panic(PANIC_NO_SUCH_CONFIG);\n    return getButtonByPin(pin, flags);\n}\n\nMultiButton *getMultiButton(int id, int pinA, int pinB, int flags) {\n    auto btn = (MultiButton *)lookupComponent(id);\n    if (btn == NULL) {\n        auto bA = getButtonByPin(pinA, flags);\n        auto bB = getButtonByPin(pinB, flags);\n        // GCTODO\n        btn = new MultiButton(bA->id, bB->id, id);\n\n        // A user has registered to receive events from the buttonAB multibutton.\n        // Disable click events from being generated by ButtonA and ButtonB, and defer the\n        // control of this to the multibutton handler.\n        //\n        // This way, buttons look independent unless a buttonAB is requested, at which\n        // point button A+B clicks can be correclty handled without breaking\n        // causal ordering.\n        bA->setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);\n        bB->setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);\n        btn->setEventConfiguration(DEVICE_BUTTON_ALL_EVENTS);\n    }\n    return btn;\n}\n\n// This is for A, B, and AB\n//%\nAbstractButton *getButton(int id) {\n    int pa = getConfig(CFG_PIN_BTN_A);\n    int pb = getConfig(CFG_PIN_BTN_B);\n    int flags = getConfig(CFG_DEFAULT_BUTTON_MODE, BUTTON_ACTIVE_LOW_PULL_UP);\n    if (id == 0)\n        return getButtonByPin(pa, flags);\n    else if (id == 1)\n        return getButtonByPin(pb, flags);\n    else if (id == 2)\n        return getMultiButton(DEVICE_ID_BUTTON_AB, pa, pb, flags);\n    else {\n        target_panic(PANIC_INVALID_ARGUMENT);\n        return NULL;\n    }\n}\n\n} // namespace pxt\n\nnamespace DigitalInOutPinMethods {\n\n/**\n * Get the push button (connected to GND) for given pin\n */\n//%\nButton_ pushButton(DigitalInOutPin pin) {\n    return pxt::getButtonByPin(pin->name, BUTTON_ACTIVE_LOW_PULL_UP);\n}\n\n} // namespace DigitalInOutPinMethods\n\n//% noRefCounting fixedInstances\nnamespace ButtonMethods {\n/**\n * Do something when a button (`A`, `B` or both `A` + `B`) is clicked, double clicked, etc...\n * @param button the button that needs to be clicked or used\n * @param event the kind of button gesture that needs to be detected\n * @param body code to run when the event is raised\n */\n//% help=input/button/on-event\n//% blockId=buttonEvent block=\"on %button|%event\"\n//% blockNamespace=input\n//% button.fieldEditor=\"gridpicker\"\n//% button.fieldOptions.width=220\n//% button.fieldOptions.columns=3\n//% weight=96 blockGap=12\n//% trackArgs=0\nvoid onEvent(Button_ button, ButtonEvent ev, Action body) {\n    registerWithDal(button->id, (int)ev, body);\n}\n\n/**\n * Check if a button is pressed or not.\n * @param button the button to query the request\n */\n//% help=input/button/is-pressed\n//% block=\"%button|is pressed\"\n//% blockId=buttonIsPressed\n//% blockNamespace=input\n//% button.fieldEditor=\"gridpicker\"\n//% button.fieldOptions.width=220\n//% button.fieldOptions.columns=3\n//% weight=50 blockGap=8\n//% trackArgs=0\nbool isPressed(Button_ button) {\n    return button->isPressed();\n}\n\n/**\n * See if the button was pressed again since the last time you checked.\n * @param button the button to query the request\n */\n//% help=input/button/was-pressed\n//% block=\"%button|was pressed\"\n//% blockId=buttonWasPressed\n//% blockNamespace=input\n//% button.fieldEditor=\"gridpicker\"\n//% button.fieldOptions.width=220\n//% button.fieldOptions.columns=3\n//% group=\"More\" weight=46 blockGap=8\n//% trackArgs=0\nbool wasPressed(Button_ button) {\n    return button->wasPressed();\n}\n\n/**\n * Gets the component identifier for the button\n */\n//%\nint id(Button_ button) {\n    return button->id;\n}\n\n} // namespace ButtonMethods\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    /**\n     * User interaction on buttons\n     */\n\n    declare const enum ButtonEvent {\n    //% block=\"click\"\n    Click = 3,  // DEVICE_BUTTON_EVT_CLICK\n    //% block=\"long click\"\n    LongClick = 4,  // DEVICE_BUTTON_EVT_LONG_CLICK\n    //% block=\"up\"\n    Up = 2,  // DEVICE_BUTTON_EVT_UP\n    //% block=\"down\"\n    Down = 1,  // DEVICE_BUTTON_EVT_DOWN\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "pxt.json": "{\n    \"name\": \"buttons\",\n    \"description\": \"Button A and B drivers\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"buttons.cpp\",\n        \"shims.d.ts\",\n        \"enums.d.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface DigitalInOutPin {\n    /**\n     * Get the push button (connected to GND) for given pin\n     */\n    //% shim=DigitalInOutPinMethods::pushButton\n    pushButton(): Button;\n}\n\n\n\n    //% noRefCounting fixedInstances\ndeclare interface Button {\n    /**\n     * Do something when a button (`A`, `B` or both `A` + `B`) is clicked, double clicked, etc...\n     * @param button the button that needs to be clicked or used\n     * @param event the kind of button gesture that needs to be detected\n     * @param body code to run when the event is raised\n     */\n    //% help=input/button/on-event\n    //% blockId=buttonEvent block=\"on %button|%event\"\n    //% blockNamespace=input\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.width=220\n    //% button.fieldOptions.columns=3\n    //% weight=96 blockGap=12\n    //% trackArgs=0 shim=ButtonMethods::onEvent\n    onEvent(ev: ButtonEvent, body: () => void): void;\n\n    /**\n     * Check if a button is pressed or not.\n     * @param button the button to query the request\n     */\n    //% help=input/button/is-pressed\n    //% block=\"%button|is pressed\"\n    //% blockId=buttonIsPressed\n    //% blockNamespace=input\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.width=220\n    //% button.fieldOptions.columns=3\n    //% weight=50 blockGap=8\n    //% trackArgs=0 shim=ButtonMethods::isPressed\n    isPressed(): boolean;\n\n    /**\n     * See if the button was pressed again since the last time you checked.\n     * @param button the button to query the request\n     */\n    //% help=input/button/was-pressed\n    //% block=\"%button|was pressed\"\n    //% blockId=buttonWasPressed\n    //% blockNamespace=input\n    //% button.fieldEditor=\"gridpicker\"\n    //% button.fieldOptions.width=220\n    //% button.fieldOptions.columns=3\n    //% group=\"More\" weight=46 blockGap=8\n    //% trackArgs=0 shim=ButtonMethods::wasPressed\n    wasPressed(): boolean;\n\n    /**\n     * Gets the component identifier for the button\n     */\n    //% shim=ButtonMethods::id\n    id(): int32;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "test.ts": ""
        },
        "accelerometer": {
            "README.md": "# accelerometer\n\nThe accelerometer library.\n\n",
            "accelerometer.cpp": "#include \"pxt.h\"\n#include \"axis.h\"\n#include \"Pin.h\"\n#include \"I2C.h\"\n#include \"CoordinateSystem.h\"\n#include \"Accelerometer.h\"\n\nenum class Dimension {\n    //% block=x\n    X = 0,\n    //% block=y\n    Y = 1,\n    //% block=z\n    Z = 2,\n    //% block=strength\n    Strength = 3,\n};\n\nenum class Rotation {\n    //% block=pitch\n    Pitch = 0,\n    //% block=roll\n    Roll = 1,\n};\n\nenum class AcceleratorRange {\n    /**\n     * The accelerator measures forces up to 1 gravity\n     */\n    //%  block=\"1g\"\n    OneG = 1,\n    /**\n     * The accelerator measures forces up to 2 gravity\n     */\n    //%  block=\"2g\"\n    TwoG = 2,\n    /**\n     * The accelerator measures forces up to 4 gravity\n     */\n    //% block=\"4g\"\n    FourG = 4,\n    /**\n     * The accelerator measures forces up to 8 gravity\n     */\n    //% block=\"8g\"\n    EightG = 8\n};\n\nenum class Gesture {\n    /**\n     * Raised when shaken\n     */\n    //% block=shake\n    Shake = ACCELEROMETER_EVT_SHAKE,\n    /**\n     * Raised when the device tilts up\n     */\n    //% block=\"tilt up\"\n    TiltUp = ACCELEROMETER_EVT_TILT_UP,\n    /**\n     * Raised when the device tilts down\n     */\n    //% block=\"tilt down\"\n    TiltDown = ACCELEROMETER_EVT_TILT_DOWN,\n    /**\n     * Raised when the screen is pointing left\n     */\n    //% block=\"tilt left\"\n    TiltLeft = ACCELEROMETER_EVT_TILT_LEFT,\n    /**\n     * Raised when the screen is pointing right\n     */\n    //% block=\"tilt right\"\n    TiltRight = ACCELEROMETER_EVT_TILT_RIGHT,\n    /**\n     * Raised when the screen faces up\n     */\n    //% block=\"face up\"\n    FaceUp = ACCELEROMETER_EVT_FACE_UP,\n    /**\n     * Raised when the screen is pointing up and the board is horizontal\n     */\n    //% block=\"face down\"\n    FaceDown = ACCELEROMETER_EVT_FACE_DOWN,\n    /**\n     * Raised when the board is falling!\n     */\n    //% block=\"free fall\"\n    FreeFall = ACCELEROMETER_EVT_FREEFALL,\n    /**\n     * Raised when a 2G shock is detected\n     */\n    //% block=\"2g (step)\"\n    TwoG = ACCELEROMETER_EVT_2G,\n    /**\n     * Raised when a 3G shock is detected\n     */\n    //% block=\"3g\"\n    ThreeG = ACCELEROMETER_EVT_3G,\n    /**\n     * Raised when a 6G shock is detected\n     */\n    //% block=\"6g\"\n    SixG = ACCELEROMETER_EVT_6G,\n    /**\n     * Raised when a 8G shock is detected\n     */\n    //% block=\"8g\"\n    EightG = ACCELEROMETER_EVT_8G\n};\n\n// defined in accelhw.cpp\nnamespace pxt {\ncodal::Accelerometer *getAccelerometer();\n\nvoid initAccelRandom() {\n    auto acc = getAccelerometer();\n    if (!acc) return;\n\n    for (int i = 0; i < 10; ++i) {\n        acc->requestUpdate();\n        if (acc->getY())\n            break;\n        fiber_sleep(5);\n    }\n    int x = acc->getX(), y = acc->getY(), z = acc->getZ();\n    DMESG(\"random seed from accel %d,%d,%d\", x, y, z);\n    seedAddRandom(x);\n    seedAddRandom(y);\n    seedAddRandom(z);\n}\n\n} // namespace pxt\n\nnamespace input {\n/**\n * Do something when a gesture happens (like shaking the board).\n * @param gesture the type of gesture to track, eg: Gesture.Shake\n * @param body code to run when gesture is raised\n */\n//% help=input/on-gesture\n//% blockId=device_gesture_event block=\"on |%NAME\"\n//% parts=\"accelerometer\"\n//% gesture.fieldEditor=\"gridpicker\"\n//% gesture.fieldOptions.width=220\n//% gesture.fieldOptions.columns=3\n//% weight=92 blockGap=12\nvoid onGesture(Gesture gesture, Action body) {\n    auto acc = getAccelerometer();\n    if (!acc) return;\n\n    acc->requestUpdate();\n    int gi = (int)gesture;\n    if (gi == ACCELEROMETER_EVT_3G && acc->getRange() < 3)\n        acc->setRange(4);\n    else if ((gi == ACCELEROMETER_EVT_6G || gi == ACCELEROMETER_EVT_8G) && acc->getRange() < 6)\n        acc->setRange(8);\n    registerWithDal(DEVICE_ID_GESTURE, gi, body);\n}\n\n/**\n * Get the acceleration value in milli-gravitys (when the board is laying flat with the screen up,\n * x=0, y=0 and z=-1023)\n * @param dimension TODO\n */\n//% help=input/acceleration\n//% blockId=device_acceleration block=\"acceleration (mg)|%NAME\"\n//% parts=\"accelerometer\"\n//% dimension.fieldEditor=\"gridpicker\"\n//% dimension.fieldOptions.width=180\n//% dimension.fieldOptions.columns=2\n//% weight=42 blockGap=8\nint acceleration(Dimension dimension) {\n    auto acc = getAccelerometer();\n    if (!acc) return 0;\n\n    acc->requestUpdate();\n    switch (dimension) {\n    case Dimension::X:\n        return acc->getX();\n    case Dimension::Y:\n        return acc->getY();\n    case Dimension::Z:\n        return acc->getZ();\n    case Dimension::Strength:\n        float x = acc->getX();\n        float y = acc->getY();\n        float z = acc->getZ();\n        return (int)sqrtf(x * x + y * y + z * z);\n    }\n    return 0;\n}\n\n/**\n * The pitch or roll of the device, rotation along the ``x-axis`` or ``y-axis``, in degrees.\n * @param kind TODO\n */\n//% help=input/rotation\n//% blockId=device_get_rotation block=\"rotation ()|%NAME\"\n//% parts=\"accelerometer\"\n//% group=\"More\" weight=38\nint rotation(Rotation kind) {\n    auto acc = getAccelerometer();\n    if (!acc) return 0;\n\n    acc->requestUpdate();\n    switch (kind) {\n    case Rotation::Pitch:\n        return acc->getPitch();\n    case Rotation::Roll:\n        return acc->getRoll();\n    }\n    return 0;\n}\n\n/**\n * Sets the accelerometer sample range in gravities.\n * @param range a value describe the maximum strengh of acceleration measured\n */\n//% help=input/set-accelerometer-range\n//% blockId=device_set_accelerometer_range block=\"set accelerometer|range %range\"\n//% weight=5\n//% parts=\"accelerometer\"\n//% group=\"More\" weight=15 blockGap=8\nvoid setAccelerometerRange(AcceleratorRange range) {\n    auto acc = getAccelerometer();\n    if (!acc) return;\n\n    acc->setRange((int)range);\n}\n\n} // namespace input\n",
            "accelhw.cpp": "// This supports a few different accelerometers.\n// If desired, overrides PXT_SUPPORT_* in platform.h (note that only LIS3DH is on by default).\n// Then accelerometer can be changed with config.ACCELEROMETER_TYPE in TypeScript.\n// This file can be overridden alltogether by a target if a different accelerometer is desired.\n\n#include \"pxt.h\"\n#include \"axis.h\"\n#include \"Pin.h\"\n#include \"I2C.h\"\n#include \"CoordinateSystem.h\"\n#include \"CodalDmesg.h\"\n\n#ifndef PXT_DEFAULT_ACCELEROMETER\n#define PXT_DEFAULT_ACCELEROMETER -1\n#endif\n\n#ifndef PXT_SUPPORT_LIS3DH\n#define PXT_SUPPORT_LIS3DH 1\n#endif\n#if PXT_SUPPORT_LIS3DH\n#include \"LIS3DH.h\"\n#endif\n\n#ifndef PXT_SUPPORT_MMA8653\n#define PXT_SUPPORT_MMA8653 0\n#endif\n#if PXT_SUPPORT_MMA8653\n#include \"MMA8653.h\"\n#endif\n\n#ifndef PXT_SUPPORT_MMA8453\n#define PXT_SUPPORT_MMA8453 0\n#endif\n#if PXT_SUPPORT_MMA8453\n#include \"MMA8453.h\"\n#endif\n\n#ifndef PXT_SUPPORT_FXOS8700\n#define PXT_SUPPORT_FXOS8700 0\n#endif\n#if PXT_SUPPORT_FXOS8700\n#include \"FXOS8700Accelerometer.h\"\n#endif\n\n#ifndef PXT_SUPPORT_MSA300\n#define PXT_SUPPORT_MSA300 0\n#endif\n#if PXT_SUPPORT_MSA300\n#include \"MSA300.h\"\n#endif\n\n#ifndef PXT_SUPPORT_MPU6050\n#define PXT_SUPPORT_MPU6050 0\n#endif\n#if PXT_SUPPORT_MPU6050\n#include \"MPU6050.h\"\n#endif\n\n#if defined(CODAL_ACCELEROMETER)\n#error \"please define PXT_SUPPORT_*\"\n#endif\n\nnamespace pxt {\n\n    /*\nRAW,                            0x000000\nSIMPLE_CARTESIAN,               0x000001\nNORTH_EAST_DOWN,                0x000002\nNORTH_EAST_UP                   0x000003\n\nCOORDINATE_SPACE_ROTATED_0      0x000000\nCOORDINATE_SPACE_ROTATED_90     0x000010\nCOORDINATE_SPACE_ROTATED_180    0x000020\nCOORDINATE_SPACE_ROTATED_270    0x000030\n\nNOT_UPSIDE_DOWN                 0x000000\nUPSIDE_DOWN                     0x000100\n    */\n\nstatic CoordinateSpace boardCoordinateSpace() {\n    int defaultSpace = ((int)ACC_SYSTEM) | ((int)ACC_ROTATION << 4) | (ACC_UPSIDEDOWN ? 0x100 : 0x000);\n#if defined(STM32F4) && PXT_SUPPORT_MPU6050\n    // meowbit\n    if (getConfig(CFG_ACCELEROMETER_TYPE, -1) == ACCELEROMETER_TYPE_MPU6050)\n        defaultSpace = 0x33 | 0x100; // ACC_UPSIDEDOWN\n#endif\n    int space = getConfig(CFG_ACCELEROMETER_SPACE, defaultSpace);\n    DMESG(\"coordinate space: %d / %d, %s\", space & 0xf, (space >> 4) & 0xf, space & 0x100 ? \"upside\" : \"normal\");\n    return CoordinateSpace((CoordinateSystem)(space & 0xf), !!(space & 0x100), (space >> 4) & 0xf);\n}\n\n// Wrapper classes\nclass WAccel {\n    CoordinateSpace space;\n\t\t\n  public:\n    Accelerometer *acc;\n    WAccel() \n    : space(boardCoordinateSpace())\n    , acc(NULL) {\n        DMESG(\"acc: mounting\");\n        auto sda = LOOKUP_PIN(ACCELEROMETER_SDA);\n        auto scl = LOOKUP_PIN(ACCELEROMETER_SCL);\n        if (NULL == sda || NULL == scl) { // use default i2c instead\n            DMESG(\"acc: using SDA, SCL\");\n            sda = LOOKUP_PIN(SDA);\n            scl = LOOKUP_PIN(SCL);\n        }\n        codal::I2C* i2c = pxt::getI2C(sda, scl);\n        if (NULL == i2c) {\n            DMESG(\"acc: no i2c available\");\n            return;\n        }\n\t\t\n        int accType = getConfig(CFG_ACCELEROMETER_TYPE, PXT_DEFAULT_ACCELEROMETER);\n        acc = instantiateAccelerometer(accType, i2c);\n        if (NULL == acc) {\n            int accDetect = detectAccelerometer(i2c);\n            if (accDetect < 0) {\n                DMESG(\"acc: not detected\");\n            } else {\n                DMESG(\"acc: detected %d\", accDetect);\n                acc = instantiateAccelerometer(accDetect, i2c);\n            }\n        }\n\n        if (NULL == acc) {\n            // the accelerometer might be damaged or incorrectly configured,\n            // in doubt, we just ignore it            \n            if (LOOKUP_PIN(ACCELEROMETER_SDA))\n                DMESG(\"acc: damaged accelereomter or invalid ACCELEROMETER_TYPE\");\n            else\n                DMESG(\"acc: invalid ACCELEROMETER_TYPE\");\n            // acc is already NULL, do nothing\n        }\n        else {\n            // acc->init(); - doesn't do anything\n            acc->configure();\n            acc->requestUpdate();\n            DMESG(\"acc: mounted\");\n        }\n    }\n\nprivate:\n\n\tint detectAccelerometer(codal::I2C* i2c){\n\t\tuint8_t data;\n\t\tint result;\n\n#if PXT_SUPPORT_LIS3DH\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_LIS3DH, LIS3DH_WHOAMI, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_LIS3DH;\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_LIS3DH_ALT, LIS3DH_WHOAMI, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_LIS3DH_ALT;\n#endif\n\t\t\t\n#if PXT_SUPPORT_MMA8453\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_MMA8453, MMA8653_WHOAMI/*MMA8453 is similar to MMA8653*/ , &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_MMA8453;\n#endif\n\n#if PXT_SUPPORT_FXOS8700\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_FXOS8700, FXOS8700_WHO_AM_I, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_FXOS8700;\n#endif\n\t\t\n#if PXT_SUPPORT_MMA8653\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_MMA8653,  MMA8653_WHOAMI, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_MMA8653;\t\n#endif\n\t\t\n#if PXT_SUPPORT_MSA300\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_MSA300, MSA300_WHOAMI, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_MSA300;\t\n#endif\n\t\t\t\n#if PXT_SUPPORT_MPU6050\n\t\tresult = i2c->readRegister(ACCELEROMETER_TYPE_MPU6050, MPU6050_WHOAMI, &data, 1);\n\t\tif (result ==0)\n\t\t\treturn ACCELEROMETER_TYPE_MPU6050;\t\n#endif \n\n\t\treturn -1;\n\t}\n\n    codal::Accelerometer* instantiateAccelerometer(int accType, codal::I2C* i2c) {\n        switch (accType) {\n#if PXT_SUPPORT_LIS3DH\n        case ACCELEROMETER_TYPE_LIS3DH:\n        case ACCELEROMETER_TYPE_LIS3DH_ALT:\n            return new LIS3DH(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT), space, accType);\n#endif\n#if PXT_SUPPORT_MSA300\n        case ACCELEROMETER_TYPE_MSA300:\n            return new MSA300(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT), space);\n#endif\n#if PXT_SUPPORT_FXOS8700\n        case ACCELEROMETER_TYPE_FXOS8700: {\n            // TODO: singleton when exposing gyro\n            auto fox = new FXOS8700(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT));\n            return new FXOS8700Accelerometer(*fox, space);\n        }\n#endif\n#if PXT_SUPPORT_MMA8653\n        case ACCELEROMETER_TYPE_MMA8653:\n            return new MMA8653(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT), space);\n#endif\n#if PXT_SUPPORT_MMA8453\n        case ACCELEROMETER_TYPE_MMA8453:\n            return new MMA8453(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT), space);\n#endif\n#if PXT_SUPPORT_MPU6050\n        case ACCELEROMETER_TYPE_MPU6050:\n            return new MPU6050(*i2c, *LOOKUP_PIN(ACCELEROMETER_INT), space);\n#endif\n        default:\n            return NULL;\n        }\n    }\n\n};\n\nSINGLETON_IF_PIN(WAccel, ACCELEROMETER_INT);\n\ncodal::Accelerometer *getAccelerometer() {\n    auto wacc = getWAccel();\n    return wacc ? wacc->acc : NULL;\n}\n\n} // namespace pxt\n",
            "axis.h": "// Override in target to change inversion of axis\r\n\r\n#define ACC_SYSTEM NORTH_EAST_UP\r\n#define ACC_UPSIDEDOWN true\r\n#define ACC_ROTATION COORDINATE_SPACE_ROTATED_0\r\n\r\n/*\r\n                        X  Y  Z\r\nLaying flat:            0  0 -1\r\nStanding normally:      0  1  0\r\nStanding on left side: -1  0  0\r\n*/\r\n\r\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum Dimension {\n    //% block=x\n    X = 0,\n    //% block=y\n    Y = 1,\n    //% block=z\n    Z = 2,\n    //% block=strength\n    Strength = 3,\n    }\n\n\n    declare const enum Rotation {\n    //% block=pitch\n    Pitch = 0,\n    //% block=roll\n    Roll = 1,\n    }\n\n\n    declare const enum AcceleratorRange {\n    /**\n     * The accelerator measures forces up to 1 gravity\n     */\n    //%  block=\"1g\"\n    OneG = 1,\n    /**\n     * The accelerator measures forces up to 2 gravity\n     */\n    //%  block=\"2g\"\n    TwoG = 2,\n    /**\n     * The accelerator measures forces up to 4 gravity\n     */\n    //% block=\"4g\"\n    FourG = 4,\n    /**\n     * The accelerator measures forces up to 8 gravity\n     */\n    //% block=\"8g\"\n    EightG = 8,\n    }\n\n\n    declare const enum Gesture {\n    /**\n     * Raised when shaken\n     */\n    //% block=shake\n    Shake = 11,  // ACCELEROMETER_EVT_SHAKE\n    /**\n     * Raised when the device tilts up\n     */\n    //% block=\"tilt up\"\n    TiltUp = 1,  // ACCELEROMETER_EVT_TILT_UP\n    /**\n     * Raised when the device tilts down\n     */\n    //% block=\"tilt down\"\n    TiltDown = 2,  // ACCELEROMETER_EVT_TILT_DOWN\n    /**\n     * Raised when the screen is pointing left\n     */\n    //% block=\"tilt left\"\n    TiltLeft = 3,  // ACCELEROMETER_EVT_TILT_LEFT\n    /**\n     * Raised when the screen is pointing right\n     */\n    //% block=\"tilt right\"\n    TiltRight = 4,  // ACCELEROMETER_EVT_TILT_RIGHT\n    /**\n     * Raised when the screen faces up\n     */\n    //% block=\"face up\"\n    FaceUp = 5,  // ACCELEROMETER_EVT_FACE_UP\n    /**\n     * Raised when the screen is pointing up and the board is horizontal\n     */\n    //% block=\"face down\"\n    FaceDown = 6,  // ACCELEROMETER_EVT_FACE_DOWN\n    /**\n     * Raised when the board is falling!\n     */\n    //% block=\"free fall\"\n    FreeFall = 7,  // ACCELEROMETER_EVT_FREEFALL\n    /**\n     * Raised when a 2G shock is detected\n     */\n    //% block=\"2g (step)\"\n    TwoG = 12,  // ACCELEROMETER_EVT_2G\n    /**\n     * Raised when a 3G shock is detected\n     */\n    //% block=\"3g\"\n    ThreeG = 8,  // ACCELEROMETER_EVT_3G\n    /**\n     * Raised when a 6G shock is detected\n     */\n    //% block=\"6g\"\n    SixG = 9,  // ACCELEROMETER_EVT_6G\n    /**\n     * Raised when a 8G shock is detected\n     */\n    //% block=\"8g\"\n    EightG = 10,  // ACCELEROMETER_EVT_8G\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "gesture.ts": "namespace input {\n    /**\n     * Registers a custom gesture recognizer\n     * @param id \n     * @param update true if gesture detected\n     * @param handler \n     */\n    export function onCustomGesture(\n        id: number, \n        update: () => boolean, \n        handler: () => void) {\n        if (!update || !handler) return;\n\n        input.acceleration(Dimension.X); // turn on accelerometer\n        const evid = DAL.ACCELEROMETER_EVT_2G + 1 + (id | 0);\n        control.onEvent(DAL.DEVICE_ID_GESTURE, evid, handler);\n        let sigma = 0;\n        control.onIdle(function() {\n            if (sigma > 0) {\n                sigma--;\n            } else if(update()) {\n                sigma = 6;\n                control.raiseEvent(DAL.DEVICE_ID_GESTURE, evid);\n            }\n        })\n    }\n}",
            "ns.ts": "\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}",
            "part.svg": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<svg\n   xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n   xmlns:cc=\"http://creativecommons.org/ns#\"\n   xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n   xmlns:svg=\"http://www.w3.org/2000/svg\"\n   xmlns=\"http://www.w3.org/2000/svg\"\n   xmlns:sodipodi=\"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\"\n   xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\"\n   width=\"92.834999\"\n   height=\"48.351559\"\n   y=\"0\"\n   x=\"0\"\n   viewBox=\"0 0 92.834999 48.351559\"\n   id=\"svg4493\"\n   version=\"1.1\"\n   sodipodi:docname=\"part.svg\"\n   inkscape:version=\"0.92.1 r15371\">\n  <metadata\n     id=\"metadata4514\">\n    <rdf:RDF>\n      <cc:Work\n         rdf:about=\"\">\n        <dc:format>image/svg+xml</dc:format>\n        <dc:type\n           rdf:resource=\"http://purl.org/dc/dcmitype/StillImage\" />\n        <dc:title />\n      </cc:Work>\n    </rdf:RDF>\n  </metadata>\n  <defs\n     id=\"defs4512\" />\n  <sodipodi:namedview\n     pagecolor=\"#ffffff\"\n     bordercolor=\"#666666\"\n     borderopacity=\"1\"\n     objecttolerance=\"10\"\n     gridtolerance=\"10\"\n     guidetolerance=\"10\"\n     inkscape:pageopacity=\"0\"\n     inkscape:pageshadow=\"2\"\n     inkscape:window-width=\"1600\"\n     inkscape:window-height=\"837\"\n     id=\"namedview4510\"\n     showgrid=\"false\"\n     inkscape:zoom=\"8.2495794\"\n     inkscape:cx=\"42.339269\"\n     inkscape:cy=\"33.871495\"\n     inkscape:window-x=\"-8\"\n     inkscape:window-y=\"-8\"\n     inkscape:window-maximized=\"1\"\n     inkscape:current-layer=\"svg4493\"\n     fit-margin-top=\"0\"\n     fit-margin-left=\"0\"\n     fit-margin-right=\"0\"\n     fit-margin-bottom=\"0\"\n     units=\"px\"\n     inkscape:measure-start=\"-5.21239,56.8514\"\n     inkscape:measure-end=\"23.6376,42.184\" />\n  <rect\n     rx=\"1.1604376\"\n     y=\"0.048351564\"\n     height=\"48.254856\"\n     width=\"92.738297\"\n     id=\"rect5038\"\n     x=\"0.048351564\"\n     style=\"fill:#5a86c2;stroke:#8e8e8e;stroke-width:0.09670313\" />\n  <text\n     id=\"text5094\"\n     y=\"40.50362\"\n     x=\"4.5252295\"\n     style=\"font-weight:400;font-size:13.53218174px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.37589398\"\n     font-weight=\"400\"\n     font-size=\"14.4\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\"\n     transform=\"scale(0.99296988,1.0070799)\">\n    <tspan\n       y=\"40.50362\"\n       x=\"4.5252295\"\n       id=\"tspan5092\"\n       style=\"font-size:10.02383709px;stroke-width:0.37589398\">ACCELEROMETER</tspan>\n  </text>\n  <rect\n     rx=\"0.78499681\"\n     y=\"32.338985\"\n     x=\"77.394577\"\n     height=\"10.968015\"\n     width=\"11.303953\"\n     id=\"rect5096\"\n     style=\"stroke:#000000;stroke-width:0.3893353\" />\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.9231954\"\n     cx=\"-9.2452202\"\n     id=\"ACCELEROMETER_INT\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-6\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5\"\n     y=\"-7.1094813\"\n     x=\"10.925499\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       y=\"-7.1094813\"\n       x=\"10.925499\"\n       id=\"tspan5098-2-4\"\n       style=\"stroke-width:0.32272473\">INT</tspan>\n  </text>\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.9231954\"\n     cx=\"-39.334583\"\n     id=\"SDA\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-3\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5-4\"\n     y=\"-37.301361\"\n     x=\"11.108133\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       id=\"tspan5156\"\n       y=\"-37.301361\"\n       x=\"11.108133\"\n       style=\"stroke-width:0.32272473\">SDA</tspan>\n  </text>\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.9231954\"\n     cx=\"-70.055618\"\n     id=\"VCC\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-1\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5-4-9\"\n     y=\"-68.672005\"\n     x=\"11.428495\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       id=\"tspan5156-5\"\n       y=\"-68.672005\"\n       x=\"11.428495\"\n       style=\"stroke-width:0.32272473\">VCC</tspan>\n  </text>\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.9231954\"\n     cx=\"-85.100304\"\n     id=\"GND\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-0\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5-4-9-3\"\n     y=\"-83.929306\"\n     x=\"11.242865\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       id=\"tspan5156-5-7\"\n       y=\"-83.929306\"\n       x=\"11.242865\"\n       style=\"stroke-width:0.32272473\">GND</tspan>\n  </text>\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.9231954\"\n     cx=\"-24.289902\"\n     id=\"SCL\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-6-2\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5-47\"\n     y=\"-22.366781\"\n     x=\"11.108133\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       y=\"-22.366781\"\n       x=\"11.108133\"\n       id=\"tspan5098-2-4-5\"\n       style=\"stroke-width:0.32272473\">SCL</tspan>\n  </text>\n  <ellipse\n     style=\"fill:#ffffff;stroke:#000000;stroke-width:0.32272443\"\n     cy=\"-5.5968285\"\n     cx=\"-54.547421\"\n     id=\"SDO\"\n     transform=\"scale(-1)\"\n     rx=\"3.23646\"\n     ry=\"3.218055\"\n     inkscape:label=\"#path5042-7-3\" />\n  <text\n     transform=\"matrix(0,1.0070833,-0.99296652,0,0,0)\"\n     id=\"text5100-8-5-4-4\"\n     y=\"-52.621964\"\n     x=\"10.784061\"\n     style=\"font-weight:400;font-size:6.13176918px;line-height:1.25;font-family:consolas;-inkscape-font-specification:consolas;letter-spacing:0;word-spacing:0;fill:#ffffff;stroke-width:0.32272473\"\n     font-weight=\"400\"\n     font-size=\"1.9\"\n     letter-spacing=\"0\"\n     word-spacing=\"0\">\n    <tspan\n       id=\"tspan5156-4\"\n       y=\"-52.621964\"\n       x=\"10.784061\"\n       style=\"stroke-width:0.32272473\">SDO</tspan>\n  </text>\n</svg>\n",
            "pxt.json": "{\n    \"name\": \"accelerometer\",\n    \"description\": \"The accelerometer library\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"accelerometer.cpp\",\n        \"accelhw.cpp\",\n        \"axis.h\",\n        \"gesture.ts\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"ns.ts\",\n        \"pxtparts.json\",\n        \"part.svg\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "pxtparts.json": "{\n  \"accelerometer\": {\n    \"visual\": {\n      \"image\": \"part.svg\",\n      \"width\": 92.83499908447266,\n      \"height\": 48.351558685302734,\n      \"pinDistance\": 15,\n      \"pinLocations\": [\n        {\n          \"x\": 6.009125520265597,\n          \"y\": 2.705139350474586\n        },\n        {\n          \"x\": 36.0982164424424,\n          \"y\": 2.705139350474586\n        },\n        {\n          \"x\": 66.81896669097237,\n          \"y\": 2.705139350474586\n        },\n        {\n          \"x\": 81.86351733614008,\n          \"y\": 2.705139350474586\n        },\n        {\n          \"x\": 21.053670981354,\n          \"y\": 2.705139350474586\n        },\n        {\n          \"x\": 51.31091788377569,\n          \"y\": 2.378772674719472\n        }\n      ]\n    },\n    \"numberOfPins\": 6,\n    \"instantiation\": {\n      \"kind\": \"singleton\"\n    },\n    \"pinDefinitions\": [\n      {\n        \"target\": \"ACCELEROMETER_INT\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"SDA\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"ground\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"SCL\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      },\n      {\n        \"target\": \"threeVolt\",\n        \"style\": \"male\",\n        \"orientation\": \"-Z\"\n      }\n    ],\n    \"assembly\": [\n      {\n        \"pinIndices\": [\n          0,\n          1,\n          2,\n          3,\n          4,\n          5\n        ]\n      }\n    ]\n  }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Do something when a gesture happens (like shaking the board).\n     * @param gesture the type of gesture to track, eg: Gesture.Shake\n     * @param body code to run when gesture is raised\n     */\n    //% help=input/on-gesture\n    //% blockId=device_gesture_event block=\"on |%NAME\"\n    //% parts=\"accelerometer\"\n    //% gesture.fieldEditor=\"gridpicker\"\n    //% gesture.fieldOptions.width=220\n    //% gesture.fieldOptions.columns=3\n    //% weight=92 blockGap=12 shim=input::onGesture\n    function onGesture(gesture: Gesture, body: () => void): void;\n\n    /**\n     * Get the acceleration value in milli-gravitys (when the board is laying flat with the screen up,\n     * x=0, y=0 and z=-1023)\n     * @param dimension TODO\n     */\n    //% help=input/acceleration\n    //% blockId=device_acceleration block=\"acceleration (mg)|%NAME\"\n    //% parts=\"accelerometer\"\n    //% dimension.fieldEditor=\"gridpicker\"\n    //% dimension.fieldOptions.width=180\n    //% dimension.fieldOptions.columns=2\n    //% weight=42 blockGap=8 shim=input::acceleration\n    function acceleration(dimension: Dimension): int32;\n\n    /**\n     * The pitch or roll of the device, rotation along the ``x-axis`` or ``y-axis``, in degrees.\n     * @param kind TODO\n     */\n    //% help=input/rotation\n    //% blockId=device_get_rotation block=\"rotation ()|%NAME\"\n    //% parts=\"accelerometer\"\n    //% group=\"More\" weight=38 shim=input::rotation\n    function rotation(kind: Rotation): int32;\n\n    /**\n     * Sets the accelerometer sample range in gravities.\n     * @param range a value describe the maximum strengh of acceleration measured\n     */\n    //% help=input/set-accelerometer-range\n    //% blockId=device_set_accelerometer_range block=\"set accelerometer|range %range\"\n    //% weight=5\n    //% parts=\"accelerometer\"\n    //% group=\"More\" weight=15 blockGap=8 shim=input::setAccelerometerRange\n    function setAccelerometerRange(range: AcceleratorRange): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "test.ts": ""
        },
        "music": {
            "README.md": "# music\n\nThe music library.\n\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum SoundOutputDestination {\n    //% block=\"pin\"\n    Pin = 1,\n    //% block=\"speaker\"\n    Speaker = 0,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "headphone.svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"142\" height=\"180\" viewBox=\"0 0 142 180\"><rect ry=\".3\" rx=\"1\" y=\"58.615\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><rect ry=\".3\" rx=\"1\" y=\"32.043\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><path d=\"M.346 7.296c-.394.39-.31 4.797-.18 4.898l13.404 10.18c.117.12.337 4.76.73 4.368l5.506-5.56.01.01 6.51-6.444c.39-.392-4.25-.614-4.366-.73L11.777.612c-.1-.132-4.51-.215-4.898.18L4.087 3.636l-.01-.01-3.73 3.67z\" fill=\"#b3b3b3\"/><rect ry=\"6.85\" rx=\"4.571\" y=\"84.758\" x=\"-20.128\" height=\"75.571\" width=\"39.643\" transform=\"rotate(-45)\"/><rect ry=\".374\" rx=\"1.038\" y=\"29.442\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"55.939\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"82.392\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\"2.317\" rx=\"2.183\" y=\"158.876\" x=\"-9.774\" height=\"25.568\" width=\"18.935\" transform=\"rotate(-45)\"/><path d=\"M128.588 128.82s14.97 11.165 7.547 26.35c-8.426 17.24-25.57 20.653-25.57 20.653\" fill=\"none\" stroke=\"#000\" stroke-width=\"6.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
            "melodies.ts": "/*\nThe MIT License (MIT)\n\nCopyright (c) 2013-2016 The MicroPython-on-micro:bit Developers, as listed\nin the accompanying AUTHORS file\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n// Melodies from file microbitmusictunes.c https://github.com/bbcmicrobit/MicroPython\n\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren,\n    //% block=\"pew pew\"\n    PewPew\n}\n\nnamespace music {\n    let _soundQueue: control.AnimationQueue;\n\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            case Sounds.PewPew:\n                return '!1200,200^50';\n            default:\n                return '';\n        }\n    }\n\n    function soundQueue(): control.AnimationQueue {\n        if (!_soundQueue) _soundQueue = new control.AnimationQueue();\n        return _soundQueue;\n    }\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    export function playSound(sound: string) {\n        const queue = soundQueue();\n        const melody = new Melody(sound);\n        control.runInParallel(() => {\n            queue.cancel();\n            queue.runUntilDone(() => melody.playNextNote());\n        })\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    export function playSoundUntilDone(sound: string) {\n        const queue = soundQueue();\n        const melody = new Melody(sound);\n        queue.runUntilDone(() => melody.playNextNote());\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=93\n    export function stopAllSounds() {\n        const queue = soundQueue();\n        queue.cancel();\n        music.rest(1);\n    }\n\n    class Melody {\n        static freqTable: number[];\n        notes: string;\n        duration: number;\n        octave: number;\n        pos: number;\n        tempo: number;\n\n        constructor(notes: string) {\n            this.notes = notes;\n            this.duration = 4; //Default duration (Crotchet)\n            this.octave = 4; //Middle octave\n            this.pos = 0;\n            this.tempo = 120; // default tempo\n            // TODO: use HEX literal\n            if (!Melody.freqTable)\n                Melody.freqTable = [31, 33, 35, 37, 39, 41, 44, 46, 49, 52, 55, 58, 62, 65, 69, 73, 78, 82, 87, 92, 98, 104, 110, 117, 123, 131, 139, 147, 156, 165, 175, 185, 196, 208, 220, 233, 247, 262, 277, 294, 311, 330, 349, 370, 392, 415, 440, 466, 494, 523, 554, 587, 622, 659, 698, 740, 784, 831, 880, 932, 988, 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1976, 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951, 4186, 4435, 4699, 4978, 5274, 5588, 5920, 6272, 6645, 7040, 7459, 7902]\n        }\n\n        hasNextNote() {\n            return this.pos < this.notes.length;\n        }\n\n        scanNextNote(): string {\n            // eat space\n            while (this.pos < this.notes.length) {\n                const c = this.notes[this.pos];\n                if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                    break;\n                this.pos++;\n            }\n\n            // read note\n            let note = \"\";\n            while (this.pos < this.notes.length) {\n                const c = this.notes[this.pos];\n                if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                    break;\n                note += c;\n                this.pos++;\n            }\n            return note;\n        }\n\n        playNextNote(): boolean {\n            let currNote = this.scanNextNote();\n            if (!currNote)\n                return false;\n\n            enum Token {\n                Note = 0,\n                Octave = 1,\n                Beat = 2,\n                Tempo = 3\n            }\n\n            let note: number = 0;\n            let isrest: boolean = false;\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: this.octave = d; break;\n                        case Token.Beat: this.duration = Math.max(1, Math.min(16, d)); break;\n                        case Token.Tempo: this.tempo = Math.max(1, d); break;\n                    }\n                    token = \"\";\n                }\n            }\n            for (let i = 0; i < currNote.length; i++) {\n                let noteChar = currNote.charAt(i);\n                switch (noteChar) {\n                    case 'c': case 'C': note = 1; break;\n                    case 'd': case 'D': note = 3; break;\n                    case 'e': case 'E': note = 5; break;\n                    case 'f': case 'F': note = 6; break;\n                    case 'g': case 'G': note = 8; break;\n                    case 'a': case 'A': note = 10; break;\n                    case 'b': case 'B': note = 12; break;\n                    case 'r': case 'R': isrest = true; break;\n                    case '#': note++; break;\n                    case 'b': note--; break;\n                    case ':':\n                        consumeToken();\n                        tokenKind = Token.Beat;\n                        break;\n                    case '-':\n                        consumeToken();\n                        tokenKind = Token.Tempo;\n                        break;\n                    default:\n                        if(tokenKind == Token.Note)\n                            tokenKind = Token.Octave;\n                        token += noteChar;\n                        break;\n                }\n            }\n            consumeToken();\n            let beat = 15000 / this.tempo;\n            if (isrest) {\n                music.rest(this.duration * beat)\n            } else {\n                const keyNumber = note + (12 * (this.octave - 1));\n                const frequency = Melody.freqTable[keyNumber] || 0;\n                music.playTone(frequency, this.duration * beat);\n            }\n\n            return this.hasNextNote();\n        }\n    }\n}",
            "music.cpp": "#include \"pxt.h\"\n\n#include \"dmac.h\"\n#include \"SAMDDAC.h\"\n#include \"Synthesizer.h\"\n#include \"CodalConfig.h\"\n\n#define NOTE_PAUSE 20\nclass WSynthesizer {\n  public:\n    Synthesizer synth;\n    CODAL_DAC dac;\n\n    WSynthesizer()\n        // DAC always on PA02 on SAMD21\n        : dac(*lookupPin(PA02), synth.output) {\n        synth.setSampleRate(dac.getSampleRate());\n        synth.setVolume(64);\n        synth.setTone(Synthesizer::SquareWaveTone);\n        this->setAmp(true);\n    }\n\n    // turns on/off the speaker amp\n    void setAmp(bool on) {\n        // turn off speaker as needed\n        auto pinAmp = LOOKUP_PIN(SPEAKER_AMP);\n        if (pinAmp) {\n            pinAmp->setDigitalValue(on ? 1 : 0);\n        }\n    }\n};\nSINGLETON(WSynthesizer);\n\nenum class SoundOutputDestination {\n    //% block=\"pin\"\n    Pin = 1,\n    //% block=\"speaker\"\n    Speaker = 0,\n};\n\n\n// override analogWrite for PA02 to use DAC\nnamespace AnalogOutPinMethods {\nvoid analogWrite(AnalogOutPin name, int value) {\n    if (name->name == PA02) {\n        auto pinAmp = LOOKUP_PIN(SPEAKER_AMP);\n        if (pinAmp) pinAmp->setDigitalValue(0);\n        getWSynthesizer()->dac.setValue(value);\n    } else\n        name->setAnalogValue(value);\n}\n}\n\nnamespace music {\n\nBuffer tone; // empty buffer to hold custom tone\n\n/**\n* This function is deprecated.\n*/\n//% help=music/set-tone\n//% weight=1 group=\"Tones\"\n//% deprecated blockHidden=1\n//% blockId=music_set_tone block=\"set tone %buffer\"\nvoid setTone(Buffer buffer) {\n    if (!buffer) return;\n\n    if (buffer->length != TONE_WIDTH * sizeof(uint16_t))\n        return; // invalid length\n\n    if (!tone)\n        registerGC((TValue*)&tone);\n    tone = buffer; // keep a reference to the buffer\n\n    auto synth = &getWSynthesizer()->synth;\n    synth->setTone((const uint16_t*)tone->data);\n}\n\n/**\n* Turn the on-board speaker on or off.\n* @param out the destination for sounds generated by the synthesizer\n*/\n// weight=2\n// blockId=music_set_output block=\"set output %out\"\n// parts=\"speaker\" blockGap=8 advanced=true\nvoid setOutput(SoundOutputDestination out) {\n    getWSynthesizer()->setAmp(out == SoundOutputDestination::Speaker);\n}\n\n/**\n* Set the output volume of the sound synthesizer.\n* @param volume the volume 0...256, eg: 128\n*/\n//% blockId=synth_set_volume block=\"set volume %volume\"\n//% parts=\"speaker\"\n//% volume.min=0 volume.max=256\n//% help=music/set-volume\n//% weight=70\n//% group=\"Volume\"\nvoid setVolume(int volume) {\n    auto synth = &getWSynthesizer()->synth;\n    synth->setVolume(max(0, min(1024, volume * 4)));\n}\n\n/**\n* Play a tone through the speaker for some amount of time.\n* @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n* @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n*/\n//% help=music/play-tone\n//% blockId=music_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n//% parts=\"headphone\" async\n//% blockNamespace=music\n//% weight=76 blockGap=8\n//% group=\"Tone\"\nvoid playTone(int frequency, int ms) {\n    auto synth = &getWSynthesizer()->synth;\n\n    if (frequency <= 0) {\n        synth->setFrequency(0, max(1, ms));\n    } else {\n        if (ms > 0) {\n            int d = max(1, ms - NOTE_PAUSE); // allow for short rest\n            int r = max(1, ms - d);\n            synth->setFrequency((float) frequency, d);\n            synth->setFrequency(0, r);\n        } else {\n            // ring\n            synth->setFrequency((float) frequency);\n        }\n    }\n    fiber_sleep(1);\n}\n\n}",
            "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    //% group=\"Tone\"\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    //% group=\"Tone\"\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    //% group=\"Tempo\"\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    //% group=\"Tempo\"\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    //% group=\"Tempo\"\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    //% group=\"Tempo\"\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
            "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#E30FC0 weight=90 icon=\"\\uf025\"\n//% blockGap=8\n//% groups='[\"Sounds\", \"Melody\", \"Tone\",  \"Volume\", \"Tempo\"]'\nnamespace music {\n}",
            "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    //% group=\"Tone\"\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
            "pxt.json": "{\n    \"name\": \"music\",\n    \"description\": \"The music library\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"music.cpp\",\n        \"enums.d.ts\",\n        \"shims.d.ts\",\n        \"melodies.ts\",\n        \"music.ts\",\n        \"piano.ts\",\n        \"ns.ts\",\n        \"headphone.svg\",\n        \"pxtparts.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"hidden\": true\n}\n",
            "pxtparts.json": "{\n    \"headphone\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"image\": \"headphone.svg\",\n            \"width\": 142,\n            \"height\": 180,\n            \"pinDistance\": 20,\n            \"pinLocations\": [\n                {\n                    \"x\": 17,\n                    \"y\": 11\n                },\n                {\n                    \"x\": 55,\n                    \"y\": 50\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"A0\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface AnalogOutPin {}\ndeclare namespace music {\n\n    /**\n     * This function is deprecated.\n     */\n    //% help=music/set-tone\n    //% weight=1 group=\"Tones\"\n    //% deprecated blockHidden=1\n    //% blockId=music_set_tone block=\"set tone %buffer\" shim=music::setTone\n    function setTone(buffer: Buffer): void;\n\n    /**\n     * Set the output volume of the sound synthesizer.\n     * @param volume the volume 0...256, eg: 128\n     */\n    //% blockId=synth_set_volume block=\"set volume %volume\"\n    //% parts=\"speaker\"\n    //% volume.min=0 volume.max=256\n    //% help=music/set-volume\n    //% weight=70\n    //% group=\"Volume\" shim=music::setVolume\n    function setVolume(volume: int32): void;\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=music_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8\n    //% group=\"Tone\" shim=music::playTone\n    function playTone(frequency: int32, ms: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
        },
        "mixer": {
            "SoundOutput.h": "#include \"dmac.h\"\n#include \"SAMD21DAC.h\"\n#include \"Mixer.h\"\n\n// DAC always on PA02 on SAMD21\n#define DAC_PIN PA02\n\nclass SoundOutput {\n  public:\n    SAMD21DAC dac;\n\n    SoundOutput(DataSource &data) : dac(*lookupPin(DAC_PIN), pxt::getWDMAC()->dmac, data) {}\n\n    void setOutput(int output) { (void)output; }\n};\n",
            "headphone.svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"142\" height=\"180\" viewBox=\"0 0 142 180\"><rect ry=\".3\" rx=\"1\" y=\"58.615\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><rect ry=\".3\" rx=\"1\" y=\"32.043\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><path d=\"M.346 7.296c-.394.39-.31 4.797-.18 4.898l13.404 10.18c.117.12.337 4.76.73 4.368l5.506-5.56.01.01 6.51-6.444c.39-.392-4.25-.614-4.366-.73L11.777.612c-.1-.132-4.51-.215-4.898.18L4.087 3.636l-.01-.01-3.73 3.67z\" fill=\"#b3b3b3\"/><rect ry=\"6.85\" rx=\"4.571\" y=\"84.758\" x=\"-20.128\" height=\"75.571\" width=\"39.643\" transform=\"rotate(-45)\"/><rect ry=\".374\" rx=\"1.038\" y=\"29.442\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"55.939\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"82.392\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\"2.317\" rx=\"2.183\" y=\"158.876\" x=\"-9.774\" height=\"25.568\" width=\"18.935\" transform=\"rotate(-45)\"/><path d=\"M128.588 128.82s14.97 11.165 7.547 26.35c-8.426 17.24-25.57 20.653-25.57 20.653\" fill=\"none\" stroke=\"#000\" stroke-width=\"6.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
            "legacy.ts": "//% deprecated=true hidden=true\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    let currMelody: Melody\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSound(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.play();\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSoundUntilDone(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.playUntilDone();\n    }\n}",
            "melody.cpp": "#include \"pxt.h\"\n#include \"SoundOutput.h\"\n#include \"melody.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\nnamespace music {\n\nSINGLETON(WSynthesizer);\n\nstatic const int16_t sinQ[256] = {\n    0,     201,   403,   605,   807,   1009,  1210,  1412,  1614,  1815,  2017,  2218,  2419,\n    2621,  2822,  3023,  3224,  3425,  3625,  3826,  4026,  4226,  4426,  4626,  4826,  5026,\n    5225,  5424,  5623,  5822,  6020,  6219,  6417,  6615,  6812,  7009,  7206,  7403,  7600,\n    7796,  7992,  8187,  8383,  8578,  8772,  8967,  9161,  9354,  9547,  9740,  9933,  10125,\n    10317, 10508, 10699, 10890, 11080, 11270, 11459, 11648, 11836, 12024, 12212, 12399, 12585,\n    12772, 12957, 13142, 13327, 13511, 13695, 13878, 14060, 14243, 14424, 14605, 14785, 14965,\n    15145, 15323, 15501, 15679, 15856, 16032, 16208, 16383, 16557, 16731, 16905, 17077, 17249,\n    17420, 17591, 17761, 17930, 18099, 18267, 18434, 18600, 18766, 18931, 19096, 19259, 19422,\n    19585, 19746, 19907, 20067, 20226, 20384, 20542, 20699, 20855, 21010, 21165, 21318, 21471,\n    21623, 21774, 21925, 22074, 22223, 22371, 22518, 22664, 22810, 22954, 23098, 23241, 23382,\n    23523, 23663, 23803, 23941, 24078, 24215, 24350, 24485, 24618, 24751, 24883, 25014, 25144,\n    25273, 25401, 25528, 25654, 25779, 25903, 26026, 26148, 26269, 26389, 26509, 26627, 26744,\n    26860, 26975, 27089, 27202, 27314, 27425, 27535, 27644, 27752, 27859, 27964, 28069, 28173,\n    28275, 28377, 28477, 28576, 28674, 28772, 28868, 28963, 29056, 29149, 29241, 29331, 29421,\n    29509, 29596, 29682, 29767, 29851, 29934, 30015, 30096, 30175, 30253, 30330, 30406, 30480,\n    30554, 30626, 30697, 30767, 30836, 30904, 30970, 31036, 31100, 31163, 31225, 31285, 31345,\n    31403, 31460, 31516, 31570, 31624, 31676, 31727, 31777, 31825, 31873, 31919, 31964, 32008,\n    32050, 32092, 32132, 32171, 32209, 32245, 32280, 32314, 32347, 32379, 32409, 32438, 32466,\n    32493, 32518, 32542, 32565, 32587, 32607, 32627, 32645, 32661, 32677, 32691, 32704, 32716,\n    32727, 32736, 32744, 32751, 32757, 32761, 32764, 32766, 32767};\n\ntypedef int (*gentone_t)(uintptr_t userData, uint32_t position);\n\nstatic int noiseTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    // see https://en.wikipedia.org/wiki/Xorshift\n    static uint32_t x = 0xf01ba80;\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return (x & 0xffff) - 0x7fff;\n}\n\nstatic int sineTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    int p = position >= 512 ? position - 512 : position;\n    int r;\n    if (p < 256) {\n        r = sinQ[p];\n    } else {\n        r = sinQ[511 - p];\n    }\n    return position >= 512 ? -r : r;\n}\n\nstatic int sawtoothTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return (position << 6) - 0x7fff;\n}\n\nstatic int triangleTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return position < 512 ? (position << 7) - 0x7fff : ((1023 - position) << 7) - 0x7fff;\n}\n\nstatic int squareWaveTone(uintptr_t wave, uint32_t position) {\n    return position < (102 * (wave - SW_SQUARE_10 + 1)) ? -0x7fff : 0x7fff;\n}\n\nstatic int silenceTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    return 0;\n}\n\nstatic gentone_t getWaveFn(uint8_t wave) {\n    switch (wave) {\n    case SW_TRIANGLE:\n        return triangleTone;\n    case SW_SAWTOOTH:\n        return sawtoothTone;\n    case SW_NOISE:\n        return noiseTone;\n    case SW_SINE:\n        return sineTone;\n    default:\n        if (SW_SQUARE_10 <= wave && wave <= SW_SQUARE_50)\n            return squareWaveTone;\n        else\n            return silenceTone;\n    }\n}\n\n#define CLAMP(lo, v, hi) ((v) = ((v) < (lo) ? (lo) : (v) > (hi) ? (hi) : (v)))\n\nint WSynthesizer::updateQueues() {\n    const int maxTime = 0xffffff;\n    while (1) {\n        WaitingSound *p;\n        int minLeft = maxTime;\n        for (p = waiting; p; p = p->next) {\n            int timeLeft =\n                p->state == SoundState::Waiting ? p->startSampleNo - currSample : maxTime;\n            if (timeLeft <= 0) {\n                break;\n            }\n            if (timeLeft < minLeft)\n                minLeft = timeLeft;\n        }\n        if (p) {\n            PlayingSound *snd;\n            int minIdx = -1;\n            for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n                snd = &playingSounds[i];\n                if (snd->sound == NULL)\n                    break;\n                if (minIdx == -1 ||\n                    playingSounds[minIdx].startSampleNo < playingSounds[i].startSampleNo)\n                    minIdx = i;\n                snd = NULL;\n            }\n            // if we didn't find a free slot, expel the oldest sound\n            if (!snd)\n                snd = &playingSounds[minIdx];\n            if (snd->sound)\n                snd->sound->state = SoundState::Done;\n            snd->sound = p;\n            p->state = SoundState::Playing;\n            snd->startSampleNo = currSample;\n            snd->currInstr = (SoundInstruction *)p->instructions->data;\n            snd->instrEnd = snd->currInstr + p->instructions->length / sizeof(SoundInstruction);\n            for (auto p = snd->currInstr; p < snd->instrEnd; p++) {\n                CLAMP(20, p->frequency, 20000);\n                CLAMP(20, p->endFrequency, 20000);\n                CLAMP(0, p->startVolume, 1023);\n                CLAMP(0, p->endVolume, 1023);\n                CLAMP(1, p->duration, 60000);\n            }\n            snd->prevVolume = -1;\n        } else {\n            // no more sounds to move\n            return minLeft;\n        }\n    }\n}\n\nint WSynthesizer::fillSamples(int16_t *dst, int numsamples) {\n    if (numsamples <= 0)\n        return 1;\n\n    int timeLeft = updateQueues();\n    int res = waiting != NULL;\n\n    // if there's a pending sound to be started somewhere during numsamples,\n    // split the call into two\n    if (timeLeft < numsamples) {\n        fillSamples(dst, timeLeft);\n        LOG(\"M split %d\", timeLeft);\n        fillSamples(dst + timeLeft, numsamples - timeLeft);\n        return 1;\n    }\n\n    memset(dst, 0, numsamples * 2);\n\n    uint32_t samplesPerMS = (sampleRate << 8) / 1000;\n    float toneStepMult = (1024.0 * (1 << 16)) / sampleRate;\n    const int MAXVAL = (1 << (OUTPUT_BITS - 1)) - 1;\n\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        PlayingSound *snd = &playingSounds[i];\n        if (snd->sound == NULL)\n            continue;\n\n        res = 1;\n\n        SoundInstruction *instr = NULL;\n        gentone_t fn = NULL;\n        snd->currInstr--;\n        uint32_t toneStep = 0;\n        int32_t toneDelta = 0;\n        int32_t volumeStep = 0;\n        uint32_t tonePosition = snd->tonePosition;\n        uint32_t samplesLeft = 0;\n        uint8_t wave = 0;\n        int32_t volume = 0;\n        uint32_t prevFreq = 0;\n        uint32_t prevEndFreq = 0;\n\n        for (int j = 0; j < numsamples; ++j) {\n            if (samplesLeft == 0) {\n                instr = ++snd->currInstr;\n                if (instr >= snd->instrEnd) {\n                    break;\n                }\n                wave = instr->soundWave;\n                fn = getWaveFn(wave);\n\n                samplesLeft = (uint32_t)(instr->duration * samplesPerMS >> 8);\n                volumeStep = ((int)(instr->endVolume - instr->startVolume) << 16) / samplesLeft;\n\n                if (j == 0 && snd->prevVolume != -1) {\n                    // restore previous state\n                    samplesLeft = snd->samplesLeftInCurr;\n                    volume = snd->prevVolume;\n                    toneStep = snd->prevToneStep;\n                    toneDelta = snd->prevToneDelta;\n                    prevFreq = instr->frequency;\n                    prevEndFreq = instr->endFrequency;\n                } else {\n                    LOG(\"#sampl %d %p\", samplesLeft, instr);\n                    volume = instr->startVolume << 16;\n                    if (prevFreq != instr->frequency || prevEndFreq != instr->endFrequency) {\n                        toneStep = (uint32_t)(toneStepMult * instr->frequency);\n                        if (instr->frequency != instr->endFrequency) {\n                            uint32_t endToneStep = (uint32_t)(toneStepMult * instr->endFrequency);\n                            toneDelta = (int32_t)(endToneStep - toneStep) / (int32_t)samplesLeft;\n                        } else {\n                            toneDelta = 0;\n                        }\n                        prevFreq = instr->frequency;\n                        prevEndFreq = instr->endFrequency;\n                    }\n                }\n            }\n\n            int v = fn(wave, (tonePosition >> 16) & 1023);\n            v = (v * (volume >> 16)) >> (10 + (16 - OUTPUT_BITS));\n\n            // if (v > MAXVAL)\n            //    target_panic(123);\n\n            dst[j] += v;\n\n            tonePosition += toneStep;\n            toneStep += toneDelta;\n            volume += volumeStep;\n            samplesLeft--;\n        }\n\n        if (instr >= snd->instrEnd) {\n            snd->sound->state = SoundState::Done;\n            snd->sound = NULL;\n        } else {\n            snd->tonePosition = tonePosition;\n            if (samplesLeft == 0)\n                samplesLeft++; // avoid infinite loop in next iteration\n            snd->samplesLeftInCurr = samplesLeft;\n            snd->prevVolume = volume;\n            snd->prevToneDelta = toneDelta;\n            snd->prevToneStep = toneStep;\n        }\n    }\n\n    currSample += numsamples;\n\n    for (int j = 0; j < numsamples; ++j) {\n        if (dst[j] > MAXVAL)\n            dst[j] = MAXVAL;\n        else if (dst[j] < -MAXVAL)\n            dst[j] = -MAXVAL;\n    }\n\n    return res;\n}\n\n//%\nvoid enableAmp(int enabled) {\n    // this is also compiled on linux\n#ifdef LOOKUP_PIN\n    auto pin = LOOKUP_PIN(SPEAKER_AMP);\n    if (pin) {\n        if (PIN(SPEAKER_AMP) & CFG_PIN_CONFIG_ACTIVE_LO)\n            enabled = !enabled;\n        pin->setDigitalValue(enabled);\n    }\n#endif\n}\n\n//%\nvoid forceOutput(int outp) {\n    auto snd = getWSynthesizer();\n    snd->out.setOutput(outp);\n}\n\n//%\nvoid queuePlayInstructions(int when, Buffer buf) {\n    auto snd = getWSynthesizer();\n\n    registerGCObj(buf);\n\n    auto p = new WaitingSound;\n    p->state = SoundState::Waiting;\n    p->instructions = buf;\n    p->startSampleNo = snd->currSample + when * snd->sampleRate / 1000;\n\n    LOG(\"Queue %dms now=%d off=%d %p\", when, snd->currSample, p->startSampleNo - snd->currSample,\n        buf->data);\n\n    target_disable_irq();\n    // add new sound to queue\n    p->next = snd->waiting;\n    snd->waiting = p;\n    // remove sounds that have already been fully played\n    while (p) {\n        while (p->next && p->next->state == SoundState::Done) {\n            auto todel = p->next;\n            p->next = todel->next;\n            unregisterGCObj(todel->instructions);\n            delete todel;\n        }\n        p = p->next;\n    }\n    target_enable_irq();\n\n    snd->poke();\n}\n\n//%\nvoid stopPlaying() {\n    LOG(\"stop playing!\");\n\n    auto snd = getWSynthesizer();\n\n    target_disable_irq();\n    auto p = snd->waiting;\n    snd->waiting = NULL;\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        snd->playingSounds[i].sound = NULL;\n    }\n    while (p) {\n        auto n = p->next;\n        unregisterGCObj(p->instructions);\n        delete p;\n        p = n;\n    }\n    target_enable_irq();\n}\n\nWSynthesizer::WSynthesizer() : upstream(NULL), out(*this) {\n    currSample = 0;\n    active = false;\n    sampleRate = out.dac.getSampleRate();\n    memset(&playingSounds, 0, sizeof(playingSounds));\n    waiting = NULL;\n    PXT_REGISTER_RESET(stopPlaying);\n}\n\n} // namespace music\n\nnamespace jacdac {\n__attribute__((weak)) void setJackRouterOutput(int output) {}\n} // namespace jacdac",
            "melody.h": "#pragma once\n\n#ifndef OUTPUT_BITS\n#define OUTPUT_BITS 10\n#endif\n\n#define SW_TRIANGLE 1\n#define SW_SAWTOOTH 2\n#define SW_SINE 3 // TODO remove it? it takes space\n#define SW_NOISE 5\n#define SW_SQUARE_10 11\n#define SW_SQUARE_50 15\n\nstruct SoundInstruction {\n    uint8_t soundWave;\n    uint8_t flags;\n    uint16_t frequency;    // Hz\n    uint16_t duration;     // ms\n    int16_t startVolume;   // 0-1023\n    int16_t endVolume;     // 0-1023\n    uint16_t endFrequency; // Hz\n};\n\n#ifdef DATASTREAM_MAXIMUM_BUFFERS\n#define CODAL 1\n#endif\n\nnamespace music {\n\n#define MAX_SOUNDS 5\n\nSTATIC_ASSERT((1 << (16 - OUTPUT_BITS)) > MAX_SOUNDS);\n\nenum class SoundState : uint8_t {\n    Waiting, //\n    Playing, //\n    Done     //\n};\n\nstruct WaitingSound {\n    uint32_t startSampleNo;\n    SoundState state;\n    WaitingSound *next;\n    Buffer instructions;\n};\n\nstruct PlayingSound {\n    uint32_t startSampleNo;\n    uint32_t samplesLeftInCurr;\n    uint32_t tonePosition;\n    int32_t prevVolume;\n    uint32_t prevToneStep;\n    int32_t prevToneDelta;\n    WaitingSound *sound;\n    SoundInstruction *currInstr, *instrEnd;\n};\n\nclass WSynthesizer\n#ifdef CODAL\n    : public DataSource\n#endif\n{\n  public:\n#ifdef CODAL\n    DataSink *upstream;\n#else\n    void *upstream;\n#endif\n    uint32_t currSample; // after 25h of playing we might get a glitch\n    int32_t sampleRate;  // eg 44100\n    PlayingSound playingSounds[MAX_SOUNDS];\n    WaitingSound *waiting;\n    bool active;\n\n    SoundOutput out;\n\n    int fillSamples(int16_t *dst, int numsamples);\n    int updateQueues();\n\n    WSynthesizer();\n    virtual ~WSynthesizer() {}\n\n    void pokeUpstream() {\n#ifdef CODAL\n        if (upstream) {\n            upstream->pullRequest();\n        }\n#endif\n    }\n\n    void poke() {\n        if (!active) {\n            active = true;\n            pokeUpstream();\n        }\n    }\n\n#ifdef CODAL\n    virtual ManagedBuffer pull() {\n        ManagedBuffer data(512);\n        auto dp = (int16_t *)data.getBytes();\n        auto sz = 512 / 2;\n        int r = fillSamples(dp, sz);\n#if defined(NRF52_SERIES)\n        int mul = out.dac.getSampleRange();\n#endif\n        while (sz--) {\n#if defined(NRF52_SERIES)\n            *dp = ((-*dp + (1 << (OUTPUT_BITS - 1))) * mul) >> OUTPUT_BITS;\n#else\n            *dp += 1 << (OUTPUT_BITS - 1);\n#endif\n            dp++;\n        }\n        if (!r) {\n            active = false;\n            // return empty - nothing left to play\n            return ManagedBuffer();\n        }\n        pokeUpstream();\n        return data;\n    }\n    virtual void connect(DataSink &sink) { upstream = &sink; }\n#endif\n};\n\n} // namespace music\n",
            "melody.ts": "enum MusicOutput {\n    AutoDetect = 0,\n    Buzzer = 1,\n    HeadPhones = 2,\n}\n\nnamespace music {\n    //% whenUsed\n    const freqs = hex`\n        1f00210023002500270029002c002e003100340037003a003e004100450049004e00520057005c00620068006e00\n        75007b0083008b0093009c00a500af00b900c400d000dc00e900f70006011501260137014a015d01720188019f01\n        b801d201ee010b022a024b026e029302ba02e40210033f037003a403dc03170455049704dd0427057505c8052006\n        7d06e0064907b8072d08a9082d09b9094d0aea0a900b400cfa0cc00d910e6f0f5a1053115b1272139a14d4152017\n        8018f519801b231dde1e`\n\n    //% shim=music::queuePlayInstructions\n    function queuePlayInstructions(timeDelta: number, buf: Buffer) { }\n\n    //% shim=music::stopPlaying\n    function stopPlaying() { }\n\n    //% shim=music::forceOutput\n    export function forceOutput(buf: MusicOutput) { }\n\n    let globalVolume: number = null\n\n    const BUFFER_SIZE: number = 12;\n\n    //% shim=music::enableAmp\n    function enableAmp(en: number) {\n        return // for sim\n    }\n\n    function initVolume() {\n        if (globalVolume === null) {\n            globalVolume = 0\n            setVolume(control.getConfigValue(DAL.CFG_SPEAKER_VOLUME, 128))\n        }\n    }\n\n    /**\n     * Set the default output volume of the sound synthesizer.\n     * @param volume the volume 0...255\n     */\n    //% blockId=synth_set_volume block=\"set volume %volume\"\n    //% parts=\"speaker\"\n    //% volume.min=0 volume.max=255\n    //% volume.defl=20\n    //% help=music/set-volume\n    //% weight=70\n    //% group=\"Volume\"\n    export function setVolume(volume: number): void {\n        globalVolume = Math.clamp(0, 255, volume | 0)\n        enableAmp(globalVolume > 0 ? 1 : 0)\n    }\n\n    /**\n     * Gets the current volume\n     */\n    //% parts=\"speaker\"\n    //% weight=70\n    export function volume(): number {\n        initVolume()\n        return globalVolume;\n    }\n\n    function playNoteCore(when: number, frequency: number, ms: number) {\n        let buf = control.createBuffer(BUFFER_SIZE)\n        addNote(buf, 0, ms, 255, 255, 3, frequency, volume(), frequency)\n        queuePlayInstructions(when, buf)\n    }\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=mixer_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8\n    //% group=\"Tone\"\n    export function playTone(frequency: number, ms: number): void {\n        if (ms == 0)\n            ms = 86400000 // 1 day\n\n        if (ms <= 2000) {\n            playNoteCore(0, frequency, ms)\n            pause(ms)\n        } else {\n            const id = ++playToneID\n            control.runInParallel(() => {\n                let pos = control.millis()\n                while (id == playToneID && ms > 0) {\n                    let now = control.millis()\n                    let d = pos - now\n                    let t = Math.min(ms, 500)\n                    ms -= t\n                    pos += t\n                    playNoteCore(d - 1, frequency, t)\n                    if (ms == 0)\n                        pause(d + t)\n                    else\n                        pause(d + t - 100)\n                }\n            })\n        }\n    }\n\n    let playToneID = 0\n\n    /**\n     * Play a melody from the melody editor.\n     * @param melody - string of up to eight notes [C D E F G A B C5] or rests [-] separated by spaces, \n     * which will be played one at a time, ex: \"E D G F B A C5 B \"\n     * @param tempo - number in beats per minute (bpm), dictating how long each note will play for\n     */\n    //% block=\"play melody $melody at tempo $tempo|(bpm)\" blockId=playMelody\n    //% blockNamespace=music\n    //% weight=85 blockGap=8 help=music/play-melody\n    //% group=\"Melody\"\n    //% melody.shadow=\"melody_editor\"\n    //% tempo.min=40 tempo.max=500\n    //% tempo.defl=120\n    export function playMelody(melody: string, tempo: number) {\n        let notes: string[] = melody.split(\" \").filter(n => !!n);\n        let formattedMelody = \"\";\n        let newOctave = false;\n\n        // build melody string, replace '-' with 'R' and add tempo\n        // creates format like \"C5-174 B4 A G F E D C \"\n        for (let i = 0; i < notes.length; i++) {\n            if (notes[i] === \"-\") {\n                notes[i] = \"R\";\n            } else if (notes[i] === \"C5\") {\n                newOctave = true;\n            } else if (newOctave) { // change the octave if necesary\n                notes[i] += \"4\";\n                newOctave = false;\n            }\n            // add tempo after first note\n            if (i == 0) {\n                formattedMelody += notes[i] + \"-\" + tempo + \" \";\n            } else {\n                formattedMelody += notes[i] + \" \";\n            }\n        }\n\n        const song = new Melody(formattedMelody);\n        song.playUntilDone();\n    }\n\n\n    /**\n     * Create a melody with the melody editor.\n     * @param melody\n     */\n    //% block=\"$melody\" blockId=melody_editor\n    //% blockNamespace=music\n    //% blockHidden = true\n    //% weight=85 blockGap=8\n    //% help=music/melody-editor\n    //% group=\"Melody\" duplicateShadowOnDrag\n    //% melody.fieldEditor=\"melody\"\n    //% melody.fieldOptions.decompileLiterals=true\n    //% melody.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% melody.fieldOptions.onParentBlock=\"true\"\n    //% shim=TD_ID\n    export function melodyEditor(melody: string): string {\n        return melody;\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=10\n    //% group=\"Sounds\"\n    export function stopAllSounds() {\n        Melody.stopAll();\n        stopPlaying();\n    }\n\n    //% fixedInstances\n    export class Melody {\n        _text: string;\n        private _player: MelodyPlayer;\n\n        private static playingMelodies: Melody[];\n\n        static stopAll() {\n            if (Melody.playingMelodies) {\n                const ms = Melody.playingMelodies.slice(0, Melody.playingMelodies.length);\n                ms.forEach(p => p.stop());\n            }\n        }\n\n        constructor(text: string) {\n            this._text = text\n        }\n\n        get text() {\n            return this._text;\n        }\n\n        /**\n         * Stop playing a sound\n         */\n        //% blockId=mixer_stop block=\"stop sound %sound\"\n        //% help=music/melody/stop\n        //% parts=\"headphone\"\n        //% weight=92 blockGap=8\n        //% group=\"Sounds\"\n        stop() {\n            if (this._player) {\n                this._player.stop()\n                this._player = null\n            }\n            this.unregisterMelody();\n        }\n\n        private registerMelody() {\n            // keep track of the active players\n            if (!Melody.playingMelodies) Melody.playingMelodies = [];\n            // stop and pop melodies if too many playing\n            if (Melody.playingMelodies.length > 4) {\n                // stop last player (also pops)\n                Melody.playingMelodies[Melody.playingMelodies.length - 1].stop();\n            }\n            // put back the melody on top of the melody stack\n            Melody.playingMelodies.removeElement(this);\n            Melody.playingMelodies.push(this);\n        }\n        private unregisterMelody() {\n            // remove from list\n            if (Melody.playingMelodies) {\n                Melody.playingMelodies.removeElement(this); // remove self\n            }\n        }\n\n        private playCore(volume: number, loop: boolean) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this.registerMelody();\n            control.runInParallel(() => {\n                while (this._player == p) {\n                    p.play(volume)\n                    if (!loop)\n                        break\n                }\n                this.unregisterMelody();\n            })\n        }\n\n        /**\n         * Start playing a sound in a loop and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/loop\n        //% blockId=mixer_loop_sound block=\"loop sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=93 blockGap=8\n        //% group=\"Sounds\"\n        loop(volume = 255) {\n            this.playCore(volume, true)\n        }\n\n        /**\n         * Start playing a sound and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play\n        //% blockId=mixer_play_sound block=\"play sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=95 blockGap=8\n        //% group=\"Sounds\"\n        play(volume = 255) {\n            this.playCore(volume, false)\n        }\n\n\n        /**\n         * Play a sound and wait until the sound is done.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play-until-done\n        //% blockId=mixer_play_sound_until_done block=\"play sound %sound|until done\"\n        //% parts=\"headphone\"\n        //% weight=94 blockGap=8\n        //% group=\"Sounds\"\n        playUntilDone(volume = 255) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this._player.onPlayFinished = () => {\n                if (p == this._player)\n                    this.unregisterMelody();\n            }\n            this.registerMelody();\n            this._player.play(volume)\n        }\n\n        toString() {\n            return this._text;\n        }\n    }\n\n    function addNote(sndInstr: Buffer, sndInstrPtr: number, ms: number, beg: number, end: number, soundWave: number, hz: number, volume: number, endHz: number) {\n        if (ms > 0) {\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, soundWave)\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr + 1, 0)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 2, hz)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 4, ms)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 6, (beg * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 8, (end * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 10, endHz);\n            sndInstrPtr += BUFFER_SIZE;\n        }\n        sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, 0) // terminate\n        return sndInstrPtr\n    }\n\n\n    export class MelodyPlayer {\n        melody: Melody;\n\n        onPlayFinished: () => void;\n\n        constructor(m: Melody) {\n            this.melody = m\n        }\n\n        stop() {\n            this.melody = null\n        }\n\n        protected queuePlayInstructions(timeDelta: number, buf: Buffer) {\n            queuePlayInstructions(timeDelta, buf)\n        }\n\n        play(volume: number) {\n            if (!this.melody)\n                return\n            volume = Math.clamp(0, 255, (volume * music.volume()) >> 8)\n\n            let notes = this.melody._text\n            let pos = 0;\n            let duration = 4; //Default duration (Crotchet)\n            let octave = 4; //Middle octave\n            let tempo = 120; // default tempo\n\n            let hz = 0\n            let endHz = -1\n            let ms = 0\n            let timePos = 0\n            let startTime = control.millis()\n            let now = 0\n\n            let envA = 0\n            let envD = 0\n            let envS = 255\n            let envR = 0\n            let soundWave = 1 // triangle\n            let sndInstr = control.createBuffer(5 * BUFFER_SIZE)\n            let sndInstrPtr = 0\n\n            const addForm = (formDuration: number, beg: number, end: number, msOff: number) => {\n                let freqStart = hz;\n                let freqEnd = endHz;\n\n                const envelopeWidth = ms > 0 ? ms : duration * Math.idiv(15000, tempo) + envR;\n                if (endHz != hz && envelopeWidth != 0) {\n                    const slope = (freqEnd - freqStart) / envelopeWidth;\n                    freqStart = hz + slope * msOff;\n                    freqEnd = hz + slope * (msOff + formDuration);\n                }\n                sndInstrPtr = addNote(sndInstr, sndInstrPtr, formDuration, beg, end, soundWave, freqStart, volume, freqEnd);\n            }\n\n            const scanNextWord = () => {\n                if (!this.melody)\n                    return \"\"\n\n                // eat space\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                        break;\n                    pos++;\n                }\n\n                // read note\n                let note = \"\";\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                        break;\n                    note += c;\n                    pos++;\n                }\n                return note;\n            }\n\n            enum Token {\n                Note,\n                Octave,\n                Beat,\n                Tempo,\n                Hz,\n                EndHz,\n                Ms,\n                WaveForm,\n                EnvelopeA,\n                EnvelopeD,\n                EnvelopeS,\n                EnvelopeR\n            }\n\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n\n            // [ABCDEFG] (\\d+)  (:\\d+)  (-\\d+)\n            // note      octave length  tempo\n            // R (:\\d+) - rest\n            // !\\d+,\\d+ - sound at frequency with given length (Hz,ms); !\\d+ and !\\d+,:\\d+ also possible\n            // @\\d+,\\d+,\\d+,\\d+ - ADSR envelope - ms,ms,volume,ms; volume is 0-255\n            // ~\\d+ - wave form:\n            //   1 - triangle\n            //   2 - sawtooth\n            //   3 - sine\n            //   5 - noise\n            //   11 - square 10%\n            //   12 - square 20%\n            //   ...\n            //   15 - square 50%\n            //\n\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: octave = d; break;\n                        case Token.Beat:\n                            duration = Math.max(1, Math.min(16, d));\n                            ms = -1;\n                            break;\n                        case Token.Tempo: tempo = Math.max(1, d); break;\n                        case Token.Hz: hz = d; tokenKind = Token.Ms; break;\n                        case Token.Ms: ms = d; break;\n                        case Token.WaveForm: soundWave = Math.clamp(1, 15, d); break;\n                        case Token.EnvelopeA: envA = d; tokenKind = Token.EnvelopeD; break;\n                        case Token.EnvelopeD: envD = d; tokenKind = Token.EnvelopeS; break;\n                        case Token.EnvelopeS: envS = Math.clamp(0, 255, d); tokenKind = Token.EnvelopeR; break;\n                        case Token.EnvelopeR: envR = d; break;\n                        case Token.EndHz: endHz = d; break;\n                    }\n                    token = \"\";\n                }\n            }\n\n            while (true) {\n                let currNote = scanNextWord();\n                let prevNote: boolean = false;\n                if (!currNote) {\n                    let timeLeft = timePos - now\n                    if (timeLeft > 0)\n                        pause(timeLeft)\n                    if (this.onPlayFinished)\n                        this.onPlayFinished();\n                    return;\n                }\n\n                hz = -1;\n\n                let note: number = 0;\n                token = \"\";\n                tokenKind = Token.Note;\n\n                for (let i = 0; i < currNote.length; i++) {\n                    let noteChar = currNote.charAt(i);\n                    switch (noteChar) {\n                        case 'c': case 'C': note = 1; prevNote = true; break;\n                        case 'd': case 'D': note = 3; prevNote = true; break;\n                        case 'e': case 'E': note = 5; prevNote = true; break;\n                        case 'f': case 'F': note = 6; prevNote = true; break;\n                        case 'g': case 'G': note = 8; prevNote = true; break;\n                        case 'a': case 'A': note = 10; prevNote = true; break;\n                        case 'B': note = 12; prevNote = true; break;\n                        case 'r': case 'R': hz = 0; prevNote = false; break;\n                        case '#': note++; prevNote = false; break;\n                        case 'b': if (prevNote) note--; else { note = 12; prevNote = true; } break;\n                        case ',':\n                            consumeToken();\n                            prevNote = false;\n                            break;\n                        case '!':\n                            tokenKind = Token.Hz;\n                            prevNote = false;\n                            break;\n                        case '@':\n                            consumeToken();\n                            tokenKind = Token.EnvelopeA;\n                            prevNote = false;\n                            break;\n                        case '~':\n                            consumeToken();\n                            tokenKind = Token.WaveForm;\n                            prevNote = false;\n                            break;\n                        case ':':\n                            consumeToken();\n                            tokenKind = Token.Beat;\n                            prevNote = false;\n                            break;\n                        case '-':\n                            consumeToken();\n                            tokenKind = Token.Tempo;\n                            prevNote = false;\n                            break;\n                        case '^':\n                            consumeToken();\n                            tokenKind = Token.EndHz;\n                            break;\n                        default:\n                            if (tokenKind == Token.Note)\n                                tokenKind = Token.Octave;\n                            token += noteChar;\n                            prevNote = false;\n                            break;\n                    }\n                }\n                consumeToken();\n\n                if (note && hz < 0) {\n                    const keyNumber = note + (12 * (octave - 1));\n                    hz = freqs.getNumber(NumberFormat.UInt16LE, keyNumber * 2) || 0;\n                }\n\n                let currMs = ms\n\n                if (currMs <= 0) {\n                    const beat = Math.idiv(15000, tempo);\n                    currMs = duration * beat\n                }\n\n                if (hz < 0) {\n                    // no frequency specified, so no duration\n                } else if (hz == 0) {\n                    timePos += currMs\n                } else {\n                    if (endHz < 0) {\n                        endHz = hz;\n                    }\n\n                    sndInstrPtr = 0\n                    addForm(envA, 0, 255, 0)\n                    addForm(envD, 255, envS, envA)\n                    addForm(currMs - (envA + envD), envS, envS, envD + envA)\n                    addForm(envR, envS, 0, currMs)\n\n                    this.queuePlayInstructions(timePos - now, sndInstr.slice(0, sndInstrPtr))\n                    endHz = -1;\n                    timePos += currMs // don't add envR - it's supposed overlap next sound\n                }\n\n                let timeLeft = timePos - now\n                if (timeLeft > 200) {\n                    pause(timeLeft - 100)\n                    now = control.millis() - startTime\n                }\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"ba ding\"\n    export const baDing = new Melody('b5:1 e6:3')\n\n    //% fixedInstance whenUsed block=\"wawawawaa\"\n    export const wawawawaa = new Melody('~15 e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8')\n\n    //% fixedInstance whenUsed block=\"jump up\"\n    export const jumpUp = new Melody('c5:1 d e f g')\n\n    //% fixedInstance whenUsed block=\"jump down\"\n    export const jumpDown = new Melody('g5:1 f e d c')\n\n    //% fixedInstance whenUsed block=\"power up\"\n    export const powerUp = new Melody('g4:1 c5 e g:2 e:1 g:3')\n\n    //% fixedInstance whenUsed block=\"power down\"\n    export const powerDown = new Melody('g5:1 d# c g4:2 b:1 c5:3')\n\n    //% fixedInstance whenUsed block=\"magic wand\"\n    export const magicWand = new Melody('F#6:1-300 G# A# B C7# D# F F# G# A# B:6')\n    //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n\n    //% fixedInstance whenUsed block=\"siren\"\n    export const siren = new Melody('a4 d5 a4 d5 a4 d5')\n\n    //% fixedInstance whenUsed block=\"pew pew\"\n    export const pewPew = new Melody('!1200,200^50')\n}\n",
            "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    //% group=\"Tone\"\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    //% group=\"Tone\"\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    //% group=\"Tempo\"\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    //% group=\"Tempo\"\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    //% group=\"Tempo\"\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    //% group=\"Tempo\"\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
            "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#E30FC0 weight=90 icon=\"\\uf025\"\n//% blockGap=8\n//% groups='[\"Sounds\", \"Melody\", \"Tone\",  \"Volume\", \"Tempo\"]'\nnamespace music {\n}",
            "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    //% group=\"Tone\"\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
            "pxt.json": "{\n    \"name\": \"mixer\",\n    \"description\": \"The music library with a mixer\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"SoundOutput.h\",\n        \"sound.cpp\",\n        \"melody.h\",\n        \"melody.cpp\",\n        \"melody.ts\",\n        \"piano.ts\",\n        \"legacy.ts\",\n        \"ns.ts\",\n        \"targetoverrides.ts\",\n        \"music.ts\",\n        \"pxtparts.json\",\n        \"headphone.svg\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "pxtparts.json": "{\n    \"headphone\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"image\": \"headphone.svg\",\n            \"width\": 142,\n            \"height\": 180,\n            \"pinDistance\": 20,\n            \"pinLocations\": [\n                {\n                    \"x\": 17,\n                    \"y\": 11\n                },\n                {\n                    \"x\": 55,\n                    \"y\": 50\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"A0\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "sound.cpp": "// to be overridden\n",
            "targetoverrides.ts": "\n",
            "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
        },
        "mixer---samd": {
            "SoundOutput.h": "#include \"SAMDDAC.h\"\n#include \"Synthesizer.h\"\n#include \"Mixer.h\"\n\nnamespace jacdac {\nvoid setJackRouterOutput(int output);\n}\n\nclass SoundOutput {\n  public:\n    SAMDDAC dac;\n\n    SoundOutput(DataSource &data) : dac(*pxt::lookupPin(PIN_PA02), data) {\n        jacdac::setJackRouterOutput(-1);\n    }\n\n    void setOutput(int output) { jacdac::setJackRouterOutput(output); }\n};\n",
            "headphone.svg": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"142\" height=\"180\" viewBox=\"0 0 142 180\"><rect ry=\".3\" rx=\"1\" y=\"58.615\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><rect ry=\".3\" rx=\"1\" y=\"32.043\" x=\"-8.878\" height=\"23.571\" width=\"17.143\" transform=\"rotate(-45)\" fill=\"#b3b3b3\"/><path d=\"M.346 7.296c-.394.39-.31 4.797-.18 4.898l13.404 10.18c.117.12.337 4.76.73 4.368l5.506-5.56.01.01 6.51-6.444c.39-.392-4.25-.614-4.366-.73L11.777.612c-.1-.132-4.51-.215-4.898.18L4.087 3.636l-.01-.01-3.73 3.67z\" fill=\"#b3b3b3\"/><rect ry=\"6.85\" rx=\"4.571\" y=\"84.758\" x=\"-20.128\" height=\"75.571\" width=\"39.643\" transform=\"rotate(-45)\"/><rect ry=\".374\" rx=\"1.038\" y=\"29.442\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"55.939\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\".374\" rx=\"1.038\" y=\"82.392\" x=\"-8.925\" height=\"2.228\" width=\"17.238\" transform=\"rotate(-45)\" fill=\"#fff\"/><rect ry=\"2.317\" rx=\"2.183\" y=\"158.876\" x=\"-9.774\" height=\"25.568\" width=\"18.935\" transform=\"rotate(-45)\"/><path d=\"M128.588 128.82s14.97 11.165 7.547 26.35c-8.426 17.24-25.57 20.653-25.57 20.653\" fill=\"none\" stroke=\"#000\" stroke-width=\"6.6\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/></svg>",
            "legacy.ts": "//% deprecated=true hidden=true\nenum Sounds {\n    //% block=\"power up\"\n    PowerUp,\n    //% block=\"power down\"\n    PowerDown,\n    //% block=\"jump up\"\n    JumpUp,\n    //% block=\"jump down\"\n    JumpDown,\n    //% block=\"ba ding\"\n    BaDing,\n    //% block=\"wawawawaa\"\n    Wawawawaa,\n    //% block=\"magic wand\"\n    MagicWand,\n    //% block=\"siren\"\n    Siren\n}\n\nnamespace music {\n    /**\n     * Get the melody string for a built-in melody.\n     * @param name the note name, eg: Note.C\n     */\n    //% help=music/sounds\n    //% blockId=music_sounds block=\"%name\"\n    //% blockHidden=true\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=285\n    //% name.fieldOptions.columns=3\n    export function sounds(name: Sounds): string {\n        switch (name) {\n            case Sounds.BaDing:\n                return 'b5:1 e6:3';\n            case Sounds.Wawawawaa:\n                return 'e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8';\n            case Sounds.JumpUp:\n                return 'c5:1 d e f g';\n            case Sounds.JumpDown:\n                return 'g5:1 f e d c';\n            case Sounds.PowerUp:\n                return 'g4:1 c5 e g:2 e:1 g:3';\n            case Sounds.PowerDown:\n                return 'g5:1 d# c g4:2 b:1 c5:3';\n            case Sounds.MagicWand:\n                return 'F#6:1-300 G# A# B C7# D# F F# G# A# B:6'; //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n            case Sounds.Siren:\n                return 'a4 d5 a4 d5 a4 d5';\n            default:\n                return '';\n        }\n    }\n\n    let currMelody: Melody\n\n    /**\n     * Start playing a sound and don't wait for it to finish.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound\n    //% blockId=music_play_sound block=\"play sound %sound=music_sounds\"\n    //% parts=\"headphone\"\n    //% weight=95 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSound(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.play();\n        pause(1);\n    }\n\n\n    /**\n     * Play a sound and wait until the sound is done.\n     * Notes are expressed as a string of characters with this format: NOTE[octave][:duration]\n     * @param sound the melody to play\n     */\n    //% help=music/play-sound-until-done\n    //% blockId=music_play_sound_until_done block=\"play sound %sound=music_sounds|until done\"\n    //% parts=\"headphone\"\n    //% weight=94 blockGap=8\n    //% deprecated=true hidden=true\n    export function playSoundUntilDone(sound: string) {\n        stopAllSounds();\n        currMelody = new Melody(sound);\n        currMelody.playUntilDone();\n    }\n}",
            "melody.cpp": "#include \"pxt.h\"\n#include \"SoundOutput.h\"\n#include \"melody.h\"\n\n//#define LOG DMESG\n#define LOG NOLOG\n\nnamespace music {\n\nSINGLETON(WSynthesizer);\n\nstatic const int16_t sinQ[256] = {\n    0,     201,   403,   605,   807,   1009,  1210,  1412,  1614,  1815,  2017,  2218,  2419,\n    2621,  2822,  3023,  3224,  3425,  3625,  3826,  4026,  4226,  4426,  4626,  4826,  5026,\n    5225,  5424,  5623,  5822,  6020,  6219,  6417,  6615,  6812,  7009,  7206,  7403,  7600,\n    7796,  7992,  8187,  8383,  8578,  8772,  8967,  9161,  9354,  9547,  9740,  9933,  10125,\n    10317, 10508, 10699, 10890, 11080, 11270, 11459, 11648, 11836, 12024, 12212, 12399, 12585,\n    12772, 12957, 13142, 13327, 13511, 13695, 13878, 14060, 14243, 14424, 14605, 14785, 14965,\n    15145, 15323, 15501, 15679, 15856, 16032, 16208, 16383, 16557, 16731, 16905, 17077, 17249,\n    17420, 17591, 17761, 17930, 18099, 18267, 18434, 18600, 18766, 18931, 19096, 19259, 19422,\n    19585, 19746, 19907, 20067, 20226, 20384, 20542, 20699, 20855, 21010, 21165, 21318, 21471,\n    21623, 21774, 21925, 22074, 22223, 22371, 22518, 22664, 22810, 22954, 23098, 23241, 23382,\n    23523, 23663, 23803, 23941, 24078, 24215, 24350, 24485, 24618, 24751, 24883, 25014, 25144,\n    25273, 25401, 25528, 25654, 25779, 25903, 26026, 26148, 26269, 26389, 26509, 26627, 26744,\n    26860, 26975, 27089, 27202, 27314, 27425, 27535, 27644, 27752, 27859, 27964, 28069, 28173,\n    28275, 28377, 28477, 28576, 28674, 28772, 28868, 28963, 29056, 29149, 29241, 29331, 29421,\n    29509, 29596, 29682, 29767, 29851, 29934, 30015, 30096, 30175, 30253, 30330, 30406, 30480,\n    30554, 30626, 30697, 30767, 30836, 30904, 30970, 31036, 31100, 31163, 31225, 31285, 31345,\n    31403, 31460, 31516, 31570, 31624, 31676, 31727, 31777, 31825, 31873, 31919, 31964, 32008,\n    32050, 32092, 32132, 32171, 32209, 32245, 32280, 32314, 32347, 32379, 32409, 32438, 32466,\n    32493, 32518, 32542, 32565, 32587, 32607, 32627, 32645, 32661, 32677, 32691, 32704, 32716,\n    32727, 32736, 32744, 32751, 32757, 32761, 32764, 32766, 32767};\n\ntypedef int (*gentone_t)(uintptr_t userData, uint32_t position);\n\nstatic int noiseTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    // see https://en.wikipedia.org/wiki/Xorshift\n    static uint32_t x = 0xf01ba80;\n    x ^= x << 13;\n    x ^= x >> 17;\n    x ^= x << 5;\n    return (x & 0xffff) - 0x7fff;\n}\n\nstatic int sineTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    int p = position >= 512 ? position - 512 : position;\n    int r;\n    if (p < 256) {\n        r = sinQ[p];\n    } else {\n        r = sinQ[511 - p];\n    }\n    return position >= 512 ? -r : r;\n}\n\nstatic int sawtoothTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return (position << 6) - 0x7fff;\n}\n\nstatic int triangleTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    return position < 512 ? (position << 7) - 0x7fff : ((1023 - position) << 7) - 0x7fff;\n}\n\nstatic int squareWaveTone(uintptr_t wave, uint32_t position) {\n    return position < (102 * (wave - SW_SQUARE_10 + 1)) ? -0x7fff : 0x7fff;\n}\n\nstatic int silenceTone(uintptr_t userData, uint32_t position) {\n    (void)userData;\n    (void)position;\n    return 0;\n}\n\nstatic gentone_t getWaveFn(uint8_t wave) {\n    switch (wave) {\n    case SW_TRIANGLE:\n        return triangleTone;\n    case SW_SAWTOOTH:\n        return sawtoothTone;\n    case SW_NOISE:\n        return noiseTone;\n    case SW_SINE:\n        return sineTone;\n    default:\n        if (SW_SQUARE_10 <= wave && wave <= SW_SQUARE_50)\n            return squareWaveTone;\n        else\n            return silenceTone;\n    }\n}\n\n#define CLAMP(lo, v, hi) ((v) = ((v) < (lo) ? (lo) : (v) > (hi) ? (hi) : (v)))\n\nint WSynthesizer::updateQueues() {\n    const int maxTime = 0xffffff;\n    while (1) {\n        WaitingSound *p;\n        int minLeft = maxTime;\n        for (p = waiting; p; p = p->next) {\n            int timeLeft =\n                p->state == SoundState::Waiting ? p->startSampleNo - currSample : maxTime;\n            if (timeLeft <= 0) {\n                break;\n            }\n            if (timeLeft < minLeft)\n                minLeft = timeLeft;\n        }\n        if (p) {\n            PlayingSound *snd;\n            int minIdx = -1;\n            for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n                snd = &playingSounds[i];\n                if (snd->sound == NULL)\n                    break;\n                if (minIdx == -1 ||\n                    playingSounds[minIdx].startSampleNo < playingSounds[i].startSampleNo)\n                    minIdx = i;\n                snd = NULL;\n            }\n            // if we didn't find a free slot, expel the oldest sound\n            if (!snd)\n                snd = &playingSounds[minIdx];\n            if (snd->sound)\n                snd->sound->state = SoundState::Done;\n            snd->sound = p;\n            p->state = SoundState::Playing;\n            snd->startSampleNo = currSample;\n            snd->currInstr = (SoundInstruction *)p->instructions->data;\n            snd->instrEnd = snd->currInstr + p->instructions->length / sizeof(SoundInstruction);\n            for (auto p = snd->currInstr; p < snd->instrEnd; p++) {\n                CLAMP(20, p->frequency, 20000);\n                CLAMP(20, p->endFrequency, 20000);\n                CLAMP(0, p->startVolume, 1023);\n                CLAMP(0, p->endVolume, 1023);\n                CLAMP(1, p->duration, 60000);\n            }\n            snd->prevVolume = -1;\n        } else {\n            // no more sounds to move\n            return minLeft;\n        }\n    }\n}\n\nint WSynthesizer::fillSamples(int16_t *dst, int numsamples) {\n    if (numsamples <= 0)\n        return 1;\n\n    int timeLeft = updateQueues();\n    int res = waiting != NULL;\n\n    // if there's a pending sound to be started somewhere during numsamples,\n    // split the call into two\n    if (timeLeft < numsamples) {\n        fillSamples(dst, timeLeft);\n        LOG(\"M split %d\", timeLeft);\n        fillSamples(dst + timeLeft, numsamples - timeLeft);\n        return 1;\n    }\n\n    memset(dst, 0, numsamples * 2);\n\n    uint32_t samplesPerMS = (sampleRate << 8) / 1000;\n    float toneStepMult = (1024.0 * (1 << 16)) / sampleRate;\n    const int MAXVAL = (1 << (OUTPUT_BITS - 1)) - 1;\n\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        PlayingSound *snd = &playingSounds[i];\n        if (snd->sound == NULL)\n            continue;\n\n        res = 1;\n\n        SoundInstruction *instr = NULL;\n        gentone_t fn = NULL;\n        snd->currInstr--;\n        uint32_t toneStep = 0;\n        int32_t toneDelta = 0;\n        int32_t volumeStep = 0;\n        uint32_t tonePosition = snd->tonePosition;\n        uint32_t samplesLeft = 0;\n        uint8_t wave = 0;\n        int32_t volume = 0;\n        uint32_t prevFreq = 0;\n        uint32_t prevEndFreq = 0;\n\n        for (int j = 0; j < numsamples; ++j) {\n            if (samplesLeft == 0) {\n                instr = ++snd->currInstr;\n                if (instr >= snd->instrEnd) {\n                    break;\n                }\n                wave = instr->soundWave;\n                fn = getWaveFn(wave);\n\n                samplesLeft = (uint32_t)(instr->duration * samplesPerMS >> 8);\n                volumeStep = ((int)(instr->endVolume - instr->startVolume) << 16) / samplesLeft;\n\n                if (j == 0 && snd->prevVolume != -1) {\n                    // restore previous state\n                    samplesLeft = snd->samplesLeftInCurr;\n                    volume = snd->prevVolume;\n                    toneStep = snd->prevToneStep;\n                    toneDelta = snd->prevToneDelta;\n                    prevFreq = instr->frequency;\n                    prevEndFreq = instr->endFrequency;\n                } else {\n                    LOG(\"#sampl %d %p\", samplesLeft, instr);\n                    volume = instr->startVolume << 16;\n                    if (prevFreq != instr->frequency || prevEndFreq != instr->endFrequency) {\n                        toneStep = (uint32_t)(toneStepMult * instr->frequency);\n                        if (instr->frequency != instr->endFrequency) {\n                            uint32_t endToneStep = (uint32_t)(toneStepMult * instr->endFrequency);\n                            toneDelta = (int32_t)(endToneStep - toneStep) / (int32_t)samplesLeft;\n                        } else {\n                            toneDelta = 0;\n                        }\n                        prevFreq = instr->frequency;\n                        prevEndFreq = instr->endFrequency;\n                    }\n                }\n            }\n\n            int v = fn(wave, (tonePosition >> 16) & 1023);\n            v = (v * (volume >> 16)) >> (10 + (16 - OUTPUT_BITS));\n\n            // if (v > MAXVAL)\n            //    target_panic(123);\n\n            dst[j] += v;\n\n            tonePosition += toneStep;\n            toneStep += toneDelta;\n            volume += volumeStep;\n            samplesLeft--;\n        }\n\n        if (instr >= snd->instrEnd) {\n            snd->sound->state = SoundState::Done;\n            snd->sound = NULL;\n        } else {\n            snd->tonePosition = tonePosition;\n            if (samplesLeft == 0)\n                samplesLeft++; // avoid infinite loop in next iteration\n            snd->samplesLeftInCurr = samplesLeft;\n            snd->prevVolume = volume;\n            snd->prevToneDelta = toneDelta;\n            snd->prevToneStep = toneStep;\n        }\n    }\n\n    currSample += numsamples;\n\n    for (int j = 0; j < numsamples; ++j) {\n        if (dst[j] > MAXVAL)\n            dst[j] = MAXVAL;\n        else if (dst[j] < -MAXVAL)\n            dst[j] = -MAXVAL;\n    }\n\n    return res;\n}\n\n//%\nvoid enableAmp(int enabled) {\n    // this is also compiled on linux\n#ifdef LOOKUP_PIN\n    auto pin = LOOKUP_PIN(SPEAKER_AMP);\n    if (pin) {\n        if (PIN(SPEAKER_AMP) & CFG_PIN_CONFIG_ACTIVE_LO)\n            enabled = !enabled;\n        pin->setDigitalValue(enabled);\n    }\n#endif\n}\n\n//%\nvoid forceOutput(int outp) {\n    auto snd = getWSynthesizer();\n    snd->out.setOutput(outp);\n}\n\n//%\nvoid queuePlayInstructions(int when, Buffer buf) {\n    auto snd = getWSynthesizer();\n\n    registerGCObj(buf);\n\n    auto p = new WaitingSound;\n    p->state = SoundState::Waiting;\n    p->instructions = buf;\n    p->startSampleNo = snd->currSample + when * snd->sampleRate / 1000;\n\n    LOG(\"Queue %dms now=%d off=%d %p\", when, snd->currSample, p->startSampleNo - snd->currSample,\n        buf->data);\n\n    target_disable_irq();\n    // add new sound to queue\n    p->next = snd->waiting;\n    snd->waiting = p;\n    // remove sounds that have already been fully played\n    while (p) {\n        while (p->next && p->next->state == SoundState::Done) {\n            auto todel = p->next;\n            p->next = todel->next;\n            unregisterGCObj(todel->instructions);\n            delete todel;\n        }\n        p = p->next;\n    }\n    target_enable_irq();\n\n    snd->poke();\n}\n\n//%\nvoid stopPlaying() {\n    LOG(\"stop playing!\");\n\n    auto snd = getWSynthesizer();\n\n    target_disable_irq();\n    auto p = snd->waiting;\n    snd->waiting = NULL;\n    for (unsigned i = 0; i < MAX_SOUNDS; ++i) {\n        snd->playingSounds[i].sound = NULL;\n    }\n    while (p) {\n        auto n = p->next;\n        unregisterGCObj(p->instructions);\n        delete p;\n        p = n;\n    }\n    target_enable_irq();\n}\n\nWSynthesizer::WSynthesizer() : upstream(NULL), out(*this) {\n    currSample = 0;\n    active = false;\n    sampleRate = out.dac.getSampleRate();\n    memset(&playingSounds, 0, sizeof(playingSounds));\n    waiting = NULL;\n    PXT_REGISTER_RESET(stopPlaying);\n}\n\n} // namespace music\n\nnamespace jacdac {\n__attribute__((weak)) void setJackRouterOutput(int output) {}\n} // namespace jacdac",
            "melody.h": "#pragma once\n\n#ifndef OUTPUT_BITS\n#define OUTPUT_BITS 10\n#endif\n\n#define SW_TRIANGLE 1\n#define SW_SAWTOOTH 2\n#define SW_SINE 3 // TODO remove it? it takes space\n#define SW_NOISE 5\n#define SW_SQUARE_10 11\n#define SW_SQUARE_50 15\n\nstruct SoundInstruction {\n    uint8_t soundWave;\n    uint8_t flags;\n    uint16_t frequency;    // Hz\n    uint16_t duration;     // ms\n    int16_t startVolume;   // 0-1023\n    int16_t endVolume;     // 0-1023\n    uint16_t endFrequency; // Hz\n};\n\n#ifdef DATASTREAM_MAXIMUM_BUFFERS\n#define CODAL 1\n#endif\n\nnamespace music {\n\n#define MAX_SOUNDS 5\n\nSTATIC_ASSERT((1 << (16 - OUTPUT_BITS)) > MAX_SOUNDS);\n\nenum class SoundState : uint8_t {\n    Waiting, //\n    Playing, //\n    Done     //\n};\n\nstruct WaitingSound {\n    uint32_t startSampleNo;\n    SoundState state;\n    WaitingSound *next;\n    Buffer instructions;\n};\n\nstruct PlayingSound {\n    uint32_t startSampleNo;\n    uint32_t samplesLeftInCurr;\n    uint32_t tonePosition;\n    int32_t prevVolume;\n    uint32_t prevToneStep;\n    int32_t prevToneDelta;\n    WaitingSound *sound;\n    SoundInstruction *currInstr, *instrEnd;\n};\n\nclass WSynthesizer\n#ifdef CODAL\n    : public DataSource\n#endif\n{\n  public:\n#ifdef CODAL\n    DataSink *upstream;\n#else\n    void *upstream;\n#endif\n    uint32_t currSample; // after 25h of playing we might get a glitch\n    int32_t sampleRate;  // eg 44100\n    PlayingSound playingSounds[MAX_SOUNDS];\n    WaitingSound *waiting;\n    bool active;\n\n    SoundOutput out;\n\n    int fillSamples(int16_t *dst, int numsamples);\n    int updateQueues();\n\n    WSynthesizer();\n    virtual ~WSynthesizer() {}\n\n    void pokeUpstream() {\n#ifdef CODAL\n        if (upstream) {\n            upstream->pullRequest();\n        }\n#endif\n    }\n\n    void poke() {\n        if (!active) {\n            active = true;\n            pokeUpstream();\n        }\n    }\n\n#ifdef CODAL\n    virtual ManagedBuffer pull() {\n        ManagedBuffer data(512);\n        auto dp = (int16_t *)data.getBytes();\n        auto sz = 512 / 2;\n        int r = fillSamples(dp, sz);\n#if defined(NRF52_SERIES)\n        int mul = out.dac.getSampleRange();\n#endif\n        while (sz--) {\n#if defined(NRF52_SERIES)\n            *dp = ((-*dp + (1 << (OUTPUT_BITS - 1))) * mul) >> OUTPUT_BITS;\n#else\n            *dp += 1 << (OUTPUT_BITS - 1);\n#endif\n            dp++;\n        }\n        if (!r) {\n            active = false;\n            // return empty - nothing left to play\n            return ManagedBuffer();\n        }\n        pokeUpstream();\n        return data;\n    }\n    virtual void connect(DataSink &sink) { upstream = &sink; }\n#endif\n};\n\n} // namespace music\n",
            "melody.ts": "enum MusicOutput {\n    AutoDetect = 0,\n    Buzzer = 1,\n    HeadPhones = 2,\n}\n\nnamespace music {\n    //% whenUsed\n    const freqs = hex`\n        1f00210023002500270029002c002e003100340037003a003e004100450049004e00520057005c00620068006e00\n        75007b0083008b0093009c00a500af00b900c400d000dc00e900f70006011501260137014a015d01720188019f01\n        b801d201ee010b022a024b026e029302ba02e40210033f037003a403dc03170455049704dd0427057505c8052006\n        7d06e0064907b8072d08a9082d09b9094d0aea0a900b400cfa0cc00d910e6f0f5a1053115b1272139a14d4152017\n        8018f519801b231dde1e`\n\n    //% shim=music::queuePlayInstructions\n    function queuePlayInstructions(timeDelta: number, buf: Buffer) { }\n\n    //% shim=music::stopPlaying\n    function stopPlaying() { }\n\n    //% shim=music::forceOutput\n    export function forceOutput(buf: MusicOutput) { }\n\n    let globalVolume: number = null\n\n    const BUFFER_SIZE: number = 12;\n\n    //% shim=music::enableAmp\n    function enableAmp(en: number) {\n        return // for sim\n    }\n\n    function initVolume() {\n        if (globalVolume === null) {\n            globalVolume = 0\n            setVolume(control.getConfigValue(DAL.CFG_SPEAKER_VOLUME, 128))\n        }\n    }\n\n    /**\n     * Set the default output volume of the sound synthesizer.\n     * @param volume the volume 0...255\n     */\n    //% blockId=synth_set_volume block=\"set volume %volume\"\n    //% parts=\"speaker\"\n    //% volume.min=0 volume.max=255\n    //% volume.defl=20\n    //% help=music/set-volume\n    //% weight=70\n    //% group=\"Volume\"\n    export function setVolume(volume: number): void {\n        globalVolume = Math.clamp(0, 255, volume | 0)\n        enableAmp(globalVolume > 0 ? 1 : 0)\n    }\n\n    /**\n     * Gets the current volume\n     */\n    //% parts=\"speaker\"\n    //% weight=70\n    export function volume(): number {\n        initVolume()\n        return globalVolume;\n    }\n\n    function playNoteCore(when: number, frequency: number, ms: number) {\n        let buf = control.createBuffer(BUFFER_SIZE)\n        addNote(buf, 0, ms, 255, 255, 3, frequency, volume(), frequency)\n        queuePlayInstructions(when, buf)\n    }\n\n    /**\n     * Play a tone through the speaker for some amount of time.\n     * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n     * @param ms tone duration in milliseconds (ms), eg: BeatFraction.Half\n     */\n    //% help=music/play-tone\n    //% blockId=mixer_play_note block=\"play tone|at %note=device_note|for %duration=device_beat\"\n    //% parts=\"headphone\" async\n    //% blockNamespace=music\n    //% weight=76 blockGap=8\n    //% group=\"Tone\"\n    export function playTone(frequency: number, ms: number): void {\n        if (ms == 0)\n            ms = 86400000 // 1 day\n\n        if (ms <= 2000) {\n            playNoteCore(0, frequency, ms)\n            pause(ms)\n        } else {\n            const id = ++playToneID\n            control.runInParallel(() => {\n                let pos = control.millis()\n                while (id == playToneID && ms > 0) {\n                    let now = control.millis()\n                    let d = pos - now\n                    let t = Math.min(ms, 500)\n                    ms -= t\n                    pos += t\n                    playNoteCore(d - 1, frequency, t)\n                    if (ms == 0)\n                        pause(d + t)\n                    else\n                        pause(d + t - 100)\n                }\n            })\n        }\n    }\n\n    let playToneID = 0\n\n    /**\n     * Play a melody from the melody editor.\n     * @param melody - string of up to eight notes [C D E F G A B C5] or rests [-] separated by spaces, \n     * which will be played one at a time, ex: \"E D G F B A C5 B \"\n     * @param tempo - number in beats per minute (bpm), dictating how long each note will play for\n     */\n    //% block=\"play melody $melody at tempo $tempo|(bpm)\" blockId=playMelody\n    //% blockNamespace=music\n    //% weight=85 blockGap=8 help=music/play-melody\n    //% group=\"Melody\"\n    //% melody.shadow=\"melody_editor\"\n    //% tempo.min=40 tempo.max=500\n    //% tempo.defl=120\n    export function playMelody(melody: string, tempo: number) {\n        let notes: string[] = melody.split(\" \").filter(n => !!n);\n        let formattedMelody = \"\";\n        let newOctave = false;\n\n        // build melody string, replace '-' with 'R' and add tempo\n        // creates format like \"C5-174 B4 A G F E D C \"\n        for (let i = 0; i < notes.length; i++) {\n            if (notes[i] === \"-\") {\n                notes[i] = \"R\";\n            } else if (notes[i] === \"C5\") {\n                newOctave = true;\n            } else if (newOctave) { // change the octave if necesary\n                notes[i] += \"4\";\n                newOctave = false;\n            }\n            // add tempo after first note\n            if (i == 0) {\n                formattedMelody += notes[i] + \"-\" + tempo + \" \";\n            } else {\n                formattedMelody += notes[i] + \" \";\n            }\n        }\n\n        const song = new Melody(formattedMelody);\n        song.playUntilDone();\n    }\n\n\n    /**\n     * Create a melody with the melody editor.\n     * @param melody\n     */\n    //% block=\"$melody\" blockId=melody_editor\n    //% blockNamespace=music\n    //% blockHidden = true\n    //% weight=85 blockGap=8\n    //% help=music/melody-editor\n    //% group=\"Melody\" duplicateShadowOnDrag\n    //% melody.fieldEditor=\"melody\"\n    //% melody.fieldOptions.decompileLiterals=true\n    //% melody.fieldOptions.decompileIndirectFixedInstances=\"true\"\n    //% melody.fieldOptions.onParentBlock=\"true\"\n    //% shim=TD_ID\n    export function melodyEditor(melody: string): string {\n        return melody;\n    }\n\n    /**\n     * Stop all sounds from playing.\n     */\n    //% help=music/stop-all-sounds\n    //% blockId=music_stop_all_sounds block=\"stop all sounds\"\n    //% weight=10\n    //% group=\"Sounds\"\n    export function stopAllSounds() {\n        Melody.stopAll();\n        stopPlaying();\n    }\n\n    //% fixedInstances\n    export class Melody {\n        _text: string;\n        private _player: MelodyPlayer;\n\n        private static playingMelodies: Melody[];\n\n        static stopAll() {\n            if (Melody.playingMelodies) {\n                const ms = Melody.playingMelodies.slice(0, Melody.playingMelodies.length);\n                ms.forEach(p => p.stop());\n            }\n        }\n\n        constructor(text: string) {\n            this._text = text\n        }\n\n        get text() {\n            return this._text;\n        }\n\n        /**\n         * Stop playing a sound\n         */\n        //% blockId=mixer_stop block=\"stop sound %sound\"\n        //% help=music/melody/stop\n        //% parts=\"headphone\"\n        //% weight=92 blockGap=8\n        //% group=\"Sounds\"\n        stop() {\n            if (this._player) {\n                this._player.stop()\n                this._player = null\n            }\n            this.unregisterMelody();\n        }\n\n        private registerMelody() {\n            // keep track of the active players\n            if (!Melody.playingMelodies) Melody.playingMelodies = [];\n            // stop and pop melodies if too many playing\n            if (Melody.playingMelodies.length > 4) {\n                // stop last player (also pops)\n                Melody.playingMelodies[Melody.playingMelodies.length - 1].stop();\n            }\n            // put back the melody on top of the melody stack\n            Melody.playingMelodies.removeElement(this);\n            Melody.playingMelodies.push(this);\n        }\n        private unregisterMelody() {\n            // remove from list\n            if (Melody.playingMelodies) {\n                Melody.playingMelodies.removeElement(this); // remove self\n            }\n        }\n\n        private playCore(volume: number, loop: boolean) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this.registerMelody();\n            control.runInParallel(() => {\n                while (this._player == p) {\n                    p.play(volume)\n                    if (!loop)\n                        break\n                }\n                this.unregisterMelody();\n            })\n        }\n\n        /**\n         * Start playing a sound in a loop and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/loop\n        //% blockId=mixer_loop_sound block=\"loop sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=93 blockGap=8\n        //% group=\"Sounds\"\n        loop(volume = 255) {\n            this.playCore(volume, true)\n        }\n\n        /**\n         * Start playing a sound and don't wait for it to finish.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play\n        //% blockId=mixer_play_sound block=\"play sound %sound\"\n        //% parts=\"headphone\"\n        //% weight=95 blockGap=8\n        //% group=\"Sounds\"\n        play(volume = 255) {\n            this.playCore(volume, false)\n        }\n\n\n        /**\n         * Play a sound and wait until the sound is done.\n         * @param sound the melody to play\n         */\n        //% help=music/melody/play-until-done\n        //% blockId=mixer_play_sound_until_done block=\"play sound %sound|until done\"\n        //% parts=\"headphone\"\n        //% weight=94 blockGap=8\n        //% group=\"Sounds\"\n        playUntilDone(volume = 255) {\n            this.stop()\n            const p = this._player = new MelodyPlayer(this)\n            this._player.onPlayFinished = () => {\n                if (p == this._player)\n                    this.unregisterMelody();\n            }\n            this.registerMelody();\n            this._player.play(volume)\n        }\n\n        toString() {\n            return this._text;\n        }\n    }\n\n    function addNote(sndInstr: Buffer, sndInstrPtr: number, ms: number, beg: number, end: number, soundWave: number, hz: number, volume: number, endHz: number) {\n        if (ms > 0) {\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, soundWave)\n            sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr + 1, 0)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 2, hz)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 4, ms)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 6, (beg * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 8, (end * volume) >> 6)\n            sndInstr.setNumber(NumberFormat.UInt16LE, sndInstrPtr + 10, endHz);\n            sndInstrPtr += BUFFER_SIZE;\n        }\n        sndInstr.setNumber(NumberFormat.UInt8LE, sndInstrPtr, 0) // terminate\n        return sndInstrPtr\n    }\n\n\n    export class MelodyPlayer {\n        melody: Melody;\n\n        onPlayFinished: () => void;\n\n        constructor(m: Melody) {\n            this.melody = m\n        }\n\n        stop() {\n            this.melody = null\n        }\n\n        protected queuePlayInstructions(timeDelta: number, buf: Buffer) {\n            queuePlayInstructions(timeDelta, buf)\n        }\n\n        play(volume: number) {\n            if (!this.melody)\n                return\n            volume = Math.clamp(0, 255, (volume * music.volume()) >> 8)\n\n            let notes = this.melody._text\n            let pos = 0;\n            let duration = 4; //Default duration (Crotchet)\n            let octave = 4; //Middle octave\n            let tempo = 120; // default tempo\n\n            let hz = 0\n            let endHz = -1\n            let ms = 0\n            let timePos = 0\n            let startTime = control.millis()\n            let now = 0\n\n            let envA = 0\n            let envD = 0\n            let envS = 255\n            let envR = 0\n            let soundWave = 1 // triangle\n            let sndInstr = control.createBuffer(5 * BUFFER_SIZE)\n            let sndInstrPtr = 0\n\n            const addForm = (formDuration: number, beg: number, end: number, msOff: number) => {\n                let freqStart = hz;\n                let freqEnd = endHz;\n\n                const envelopeWidth = ms > 0 ? ms : duration * Math.idiv(15000, tempo) + envR;\n                if (endHz != hz && envelopeWidth != 0) {\n                    const slope = (freqEnd - freqStart) / envelopeWidth;\n                    freqStart = hz + slope * msOff;\n                    freqEnd = hz + slope * (msOff + formDuration);\n                }\n                sndInstrPtr = addNote(sndInstr, sndInstrPtr, formDuration, beg, end, soundWave, freqStart, volume, freqEnd);\n            }\n\n            const scanNextWord = () => {\n                if (!this.melody)\n                    return \"\"\n\n                // eat space\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t')\n                        break;\n                    pos++;\n                }\n\n                // read note\n                let note = \"\";\n                while (pos < notes.length) {\n                    const c = notes[pos];\n                    if (c == ' ' || c == '\\r' || c == '\\n' || c == '\\t')\n                        break;\n                    note += c;\n                    pos++;\n                }\n                return note;\n            }\n\n            enum Token {\n                Note,\n                Octave,\n                Beat,\n                Tempo,\n                Hz,\n                EndHz,\n                Ms,\n                WaveForm,\n                EnvelopeA,\n                EnvelopeD,\n                EnvelopeS,\n                EnvelopeR\n            }\n\n            let token: string = \"\";\n            let tokenKind = Token.Note;\n\n            // [ABCDEFG] (\\d+)  (:\\d+)  (-\\d+)\n            // note      octave length  tempo\n            // R (:\\d+) - rest\n            // !\\d+,\\d+ - sound at frequency with given length (Hz,ms); !\\d+ and !\\d+,:\\d+ also possible\n            // @\\d+,\\d+,\\d+,\\d+ - ADSR envelope - ms,ms,volume,ms; volume is 0-255\n            // ~\\d+ - wave form:\n            //   1 - triangle\n            //   2 - sawtooth\n            //   3 - sine\n            //   5 - noise\n            //   11 - square 10%\n            //   12 - square 20%\n            //   ...\n            //   15 - square 50%\n            //\n\n            const consumeToken = () => {\n                if (token && tokenKind != Token.Note) {\n                    const d = parseInt(token);\n                    switch (tokenKind) {\n                        case Token.Octave: octave = d; break;\n                        case Token.Beat:\n                            duration = Math.max(1, Math.min(16, d));\n                            ms = -1;\n                            break;\n                        case Token.Tempo: tempo = Math.max(1, d); break;\n                        case Token.Hz: hz = d; tokenKind = Token.Ms; break;\n                        case Token.Ms: ms = d; break;\n                        case Token.WaveForm: soundWave = Math.clamp(1, 15, d); break;\n                        case Token.EnvelopeA: envA = d; tokenKind = Token.EnvelopeD; break;\n                        case Token.EnvelopeD: envD = d; tokenKind = Token.EnvelopeS; break;\n                        case Token.EnvelopeS: envS = Math.clamp(0, 255, d); tokenKind = Token.EnvelopeR; break;\n                        case Token.EnvelopeR: envR = d; break;\n                        case Token.EndHz: endHz = d; break;\n                    }\n                    token = \"\";\n                }\n            }\n\n            while (true) {\n                let currNote = scanNextWord();\n                let prevNote: boolean = false;\n                if (!currNote) {\n                    let timeLeft = timePos - now\n                    if (timeLeft > 0)\n                        pause(timeLeft)\n                    if (this.onPlayFinished)\n                        this.onPlayFinished();\n                    return;\n                }\n\n                hz = -1;\n\n                let note: number = 0;\n                token = \"\";\n                tokenKind = Token.Note;\n\n                for (let i = 0; i < currNote.length; i++) {\n                    let noteChar = currNote.charAt(i);\n                    switch (noteChar) {\n                        case 'c': case 'C': note = 1; prevNote = true; break;\n                        case 'd': case 'D': note = 3; prevNote = true; break;\n                        case 'e': case 'E': note = 5; prevNote = true; break;\n                        case 'f': case 'F': note = 6; prevNote = true; break;\n                        case 'g': case 'G': note = 8; prevNote = true; break;\n                        case 'a': case 'A': note = 10; prevNote = true; break;\n                        case 'B': note = 12; prevNote = true; break;\n                        case 'r': case 'R': hz = 0; prevNote = false; break;\n                        case '#': note++; prevNote = false; break;\n                        case 'b': if (prevNote) note--; else { note = 12; prevNote = true; } break;\n                        case ',':\n                            consumeToken();\n                            prevNote = false;\n                            break;\n                        case '!':\n                            tokenKind = Token.Hz;\n                            prevNote = false;\n                            break;\n                        case '@':\n                            consumeToken();\n                            tokenKind = Token.EnvelopeA;\n                            prevNote = false;\n                            break;\n                        case '~':\n                            consumeToken();\n                            tokenKind = Token.WaveForm;\n                            prevNote = false;\n                            break;\n                        case ':':\n                            consumeToken();\n                            tokenKind = Token.Beat;\n                            prevNote = false;\n                            break;\n                        case '-':\n                            consumeToken();\n                            tokenKind = Token.Tempo;\n                            prevNote = false;\n                            break;\n                        case '^':\n                            consumeToken();\n                            tokenKind = Token.EndHz;\n                            break;\n                        default:\n                            if (tokenKind == Token.Note)\n                                tokenKind = Token.Octave;\n                            token += noteChar;\n                            prevNote = false;\n                            break;\n                    }\n                }\n                consumeToken();\n\n                if (note && hz < 0) {\n                    const keyNumber = note + (12 * (octave - 1));\n                    hz = freqs.getNumber(NumberFormat.UInt16LE, keyNumber * 2) || 0;\n                }\n\n                let currMs = ms\n\n                if (currMs <= 0) {\n                    const beat = Math.idiv(15000, tempo);\n                    currMs = duration * beat\n                }\n\n                if (hz < 0) {\n                    // no frequency specified, so no duration\n                } else if (hz == 0) {\n                    timePos += currMs\n                } else {\n                    if (endHz < 0) {\n                        endHz = hz;\n                    }\n\n                    sndInstrPtr = 0\n                    addForm(envA, 0, 255, 0)\n                    addForm(envD, 255, envS, envA)\n                    addForm(currMs - (envA + envD), envS, envS, envD + envA)\n                    addForm(envR, envS, 0, currMs)\n\n                    this.queuePlayInstructions(timePos - now, sndInstr.slice(0, sndInstrPtr))\n                    endHz = -1;\n                    timePos += currMs // don't add envR - it's supposed overlap next sound\n                }\n\n                let timeLeft = timePos - now\n                if (timeLeft > 200) {\n                    pause(timeLeft - 100)\n                    now = control.millis() - startTime\n                }\n            }\n        }\n    }\n\n    //% fixedInstance whenUsed block=\"ba ding\"\n    export const baDing = new Melody('b5:1 e6:3')\n\n    //% fixedInstance whenUsed block=\"wawawawaa\"\n    export const wawawawaa = new Melody('~15 e3:3 r:1 d#:3 r:1 d:4 r:1 c#:8')\n\n    //% fixedInstance whenUsed block=\"jump up\"\n    export const jumpUp = new Melody('c5:1 d e f g')\n\n    //% fixedInstance whenUsed block=\"jump down\"\n    export const jumpDown = new Melody('g5:1 f e d c')\n\n    //% fixedInstance whenUsed block=\"power up\"\n    export const powerUp = new Melody('g4:1 c5 e g:2 e:1 g:3')\n\n    //% fixedInstance whenUsed block=\"power down\"\n    export const powerDown = new Melody('g5:1 d# c g4:2 b:1 c5:3')\n\n    //% fixedInstance whenUsed block=\"magic wand\"\n    export const magicWand = new Melody('F#6:1-300 G# A# B C7# D# F F# G# A# B:6')\n    //A#7:1-200 A:1 A#7:1 A:1 A#7:2\n\n    //% fixedInstance whenUsed block=\"siren\"\n    export const siren = new Melody('a4 d5 a4 d5 a4 d5')\n\n    //% fixedInstance whenUsed block=\"pew pew\"\n    export const pewPew = new Melody('!1200,200^50')\n}\n",
            "music.ts": "enum Note {\n    //% blockIdentity=music.noteFrequency enumval=262\n    C = 262,\n    //% block=C#\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F = 349,\n    //% block=F#\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G = 392,\n    //% block=G#\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B = 494,\n    //% blockIdentity=music.noteFrequency enumval=131\n    C3 = 131,\n    //% block=C#3\n    //% blockIdentity=music.noteFrequency enumval=139\n    CSharp3 = 139,\n    //% blockIdentity=music.noteFrequency enumval=147\n    D3 = 147,\n    //% blockIdentity=music.noteFrequency enumval=156\n    Eb3 = 156,\n    //% blockIdentity=music.noteFrequency enumval=165\n    E3 = 165,\n    //% blockIdentity=music.noteFrequency enumval=175\n    F3 = 175,\n    //% block=F#3\n    //% blockIdentity=music.noteFrequency enumval=185\n    FSharp3 = 185,\n    //% blockIdentity=music.noteFrequency enumval=196\n    G3 = 196,\n    //% block=G#3\n    //% blockIdentity=music.noteFrequency enumval=208\n    GSharp3 = 208,\n    //% blockIdentity=music.noteFrequency enumval=220\n    A3 = 220,\n    //% blockIdentity=music.noteFrequency enumval=233\n    Bb3 = 233,\n    //% blockIdentity=music.noteFrequency enumval=247\n    B3 = 247,\n    //% blockIdentity=music.noteFrequency enumval=262\n    C4 = 262,\n    //% block=C#4\n    //% blockIdentity=music.noteFrequency enumval=277\n    CSharp4 = 277,\n    //% blockIdentity=music.noteFrequency enumval=294\n    D4 = 294,\n    //% blockIdentity=music.noteFrequency enumval=311\n    Eb4 = 311,\n    //% blockIdentity=music.noteFrequency enumval=330\n    E4 = 330,\n    //% blockIdentity=music.noteFrequency enumval=349\n    F4 = 349,\n    //% block=F#4\n    //% blockIdentity=music.noteFrequency enumval=370\n    FSharp4 = 370,\n    //% blockIdentity=music.noteFrequency enumval=392\n    G4 = 392,\n    //% block=G#4\n    //% blockIdentity=music.noteFrequency enumval=415\n    GSharp4 = 415,\n    //% blockIdentity=music.noteFrequency enumval=440\n    A4 = 440,\n    //% blockIdentity=music.noteFrequency enumval=466\n    Bb4 = 466,\n    //% blockIdentity=music.noteFrequency enumval=494\n    B4 = 494,\n    //% blockIdentity=music.noteFrequency enumval=523\n    C5 = 523,\n    //% block=C#5\n    //% blockIdentity=music.noteFrequency enumval=555\n    CSharp5 = 555,\n    //% blockIdentity=music.noteFrequency enumval=587\n    D5 = 587,\n    //% blockIdentity=music.noteFrequency enumval=622\n    Eb5 = 622,\n    //% blockIdentity=music.noteFrequency enumval=659\n    E5 = 659,\n    //% blockIdentity=music.noteFrequency enumval=698\n    F5 = 698,\n    //% block=F#5\n    //% blockIdentity=music.noteFrequency enumval=740\n    FSharp5 = 740,\n    //% blockIdentity=music.noteFrequency enumval=784\n    G5 = 784,\n    //% block=G#5\n    //% blockIdentity=music.noteFrequency enumval=831\n    GSharp5 = 831,\n    //% blockIdentity=music.noteFrequency enumval=880\n    A5 = 880,\n    //% blockIdentity=music.noteFrequency enumval=932\n    Bb5 = 932,\n    //% blockIdentity=music.noteFrequency enumval=988\n    B5 = 988,\n}\n\nenum BeatFraction {\n    //% block=1\n    Whole = 1,\n    //% block=\"1/2\"\n    Half = 2,\n    //% block=\"1/4\"\n    Quarter = 4,\n    //% block=\"1/8\"\n    Eighth = 8,\n    //% block=\"1/16\"\n    Sixteenth = 16,\n    //% block=\"2\"\n    Double = 32,\n    //% block=\"4\",\n    Breve = 64\n}\n\nnamespace music {\n\n    let beatsPerMinute: number;\n\n    /**\n    * Play a tone.\n    * @param frequency pitch of the tone to play in Hertz (Hz), eg: Note.C\n    */\n    //% help=music/ring-tone\n    //% blockId=music_ring block=\"ring tone|at %note=device_note\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music inBasicCategory=true\n    //% weight=75 blockGap=8\n    //% group=\"Tone\"\n    export function ringTone(frequency: number) {\n        playTone(frequency, 0);\n    }\n\n    /**\n    * Rest, or play silence, for some time (in milleseconds).\n    * @param ms rest duration in milliseconds (ms), eg: BeatFraction.Half\n    */\n    //% help=music/rest\n    //% blockId=music_rest block=\"rest|for %duration=device_beat\"\n    //% parts=\"headphone\" trackArgs=0\n    //% blockNamespace=music\n    //% weight=74\n    //% group=\"Tone\"\n    export function rest(ms: number) {\n        playTone(0, Math.max(ms, 20));\n    }\n\n    function init() {\n        if (!beatsPerMinute) beatsPerMinute = 120;\n    }\n\n    /**\n     * Return the duration of a beat in milliseconds (the beat fraction).\n     * @param fraction the fraction of the current whole note, eg: BeatFraction.Half\n     */\n    //% help=music/beat\n    //% blockId=device_beat block=\"%fraction|beat\"\n    //% weight=9 blockGap=8\n    //% group=\"Tempo\"\n    export function beat(fraction?: BeatFraction): number {\n        init();\n        if (fraction == null) fraction = BeatFraction.Whole;\n        let beat = 60000 / beatsPerMinute;\n        switch (fraction) {\n            case BeatFraction.Half: beat /= 2; break;\n            case BeatFraction.Quarter: beat /= 4; break;\n            case BeatFraction.Eighth: beat /= 8; break;\n            case BeatFraction.Sixteenth: beat /= 16; break;\n            case BeatFraction.Double: beat *= 2; break;\n            case BeatFraction.Breve: beat *= 4; break;\n        }\n        return beat >> 0;\n    }\n\n    /**\n     * Return the tempo in beats per minute (bpm).\n     * Tempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.\n     */\n    //% help=music/tempo\n    //% blockId=device_tempo block=\"tempo (bpm)\"\n    //% weight=64\n    //% group=\"Tempo\"\n    export function tempo(): number {\n        init();\n        return beatsPerMinute;\n    }\n\n    /**\n     * Change the tempo up or down by some amount of beats per minute (bpm).\n     * @param bpm The change in beats per minute to the tempo, eg: 20\n     */\n    //% help=music/change-tempo-by weight=37\n    //% blockId=device_change_tempo block=\"change tempo by %value|(bpm)\"\n    //% weight=66 blockGap=8\n    //% group=\"Tempo\"\n    export function changeTempoBy(bpm: number): void {\n        init();\n        setTempo(beatsPerMinute + bpm);\n    }\n\n    /**\n     * Set the tempo a number of beats per minute (bpm).\n     * @param bpm The new tempo in beats per minute, eg: 120\n     */\n    //% help=music/set-tempo\n    //% blockId=device_set_tempo block=\"set tempo to %value|(bpm)\"\n    //% bpm.min=4 bpm.max=400\n    //% weight=65 blockGap=8\n    //% group=\"Tempo\"\n    export function setTempo(bpm: number): void {\n        init();\n        if (bpm > 0) {\n            beatsPerMinute = Math.max(1, bpm >> 0);\n        }\n    }\n}\n",
            "ns.ts": "\n/**\n * Generation of music tones.\n */\n//% color=#E30FC0 weight=90 icon=\"\\uf025\"\n//% blockGap=8\n//% groups='[\"Sounds\", \"Melody\", \"Tone\",  \"Volume\", \"Tempo\"]'\nnamespace music {\n}",
            "piano.ts": "namespace music {\n    /**\n     * Get the frequency of a note.\n     * @param name the note name, eg: Note.C\n     */\n    //% weight=1 help=music/note-frequency\n    //% blockId=device_note block=\"%note\"\n    //% shim=TD_ID\n    //% color=\"#FFFFFF\" colorSecondary=\"#FFFFFF\" colorTertiary=\"#D83B01\"\n    //% note.fieldEditor=\"note\" note.defl=\"262\"\n    //% note.fieldOptions.decompileLiterals=true\n    //% useEnumVal=1\n    //% weight=10 blockGap=8\n    //% group=\"Tone\"\n    export function noteFrequency(name: Note): number {\n        return name;\n    }\n}",
            "pxt.json": "{\n    \"name\": \"mixer---samd\",\n    \"description\": \"The music library with a mixer\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"SoundOutput.h\",\n        \"sound.cpp\",\n        \"melody.h\",\n        \"melody.cpp\",\n        \"melody.ts\",\n        \"piano.ts\",\n        \"legacy.ts\",\n        \"ns.ts\",\n        \"targetoverrides.ts\",\n        \"music.ts\",\n        \"pxtparts.json\",\n        \"headphone.svg\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "pxtparts.json": "{\n    \"headphone\": {\n        \"numberOfPins\": 2,\n        \"visual\": {\n            \"image\": \"headphone.svg\",\n            \"width\": 142,\n            \"height\": 180,\n            \"pinDistance\": 20,\n            \"pinLocations\": [\n                {\n                    \"x\": 17,\n                    \"y\": 11\n                },\n                {\n                    \"x\": 55,\n                    \"y\": 50\n                }\n            ]\n        },\n        \"pinDefinitions\": [\n            {\n                \"target\": \"A0\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            },\n            {\n                \"target\": \"ground\",\n                \"style\": \"croc\",\n                \"orientation\": \"Y\"\n            }\n        ],\n        \"instantiation\": {\n            \"kind\": \"singleton\"\n        },\n        \"assembly\": [\n            {\n                \"part\": true,\n                \"pinIndices\": [\n                    0\n                ]\n            },\n            {\n                \"pinIndices\": [\n                    1\n                ]\n            }\n        ]\n    }\n}",
            "sound.cpp": "// to be overridden\n",
            "targetoverrides.ts": "\n",
            "test.ts": "for(let i = 1000; i > 0; i -= 50)\n    music.playTone(440, i)\n\nfor(let i = 0; i < 1000; i += 20)\n    music.playTone(440, i)\n"
        },
        "microphone": {
            "README.md": "# microphone\n\nThe microphone library.\n\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare enum LoudnessCondition {\n    //% block=\"loud\"\n    Loud = 2,  // LEVEL_THRESHOLD_HIGH\n    //% block=\"quiet\"\n    Quiet = 1,  // LEVEL_THRESHOLD_LOW\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "microphone.cpp": "#include \"pxt.h\"\n#include \"LevelDetector.h\"\n#include \"LevelDetectorSPL.h\"\n\n#define MICROPHONE_MIN 52.0f\n#define MICROPHONE_MAX 120.0f\n\nnamespace pxt {\n    codal::LevelDetectorSPL* getMicrophoneLevel();\n}\n\nnamespace input {\n/**\n* Registers an event that runs when a loud sound is detected\n*/\n//% help=input/on-loud-sound\n//% blockId=input_on_loud_sound block=\"on loud sound\"\n//% parts=\"microphone\"\n//% weight=88 blockGap=12\nvoid onLoudSound(Action handler) {\n    pxt::getMicrophoneLevel(); // wake up service\n    registerWithDal(DEVICE_ID_MICROPHONE, LEVEL_THRESHOLD_HIGH, handler);\n}\n\n/**\n* Reads the loudness through the microphone from 0 (silent) to 255 (loud)\n*/\n//% help=input/sound-level\n//% blockId=device_get_sound_level block=\"sound level\"\n//% parts=\"microphone\"\n//% weight=34 blockGap=8\nint soundLevel() {\n    auto level = pxt::getMicrophoneLevel();\n    if (NULL == level)\n        return MICROPHONE_MIN;        \n    const int micValue = level->getValue();\n    const int scaled = max(MICROPHONE_MIN, min(micValue, MICROPHONE_MAX)) - MICROPHONE_MIN;\n    return min(0xff, scaled * 0xff / (MICROPHONE_MAX - MICROPHONE_MIN));\n}\n\n/**\n* Sets the minimum threshold for a loud sound\n*/\n//% help=input/set-loud-sound-threshold\n//% blockId=input_set_loud_sound_threshold block=\"set loud sound threshold %value\"\n//% parts=\"microphone\"\n//% value.min=1 value.max=255\n//% group=\"More\" weight=14 blockGap=8\nvoid setLoudSoundThreshold(int value) {\n    auto level = pxt::getMicrophoneLevel();\n    if (NULL == level)\n        return;\n\n    value = max(0, min(0xff, value));\n    const int scaled = MICROPHONE_MIN + value * (MICROPHONE_MAX - MICROPHONE_MIN) / 0xff;\n    level->setHighThreshold(scaled);\n}\n}",
            "microphonehw.cpp": "#include \"pxt.h\"\n#include \"dmac.h\"\n#include \"LevelDetector.h\"\n#include \"LevelDetectorSPL.h\"\n#include \"DataStream.h\"\n\n#if defined(NRF52_SERIES)\n#include \"NRF52PDM.h\"\n#define PDMDevice NRF52PDM\n#elif defined(SAMD21) || defined(SAMD51)\n#include \"SAMDPDM.h\"\n#define PDMDevice SAMD21PDM\n#else // STM?\nclass DummyDataSource : public codal::DataSource {\n    public:\n        DummyDataSource() {}\n};\nclass PanicPDM {\n    public:\n        uint8_t level;\n        DummyDataSource source;\n        codal::DataStream output;\n\n        PanicPDM(Pin &sd, Pin &sck):\n            output(source) \n        {\n            target_panic(PANIC_MICROPHONE_MISSING);\n        }\n        void enable() {\n\n        }\n        void disabled() {\n\n        }\n};\n#define PDMDevice PanicPDM\n#endif\n\nnamespace pxt {\n\nclass WMicrophone {\n  public:\n    PDMDevice microphone;\n    LevelDetectorSPL level;\n    WMicrophone()\n        : microphone(*LOOKUP_PIN(MIC_DATA), *LOOKUP_PIN(MIC_CLOCK))\n        , level(microphone.output, 95.0, 75.0, 9, 52, DEVICE_ID_MICROPHONE)\n    {\n        microphone.enable();\n    }\n};\nSINGLETON(WMicrophone);\n\n\ncodal::LevelDetectorSPL* getMicrophoneLevel() {\n    auto wmic = getWMicrophone();\n    return wmic ? &(wmic->level) : NULL;\n}\n\n}\n",
            "pxt.json": "{\n    \"name\": \"microphone\",\n    \"description\": \"The microphone library\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"microphone.cpp\",\n        \"microphonehw.cpp\",\n        \"enums.d.ts\",\n        \"shims.d.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Registers an event that runs when a loud sound is detected\n     */\n    //% help=input/on-loud-sound\n    //% blockId=input_on_loud_sound block=\"on loud sound\"\n    //% parts=\"microphone\"\n    //% weight=88 blockGap=12 shim=input::onLoudSound\n    function onLoudSound(handler: () => void): void;\n\n    /**\n     * Reads the loudness through the microphone from 0 (silent) to 255 (loud)\n     */\n    //% help=input/sound-level\n    //% blockId=device_get_sound_level block=\"sound level\"\n    //% parts=\"microphone\"\n    //% weight=34 blockGap=8 shim=input::soundLevel\n    function soundLevel(): int32;\n\n    /**\n     * Sets the minimum threshold for a loud sound\n     */\n    //% help=input/set-loud-sound-threshold\n    //% blockId=input_set_loud_sound_threshold block=\"set loud sound threshold %value\"\n    //% parts=\"microphone\"\n    //% value.min=1 value.max=255\n    //% group=\"More\" weight=14 blockGap=8 shim=input::setLoudSoundThreshold\n    function setLoudSoundThreshold(value: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "test.ts": "// tests"
        },
        "lightsensor": {
            "README.md": "# lightsensor\n\nThe lightsensor library.\n\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum LightCondition {\n    //% block=\"dark\"\n    Dark = 1,  // SENSOR_THRESHOLD_LOW\n    //% block=\"bright\"\n    Bright = 2,  // SENSOR_THRESHOLD_HIGH\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "lightsensor.cpp": "#include \"pxt.h\"\n#include \"AnalogSensor.h\"\n\n#ifdef CODAL_LIGHT_SENSOR_HEADER\n#include CODAL_LIGHT_SENSOR_HEADER\n#endif\n\n\n#ifndef CODAL_LIGHT_SENSOR\n#define CODAL_LIGHT_SENSOR AnalogSensor\n#endif\n\n#ifndef LIGHTSENSOR_SENSITIVITY\n#define LIGHTSENSOR_SENSITIVITY 868 // codal has 912 now\n#endif\n\n#ifndef LIGHTSENSOR_LOW_THRESHOLD\n#define LIGHTSENSOR_LOW_THRESHOLD 128\n#endif\n\n#ifndef LIGHTSENSOR_HIGH_THRESHOLD\n#define LIGHTSENSOR_HIGH_THRESHOLD 896\n#endif\n\nenum class LightCondition {\n    //% block=\"dark\"\n    Dark = SENSOR_THRESHOLD_LOW,\n    //% block=\"bright\"\n    Bright = SENSOR_THRESHOLD_HIGH\n};\n\nnamespace pxt {\n\nclass WLight {\n  public:\n    CODAL_LIGHT_SENSOR sensor;\n    WLight()\n        : sensor(*LOOKUP_PIN(LIGHT), DEVICE_ID_LIGHT_SENSOR) //\n    {\n        sensor.init();\n        sensor.setPeriod(50);\n        sensor.setSensitivity(LIGHTSENSOR_SENSITIVITY); \n        sensor.setLowThreshold(LIGHTSENSOR_LOW_THRESHOLD);\n        sensor.setHighThreshold(LIGHTSENSOR_HIGH_THRESHOLD);\n    }\n};\nSINGLETON_IF_PIN(WLight, LIGHT);\n\n}\n\nnamespace input {\n\n/**\n* Register an event that runs when light conditions (darker or brighter) change.\n* @param condition the condition that event triggers on\n*/\n//% help=input/on-light-condition-changed\n//% blockId=input_on_light_condition_changed block=\"on light %condition\"\n//% parts=\"lightsensor\"\n//% weight=84 blockGap=12\nvoid onLightConditionChanged(LightCondition condition, Action handler) {\n    auto wlight = getWLight();\n    if (NULL == wlight) return;    \n    auto sensor = wlight->sensor;\n\n    sensor.updateSample();\n    registerWithDal(sensor.id, (int)condition, handler);\n}\n\n/**\n * Read the light level applied to the LED screen in a range from 0 (dark) to 255 (bright).\n */\n//% help=input/light-level\n//% blockId=device_get_light_level block=\"light level\"\n//% parts=\"lightsensor\"\n//% weight=30 blockGap=8\nint lightLevel() {\n    auto wlight = getWLight();\n    if (NULL == wlight) return 127;\n    auto sensor = wlight->sensor;\n    // 0...1023\n    int value = sensor.getValue();\n    return value / 4;\n}\n\n/**\n* Set the threshold value for the light condition event.\n*/\n//% help=input/set-light-threshold\n//% blockId=lightsensor_set_threshold block=\"set %condition| light threshold to %value\"\n//% parts=\"lightsensor\"\n//% value.min=1 value.max=255\n//% group=\"More\" weight=13 blockGap=8\nvoid setLightThreshold(LightCondition condition, int value) {\n    auto wlight = getWLight();\n    if (NULL == wlight) return;\n    auto sensor = wlight->sensor;\n\n    int v = value * 4;\n    if (condition == LightCondition::Dark)\n        sensor.setLowThreshold(v);\n    else\n        sensor.setHighThreshold(v);\n}\n}\n",
            "ns.ts": "\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}",
            "pxt.json": "{\n    \"name\": \"lightsensor\",\n    \"description\": \"Onboard light level sensor\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"lightsensor.cpp\",\n        \"ns.ts\",\n        \"shims.d.ts\",\n        \"enums.d.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Register an event that runs when light conditions (darker or brighter) change.\n     * @param condition the condition that event triggers on\n     */\n    //% help=input/on-light-condition-changed\n    //% blockId=input_on_light_condition_changed block=\"on light %condition\"\n    //% parts=\"lightsensor\"\n    //% weight=84 blockGap=12 shim=input::onLightConditionChanged\n    function onLightConditionChanged(condition: LightCondition, handler: () => void): void;\n\n    /**\n     * Read the light level applied to the LED screen in a range from 0 (dark) to 255 (bright).\n     */\n    //% help=input/light-level\n    //% blockId=device_get_light_level block=\"light level\"\n    //% parts=\"lightsensor\"\n    //% weight=30 blockGap=8 shim=input::lightLevel\n    function lightLevel(): int32;\n\n    /**\n     * Set the threshold value for the light condition event.\n     */\n    //% help=input/set-light-threshold\n    //% blockId=lightsensor_set_threshold block=\"set %condition| light threshold to %value\"\n    //% parts=\"lightsensor\"\n    //% value.min=1 value.max=255\n    //% group=\"More\" weight=13 blockGap=8 shim=input::setLightThreshold\n    function setLightThreshold(condition: LightCondition, value: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "test.ts": "for(let i = 0; i < 100; ++i) {\n    pause(500)\n    console.log(`light=${input.lightLevel()}`);\n}"
        },
        "thermometer": {
            "README.md": "# temperature\n\nThe temperature library.\n\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum TemperatureCondition {\n    //% block=\"hot\"\n    Hot = 2,  // SENSOR_THRESHOLD_HIGH\n    //% block=\"cold\"\n    Cold = 1,  // SENSOR_THRESHOLD_LOW\n    }\n\n\n    declare const enum TemperatureUnit {\n    //% block=\"C\"\n    Celsius = 0,\n    //% block=\"F\"\n    Fahrenheit = 1,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "ns.ts": "\n//% color=\"#B4009E\" weight=98 icon=\"\\uf192\"\nnamespace input {\n}",
            "pxt.json": "{\n    \"name\": \"thermometer\",\n    \"description\": \"A thermometer driver\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"temperature.cpp\",\n        \"target_temperature.h\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"ns.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Run some code when the temperature changes from hot to cold, or from cold to hot.\n     * @param condition the condition, hot or cold, the event triggers on\n     * @param temperature the temperature at which this event happens, eg: 15\n     * @param unit the unit of the temperature\n     */\n    //% blockId=input_on_temperature_condition_changed block=\"on temperature %condition|at %temperature|%unit\"\n    //% parts=\"thermometer\"\n    //% help=input/on-temperature-condition-changed blockExternalInputs=0\n    //% group=\"More\" weight=76 shim=input::onTemperatureConditionChanged\n    function onTemperatureConditionChanged(condition: TemperatureCondition, temperature: int32, unit: TemperatureUnit, handler: () => void): void;\n\n    /**\n     * Get the temperature in Celsius or Fahrenheit degrees.\n     */\n    //% help=input/temperature\n    //% blockId=device_temperature block=\"temperature in %unit\"\n    //% parts=\"thermometer\"\n    //% weight=26 shim=input::temperature\n    function temperature(unit: TemperatureUnit): int32;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "target_temperature.h": "#include \"NonLinearAnalogSensor.h\"\n\n/*\n * @param nominalValue The value (in SI units) of a nominal position.\n * @param nominalReading The raw reading from the sensor at the nominal position.\n * @param beta The Steinhart-Hart Beta constant for the device\n * @param seriesResistor The value (in ohms) of the resistor in series with the sensor.\n * @param zeroOffset Optional zero offset applied to all SI units (e.g. 273.15 for temperature\n * sensing in C vs Kelvin).\n */\n\n#ifndef TEMPERATURE_NOMINAL_VALUE\n#define TEMPERATURE_NOMINAL_VALUE 25\n#endif\n\n#ifndef TEMPERATURE_NOMINAL_READING\n#define TEMPERATURE_NOMINAL_READING 10000\n#endif\n\n#ifndef TEMPERATURE_BETA\n#define TEMPERATURE_BETA 3380\n#endif\n\n#ifndef TEMPERATURE_SERIES_RESISTOR\n#define TEMPERATURE_SERIES_RESISTOR 10000\n#endif\n\n#ifndef TEMPERATURE_ZERO_OFFSET\n#define TEMPERATURE_ZERO_OFFSET 273.5\n#endif\n\nnamespace pxt {\nclass WTemp {\n  public:\n    NonLinearAnalogSensor sensor;\n    WTemp()\n        : sensor(*LOOKUP_PIN(TEMPERATURE), DEVICE_ID_THERMOMETER,\n                TEMPERATURE_NOMINAL_VALUE, \n                TEMPERATURE_NOMINAL_READING, \n                TEMPERATURE_BETA, \n                TEMPERATURE_SERIES_RESISTOR,\n                TEMPERATURE_ZERO_OFFSET)\n    {\n        sensor.init();\n    }\n};\n}",
            "temperature.cpp": "#include \"pxt.h\"\n#include \"target_temperature.h\"\n\nenum class TemperatureCondition {\n    //% block=\"hot\"\n    Hot = SENSOR_THRESHOLD_HIGH,\n    //% block=\"cold\"\n    Cold = SENSOR_THRESHOLD_LOW\n};\n\nenum class TemperatureUnit {\n    //% block=\"C\"\n    Celsius,\n    //% block=\"F\"\n    Fahrenheit\n};\n\nnamespace pxt {\nSINGLETON_IF_PIN(WTemp, TEMPERATURE);\n}\n\nnamespace input {\n\n/**\n* Run some code when the temperature changes from hot to cold, or from cold to hot.\n* @param condition the condition, hot or cold, the event triggers on\n* @param temperature the temperature at which this event happens, eg: 15\n* @param unit the unit of the temperature\n*/\n//% blockId=input_on_temperature_condition_changed block=\"on temperature %condition|at %temperature|%unit\"\n//% parts=\"thermometer\"\n//% help=input/on-temperature-condition-changed blockExternalInputs=0\n//% group=\"More\" weight=76\nvoid onTemperatureConditionChanged(TemperatureCondition condition, int temperature, TemperatureUnit unit, Action handler) {\n    auto thermo = getWTemp();\n    if (!thermo) return;\n\n    auto sensor = &thermo->sensor;\n    sensor->updateSample();\n\n    int t = unit == TemperatureUnit::Celsius ? temperature : ((temperature - 32) * 10) / 18;\n\n    if (condition == TemperatureCondition::Cold)\n        sensor->setLowThreshold(t);\n    else\n        sensor->setHighThreshold(t);\n    registerWithDal(sensor->id, (int)condition, handler);\n}\n\n/**\n * Get the temperature in Celsius or Fahrenheit degrees.\n */\n//% help=input/temperature\n//% blockId=device_temperature block=\"temperature in %unit\"\n//% parts=\"thermometer\"\n//% weight=26\nint temperature(TemperatureUnit unit) {\n    auto thermo = getWTemp();\n    // default to 21 if not present\n    int value = (NULL != thermo) ? thermo->sensor.getValue() : 21;\n    if (unit == TemperatureUnit::Celsius) return value;\n    else return (value * 18) / 10 + 32;\n}\n}\n",
            "test.ts": ""
        },
        "color": {
            "README.md": "# Colors\n\nColor manipulation",
            "colorbuffer.ts": "namespace color {\n    export enum ColorBufferLayout {\n        /**\n         * 24bit RGB color\n         */\n        RGB,\n        /**\n         * 32bit RGB color with alpha\n         */\n        ARGB\n    }\n\n    /**\n     * A buffer of colors\n     */\n    export class ColorBuffer {\n        layout: ColorBufferLayout;\n        buf: Buffer;\n\n        constructor(length: number, layout?: ColorBufferLayout) {\n            this.layout = layout || ColorBufferLayout.RGB;\n            this.buf = control.createBuffer((length | 0) * this.stride);\n        }\n\n        static fromBuffer(buffer: Buffer, layout: ColorBufferLayout) {\n            const b = new ColorBuffer(0, layout);\n            b.buf = buffer.slice();\n            return b;\n        }\n\n        get stride() {\n            return this.layout == ColorBufferLayout.RGB ? 3 : 4;\n        }\n\n        get length() {\n            return Math.idiv(this.buf.length, this.stride);\n        }\n\n        color(index: number): number {\n            index = index | 0;\n            if (index < 0 || index >= this.length)\n                return -1;\n\n            const s = this.stride;\n            const start = index * s;\n            let c = 0;\n            for (let i = 0; i < s; ++i)\n                c = (c << 8) | (this.buf[start + i] & 0xff);\n            return c;\n        }\n\n        setColor(index: number, color: number) {\n            index = index | 0;\n            if (index < 0 || index >= this.length) return;\n\n            const s = this.stride;\n            const start = index * s;\n            for (let i = s - 1; i >= 0; --i) {\n                this.buf[start + i] = color & 0xff;\n                color = color >> 8;\n            }\n        }\n\n        slice(start?: number, length?: number): ColorBuffer {\n            start = start | 0;\n            if (start < 0)\n                start = this.length - start;\n\n            if (length == undefined)\n                length = this.length;\n            length = Math.min(length, this.length - start);\n\n            const output = new ColorBuffer(length, this.layout);\n            for (let i = 0; i < length; ++i) {\n                output.setColor(i, this.color(start + i));\n            }\n\n            return output;\n        }\n\n        /**\n         * Writes the content of the src color buffer starting at the start dstOffset in the current buffer\n         * @param dstOffset\n         * @param src\n         */\n        write(dstOffset: number, src: ColorBuffer): void {\n            if (this.layout == src.layout) {\n                const d = (dstOffset | 0) * this.stride;\n                this.buf.write(d, src.buf);\n            } else {\n                // different color layout\n                const n = Math.min(src.length, this.length - dstOffset);\n                for (let i = 0; i < n; ++i)\n                    this.setColor(dstOffset + i, src.color(i));\n            }\n        }\n    }\n\n    /**\n     * Converts an array of colors into a color buffer\n     */\n    export function createBuffer(colors: number[], layout?: ColorBufferLayout): color.ColorBuffer {\n        const p = new ColorBuffer(colors.length, layout);\n        const n = colors.length;\n        for (let i = 0; i < n; i++) {\n            p.setColor(i, colors[i]);\n        }\n        return p;\n    }\n}",
            "colors.ts": "/**\n * Well known colors\n */\nconst enum Colors {\n    //% block=red\n    Red = 0xFF0000,\n    //% block=orange\n    Orange = 0xFF7F00,\n    //% block=yellow\n    Yellow = 0xFFFF00,\n    //% block=green\n    Green = 0x00FF00,\n    //% block=blue\n    Blue = 0x0000FF,\n    //% block=indigo\n    Indigo = 0x4b0082,\n    //% block=violet\n    Violet = 0x8a2be2,\n    //% block=purple\n    Purple = 0xA033E5,\n    //% block=pink\n    Pink = 0xFF007F,\n    //% block=white\n    White = 0xFFFFFF,\n    //% block=black\n    Black = 0x000000\n}\n\n/**\n * Well known color hues\n */\nconst enum ColorHues {\n    //% block=red\n    Red = 0,\n    //% block=orange\n    Orange = 29,\n    //% block=yellow\n    Yellow = 43,\n    //% block=green\n    Green = 86,\n    //% block=aqua\n    Aqua = 125,\n    //% block=blue\n    Blue = 170,\n    //% block=purple\n    Purple = 191,\n    //% block=magenta\n    Magenta = 213,\n    //% block=pink\n    Pink = 234\n}\n\n/**\n * Color manipulation\n */\n//% advanced=1\nnamespace color {\n    /**\n     * Converts red, green, blue channels into a RGB color\n     * @param red value of the red channel between 0 and 255. eg: 255\n     * @param green value of the green channel between 0 and 255. eg: 255\n     * @param blue value of the blue channel between 0 and 255. eg: 255\n     */\n    //% blockId=\"colorsrgb\" block=\"red %red|green %green|blue %blue\"\n    //% red.min=0 red.max=255 green.min=0 green.max=255 blue.min=0 blue.max=255\n    //% help=\"colors/rgb\"\n    //% weight=19 blockGap=8\n    //% blockHidden=true\n    export function rgb(red: number, green: number, blue: number): number {\n        return ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF);\n    }\n\n    export function argb(alpha: number, red: number, green: number, blue: number): number {\n        return ((alpha & 0xFF) << 24) | ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF);\n    }\n\n    /**\n    * Get the RGB value of a known color\n    */\n    //% blockId=colorscolors block=\"%color\"\n    //% help=\"colors/well-known\"\n    //% shim=TD_ID\n    //% weight=20 blockGap=8\n    //% blockHidden=true\n    export function wellKnown(color: Colors): number {\n        return color;\n    }\n\n    /**\n     * Convert an HSV (hue, saturation, value) color to RGB\n     * @param hue value of the hue channel between 0 and 255. eg: 255\n     * @param sat value of the saturation channel between 0 and 255. eg: 255\n     * @param val value of the value channel between 0 and 255. eg: 255\n     */\n\n    //% blockId=\"colorshsv\" block=\"hue %hue|sat %sat|val %val\"\n    //% hue.min=0 hue.max=255 sat.min=0 sat.max=255 val.min=0 val.max=255\n    //% help=\"colors/hsv\"\n    //% weight=17\n    //% blockHidden=true\n    export function hsv(hue: number, sat: number = 255, val: number = 255): number {\n        let h = (hue % 255) >> 0;\n        if (h < 0) h += 255;\n        // scale down to 0..192\n        h = (h * 192 / 255) >> 0;\n\n        //reference: based on FastLED's hsv2rgb rainbow algorithm [https://github.com/FastLED/FastLED](MIT)\n        const invsat = 255 - sat;\n        const brightness_floor = ((val * invsat) / 255) >> 0;\n        const color_amplitude = val - brightness_floor;\n        const section = (h / 0x40) >> 0; // [0..2]\n        const offset = (h % 0x40) >> 0; // [0..63]\n\n        const rampup = offset;\n        const rampdown = (0x40 - 1) - offset;\n\n        const rampup_amp_adj = ((rampup * color_amplitude) / (255 / 4)) >> 0;\n        const rampdown_amp_adj = ((rampdown * color_amplitude) / (255 / 4)) >> 0;\n\n        const rampup_adj_with_floor = (rampup_amp_adj + brightness_floor);\n        const rampdown_adj_with_floor = (rampdown_amp_adj + brightness_floor);\n\n        let r: number;\n        let g: number;\n        let b: number;\n        if (section) {\n            if (section == 1) {\n                // section 1: 0x40..0x7F\n                r = brightness_floor;\n                g = rampdown_adj_with_floor;\n                b = rampup_adj_with_floor;\n            } else {\n                // section 2; 0x80..0xBF\n                r = rampup_adj_with_floor;\n                g = brightness_floor;\n                b = rampdown_adj_with_floor;\n            }\n        } else {\n            // section 0: 0x00..0x3F\n            r = rampdown_adj_with_floor;\n            g = rampup_adj_with_floor;\n            b = brightness_floor;\n        }\n        return rgb(r, g, b);\n    }\n\n    /**\n     * Fade the color by the brightness\n     * @param color color to fade\n     * @param brightness the amount of brightness to apply to the color, eg: 128\n     */\n    //% blockId=\"colorsfade\" block=\"fade %color=neopixel_colors|by %brightness\"\n    //% brightness.min=0 brightness.max=255\n    //% help=\"light/fade\"\n    //% group=\"Color\" weight=18 blockGap=8\n    //% blockHidden=true\n    export function fade(color: number, brightness: number): number {\n        brightness = Math.max(0, Math.min(255, brightness >> 0));\n        if (brightness < 255) {\n            let red = unpackR(color);\n            let green = unpackG(color);\n            let blue = unpackB(color);\n\n            red = (red * brightness) >> 8;\n            green = (green * brightness) >> 8;\n            blue = (blue * brightness) >> 8;\n\n            color = rgb(red, green, blue);\n        }\n        return color;\n    }\n\n    export function blend(color: number, alpha: number, otherColor: number) {\n        alpha = Math.max(0, Math.min(0xff, alpha | 0));\n        const malpha = 0xff - alpha;\n        const r = (unpackR(color) * malpha + unpackR(otherColor) * alpha) >> 8;\n        const g = (unpackG(color) * malpha + unpackG(otherColor) * alpha) >> 8;\n        const b = (unpackB(color) * malpha + unpackB(otherColor) * alpha) >> 8;\n        return rgb(r, g, b);\n    }\n\n    export function gradient(startColor: number, endColor: number, steps: number): ColorBuffer {\n        steps = Math.max(2, steps | 0);\n        const b = new ColorBuffer(steps);\n        b.setColor(0, startColor);\n        b.setColor(b.length - 1, endColor);\n        for (let i = 1; i < steps - 1; ++i) {\n            const alpha = Math.idiv(0xff * i, steps);\n            const c = blend(startColor, alpha, endColor);\n            b.setColor(i, c);\n        }\n        return b;\n    }\n\n    export function unpackR(rgb: number): number {\n        return (rgb >> 16) & 0xFF;\n    }\n    export function unpackG(rgb: number): number {\n        return (rgb >> 8) & 0xFF;\n    }\n    export function unpackB(rgb: number): number {\n        return (rgb >> 0) & 0xFF;\n    }\n\n    export function parseColor(color: string): number {\n        switch (color) {\n            case \"RED\":\n            case \"red\":\n                return Colors.Red;\n            case \"GREEN\":\n            case \"green\":\n                return Colors.Green;\n            case \"BLUE\":\n            case \"blue\":\n                return Colors.Blue;\n            case \"WHITE\":\n            case \"white\":\n                return Colors.White;\n            case \"ORANGE\":\n            case \"orange\":\n                return Colors.Orange;\n            case \"PURPLE\":\n            case \"purple\":\n                return Colors.Purple;\n            case \"YELLOW\":\n            case \"yellow\":\n                return Colors.Yellow;\n            case \"PINK\":\n            case \"pink\":\n                return Colors.Pink;\n            default:\n                return parseInt(color) || 0;\n        }\n    }\n}",
            "pxt.json": "{\n    \"name\": \"color\",\n    \"description\": \"Color manipulation\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"colors.ts\",\n        \"colorbuffer.ts\",\n        \"README.md\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"weight\": 1\n}\n"
        },
        "light": {
            "README.md": "# neopixel\n\nThe neopixel library.\n\n",
            "animations.jres": "{\n  \"*\": {\n    \"namespace\": \"light\",\n    \"dataEncoding\": \"base64\"\n  },\n  \"rainbowAnimation\": {\n    \"icon\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG8AAABvCAYAAADixZ5gAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAPYQAAD2EBqD+naQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAABZcSURBVHic7Z15nFTVsce/1ctMz8IywzIMM7KLaFwQRBYVSSSguOCGWzQaY4xb0GdUfC/GJdGYpy/uGBVRgxqNihjNiyv6VJBNSdh3EBl2Zh9m6Z7uen+c23dmcLr73p7RgaF/f/Xtz6mqc2/dc+45VXWqIIUUUvj+IW3dgeagqj2A8UBfoDtQDBQBH4nIhu9QbnfgVEtuHlAKbAVmi8ia70puu4CqDlfVj1Q1rLHxL1U9q5XlDlXVdxPIXaaq56vqfvPC7xcdUVUf8BBwA1af6koilK8KEiqL4OvgoUM/H5mFvsZk7wCXikhFC+R6gPuBW6NyI6WVhFZ/TaS0Ak92Jr4++Xh79WhM9gFwkYiUJiu3tdDmyrMU93dgAkDxV3Wse7qSkn/VoZGmbTse6mfAzzuQPzYj2vPlwMkiUpKEXC/wGnAuQGjpeiqfmknwy1UQaSrY16+ArJ+dScb4keARgLXASSKyy63c1sT+oLwngOs1AmumVrDhhcqENPljMzjmnhy8AQH4CDhNROpdyn0QuAVVqqa9RdW0t0A1Lk366GPpfO+1SGYAYA5wiogE3chtTbSp8lT1JOAzgFWPlLPxxSrHtN1GBRj2aBfEA8A1IvK0C7nDgAWAVD0zi6pnZjmWm3b8D8h9/BbwegFuFpGHHRO3MjxtJdjC/QB7FtS5UhzA7i9q2fyaTXOXqgZckN8HSHDJOjPiXCC4cAV7X3w3evkbVc12xaAV0WbKU9W+wAkAa55Mbs2xblolkaAC5AOnOJTbI9q26s9vJJwqm0PVC/9Aq2sBugCnuWbQSmjLkTcBoGZ7mLLlyX02gmUR9iyqa8LPAU4FPJHicoKLVyclV6uqqZu3zK3cVkdbKq8/QNmKln3vGym+vxu5oZWbIOJ+1EURWmHbCpzKbXW0pfK6AQRLIonaxUUj+jw3ciOlSW8PAYgU2/RO5bY62lJ55QC+7JYteP0d7FsocyNXsjNbJFc6ZrmV2+poS+UVAWT39beISVYf2+pS5JBkK4CvT36L5Daidyq31dGWyvsYoNMgP4E8b1IMxCd0P9HeIXzsRq6vX8G+Zi/n8AjpJw12K7fV0ZbKWwR8g8CAKzokxaDX2ZmkdfYA1AH/cEIjIsuBNQDZV5yRlNyMCSfg7Z4LUI8x7bUJ2kx5IqLA7wEOOTeTLkPTXdFnFvgYeF3H6OWTIrLbBfnvADLOOJH0kUe5kuvNy6XD5Aujl9NFpM2mzbY2j3kxNsIRwfIIi24spmxZ4q1DZoGXYY91Jdt877YAg90Ypy1vwmxgjFZVU3rzwwQXJ3bXebvnkvPYr/ENOARghyV3p1O5rY2klaeqg4DjgB6AF9gGLBWRJS755GPsjIdEgsq6ZyvZ9HIV4dpv78HEA4VnZTLoV52i0+VeYLSILE6i/10tuf00VM/e599h70vvRi0nTeERMk4dRYebLsKT2wmgFviRiMxzKbM3MArzzDIxi6fVwEIRcb1ncqU8VfUDVwE3AQNjNPsamAo8ISLNPIlm+R6C+XYcCxCqiLBrTi3lK0PUlYRJy/GS3ddH3kmBxoubIuAcEfnSzT3sIzcfmAUMB4hUVhP8YgmhFRsJF1fg6ZSFr08+6aOH4O3RJUq2AzhPRL5wKEOAC4DbgCExmu0EpgMPiEh5svcTrxOHq+rKxq7l7WWqSzar/vtr1aKSb3meN6nqUBf8M1X1t6paEcebraoaVNWpqtqtle4roKpTVLU0gdyQqj5j2Uad8s5X1TlNuFTvVN2xUCPb5qqWrVONNHHe71FVx7ZSRyNPVU/ErOY6heph1pfw9pfKN8VN2+V3htOHCBcMh0AaANXAJBH5p4sbzgHOwBh8+9AQS7IF47t7S0S2OuXnQm4n4HSMrTIaw1Juyf3YkvuNC34DMd/VQjSCrn8dXfEs7FnatGFGd2TA+cjgyZCeAxAGrhWRaYlkJFSeGuv/QqDrtlL4z1eUTQnWdfmd4Y8XC327A1AJjLKW6AcFrBdwPjCQ2hIiH10JOxJ8HgO5yCnTkfxRYLYgE0Tkw3gkTpT3ITB2dyX8cpqyJ7GjG4AOAXjqKuEQ86n4ChhmbQ/aPVT1aeBqQlVE3jkDSlY5I/T48Ux4A3qMALMAPFREqmM2T9CJscBYgN/NdK44gMpauOt1jYaDDMV8tNs9rOnySgCd9xvnigOIhIjM/gWEqgB6AjfGa55ok34FwPz1sGSz8z5EsX4nfNQwWV7hnsMBiUsBH2Vr0XWvuaeu2YUutyM6rojXNKby1GxkJwB8tCz52a4R7Q9VtWWm/AMDZwDohrf4VvibQ+j6N6M/B1ojuVnEG3ndgByA5VuS6gMAyxpo0zGrx/aOQwHYuTB5DuXrodY2GCWlPNvJWOIuNqgJ9tZBbci+bJkfZj+HmmCkbACtcWNqbQbVttUt5r4ynvJslWWkJd8HrwfSGgKdXSx5DkjUYPZp4G/hFyLN9rTEHDrxlLcDUICC3OT7UJATDTIGLEdoe4WIhDGmLqRjv+QZ+TIh0574tsVqFlN51v5iEcCogck7H0Y2zNgbvgvLyH6IzwDoNS5pBlI4Bjx+MBaqRbHaJdoqzAI4cwhkuXO3AeD3wnnDbcU7D0s+sDELQPpMgA69k2IgR10X/fmeiNTEapdIeU8BJZ0y4fpx7kfflWOEHp0A8wa1WVj494w3gdV4/MiJD4C4C/GQQZdB3jAwn6w/xGsbV3kiUgbcAXDGEPjpaOedOPs4uOQE+/I+EYk5d7cnWAde/gOISMEY5MQHweNLRGZoe41DRt0fvXxeRL6K294JU1WdjmXy+WQlTH1f2RUj7DEnC64+RTj9WPuvtzD+r5YFaB5gUNXfAPcC6Pa56NzboWxt84392cjgycjRv8I6ObMIc3Qt5pQJzpXnw0x7NwAE62HeOli0QdlZDuEI5HWC4/oJowY22Vq8BPzCqVO2vUFVp2CmPg8aRrd+CltmQ8VmCNdAVk/oMRLpc1rUHQTG7XVhMmcOE3VmkqpuSOC0VFUtUtWftarwAxSq+kNVXezgmZWo6i3WQHEE16sQVU0DzgQmYrwFBZgYliJgKWaa/Hs8V8bBBstOPA44GxPD0hMTw1KEiWF5G5i5PxyVTiGFFFJIIYUUUkghhSRgLXlT+A7h5hnHi2Hxq+oFqvpXNdHPtUBIVbep6mxVvVFV2+xIb3uAqmao6uWq+qaqblHVOqBOVbeqyYV2jap2dsv0bFVd58AqUKmqd1kb9xRcQFWvsCxRiVCsqjc3NyJlH4YejC1uCkAoEmLuzi9YuHshW6u3E47UkxvIZXDuMZycfzJd0m0X++cY43MLAzfaP6wX/Ung5+aPvRB+B+o/Bv0GUJB88J4Mvokg9jN+B/iJiNihJPsqz+TjAubu/IInVj7Jzprmj5+le9OZ1Pd8Lj/0MrzGZ7UYk0wtZRaLA1WdAVwGQP0rUHcXaIz8c9IB0qaA/3osVc0GTo3mWbOVp6qTMFnweG3j6zy9ehpK4njNYd2O496hv8Nv3PYzROTy5G+tfUNVfwU8BkDwTgg+5ozQNwkCT2MtUR4QkSlgKU9V0zHntHt/tuNz7ln8e0eKi+LUwvHcdvQtYLy/w0UkZtzFwQo1h082ADmEnoW6W9wxSLsZ0u4ECAKHi8jG6EfwYqB3XbiOx1dOdaU4gPeK3mdZ6XIwL8Pt7np10OCXQA66B4J3u6cOPgaRtQBpwK+hYatwDsAn2z+luLa4eeIEeGPTzOjP8aqakRST9o2zAQjNAE0mirkeQs9ELyaqqkSVdwLAgl0Lku7Zot1fEtYwQBbW8eQUDKwV5jAAwh8kz6j+/eivAqCvR02eylyArdXJh1XWhmsprrM99wXJ97BdIp/oLBfZlDwXLcKknAGgwANkEE3KHW5ZBr66sB2qcjCcBnKDRp+RuDFFCaCgtvIyPZjEZybzZ6BLLKqEEIQu6Tb9QRHm5wI77F+SZMosAMkCsRMHbfdYR43XAByVc2TSfPt37Eemzx5wqQISjWDFvxoFekcmz8hj0wYBe6vwDsCPev4QjyTnOBhbMDb6c4mbrAkHEUxuNN+FCZrFgd8+Gf6JiFRFNTUDqO+d3YvTCse75tkjI4+Jvc6MXk5PvnftGs8B4B0FPvfPGM8x4Du/CS8PgIisA54FuP6I6zi04wDHPAPeAPcMvZt0bzrARsBxivyDCVaqK5NKPv1J8PRxQdwFAn/BUtci4HVo6s+bAqwMeAP8afiDHN9tWEKe3QPdeGTEQ1Fl12Gs3m1WJOIAwLVAEdIFMt4Db+JnjGcgZLwfVXY58NNoSpR9vQr9gQ+Bvory+Y45vPn1LJaXriDS6HB8YVYh4wvHcV6fcwh4A2AUd7mI/K1VbrEdQ1WPBd4F8iACoVehfjqEF0Njs6TnB+C/DPxXYixiVALnishH8Zh3VdUPGnsDq0JVurFik64qXaXFtcX7Ogs3q+qo7/KG2xtUtZeqzm/yFCMlquFlquF/qUZ27fuMV6mq862Aqp6uqp+qan0MD+9aVb1V3VUSScGCqoqqXqSqC1Q1EuMZL1UTCtHs+QUn6au6Acdj4uszMOfKV4qIi9Q+KcSDqvak4dyHD5OsbpmIbGzTjqWQQgoppJBCCimkkEIKByJaVBRDTdr5wcAgTJbAKowjdl7qfHUDLEPGSOAQoCuwB1PCYP73bgtW1c6qep/GjrUPqTGxjfleO7afQVUPU9WX1ZzpaA5lqvqcqvb5vjo0UU3+fwsR1fBm1foFquGVqpFvlUV4XVWTq/R0gEJVPap6r/USq6pqMBzUzZXf6IqSFbqlaovWR5pYHWvV1HZwNRO6rWgyGZNMx4MWQ+hRCL0B2jhkxQ/eEyDtBvDa3vXlwNi2rLvzfcGyQ76OFae5sXITL6//K/N3LaAm3BB8lO3PZlT3kVw64BIKswqjf88AfuY0W5Rj5anq2cBMwEP4Y6i9EjRB0UbfeZD+BEgGwFxM/Z127e9T1anAdYry0vqXeWHdDDRORWif+Ljm8Ks5t8850b/uFZHfOpHlNH1VLrAeyCE8G2ouxNRtcADvyZAxE2Nv5U4R+b0zwgMPqnoqxlfH06un8beNzrO7X3XYlVzS/2IwTr2RIpIwAtpptNHtQA6624w4p4oDCH8KwQeiV7eqqZ7V7mB9r+4HmLdrvivFAUxf+zzLSpaBGVB/dEKTUHlqDlyaY1vBh0CTKDIVfDx6Bq0DMMk9gwMCQ4DBivLM6mddE6sq09bYsVtjVDVhnmMnI2840B0iUD8zYePmUQP1dlXQ5Gp97v84A2B9+Xo2VyVRQQRYXrqC7dV2fO6Z8dqCM+UdBkBkQ+wTnE4QtgshDUqeyX6Nw4DoUbeksax0WRN+8eBEeSY+W1u4ytft0V/ttbZCPtD4sE1SaHTErmeitk6UZ21OWnjkTrKjv/a2jNF+i2qAdE8SmdQbIcNnP+eEh/icKM/swD29HTaPAenTlF/7wzaAgqyEAyYuembaE9P2eO3A2nwlwFxAka6CdyiEkzxu3hDiPSdRUzU1ZM8CRmCCctIxN7MCc67iq9auxacmZjWaALYQ86ZuxySAfVtElsYhB3NfVw3rehxe8UYPmrpCwBvgmNxjopefJ2rvdJM+DxhB/SyoTSL7sOdIyPwMa+SOi1WR0Voe3wtclKBvi4HbRGS2+858S+YRmP3ZWQmazrFkNluC0tq/bgP8Dy79E+8Wvee6Lxf0m8Q1g64GM2XmJUqL4lR5ZwF/B4WaCyActxrmPkiDjHfAOxxM+dIRzY0ay/z2IlYhpZqdYXbPraVme5hwrRLI89JlaDqdBvkb9/pPwBSrDIxrqOoVmNoR6QBbS2HhethVrtRHIK+TMKQv9Otuk0SAO4E/xLiHqcB1xXUlXDPnWleLl56ZPXnqhKlk+7PBlDK4IxGNG9vmh8BYtAJqz4WwkwrXaRB4AnwXgDHLjBGRuc3w/gnGKOvZu6We1Y9WsOP/amguKUWH/n4Ov6kj3UbZsb4vA5e5nUYtI/ujABt3wdQPlEUbmm97eIEpCnJ0L/uvR0XkpmZ45gHLgG5rytdy+6L/ojyY2KjRNdCVB4//I72ze4OJ2TxSRGIUP2iAG+XZReHRWpOOIvQc5pxfM/AcDukPg3dE9J+bROTRZvgeh5nfA3sW1LF4SgmhygRGdYFDr+rAwGvsU6JTROSBeCT7yBwLvAd4P10F983SxmXimr8dgRvGC+cPt/+6UkSeb4b3aMx5j7Tt1Tt4ePkjfLkndm2LE/NO4MYjJ0dTgVVjskgtdnIfbl1CvTHHlAabP7ZA/VsQnm9t4DPBMwC848A3FpP0nXrgVhF5pBl+AswDhlesCfHFz3cTrnE+gI74dSf6XmJmWWCgiBQ5uAcfZuEz8N+b4eYZZop0AgHuOFf48VEAlAADmosYUNVxwKtYxSNXla3m8x1z2FS5ibJgGTnpOQzo2J/RPUYzoGP/KNlO4HwRSbiga9wfV1DVLOBuTIGMROcUFmNGXLMrJ1WdAPyvRmDOpbuoWJPg9d8HHr9w8szuZBb4AJ4Ukesd9P9y4IVQPVw6VdmewKu1L7LS4dXJQidzgvseEbk7hpz+wEMkXggp8DfMC57w5WsM1xs3EdkrIrdiymvehik5tt3qRDWwFnNQ83TguFiKszAJYNecWteKA4iElI0z7L3seeos0egkgA+W4VpxYCpxvrHAnh1iGtlFZIOITMSc83gQWAJER2kx5sX+AzBYRC52qzhoYQBSY6iqJLFoKAIKlt5Typa3k0sWmJ7rYewH+dE7GSwiS+LI82AsPIHbX1G+iFHaJxH6doe/XGs/ukI3dQGTeU6x0Gpph5NQnA/LHlix3oV/cB/UlUQIltofrUQF67pjTfUbW2Cq3bzb1E+y0CtO02+hNY0LbZkzunNUfn2i1WUCBCts+kQFUu2Uv5UtKE0VUTN9OpT5naEtlVeC5ZJPy2lZN9JzbfpEPqs90R+ds5KX5/NAdsNSrQV+spahzZRnRUhtAeg4yJ80n4yeXvwd7dv4OkHzYqACYGALEhEN6GEXMVYgOc9rK6CtU+2/B5A/Nnl3U/4pNu1mEVkZr631vXkfYMwPkl+rjTnCpl0sIgffyLPwCkCXoel0GereD+bLFPr91I7nfdUh2asAJx8O/ZMoLJCbDec0ZOB4xT2H1kObKs/aA74HcMw9OaTluuiOwFF35ES/d2WYvZQTzALmewTuOk9cVaH2CNw+UaKVObcCf3ZO3fpo65EHMBkozcj3MnxqVzJ6JK5u7PELR9+RQ8/x9pR5o4g4StFrTZ3XAzV9usF/XyJ0dpBgMuCHeyYJI0xyqAhwTVtnsm+1TXpLoKo/xlRvDIQqIqx7tpJv3tz7LTuneKDbyACDJnekwwB7kWNnO3cp8wKMR8JXXAXPfaK8v9TUw20MrwdGD4JfnCIUNmwKbhWR/3Ers7WxXygPQFWHY6a0fIBIUCleHKS6qJ5ISAl089JlSHrjqbUeuFlEHm+BzB9jvoG5ADVBWLIZtpWavVxeJzimN3RsWE/VYgoYv5SszHYLNUfH7o9zJEpVNayqs1S1VUIIVbWbqj6mqjVxZIZU9UX9vo5iOcR+M/IaQ012+LGYGJZCwI9xmSwH/vFdnDZS1WxgPCaRd0/MemAH8G/gn61e+jqFFFI4QPH/KtrIalfQZUsAAAAASUVORK5CYII=\"\n  },\n  \"colorWipeAnimation\": {\n    \"icon\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG8AAABvCAYAAADixZ5gAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAPYQAAD2EBqD+naQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAABX1SURBVHic7Z15fFXVtce/64ZAmAKBBIKIAYIBKSAqFkSiVBAHUFGLYnFqn21tbW2f1qGvgx20trXte/ZVO1hpa7WiaFHrQysogsgsCoioYRAyEJlCJAkBkvzeH/vcmxvIzT3nJhKG+/18/Hxyce+99jnrnH32XnuvtSBJkiSHH2vtDjSGpGzgAqAf0APYCRQBc81sw6cotwdwoSe3J1AGFAOvmtkHn5bcYwJJIyXNlVSr2Lwt6dIWlnuGpJfiyF0j6fOSjpgH/ojoiKQ2wG+Ab+D1aVclfFgC5XuhUxr0zYLeGQ2q/Qu41sw+aYbcEHA/cEdYblVVFVu3bqWyspK0tDQyMzPp1q1bdLVXgKlmVpao3Jai1ZXnKe554GKAdzbD9Hli9RaoU8OyuT3h+nxj7GAw1/N3gXPNbFcCclOAp4ErAIqKipg3bx6bNm1Caig4KyuL/Px8hgwZgjnBHwL5ZrYtqNyW5EhQ3u+AW+oEj7wqnngzfp2xg+G/JhtpqQDMBS4ys5qAch8AviOJ+fPnM3/+/Lh18vLyuOKKK2jXrh3AQmCcme0PIrclaVXlScoHFgA8PEfMWOS/7sgB8ItrjFAIgJvN7I8B5J4JLAXs9ddf96W4MP3792fatGmEnODbzOy//fe6ZQm1lmCP+wFWbCSQ4gCWrod/Lo/8vEdSWoDq9wFWWFgYSHEAGzduZNGiSGe/J6lToAZakFZTnqR+wNkAf35NcUo3zt8WiP1usOwFjPMpNztc9rXXXktI7sKFC9m/fz9Ad+CihBppAVrzzbsYoLQc3itOrIHyKli5qWF7PrgQCFVUVLB58+aE5O7bt4/169cHldvitKbycgHWJai4MOuKI29tbhC5JSUlh8wqg1BcHOm4X7ktTmsqLwtgd2XzGtlVX79nELlVVVXNkltZGRHsV26L05rKKwfo2K55jXSun6bsDiLXm+4nTFpaRLBfuS1OayqvCCAnq3mNnJQZWe0U+axSDJCZmdksuVH1/cptcVpTea8B5GVDVnpiDbQJwVknN2zPr9ysrKyDzV6+MTPy8vKCym1xWlN5y4EtZnDtmMRsBZNOhy4dANgHvOinjpm9C3wAMGbMmITkDhs2jPT0dIAanGmvVWg15ZmZgJ8CXHI6DM8JVv+EDLjpvIjSHzaz7QGq/wTg1FNPJTc32GQxPT2d888/P/zzUTNrtWGztc1jKTgb4ahP9sJd/xBrfdyKXl3hgWnGSe6zUwgMD2Kc9nYTXgXGVldXM2PGDF9rvvT0dKZNm0aPHj0ASj25H/uV29IkrDxJg4ARQDaQApQAq81sVcB2euHsjH3218BjC8TTS6D6wKFlQwYXDYebx1t4uKwEzjGzlQn0P9OT27+2tpaFCxeyaNGisOWkAWbG0KFDmTBhAh07dgSoBs4zs8UBZeYAo3H3rANu8vQ+sMzM6oJeQyDlSUoFbgK+DeTFKPYR8BDwOzOr9tluH9y34zSAT/bCkgJ4v0SUVULXDpCTZZyd12ByUwRcbmYrglzDQXJ7AbOAkQDV1dWsX7+e4uJiKioqaN++PZmZmQwcOJAuXbqEq5UCV5qZL2ust3l7FXAncHqMYh8DjwK/NLPyRK+nqU6cIum96K3lrbulVZuldz6SinYdsvO8SdIZAdrvIOkHkj5pYjdbkvZLekhSMxcZEblpku6SVBZH7gFJf/Jso37b7iVpYXQje/bs0ZYtW7Rp0ybt2LFDdXV10f97hyTftlJfb56kMbjZXJcDNTBrBbywQmzZ2bBcr64w8XTjqpGQ1haAKmCKmc0OcMEZwCScwbcv9WdJCnF7d8+ZWTONao3K7QJMxNkqw2dYyj25r3lytwRoLw/3XT1REqtXr2bp0qVs3bq1QblOnToxbNgwxowZQ/v27QFqga+Z2SPxZMRVnpz1fxmQWVIG331SbIozr+vVFX5+jdGvBwB7gNHeFP24wHsAlwB5VVVVPP3003EnRB06dGDKlCn07dsX3BLkYjOb01QdP8qbA4zfvge++ojYscffBXROgz/cZPTpDsBbwJne8uCYR9Ifga/s27eP6dOns22bv9MSKSkpXH/99Zx00kngJoAnm1lMI2yT6zxJ44HxAD951r/iAPZUwz0zRZ2bQ52B+2gf83jD5ZcAXn75Zd+KA6itrWXmzJnhGe8JwLeaKh9vkX4jwJL1sCqBra/1H8Pc+sHyxuAtHJVcC7TZvn07q1YFWjUBUFFRweLFkRXIjU2Vjak8uYXsxQBz1yQ+2kXV/ZykDgk3dPQwCWDt2rUJ7xeuWbMm/Gee9yY3SlNvXhaQAfBuYUJ9cB2pr9sON3s81jkZYMsW3xPTQ9i5c2f0fmNCyotsMu6qSLgfVO5rYC3plXhLRz5yh5E6QYPN2oSoqIjc9JjryqaUF6ndvm3inUgJQds2kZ8BpjxHJXtx6zRSU1Ob1VDUZnHMV6cp5ZUCAuid2LYX4I6oh+oXJC2+uD6SMLNanKmL7t27J9xOamoqnTt3Dv8siVUupvK89cVygNF5iW8+nFU/Ym/4NCwjRyALgOjN2sDk5uaGD/VGdNAY8ZYKs8DttyVy1iQ1Ba4cGVH8rOAtHJXMAhg0aBAZGRnxyjbK6NGjw3++bGZ7Y5WLp7w/ALu6dIBbJgR/+7401sh2xvgqoNWOhR9m/gm8n5KSwsSJE8OOKb4544wz6NOnD7hP1s+aKtuk8sxsN/B9cEcOrj/Hfycmj4AvnB35eZ+ZxRy7jyU8h5f/BOpyc3OZNGlSeAiMS15eHhddFNlU+IuZvdWkLD+NSnoUz+Qz7z146N9iWwyvuIyO8JVxxsTTIv/0HG7/K/Bm49GMpO8B9wJ89NFHzJ49m+3bG7fot23blvz8fM4+++zwm7oc57oWc8gE/8prgxv2vgGwvwYWF8DyDeLjcqitg55dYER/Y3Reg6XF48CX/W7KHmtIugs39IXq6urYuHEjBQUFlJWVUVNTQ3p6Ojk5OQwaNCi8HQRu2+vqRHwO43VmiqQNcTYtJalI0hdbVPhRiqTPSVrp457tkvQd70XxReBZiKS2wCXAZbjdgt64MyxFwGrcMPl8U1sZxxuenXgCMBl3huUE3BmWItwZlheAZ48EV+kkSZIkSZIkSZIkSRLAm/Im+RQJco+bOsOSKukqSf+QO/1cDRyQVCLpVUnfktRqLr3HApLaS7pB0j8lFUraB+yTVCwXC+1mSV2DNjpZUoEPq8AeSfd4C/ckAZB0o2eJisdOSbc19kbaQQ2GcLa4uwAO1MDCD2DJelG8y9kwu3eC4X2Nz33G/e3xBs74HMRH7rjEe9AfBv4DYP/+/axbt44NGzZQXl6OJDp37kz//v0ZPHhwtM3zX8A0M4scJTlYeQ8A3wGntN++JEpj+Ky0awNXj4YvnmukuGdiJS6YWtIs1gSSHgOuA1i1ahVz5syJeVipXbt2nHvuuYwaNSq82/AqcGE4zlpEeZKm4KLgMWMR/H6O8HPq8LO5cP9UI9WZUx8zsxsSv7RjG0nfBH4LMGfOnOgwWE0ydOhQLr/88rACf2lmd4GnPEntcH7aOfPXwQ+f9qe4MBcPh7svc00BI80s5rmL4xU555MNQMby5cuZPdu34xTg/OfHjRsHsB84xcw2hj+C1wA51QfgwZeCKQ5g9juw2p0xNeDugNWPF74KZFRVVTF37tzAlRctWsSOHTsA2gK3Q/1S4XKAeWsJ5EwSzdNLIiq/QFL7psoep0wGWLlyZaOu0/Goq6tj2bJl4Z+XSbKw8s4GWFyQuE/CsvVuNgp0xHNPTuLwZphnAnz44YcJtxNVtzfQLyQXp7IbQHEzNt6rD8DO+rO9vRNv6ZikF94oV1aW+H5reXk5tbW14Z+9Q0B7vInLvkYiMAQhyifhePAGCkLkM3LgQPNuck1NJBpzhxAu8Fk1QPfOsarEx4DM+vrHxTG/AJSG/4g6xh6Ytm3bRvswbA15rsYfAAw7KfHeDciGDvVGsmQCiSi886+lQNhlOSGi6u4HIkuFfwGMH2rRTiGBmDAsUnFVkKgJxxEvgotblihRdeeZWUVYeY8BNTmZcHEC88Tsru6EtMejCffu2GY6QE5ODieffHK8sofQq1cvhgwZ0qCtEICZFQB/Brj1AuNk32FiIC0V7rvaaOfc0TYCvkPkH094oa6eA5g8eXIgJ5RwmI+o09QzoaFtMx1YDAyuqIYfPyuWrm+0rQg90uG+qcZA5++6DxhrZksCXNNxhVz0pOXAiRUVFTz11FMUFTUdKS8zM5OpU6eG/f3KgVFm9j4cuquQC8wB+kmw4H14ZqlYc1BqmD7d4cJTjSn1kY72ATeY2VMtdaHHKpJOA14Cekpi1apVrFixIjrgOAA9e/bktNNOY8SIEaSkpIDzKr7CzGLb1iRlSnolejewolra+LH0XpG0c88hm4WbJY2O2WCSQ5B0kqQl0TexqqpKpaWlKikpUUVFxcH3eJ2kIfFbrhcwUdJ8STUxdng/lHSHgmUSSeIhySRNlbRUUl2Me7xa7ihEo/4LfsJXZQGfxZ2vb4/zK3/PzNa16NUcx0g6gXq/jza4YHVrzGxjq3YsSZIkSZIkSZIkSZIkRyPNSoohF3Z+ODAIFyWwArcRuzjpX12PZ8g4C+gDZAI7cCkMlhz2hMGSukq6T7HP2h+QM7GNPawdO8KQNFDSE3I+HY2xW9J0SX0PV4cuk4v/L0mqq5O2lknvFjr7Z0X1IR2cKakZByyOPiSFJN3rPcSSpJqaGm3fvl2FhYXasWOHamtro+9RtVxuh0AjYdCMJrfigumEyqvgH2+Kue/C9qhoSG1CMLwvXH2WMXJA5J/fBca3Zt6dw4Vnh5yJd05z27ZtLFiwgIKCggbnNdPS0hg4cCD5+fnR4R0fA77oN1qUb+VJmgw8C4SWb4AfPSP2xIlrNG4I3HVpJBn9m7j8O62WFP5wIOkh4OuSeOONN3j99debjDUdCoWYMGECI0eODP/TvWb2Az+y/Iav6gasBzKWbXDZtmp9RhI7ox/86tqIJ9EPzeyn/moefUi6ELdXF8iRBGDcuHHhfH4CzjKzpfHq+HWhvRvIKKt0b5xfxQG8tQn+Oj/y5N0hlz3rmMP7Xt0P7mRzEMWBy9nuBRU34Od+6sRVnpzD5Q0Ajy8UFQmEgHtqcSSrcmdgSvAWjgpOB4ZLSsiR5KB6YyX1j1fHz5s3EuhRJ5i7Jm7ZRqk+AG/U7/5NSqyVI55JAKWlpTFDM8ajsLCQ3bsjyZ8viVfej/IGAhTtgrJmRJtftSUydA5KvJUjmoHQvHwKQHTCqIHxyvpRXjbAzmYG1Y+qf6zmVugFDfIhJMSePZEbdUK8sn6UtxcIT/cTJiqAavOyRRy5VAG0aeM7XGajtG0buVFxnwI/yisB6NUwP0JgTqg/Y3qsOqGUAAnnXg8TVX9rU+XAHXaJx5uAunbATumNr2zKjRGVm2FhvLJyOWQvBUbhDuW0w13MWpxfxVstnYtP7sxqOADsibgHeysuAOwLZrY6ThMLgZsGDBhAKBSiri54SO3U1NRw8kNw4VGaxO8ifTEwat5auOeZ4PdsQE/481cjTiwTYmVk9KbH9wJT4/RtJXCnmb0auDOHyhyMW59dGqfoQk9moxmavfVrCZD6wgsv8Pbbbwfuy+jRo8M52CuAnvHCovgdoO8Hnh87GEYNcPn0/JKaArdNjChuGS4A9iF45re/4yVS2vaJy9j8cbmoPgA90o3hfSEvG8w4HZgr6dfAXV4amMBIuhGXO6IdQHGZc8/eVi5q6qBnF+P0ftDfpU8dAyyU9EPgZwe/+Wa2Q9IjwNfPO+88CgoKAk1eMjIyyM/PD/980E88myC2zTnA+MpquP1x8Z6PxDKpKS7Ex/lDAZcHdayZvdlI29NwRtlQ8S4XA+aN92k0KkW/HvD18xsYvZ8Args6jHpG9gcBNm6Dh14Ryzc0XvaU3i4pSJT/4oNm9u1G2uwJrAGySkpKeOKJJ6JTqcWkc+fOXHfddWRlZYE7sznEzGIkP6gniPIiSeH318Af5ornV8CBGM98vx5w+8QGF/xtM3uwkXZH4Mb3tBUb4Ycz41txDLjhXJcxxeMuM/tlgGsZD7wMpMxfB/fNUrRLdqOEDL5xgfH5iP2YL5nZXxpp+xycv0fb3bt38+KLL7JhQ4ynApe2ZuLEiXTq1AncjDXfzFb6uY6gW0I5ODel4QCl5fD6WlhTKHZVuOVEn+5wVp4xMhe8RB41wB1m9j+NtGc4z6SRBaVwy/T4NzGab15gTBkFuOVMnpnFnU55WzZrgbx3NsNtj7kh0g8GfP+KyEiyCxjQ2IkBSROAGXjJI4uLi1m3bh3btm2jsrKSjh07kp2dzeDBg8nOjvjTfQx83sziTuii+xMISR2BH+ESZMTzU1iJe+ManTlJuhj4vzrBl/8kCkobKxWb1BT4+y0WXoY8bGa3xKsj6Qbgrwdq4NqHxNbd8Wo0pGM7mHGr0cWFTPixmf0ohpxc4DfEnwgJeAr3gAeaywcOfmpmlWZ2By695p24lGNbvU5UAR/iHDUnAiNiKc5jCrjsKEEVB27IfnJR5FN3pfwFGp0C8MoaAisOXCbOZ5ZGZMY0spvZBjO7DOfn8QCwCgi/pTtxD/bPgOFmdk1QxUEzDyBFI8kSmDQUAb1//ryY/U5icjM6wnO3G16yrOFmFjNFsqfcSiDt7ifFogTj2fTrAX/7WuTWnRgkL2Ai9ykWLRZ2OAHFtcGzB270n0r8EMoqYXf9hC4nTvEeeEP9xmYcyNi8neg9zUDhHVrSuNCaMaO7huXHO04Rjz31ua7i2aYiIX+bI7NObvj0KfNTozWVtws3E6VrM+MlZdRH3I33Du8I/9G1Y+Ly2oSgU/1UrRnjRvNoNeV5J6QKAfKasUmU3RU619/Ij+IU3wl8As5SkygDsiNGegGbmy796dHaofZfBhg7OPF509jBkT83m9l7TZX1vjf/Bhj7mebIjNRdaWbH35vn8STAaX3df0Hp0Bamjo7cyBk+q80AOPcUyE0gsUC3TnD5mZGfTwZvoeVoVeV5a8CXAb472cgI8B0y4I5LjG6uzm7cWsoPs4AlIYN7rrRAWahD5my13sZyMfB7/7VbntZ+8wBuBcqyu8CvrzN6dolfITUF7rzUGFcf3OJbZrbTjzBv6LwF2Ns3C37xBfM1YUpLhR9PMUY5g3gdcHNrR7JvsUV6c5B0Pi57Y9one+GxBeKFtzjEzhky+OwAuHm8hbdpICraeUCZV+F2JNrsrIDp88S/V7t8uNGkhOCcQfDlccaJ9YuCO8zsV0FltjRHhPIAJI3EDWm9wN3EVZvdHltNrYvleWoO0UNrDXCbmf1vM2Sej/sGdgPYu9/JLClza7meXZzM9PqI2dW4BMaPJyrzmEXOdez+JlyiJKlW0ixJLXKEUFKWpN9K2tuEzAOS/q7D5YrlkyPmzYtGLjr8eNwZlhOBVNyWybvAi5+Gt5GkTsAFuEDeJ+DmA6XAO8DsFk99nSRJkqOU/wcDidIKGoX9TwAAAABJRU5ErkJggg==\"\n  },\n  \"runningLightsAnimation\": {\n    \"icon\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG8AAABvCAYAAADixZ5gAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAPYQAAD2EBqD+naQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAABHaSURBVHic7Z15eBRV1off00vSC52NAIIgIiAKAjKOIuICCIiKIIo746gj7o7Lp47jhqjgDKPO5+i4MSLuMy6g4oqIooD7AuOKioigEkggIXsv5/vjVsUI6aS7052EfPU+T57QlVu3TvPrunXvueecBgcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHh0SQ1jZgR0dVfUBXIARsAIpERFvXKoe4qKpbVU9T1UWqGtZf85Oq3quqe7a2nQ7boKoDVfVTW6lYOKKR9UUaXrVWo5vL6osYVtXbVNWTKVucYTMJVHUU8AwQiv6wgfJ/PUv1ko/Q8sq6Np7e3QkcOxL/MaMQjxtgEXCUiFSn2x5HvARR1b7Au0B+1QtLKZsxB62NxG3v7b8bebdehLtTPsDDInJqum1yxEsQVV0IjKle/AFbrrwDYk3PSTy9utFx7jSVoF+Aw0Xk5XTa5EpnZ+0VVT0AGBMrK6fspvsTEg4g8t2PlN87z75BpqfbLke8xJgMUDXvDWJlFUmdWPnUa8TMM3FfVd0lnUY54iXGgQA1Sz9J+kStjVD73mdgHlHD02lUxqaxjaGqASAbyLFsyLN+hwAv0AHIAoL1foeBcmCNiCxsYZN3Bois35jSydF1ded1T5M9QIbEU9XzgaOBfIwwbiCXX4Robv9niMgDze1nRyft4qnqFODOdPe7DVcCLSnej0A3T7dCajduTvpk986d6veTNjLxzDsgA31uS68WuEZ9lgNkDR+c9Ini9ZC134Bf9ZMuMiHei0CmHbOfZrj/bXkKIHDMSKRDIKkT/ZNG4goFAD4Uke/SaVRGFumqOhQYCnTBTELsn1zMM9B+HbSOJUMFxt30etoMTgBVfQ0YVf3K22y55h7QBBbpPbtS8OA0XEbwo0Tk+XTa1CY8LNa2ih8z+8yyfvsBH79MdEJAKbBMRNa1go17Au8AOZXzXqds1kMQicZt79l9F/JvuwT3Th0B/iMiJ6bbpjYh3o6Cqh4GzAMCkdXrKb9vPjVLP0Gra+vauLt3JnDsKAInjEGyvABvAeNEpLLhXh1aDFXdR1VX1W0JVddo+Nt1Wrvia438tKn+llBUVe9S1ezWttmhHqrqVdVzVHWZJVJ9ilX1IVXdO9N2tPthU1VzgT4Yh0EIiGEmPRuA1SKSnLNy+/5zgB6Y5/R64EcRib9X1HAfXYE9gRLgKxGpao5NOyzWXTFBVWer6rfaNGtU9VHrTurawrYOVtW3trGnXFXvVtXCps5vN3eeqnYCLgamAnUuDa2sJrKuCN2ylVh5FeJxIb5sXIV5uLt3ticVNlFgCXAXMF9EYhm090BVXSgi/lhZBZFVa3HlBPH06QEuAVgDjBaRb+P1kbR4qmo7jhtyLtu+y/p/82Km+9suB3yY4QvMcDFHRN5LwR4fxl12mXVtIt/8QNWLy6l991PCX6+Nv/8mgqdXN7L23p2sYYPIHj6ovpjfADOBh0Qk/pogBVR1D+BtIK/quTcp+9vDaFUNAJ5ddiL3+ql4B/UF+AgYGm8YTlg8VT0a47PcubnGx6EU6CUiCTsPVXU48CDQG1Vq3vqY8jkLCH8a98PaKBL04z/8AIKnjMPdo4t9+DPgynQtsK0RYhnQt/rVd9ly9V3bfbjEn03h4zNwd+8McISIvNSgvQleMAT8jLmjMsnJIvJ4AvYI8GfM7rQn8vUPlN48l/DKr9NjhUvwjR5K6LzJ9n8gwJvAFSLybqrdWsK9CgwOf7GGkqk3/WqNWJ/QJScTPGUcwKUi8vcGzUzwuvlkXjgww3GjqGoW5m6bQUw9FQ8sYNOU69InHEBMqV74DpuOu5Kyvz1MbPNWgIOBt1X1KVXtl2yXqjoEE8A0OLJ6PZsvuiWucACunLqds7hRZ8kMm08BxybaPgViwAAR+bIRG7KB+cDhsYpqSv98JzXLV2bQJIME/QRPPYLgyeMQf7Zt6wLgf0XkjcbOVdWOwOXApYA3vPIbNl92O7GS0rjnePv1pOCB65AsrwL9RKTBT2ZSExZV3RXojZl05GDWTfa/8+u9zsZMYMQ6LtZrFw07okuBG0Tktkau7QWeBCbGSkrZfOEthL/6Phnzm42rMI8OZ07EP+Hg+hObbzFD4TKgCCjGvOe+wAhgPBAgplT+ZyFb73gCrQ3HvYYEfHR8eDqenl3BfDguids2De8padREEYes61cn4vdT1TuB82Ol5ZScfTORb35I6FqSnYV3YG88u3YzTuJYjMj6jURWryf82WqIJb8acOWHjP9y8qG4CvMabxxTapavoPy+Zwh/vrqJjl3kzboQ34h9AD4B9heRmrjvLWnLWwFVnQrcp7VhSs6a2fRsUoTsoQMInDCWrKEDtl3L1REtLqVs+uzUh16X4N1jV7L2HYCnT3dceSFceSG0vJLoz8WEP19NzZKPiRaVNN2XCDlXnU5g0ggwd+9wEfmqsVNaJQApGVR1N+DvAGU33t+kcO4eXci96nSy9u1vH4pi1kufYBa+LsyQNtqVE8wLf7Y69YlYTAl//h3hz5u5xypC6MITbOEqgPFNCQc7gHiYtWWw6vmlVL3UeBRB9oF7k3vTOfbmZxFwC2bxX1y/nTVsr6p69s3NsdLylphFx0W8HnKuPRP/EQeAiZA7TkTeSeTcNi2eqnYBxmllNVtve7TRtv7DDyDn+qmI2w3wBHCuiMQbr34P9HIVhNJqb7K4d+pI7o3nkDWkH8BW4PhkQuLbtHiYpEWJrCtqNFI5++Ah5Ew/C3G5wCzcp8dLcLSWG9cBVC9K2huXHkTwHzmc0GVT7FFiHWaoXJFMN21dvA2AursViisn2KCA3j12Jfemc23hponIDU30eS6wS/ir76l+teXFyx42kA7nTsbbvy4A7mngHBHZlGxfdbNNax21F+bTHsRM5X38Eihkx5PYTud8jKPZj1nD2cfr8wXwh8YW3k2hqi8B42re+ZQtV97561y43Xam4J4rcRXkAswVkdOb6KsDZl3WefNFt1KzLKkPeh3iz65zJCeCu3MBvrFD8Y8/0OwaGNYDfxKRxp8HjdkBdRuWbwEDU+2oEeaLyDGpnqwmOeN9oHOsrJyaNz4i+tMm3F0L8Y0diviyAV4GJohI/NWv6eta4IbaT1ZRcuZNKdnj6pRP4b9nqAT9EisuJfr9T0S++5Fo0WZ0qzUyZGfhLsjB3b0z3oF97CAkmw3ALODu5m662uKdDsxpTkeNUCwiTW4sNoYl4Bzg0Ab+fB9wcVP/EZab6lsgt2TqDGo/bnImvj0i5N9xOdn77wVWFHWCZ5ZivDAPAS839SFLFPuZl/gYkDzNTucVkbXAaFUdBAzDxIOWAi/G8/s1wBVAbs3ylakJBwROGGMLt0RERqhqL6Af0B/ojHmsuDDvuQhYC3wIfJmJjV37zgsC9wKjgJ1Ir+fldhG5OI39JY2qdgO+QdVf/LtphL9ck3QfroIcCufNsmeHI5tySLcEHgArCGcK1G25dAUKMRMVe/d720mLDzNRsYNj8/llt7zQOmchcE2LvZv4XAv4qxe9l5JwAB3OPsYW7vm2IBw0sFQQkVrge+tnh8ca2s4gFqP8vvkp9eHp1Q3/0YcARDAhF22C/w+ZsTcCWVUL3iLyXWoZVqFLTrY9N/eIyGfpNK45tGvxVHUgcJLWhimf/UxKfWTtN4DsAwaBteeYRvOaTbsWDxP95ap8ajHRn4ubbLwdLiF0UV1+yAwRSS2vOUO0W/FU9UBgfKyymoq5C1Lqwz9uGN5+PcF4QzKd7Zs07VY84C8AlQ++QKykLOmTxeuhw1l1jqGr22IIersUT1UnAsNjJWVUPP5KSn0Ejhtth/39F3gkjealjXYnnuVgnwFQPns+Wpm8g0eCfoJnHGW/vCrdEdPpot2Jh1kaDIiu/ZnK+W+k1EHghDG48kIAb6Y7FTmdtCvxVHUCcLlGo2y5fnajacfxEK+HwPGjwRRF+FOaTUwr7UY8Vd0feAxwld/9dMoR1L6x++M24XzzE40laS3ahXhqipguBIJVzy6hYm7qI52nt6kwpTXhTlbOXrMrNmWKVo/btIKMCjGFtZNaBFsJJ5cCNwPeqheXUTr9XxBtxvzC46bD1KMJnjbedomtBS4QkdQWixmk1cRT1bEYD8g+9Q6vxCQ2PtJUurGaGpi3AvujSsWDL7D1n08mVB8lEbz9epJz9el4++9mH3oEuFBEtqTlAmmgtcLdz8N4LCS2tZLYhmJcnfJx5dYlCZVgaos9B6wUkS1W7ndf4BDgeEyRHqJFmymb+UBK5RSbxOUicNyhhC443k4w+QE4TUQWp/9iydPi4qnqwcBiVN1b//kklY++jIYj4HHjG/lbAieOJWtw3yb7iW3ZSuWTr1Hx0AuJBwO53SY3Icm7092jC3nTz8Y7qA+YWegtGK9LWsIZUqU1xFsMjCy/b37c/TVv/174Rg8la9/+eHruhAR8aGU10fUbCX/xHTXv/JeaNz5qNNtmW9w9upD/1wtVQgGpXvQelU8vJrquKHHDXS46nDae4FmT7Krty4ETRSSxjJcM0KLiWWHmlcRi3g0jzknJ+5EKWYP7kv+Py1QCPkXEzLBjMaoXf0DFnOcIr1qbcF/eQX3Im3m+HRFWjIlybpVhtKWXCkHAG6uobjnhfrMHef+4HAn6BZMePAi4H5erxjd6Pzo+ciO508/C3aUgof7CK7+h+JRr7WdsR+AlVT0lc+8gPq1x51VpNOrZOOaCpIttJ0tg0ghCV5yKeD1gUqH/YPspraCkS4HzAZ/W1FLx6MtU3P8cWhM/3bgOK7MneOoRYJ6DE1t6OdEaz7wFwPiqF5dTOn1289ZkcXDlh8i5/Hf4xu5vH7oVUwxgu/A7Ve2JWbKcBEh0XRGlMx+wi3o3SfC08YQuOB5gMzBERFos9qc1xOuPSazvEP7qe8pmzGl+fpuFeD34jx1FhzMn2o7lrZhsoSZDylV1P0z4494AVS8uY+stjzQ9OoiQN+uP+EbuA7BARCY0820kTGut84YBDwO9iSk1y1ZQ8fgr1L7/eUqLbFdBLv4JBxGYfGj90PKFwFnJ3AnWsH4pMA0IRDeUUHrdvdR++EUT18+h8OlZdkXb8SLyQtJvIgVa08Pix8RTXoRVJiS6voiapSuoWbaC8FffEytuuGKC+LPx9O1B1sA+ZB80BO+Q3W1XFsAK4JrmbOWoam/MM3K4xmJUzH2e8nuebvSbTAInjiXnsikAq4D+LbEH2BZ8mx0x9cLOw1TP++Vv1tpOra0d8bhxFeTgys+x63PZhIHngXuARekILbfuwmuAqwFP9avvUnrdvcah0BBuN52evBn3LjsBTGlO9k+itLp4NqrqAn4LHIkJu98D47BuiFpMkfCPMAkcr4hI/MImzbPrYEztl4LqNz5ky2W3x23rP+ogcqdNBZPatlcmC89BGxKvIVQ1H3M32uUcIpgEjqKWDE2wJllvAh1Lp8+masFbDTd0u+k076+4d+4McIKIPJFJu9q0eG0JayH+SKy4lI2TLo/rZPAfPYLca84AE7g0OJPfH9suNmNbiMeAt10dcwlOOTxuo+oXlhL9aROYRNVJmTTIES9BrDvoCoDASYfF/XIMDUeoeLBupXCNtWGcERzxkkBElgKvu0IBApNHxW1X9dwSu+rREEztsYzgiJc8MwGCJx+GZGc12EBrf333ZcoQR7wkEZFFwPuuglz8Ew+J267qmSV2mP1+1nIj7TjipcbNAMHfH2nvWGyH1tRS+dRr9sv/yYQRjnip8QzwqbtLAb5xw+I2qvz3QjtE4yg130WUVhzxUsCaec4CCJ565LauujpiZRV2sTsB/phuOxzxUudxYI2nVzd8B/8mbqPKx+rqwB2nqu64DVPAES9FrO86uBXMsy8ekTU/2QXGOwKJxVokiCNe85gDbPQO7GMX19kOCfqRoA9MUfHydF7cEa8ZWLWx/wIQuvgk8Gw/KobOm2yXSX4t3dm1jmO6mVhFhz4D+tS8+THl984j8sMGPH260+G08WSb52EtMExEPmpVYx22R1UHqurGON8StsnKG3Roq6hqD1W9XVVXq2qpqn6gqrdYX0Hj4ODg4ODg4ODg4ODg4ODg4ODg4ODgsOPzfyENJ/T/2ygfAAAAAElFTkSuQmCC\"\n  },\n  \"sparkleAnimation\": {\n    \"icon\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG8AAABvCAYAAADixZ5gAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAPYQAAD2EBqD+naQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAqRSURBVHic7Z17rB1VFYe/dS8tLXC59iUgbRHwFYskGgMiakANNVIFXyho8YFREARFRBCIEhGUoEikEB5FIZo2QAKC8gighcRojBpFIlUpahHt49JCaWnp4/78Y81w5syZOfc85syZc7O/5AbOnrkzq/c3a++1116zDwQCgUAgEAgEAoFAIBAIBAKBQCAQCAQCgUAgEKhh/TZgIiQNA0cCrwZeAH5tZqv7a1U1qLR4kg4AfogLFzMOLDWz7/fHqupQWfEkTQd+BszLOeW7Zvbj8iyqHkP9NqAJi8kXDuAsSXPLMqaKVFI8SXsAn5rgtGnAeb23prpUUjzgE8CMVNssYGqq7V2S3lGOSdWjcuJJ2pNGrxsGZgL7ZPzKeZKm9NquKlI58YCP0+h1M3AB9wT2Sh07EPhkCXZVjkqJF411aSGGqRdzHxqj5NMl7ddL26pIpcQDTsa7xyQzcQFjpuDjX5JpwFd6aFclqYx4kdctTjUPAy/LOH0WLmKSYyUd3gvbqkplxKM1r4sx4OUZ7RdK2q1ow6pKJcSLvO7kVHOe18WM4AFMklcBJxVoWqWphHi4cOkIM8/rkmQFL2dISo+Jk5K+iydplOx5XVrMLKZmnDcC3CxpoaS+//t6Sd8S05IMWAScQ+P4NYfGiDKPceBJYGfGsb8D1wAPmNl4h6ZWlr6IJ+kg4ALgrRmHh4GDaa9X2AT8t8nxJ4AbgZ+b2a42rltpShVP0ghwJnAi+eNZO16XZA3wHKAm5/wNWAI8aGbNzhsIShEv6iLfD3yVfGHi/OXMLuzaATzDxCL+A1gK3D3I3WnPxZN0CHARcGiT00ZxjytqjtaqiCtxT3xoED2xZ+JJmgF8GfgQ+ePXNDzcn94jM1oV8Y/AuWb2dI/s6AmFixd1kSfgwo3mnDYMzKa16UARtCLiauB4M9takk1d0wvxLsbFy2MUnxpMNAHvBROJeJmZ3VKuSZ1T6CQ2WtXOE24acACwH/0RDjyZvS9wEJ56Sz+8h5VuURcUncRdlHOPOeR3of1gN1xIo94D+/VQdUTR4qXLFIaAubjXVYUtwFpge8axP5VsS1cULV46yzEO/BvYm+wCojLZCazHx7ssxoBlzS6QCMY+jEfIK4Al/QpyCg1YJB0G3NzkXv0QUcAGPFDJm5CvBs4ys5VNLySdDpyRav4NcEo/5omFBixm9jvghpzDwp/6fwL/I7vbKprNeNJ6PdnCvYgnro9rQbi5wOczDh0BLOzSzo7oySRd0juBs/EEc7N798oTtwPrcPHy+BU+NXiqlQtKugw4PtGUDHZWAh8s2/t6mWEZAo4BvoiH5s1sKErEcWpdZLPJ+GVmtqLVi0o6ELibWjQ6PfrZkDjtVDN7uF2Du6GM3OYQ8F7gNCYWcZTs4qJW2Ab8h+x1PYCtwHXAj8ysrS5b0lX4gxgzH3/QVlF7SP5sZh9ry+IuKW1JqA1PHI6OtzvnWo2/v5fFCuCSTnKXkhYAt1H7W+1J7QWYtcDGxOmfNrPftnuPTimtTMDMxs3sPnxp6Gt44JLFLjzAaIetZAu3Cv+DntZF0vlL1D/kcxL/n16+ygpoekbpNR5mtsvM7gLeh4v4r4zTnsUFaZUssa/AE80de4KkNwNvSzSNUJ9wmIKP1zFvkfTGTu/XLn0r0EmIuAj4XsYpa1u81As0et0jZrbUzPLGvwmJgpQLUs1zMk6dnfp8pqTdO71vO/S9uiqqKVkK/D51aBvugRMxltG2pFN7JO0t6XzgLuB1iUOjZEfDDd4H3CUpqz6nUPouHkA0P7oUH++SrM9oS5LndY+2a4OkYUknAffjdaTJ1KHR6GFJ0qUd84Glkq6Q1Oz3uqIS4gGY2ePAranmXWR7VkwhXifpSPz994torNKeAryC5tOX3fEuNR29HwvcI+nEXtSQVmpDAUl7A/fS+M7CK2lcmXgBnx4kedjMTm3jfrOAbwFHZxweiuyYRet/p+34WL0l49ijwDcmSsO1Q2U8D8DMNgFXZRzKCl6yvO6aVu8V7e9yPdnCjeAvbc6mvQd8Kj4H3J/GeeqhwK2S3t3G9ZpSKfEibsef0iRb8cLamC00jnUr2hzrjgJen2qLV/v3p7MsT8wInmhI1+hMAS6JtinpmsqJF9VRfpvGVYB1ibZnMn61Za+LeE3q835491xUJdswvjg9Hx8TY0aBNxVxg8qJBxB50B2p5p14V5nndX9p8zYbU5/HgOfbvEYrTKVxvC6ksqBSAUsSSTPx4CU5hzL8j/Fi8lTgBDN7rM3rz8anBXukDu2Fe0y3O0wIn6em1xJ3AUebWbspwAYq6XkAZrYB33csiagXDtzr2hIuuv4YcC6eDEiyGc+7jtG8ULcZ8SLwWhq7/xuKEA4q7HnwUkR4O/WZjiTjwEfM7K9d3GMuPr/L2oxnd7xUsNVxcBs+NmclyZ/DI+nlRS3aVlo8eCnHuJz67jNmiZldXdB9FgLnk71Rz2yaZ1jA31LKSuftxAublphZXvFTR1RePABJ8/ClmbfjY9TjwE1mdm/B99kLfwXtJOrnaYaH/nnj4HN4XU6aR4DLzWxVkXYmjQqkiBZgvwkckmieQbZXCh/fdiTaVuGiPdIrGyGIl0s03i4D3hA1GV5Qla513Uh9BmgZcGk3y1GtUtlos99ES1XXJZpE49xQ1CcMNgFXliEcBPEm4pf4q9AxG6lfotpAfcHT9WbWi4l+JkG8JkQh/fWJpnFq3heXGcasB35akmlAEK8V7qe+zmYDNeGSXnitmaUn/D1lUoknaV9J84u8ZjT2pb1vjHqvewpPJpTKpBFP0ueAh4D7JX0neqOnKO4GkqWDsffFXG1mOyiZSSGepNcCZ1H79xwHvKeo60fR4405h58AflHUvdphUoiHb4E1hOci4zTa2ZKKfIHlNiBdA7oNuHAy7apUKpKOkPR49LNZ0nZJK6PP6c1Xu73XFEmLJV0p6YJoG66+MdAZlqgi61ZgAfXvEKzDx6WNwMIy515lMujd5iJcOKivZp5FbdvHz5ZtVFkM5Ja+kqbhu8DHwoxSX1oQ72O2HvhMVPBzrZml01sDzUB1m1Gy+Hj8NbE4w78bXvGVXq4RPrmOV96fxyPGW8qeTPeKgREv2qDnHGpfxzaEd4uzyO/+4/fgx6jlINfg5RV3DvKOfzAg4kk6BRcupt1dAuOcZHJHiDvM7OuFGdkHBkW8FXg3uQdeU9Lp/G0nHoluwr3y8EGORAcl2ozXzLbh3WAn3Z3wqq64OGgzjZVjA8WgiHcxPlaN40KuovmOD2m24MHLGtz7nsczI6XnI4tkILpNaJgexN/kNRUf+0Zyfm0r3k3Gr0jvwCvRJsW0YWDEi4kqqb8AfJRawDKPxm832YEXBin6uQ/4Qfim5wogab6k5VEO80k18nR07EFJzfa3DvQDSQdLeiwS6dmEcFsTyepjJr7SYDIoAUsmUTHrndHH5Asd66L/Pgo8ULZdZTHQ4kVcjYf8O/GJeHI6cPkgbrnfKgMvnpmtobbH5wZqXveQmf2hP1aVw8BFm1lEX3NzD7WXQbYDHzCzJ/tnVaBlJC2QdJOkn0g6qt/2BAKBQCAQCAQCgUAgEAgEAoFAIBAIBAIF8H+sMl4IpqCuzQAAAABJRU5ErkJggg==\"\n  },\n  \"theaterChaseAnimation\": {\n    \"icon\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG8AAABvCAYAAADixZ5gAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAPYQAAD2EBqD+naQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAABksSURBVHic7Z15fFTV2ce/z2Qy2SEJsoQdRUAQEVFEliq4K6i1n0q1WrVa61Jqq9W2b+tWfW3d16q0WJVqq7Qfa0VxQUXZROpWcQFRCTsECSEbySS5z/vHufdyM5lk5t5heD+G+f2TnDv3/O6Z55l77j3n2SCDDDLY+5D/j4uq6gjgdOAgoC+wC9gCLAPmisjmgLw5wBTgBGAgUALsAMqBV4AFItIYgDcLOAO4BBgCdAEsYDvwLnCviLwbZMzfGKjqBFVdoh2jRVWfUNX+Pngjqnqlqm5LwF2hqjNUNZIkb0hVr1LV2gS8qqprVXVKcOn4x16581RVgBuB65xrNn+1kei7n2F9XQXhLLJ6dyfnqJGEunV1utUA3xeRuQm4y4DngLEAtETRzYuh8lNorIKcYigdgZRNgCxXZ8uAMzu6w1W1K/AGcBgAlkX0g1U0rVyLVVlNqCCX8AF9iYwdgeTleLs+AFwpIpq0gAJibylvJmbKIfr+SmrufZqmT79qe2JIyD12LEUzziKrd3cwU9N5IvK3dnjLMIrojxVFV8xEP3rQKC0WOcXIqBnIwT+GUDbAWmCciGyJw1sIfAwMQJX6f71J7Z+fw9q2ow2t5OWQf/aJFF4wFcnPdQ4/LSJnJ5JLqki78lR1BnA/QN3sedQ8+AxYHf8oQ10KKP7DT4iMHQHQAEwUkfdieCPAQuBIGquw5l8AW95OPKCy8YSOe8zckfA2cLSINMVwvwkcrY1Rdl43k4Y3/pOQNnxgP0ruvZqsnqXOoatF5O7EAwqOtCpPVXsAXwBFu55fyM7fzUq6r+REKJ31W7IPGgiwHHOXuFp3fxRWE/rSdHTzkuQH1mscoVP+AaEIwOUi8rCH9wzgX6hSdd0jNLycxA/CRnhQb7o9dj1SmA8QBfqLyNbkB+YPoXQR2/glUNRSUUn1bbN9ddTGKNU3z3Lu0rHAqe5nqtnAbwD0k1n+FAewZRn66WNO63qbz8HdAA2vLfelOIDmNZuo/dNzTjOCecanDWlTnv2S8l2Aur++hDZGfXM0fb6OxkUfOM2zPB8dA/TEakL/e3+w8X14H1jNAL2ASfaYhwKDAGoffT4Qb/0/X8PaWes0v2fLIS1I5513ENAPoHFB8CVQwxtu3+M9h48H0C3LoKEyIPF2dOs7TusEL2/Lui00f7E+EK1Gm2lc/KHT7IZZF6YF6VRefwCrpp6WLdsDk3iE2FNVnde5AYBZDqSC7W5/Z015AEBTQMU5aP5ig7c5ICWyDpBO5ZUAaE1dSiSeKUgA51WuBIi/JPCDRveu3c/+2xNAq1Mcc1WNt9ktJbIOkE7lbQcIFRelRBIqcfurwwl8DUBuaZwePpDn6IwK++9GAEl5zF28zYr2zksV6VTeWgDJzyWrT4/AJOEh7qyz2bMvabi7HZzK+JBSt/9a++9XANlDkt6Zi4vsoa36r23vvFSRNuWJyCpgDUDusUcE5vH0fdlz+BUAeo6FvIA/jPxe0PPw1nz236ze3Z31pW9IboTI+FFOc6uIfBFsgImR7nXe0wAF557k3TpKGtkjB5Nz1MhWXDYWAxuQLGT0VYEGJqOvAskCWA8sARCRr4BVAIWXnBmIN/+ckwgV5TvNJwORJIl0K+8OoDJU2pWuN/wIJPkljxTk0fW6i5w+C0VkvvuZSDNmoxs56Hyk//HxSdrj7jsZGXau07xORFo8H18GkDPpUPLPnOyLN3vYQAp/eJrT3AXc6ovAJ9KqPBHZAVwNZvrr8usLIJyVeFDdulL64DWE9+8DxrpweZzTHgcWICFk8iNIv+QUKP2PR46d5dx1rxFzd4jIAuAFgKJrziPvtG8lxZt9yGBK7r8ayXUtFzNEJOAiNDnsLavCHcAvAJpWllPzwByiyz8Bbb1BLZEweVMnUfjjMx3TUBPwXRH5dzu83TBT3lC0BV31N/SDu6FuU9uTC3ojo69Ghp4DEgIzPY6PJ2B7PfkBMAygYf471D7yLM1r21qQQsVFFJx/KvnTT0AiYefwTBG5NAnRpIS9ZklX1Z9jptEsgJaKSqLvrcSqqITsbMJ9uhM5Yrj32fg1RnFvJuAtBeYAx5oDFmz7AK38BBp2QG4pUjoCuh/qKA1gPvC9ju4MVc0DXgTcubPp83U0f7YGa/tOpKiA8AF9iIw6ELLc2USBm0TkJh+i+WZAVUeq6guqanVgkW5Q1ftUtbsP3pCqnq+q5Qms3WtU9TxVTfpxYZ+/PQlL+seqOjqYZIIhqTvP3lwdhtnqKQYqgbX2csA3VLUfMA0Yjtn/bAA2YexrL4tIdUDeEHAkZq9yEGZ3YztmyfIq8I6IWAG5JwJXACMxOzwWsBUzbd8jIuUBeYey29+mCrMuXJmyJV5Ve6rqXaq6rp1f21eqequaqSuDJKGq3VT197b84mGdLfeeQS8wQ1VrWlFGq1Wry1WjbfxxdqjqhXv4O3ZKqOoPVbWqtVxrbblWx8q1RlWvaI+rzbRpT5GPYPucULcJXfEQWj4PajfuPrFoADJoGjLyMu8e4Z0ics0e/K6dCqp6J/bSiV3b0BUPo2vmQs263ScV9kEGnoqMvBwKypyjM4HLYqfSeMq7CbgeQFc+iS77DTQ3tD+i7EJk4l3IAWc4R64SkXsCfbtODFW9GrgTQL98Fl38C2jqwHoRzkOOutUsbQxujH2LbaU8VZ0ALAJEVzyEvpPsG68gE+9Ahp0H0AKMFpEVSXbu9FDVUcB7QJaunI0uvhazqkgMOfJGM7uZDhNExPXNiFXeYmACm5dizfuOWTMli1A2odPmwX6HALwoIlOT79y5oarzgJP5+kOs56eC1ZSwjwvJInTqs9BrHMAiEXG3fNz1jhoX9AkA1vKb/CkOwGpC/3OL0zpFVfv6I+icUOP5fRKALr/Fn+IAtMXow2CSqg53Gt7FqtlR3bEKtn1IEOjGhc7WlLh8GUwDhNqN6KbFwRgq3oeq1U7LlatXeSMA/250raDoZndKHpECUWeCkeuWpST7nIsHj15cuXqVZ95L69p4f/vD7k3h3qkRdRrYcg0U+LQbceTqVZ5xrMxKKoCmfWS5QRe+Q6k6KYxcQ3terl7lGdUW9UvtIkWu/0aKP7VOA1uuqfnFxJOrV3nvAEjfKV7TiT9kRZDeE53W0mAknQ5Grn0mOdFJ/iEhpM/RTsuVq1dLcwGLvO7IoGnBrnHgdMguBHNrv5Lg9H0FLwFRsouQA89KeHI8yP6nOY5WLdhWfvAozw40fBJAjvitEwKVPPJ6IGOudVozg5p1OhtEZCfwJwAZ80vIS9pMaZBTjBzhxqv81Rt1FLvDMgBYARTppkXoqz+A5vrEF4h0JXTS36HHGDAW8OEiss3fKDsv1IS6fQp0o+JdrJfPhmgSv+3sAuT42c6jqBo4WERcX/xWDzcRWQucC1jSexKh016ARI6tPcYQOn2eo7gm4KyM4lpDRCowUU5N9DjcbCP2OKzjTt1GEpr2gqM4CxPi3SqIIq4lXVXPAR4FclELXfcqlL+IOnHeuaXGW3ngVKTfFIemBhOCHNdZKAM3cPOvQCEouv4NWPMCWvmxiXbKKTZyHXCKcWc0L467gItE5O9+LjRGVZe1Y+mNxZv23mgGCaCqB6vqW0nK9W1VTXCLtn8hUdWpqjpbVTfHEG9Q1UdV9YTETBnEQlVPtOW3IUaum215T9U9GZipqrmq2ltNspoM9hBUNceWq/+YgAy+mUh4W6oJtj8G407XFxOIWAGswyzEF8X4+meQBFQ1jImFPxHj/tgDs8xaj3FTfCs2xYgf8mxV/Ymqbk3wUF2vqhepyc+VQQKoalhVL47zrIvFFlW9QltnqmiF9pYKZcC/MA6s0NxC9P2VNH+5AauqllBJEeEh/YkcOgRC7lJxAcY9PXgAeieHmtiKf2JmMjclVvPq9Vg7aggVF5qUWGOGeV3o38ak2mpjq4vnPeamhNKmZuqfmU/d4y/ExlkDJpqn8OIzyP/OZEeJ7QZv7OuwFbcUGIJlUf/P16md9TxW5c4254aKiyi4cBr5049HTFTVWuCo2FxpsdtjEYz32Firuo6qX9xH9P2VCQeWM2EUxb+/wgkSeR04IahbeWeE/UiZD0zW+gaqfvUgjUs/StgvMuYgiu/4KaEuBWBuqKNFxE1oE2v7uRwYq80tVF17f1KKA2hc8l+qfvkAWBaYaJ3zkuq47+B8YDKWUvWbh5JSHED0vc+ouuoetKkZYBzwY+/nXu+xHOyUUPVPvUT03c98ja7x7RXUP/eW07xJfUTidGbYcrgBoP7ZN2hc5M+5K/rh59Q//arT/K16coV6BTwF2E+jzdQ98WKggdbN+reTK2wAzstOBkcB/bGUur8ES4lV99hc5+7rgSde0Ku8EwCi736KFTCJTEtFJU2ffOk0TwxE0vlg5LriC1oq2ubrTAZWdR3R99xHmCtXr/IGAjSv9gQ9BEDTatdqkba0Td8wDITU5dr8udvflatXeaUA1s49lrppv47O24dg5LrnUmK5cvUq72uAUHFhShfxpG7KGGQNjFy7pijX0rZy9SpvHUB4cGquf9kHuv1Tmyc6D9ZBK7kEQjy5epX3CkDk8OHOotA3snqWkj18/1Z8GRg5ZB88mKweJYEIQl0LyT5sWCs+aK28BcA2iYQpuCBYdFbBxWdASMAUoXin47P3GSwD1hESCi46PRBBwYXTkOwwGGvOAue41/WvEbgZTP6syOEH+bpAzvhDyD/dDR27LrM9ZmDL4XqA/G9PJmfSob76R0YPJX+6m93pJu/2WLy9zbeAcVZ1HVXX3E/0vcQ7LTkTD6X41sudvc35wEkZ5e2Gvbf5CnCs1jdQ9es/0rjkvwn7RY4YTvFtM5zH2FLgGK+Nrz2rwtvAAG1uoX7OfOoem4u1I45VoXsJhRefTv63JzvT5UpM6G3GqhADNelOlgJDsSzqn11A7ax/m4ouMQiVFFFw4WkUTD/OMQ2VY6wKrcxC7dnzegHPYrZ2oKWF6PuraP5iPdbOWkLFRYSHDSRyyGCvPe81YHpGce3DNgvNwWxFGnveh6tp/nwtVlWNkevgfkRGD/Ha85YA3/FVn8G2pF+mbb3GYrFOVS/IbEQnB1XNUpOLZX0CuW5S1UvVuEvERTI+LGHgaEzaesfXYivGQPgKsCTjw+If9nNwAmavcgAmOXkFu31YFtp5RTPY56GqearaRzN+m3sUavxh++ie9NtU4zF9mqo+qaZwYOyc/JiqnrTHLrgPQVVPVtXH47xTbLXlPU2Dekyr6lhVXZ7goepgkaqOTMyagaoeoqqLk5TrO6p6eHtc7S0VzgX+jBMltPZlKJ9nooSiOyGnBOk2EgadgvQ7zqGpxUQJPRePMwNQ1W9jooQKTJTQa7DmRXT7x9C4AyJdkW4jYOApSP8TnSihBuBiEXkqli/eIv10zBovxPYVWG/9tOOaPd1HEzr6ASg+EEx83kki8sae+LKdCap6LKY2RJiq1Vhv/aTjZEWlIwgd8wCUjgATn3dGbAnW2O2xgZjI2ELduBCdf36SkbFd7MjYw8Fklh1uBxRmgEk6i4mMLWXrf7BeOSe5yNhwPnLCbKT3JDDxjweLSFyTEJiN6UJq1qKvX5yc4gCi1absZ/1WMKmB01r07xuI64FS6rdgvXZBcooDaK43ejD5OIuwDQcOvK5/ZcA5YCc4i7b15O0Qu7ah79/utH6kql06On1fgZqqzxcD6Hu3wa6v/RE0VnkT8p2rZusSaH3nnQ6EqN9qsq8GGejnz0BTDUAOcHIgks6HU4EI0Wp09T8CEeiaubCrAoy+3DwrXuWNBdANCwic4Mxq8ma2y/htGhi5blrkP12jA7XQDW86LVeuXuWZhGQ1Kbqe7O7fJzWiToO0ydWrPBMHZqW4F9riGnpTzJTWaWDLNeBd58BqK1ev8kz4UEEvUkKBm1EwTkGffRK2XMsSnJYABe4N58rVq7xPAG/itwAQpGy80/g4BaLOBCPXsvGkUropnly9yjNREMVDTNGkIBfo8y3nF6aYRHQZGDkoBX2C3xg9xjg7WODoidbeY59gV3AMjb3Bf9rGUDYy1l2bzxORDR2dvq/A3hF5GTDy8Zu2UbKMPgwWiYjrERarIZPwv2w8MvZ6P1dAxv8Buo0EaAZ+5W+EnR6/AlrYbxQy/vf4mT5l7PXQ60gws9m13s9iE8ctBX4HICMvQybdA+G8jtmzi5ApM71lPK8RkczzzgMR+Qhb8DLsPGTyI05e0vYRzke+dS8y0q2heKOILGvFG9vHNgA+BJhe9VvQjx5Cy1+EWs9M2GWQXUvoUsh167jfLiK/9P/19g2o6u2AqbW062v040fM7kl1+e6TivphagldZipKGzwMXJF0WTZVvVxVW5eVitaYalNNdbFGw+2q+oM99zU7L9QUaaxsJb2mOruKV02sXHeqarDyparaQ1Xv0PYrQn6hqreoarAIin0Uqlqqqv+rql+2I9dyW+4dpsVN+smpqsOA/phgwe1AuYis7rhXu1z92V25si/GWrwZE5Txkp3aNwhvCOMofALGnc6pXFmOcadblkLlyq6YzfZxmFoJucAGjJ1urtfO5pP3QEz0bDdSrAiaVqjqKFWd186vzUGjqj6oJrVvsrxZqnqhqq5NwL1WfToIq6ne+Ud7XB1hnqoeEkwywbA3qzVfDdyGU615y3ai76/EqtgBkTBZZd3JOeIgpDDf6bIdk/K4Q5cKNS7k/8DJkqAWVLxnqjU37oScriZ7bPfDvGvX123uDl3zVfU44Bns0GStradx+ae0bPkaos2EepQSGTOMrJ5u1dUW4FoRuduPbIJib9VJdys2Nn26hpoH7TrpsYPJDpN76kSKLj2T0H7FYNaM323PqUm9KaG0BV35V/SDe6A+TkmdgjLk0J+bJY0pcL8KExQTN1eaGmehOUDY2raDmkeepWHeEielhmfQQuSI4RTNmE72QQOdo3ulgmfalaeqP8Tkq6b+2QVU3z4bmjv2jg+VdqXkzivJPmQwGK+0o2LXjmrc8OcDx9BUi75xCbr+9YTjkX7HIVNmOuusNzCptloNyJ7+lgIFTR+tZscv7sOqTOC6EM6iy7U/IP9MN03KBSLyRMIBpYC0Kk/NW+iXQEnDa8up+vUfQZOs2JifS7fHbyC8fx+IKfpnc18CzERb0Pnno+vmJz0u6TsZOfEp5w68SET+EsO9GJjQXL6ZygtvwqpJ0pdHhOKbLyX3pKPAlM0enM4siOmO7LkWKLEqd7Lzd7OSVhyA1jd4+0xSTy5r+64zdW0/e9yX4sB4C+hns53mjerJFaqqJwMTUGXn9TOTV5zpzM5bH3Pu0mLgKl8D84l0K286QN2TL6H1HRQNbgdNH3/pTbL2Pc9HE4E+WM3oB/cGGph+eA9oC5jIpwmxY25c8l+aPv3KP299A3VPvdyKK11Im/JUdSgwCKDh9XcD8zS8/h/nX286LBMfsXW545jjH/VbTf+23CfGXNc3Gl53eQ+w13FpQTrvvIEAWreLlo3B/W89aZvKdHcUjeHe3vaN1Q90u/sOZPgMfy+A5lVrA/O2bKjwzjRpS+OVTuXZ6bBqUyLxpG0Sh9P925hiBHWD29/ZhnJ32PfguH1Wfkoe6VReJRA4IY+DUHGR8686nO7fnBS3VHPdxbWTEsp9M0w53dTucfv0svVxjXQRY6dZksJ8ssqC55ALD3Yrdm8VEWcuMnNp6fB4XZJHqVtBZz2AzV9hrhs83VRW7/2ctCaQxjRe6VTeSmyh5E4eE5gkd4obnuZdD7wKIL2O9N49/pC3H9JzbCs+73VyprQbFpcQuZPdvmndZE6b8mzD4RyA/HNPQXL9u3FmDx1AzsTRTvMZz0dvAVsJZSOjrgw2vlFXQigMxpqx0PPRHIDcbx1GeIj/Oq+Sl0PBua6n/5xAg0sS6V7n3QZUZ/UoocuvLvDVUfJz6XrjJU5ynneAee5nJgvQzQAy4iL/Xlm9xiHD3fHcFJN1YS7wNiGh+MZLkDx/4fddrv4+oe4lYEKy7vI3MH9Iq/LsIoj/A5A3dSJFPzvbm3Sn/UF1KaDkrp8RNmkKdwGXx3EB+BOwjFA2cuyjsNuvseMxlU0gdPwTTunrJdj7rp4xK/BToCE8pD8ld/0suZeuUIiin59D3hnHOEeu9ZX4JgD2llXhEey08tEPVlFz39M0ffxl2xNDQu5xR1I04yznJccCzm2v8J+acKdlwACsJvSTP6Mf3m9ChGORU4IceiUy4mLH/a4cGNeegFX1+8BsINSyaRs1D86h4bXlTgL0Vsg++ACKfna2qfBi8LCIXN6BSPYI9pbyBLMXeYNzzebyzSYZ+bYqyAqR1bcHOeNGejO6VmNKbb4Qn9XlLsOEYY8DTKTS5iUmFLuh0rzQlI4wHse7fSaXYlJCxbEdteKeBjyFCWzEqtxJ49sraNm4DVosQt2LiRw+nPBA15Vd7e94S9LOQt8UqOpRqrowgUW6RU2KkKTf1VU1oqZoVWy6kVhs1QTFleJw91eTcqMlAfdCVR0XTDLBsNcs6V6o6nDgNOL7sDwf9FmhJuXkZMz+5EDMTkwlZop8GXjTm6/SJ3cvjN/NOMwWWh6wEROL8G+vJ3MGGWTQmfF/33vZk7RZtrIAAAAASUVORK5CYII=\"\n  },\n  \"cometAnimation\": {\n    \"icon\": \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG8AAABvCAYAAADixZ5gAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAPYQAAD2EBqD+naQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAA6rSURBVHic7Z15lFTVncc/t6q7unqnobvZZToExCiyKrIlmmgSMyPJmMl4XIJxy1FncyHKjMvRiGFiBqPG5EzEIXLCETITlcBkjiYmIKJIWIK0gOyIgjTQXd3Ve22/+eNVN93v3Vq6ul5Vded9/rz3Lbfet+59v/u7v/t74ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4JBlRORSEVkkInOz3RaHJBERt4j8UEQico47s90uhwSISJWIvClWDmS7bQ5xEJGZIvKRRjgRkdpst88hBiJym4i0xxBOROShbLfRwYSIFIjIs3FEExEJisiobLfVoQciMlpEtiQQTkTklWy31aEHIjJfRD5NQjgRka9mu70DHhG5SER2i2HC/0FEqlO8zn3RoTAZjoqIK92/5S+K6BB3wvRgV/TxGsUisiZJ0bpwDJX+EH3oOzQPdkcfrjFBRGpjKeQ/FNAVB0VkpF2/K8+uC+cK0SFrFTBdUx1K8hrXAL8Eyq2VcGhFMxKB0vH55tr1SqlP+9Zih27EcFPFYlOCc5WIPCgiYW23ao3I9u/Vy29nfiJtJ0O6Q2w1VAZ1zxOR7wAPxDkkEOfcMmAl8A1dfetHIbYvqqflSIjq+V4KR7rNhxwHft+3FveNQSueiMwH/jPBYZ0xzp0CvAKM19XXvdXBrkd9hFoiAJz3t8W6w15QSoWTbnAKDErxRKQG4+EXJDjU0vNE5HpgOWBRRCKw/6d+Dq9sBjHKvMPdVM/zmg8NAb/oe8v7xqATLzrcrQeqkji8u+eJSB6wBHhQd2CgKcKf/7WBs1t7d9axXy9CWUZM1imlTvah2SkxqCaPIpIPvApcaK6r29ShOyUQPW8E8EdiCNe0N8DmG05bhFMuGPt17ZC5vE8NT5FBJR7wLPAlc+GpDe0cerFZd3yniMwEtgLzdQec+G0bW24/S/sp6+uraq6XwhGZN1S6GDTDpojcB9xlLm/6MMiuR3yUTbDMwQC+ACwEPOaKSEDY86Mmjr/aGvOe2TJUuhgU4onI1cBT5vLOs2F23FdPuF1w5SvdqRN0hR2nw+x4oIHG2pgziawaKl0MePFE5EJgNdBr/Ap3Ctvva6C9zugELo9WPAsNOzvZudhHZ338zpNNQ6WLAS1e1ND4P0xuK4nArod8NO4513Nc2lGzN0dWtfDhc01IgkEv24ZKFwNWPBHxAq8B55nr9v/Uz6kN7b3K4vW8UJtQ+4SPk79rj3lMT7JtqHQxIMUTEYXhurrMXPfJ+jYOv6S1LLW0Hg+xY1EDzYeDSZ+TbUOliwEpHvA48PfmwoadndQ+2ag9wb8/iESMIa+Luk0d7HrknJsrGeIYKn1aG0wH1ldujiMiNwLPAL3GwdaPQ/zp7npCbaI9L+iP0HYiTPkkD+F24dCKFvY81UgkoD8+FjU3lFB5qcXr9hul1H/16UJpIDkTLEcQkTnAH4Bef/1Qq/DuLWf6NPSlgnLBFetG6FYQrlZKvW7rzTUMGA9L1Nn8GibhJCTs+F697cIBVM3RLv0cA36X6FwxQgSnRH9HWhgQ77wezmZLwNAHTzVZfI52cd61WkPlRaWU5aUpRnDTbGAuMAeYSXSVQ0SeVkrd39/25PywKSJu4H8By6r00Zdb2LusKSPt8A5388X1I8wT8xDGVKUOuABDpLkYok1McMlJSqn9/WnTQOh5P0Yj3OnNHez7cWaEAxi7QOtRqQdexBCroo+XHNrfNuV0zxORfwCeN5f7DwbZcuuZmJZlulEuuGL9CN3EPFU+AKb2d16YswaLiHwFY0rQi876MNvviT0lsIOqOVqPSqp0ADekY0Kfk+KJyOeAX2Ea1rudzZq1NTupmmOZlCdEYs/7Fyml0rLdK+feeSJShWFZ9o6RFNj9uI/GD2Iv09hFqDm+ByYSEBr3BvG9H8D3fieufMW0pdpX2jrgZ+lqV06JJyIFGGEMnzHXHfi5n5NvJOc4TjdH17Qw/Apvd1BtZ30Y3+4Avl0BfLsDNO0LEgkaw7in3MX81dW93HBRTgC3KaXSNt7njMHSw9n8bXPdydfb+PPDvu6IrWyg3EZEdKhVaDsRO9B6xrJhjLjcMsxGgCuVUhvS2aZc6nkPoRGuaW+A3U80ZlU4AAmD/0B8L864bxXrhANYmm7hIEd6noh8E/hvTAZU+6dh3ll4ms6G5L3+2aJ0fD5zf1mFu8DySLcBc5VSafffZd3aFJHpGMNlr7aE2oTt99YPCOFcHsXUJyt0wjUB19khHGRZPDH2af8GU3SyEcbQgP+g/c7mdPC5+8tjRafdrZQ6atd9syaeiBQBa4Ex5rq9y5piBcnmHNXzvIz7ptZh/Qul1Mt23jsr4kX3zK0GLjHXffTrVo6tacl8o1LAO9zNlO9X6CyHA8A/233/bPW8HwALzIVnt3ay5yl9GEOuoVww9fEKPOWWRxgEvq2Usv0fmHHxROQmNHsCWo6G2PlgQ8Kwu1xh/K2lDLtEuwlpsVLqT5loQ0anCtEA2W1AYc/yQGOEdxaeiTv5zSUqpniYvbxKt0T0OvC1dHpR4pGxnhd1fa3CJJyEhJ0PNAwY4fJKXExbMlQn3GnglkwJB5kdNp8EppoLa5c2Ub8jM2EM6eDih4dQOMqinAALlVKnMtmWjIgnIhcD95jLP17XxsdrY+/CyTXGfqOIkVcV6qqWKaXeyHR7MvLOE5HXga/0LGs7EeLt608Tak08ypSdn0/lrAIKh7vxVLgJ+MK0fxrmzJbOjESNARSPzWPey9XkFVke2U5gtlIq42tVtosnIldijuEXePe2M/jej/N7FYy6qpCJd5ZRPC62/7z5cJADP/NzaqN9k3qXRzH3pSrKzrd4UVqA6Uqpg7bdPA6ZWFVYai44+UZ7XOHySlxMX1rRawX7UB0cqQN/O5QVwoSRUFNlOIRnLBvGqQ3tvP+oz5bwiEn/VKYTDuAfsyUc2NzzROQyYEvPskhQeOvvTtP2id66zC9zMfvFSkrH5yMCb+yGlW8JJ3zWY8+rhFu+oPjihaCUsQv2vTvSG5hUNcfLpc8N0z2p/1FKWfZLZBK7xVsO3N6z7NiaFvb8SB+yp1xw6fOVVM4qoCMAS14TNn2Y+D5XTobFCxSePDi1sYMdi+rTsv5XMMzN59dU4xlqseuOANOUUv7+3yV1bLM2o/7La8zlH70S27ocs6CYylkFiMDjryYnHMCbtYbQIjDici8jv6S1CPuEcsHUJyp0woWAm7ItHNg7VZgGDO9Z0LgnQMsR/XCp3DDxu6UArN0O7/QxlnjjXvh9NCbr/LvL+j2m1NxUQuUsrfvrUaXUFl1FprFTPMuKwZl3Yk/Gh04rwDvcTTgCKzelNuat2Gj0vuJxeZRfYEnwkDRDLvQYfwArfwR+mPKF04yd4k0xF/jihO1VzzUsy93HoSFFf/xJH+yPJkisnpMoc5WevCJjVVyTPeIsxmpBzizt2yneaHNBS5wJdZfL6UA/s1N2nV84OrVZ0EWLh1A81nKuALdmMtNDMtgpniWxaKAp9p/WU2E0pbGfZn5j1B4qsBoaCRl5VSGj/7pIV/W8Ump9vxpmA3aKZ3npSJyFg6DfELbU2z9Loyz67AONfRvdisbkcfEj2o0+u4mfszNr2CmeZVqdXxpbmI5ospualPKtn6Omqvf1kkG5YdqSCvKKLe3rwHjP5WRAjZ3i1ZsLCkfFfg917W6dUQPFqdkaVBTD5LG9r5cM599dxpDJWuv0X5RSu1Nrjf3YKd5ec8GQi2Kb72e3dhL0R/DkwXWzUxs6b5yncLmMvQQNu5ITb9iMAj6zsFRX9apS6oWUGpIh7BTPEsdRNTt2lwp3CodXGnOE6+fApD5+eWfKOLg2OrM8+EJzUrEwngoX035QodsUchyTWy8XsVu8Xu+KqssKuq1KHcdWt+A/GKQgH/79epW0gJPHwpPXKfLc0Fgb4PjatsQnKZjyWAUFlZZV8TCG+0vjCs8tbBNPKdWMkdTtXFmeipX6CejaPGmEuA8tgZ98R7Hw8+CNkfStuABuv0LxzEJFWSG014XZvqgBCSWebvzVdSW6TEYAS5RSbye8QA5g96rCtRiJursJNkfYsKCue2qgo2i0m5lPD6P0s4Zq7QHYegiOnBYaWw3D5LMjFJeMPyds094A2+9voON04vEyzqaQzcDlmc4hlip2i5cP7Ad6JY45sqolYSYHt1dRc2MJ428u1Znw3QT9EQ6taObYr1qTSkXl9irmraqmpMZi+fowNvkfT3iRHCETYRA3Ay/1KovAe3ecoWFX4rCPvCJF1RwvVbML8I7Iw1PuItAYjWF5t5Mz73UQbk/eKzPlsQrGXKP1onxLKfXrpC+UA2RCPDdQi5Fkppu2T0JsvukMwQT7vdPJhNtLmXiXdrVguVLquxlrSJqwPfQv+v64DcOK66ZoTB4znx4aK/dz2hl9dRET79QKtw9NWOJAICNxm9HFy/8wlw+dXsDkh4fooo/TyqgvFzLlsSG6caYZY/NjEnOL3CNjexWi4e6bMRKo9aJhV4BdD9mTX6XmxhIuuKdcNxEPAn+jlEqYsS9XyfRGk1HAe8BYc13QH+HDn/j5eG1rvAQ0SZNf6uKixUMY9VVtPEvX+txL/b9T9sh4QoHoF7LeBrQOxaZ9QfY920T9thT3LyhjmLzg3nK8VTHH439TSlniSQcaWckGEf082hogpgOsaV+Qo6tbqNvYnlRIvMujGPXlQmpuKIkVIAtGPpR7lVLPpdLuXCNrqTxEpBIjqbYlPLAnkYBQv60T3wcB/AeCdNZHCDVHcBcqPEPclI7Po2Kqh8pZXt0+gp74gZuVUmvT+DP+col+1vMOETkb59Og6WCbiEzK9u8dlIjIUBF5XpL/9niy+MX45msuZXoanIjIOBF5RkSa0yDaM2JkEHTIJCJSLiILRWSdiLQnKViniLwpIneJiNaSHWzkRO6xeIixMjEZmIExP6zEyOfsx9gfdxjDxbU9uobo4ODg4ODg4ODg4ODg4ODg4ODg4ODg4GAH/w8WJjwazIM10wAAAABJRU5ErkJggg==\"\n  }\n}",
            "create.ts": "// Overriding the createStrip function here to place it into the \"NeoPixel\" subcategory\n\nnamespace light {\n    /**\n     * Create a new programmable light strip.\n     * @param pin the pin where the neopixel is connected, eg: pins.A1\n     * @param numleds number of leds in the strip, eg: 30\n     * @param mode the light encoding mode for different LED strips, eg: NeoPixelMode.RGB_GRB\n     */\n    //% blockId=\"neopixel_create_strip\" block=\"create strip on %pin with %numleds pixels\"\n    //% help=\"light/create-strip\"\n    //% trackArgs=0,2\n    //% parts=\"neopixel\"\n    //% weight=100 blockGap=8\n    //% subcategory=\"NeoPixel\"\n    //% blockSetVariable=strip\n    export function createStrip(\n        pin: DigitalInOutPin = null,\n        numleds: number = 10,\n        mode: NeoPixelMode = NeoPixelMode.RGB\n    ): NeoPixelStrip {\n        return light.createNeoPixelStrip(pin, numleds, mode);\n    }\n\n    /**\n     * Creates a strip of colored LEDs (APA102)\n     */\n    //% blockId=\"light_create_dotstar\" block=\"create APA102 strip|data %data|clock %clk|with %numleds pixels\"\n    //% help=\"light/create-apa102-strip\"\n    //% trackArgs=0,1,2\n    //% parts=\"dotstar\"\n    //% weight=100 blockSetVariable=strip\n    //% subcategory=\"NeoPixel\"\n    export function createAPA102Strip(\n        dataPin: DigitalInOutPin,\n        clkPin: DigitalInOutPin,\n        numleds: number): NeoPixelStrip {\n        const strip = new NeoPixelStrip();\n        strip._mode = NeoPixelMode.APA102;\n        strip._length = Math.max(0, numleds | 0);\n        strip._dataPin = dataPin;\n        strip._clkPin = clkPin;\n        return strip;\n    }    \n}",
            "defaultlights.ts": "namespace light {\n    /**\n     * Gets the default external light strip\n     */\n    //% whenUsed\n    export const pixels = light.defaultStrip();\n\n    /**\n     * Set all of the pixels on the strip to one RGB color.\n     * @param rgb RGB color of the LED\n     */\n    //% blockId=\"builtin_neopixel_set_strip_color\" block=\"set all pixels to %rgb=colorNumberPicker\"\n    //% help=\"light/set-all\"\n    //% weight=79 blockGap=8\n    export function setAll(rgb: number) {\n        light.pixels.setAll(rgb);\n    }\n\n    /**\n     * Sets a gradient between two colors\n     * @param startColor the start color\n     * @param endColor the end color\n     */\n    //% blockId=\"builtinlightsetgradient\" block=\"set gradient from %startRgb=colorNumberPicker to %endRgb=colorNumberPicker\"\n    //% weight=78 blockGap=8 blockHidden=true\n    export function setGradient(startRgb: number, endRgb: number) {\n        light.pixels.setGradient(startRgb, endRgb);\n    }\n\n    /**\n     * Turn off all pixel LEDs on the onboard strip.\n     */\n    //% blockId=\"builtin_neopixel_clear\" block=\"clear\"\n    //% parts=\"neopixel\"\n    //% help=\"light/clear\"\n    //% group=\"More\" weight=9 blockGap=8\n    export function clear() {\n        light.pixels.clear();\n    }\n\n    /**\n     * Display a vertical bar graph based on the `value` and `high` value.\n     * If `high` is 0, the chart gets adjusted automatically.\n     * @param value current value to plot\n     * @param high maximum value, 0 to autoscale\n     */\n    //% blockId=builtin_neopixel_show_bar_graph block=\"graph %value||up to %high\" icon=\"\\uf080\"\n    //% help=light/graph blockGap=8\n    //% weight=10\n    export function graph(value: number, high?: number): void {\n        light.pixels.graph(value, high);\n    }\n\n\n    /**\n     * Set the pixel to a given color.\n     * @param pixeloffset position of the NeoPixel in the strip\n     * @param color RGB color of the LED\n     */\n    //% blockId=\"builtin_neopixel_set_pixel_color\" block=\"set pixel color at %pixeloffset|to %rgb=colorNumberPicker\"\n    //% help=\"light/set-pixel-color\"\n    //% group=\"More\" weight=89 blockGap=8\n    export function setPixelColor(pixeloffset: number, color: number): void {\n        light.pixels.setPixelColor(pixeloffset, color);\n    }\n\n    /**\n     * Gets the pixel color at a given offset.\n     * @param pixeloffset position of the NeoPixel in the strip\n     */\n    //% blockId=\"builtin_neopixel_pixel_color\" block=\"pixel color at %pixeloffset\"\n    //% help=\"light/pixel-color\"\n    //% group=\"More\" weight=88\n    export function pixelColor(pixeloffset: number): number {\n        return light.pixels.pixelColor(pixeloffset);\n    }\n\n    /**\n     * Set the brightness of the strip. This flag only applies to future operation.\n     * @param brightness a measure of LED brightness in 0-255. eg: 20\n     */\n    //% blockId=\"builtin_neopixel_set_brightness\" block=\"set brightness %brightness\"\n    //% brightness.min=0 brightness.max=255\n    //% help=\"light/set-brightness\"\n    //% weight=2 blockGap=8\n    export function setBrightness(brightness: number): void {\n        light.pixels.setBrightness(brightness);\n    }\n\n    /**\n     * Move a photon effect along the pixel strip by a number of steps.\n     * @param steps number of steps (lights) to move, eg: 1\n     */\n    //% blockId=builtin_neophoton_fd block=\"photon forward by %steps\"\n    //% help=\"light/photon-forward\"\n    //% group=\"Photon\" weight=41 blockGap=8\n    export function photonForward(steps: number) {\n        light.pixels.photonForward(steps);\n    }\n    /**\n         * Switch the direction of the photon pulse.\n         */\n    //% blockId=builtin_neophoton_flip block=\"photon flip\"\n    //% help=\"light/photon-flip\"\n    //% parts=\"neopixel\"\n    //% group=\"Photon\" weight=40 blockGap=8\n    export function photonFlip() {\n        light.pixels.photonFlip();\n    }\n\n\n    /**\n     * Sets the photon position to a given light index\n     * @param index index of the light, if out of bound, the index is wrapped\n     */\n    //% blockId=builtin_light_photon_set_position block=\"photon set position %index\"\n    //% help=\"light/set-photon-position\"\n    //% parts=\"neopixel\"\n    //% group=\"Photon\" weight=39 blockGap=8\n    export function setPhotonPosition(index: number) {\n        light.pixels.setPhotonPosition(index);\n    }\n\n    /**\n     * Set the photon color hue.\n     * @param hue the color hue of the photon\n     */\n    //% blockId=builtin_neophoton_set_pen_hue block=\"photon set pen hue %hue=colorWheelHsvPicker\"\n    //% help=\"light/set-photon-pen-hue\"\n    //% group=\"Photon\" weight=39 blockGap=8\n    export function setPhotonPenHue(hue: number) {\n        light.pixels.setPhotonPenHue(hue);\n    }\n\n    /**\n     * Set the photon mode to pen up, pen down, or eraser.\n     * @param mode the desired mode\n     */\n    //% blockId=builtin_neophoton_set_photon block=\"photon %mode\"\n    //% help=\"light/set-photon-mode\"\n    //% group=\"Photon\" weight=38\n    export function setPhotonMode(mode: PhotonMode) {\n        light.pixels.setPhotonMode(mode);\n    }\n\n    /**\n     * Show an animation or queue an animation in the animation queue\n     * @param animation the animation to run, eg: light.rainbowAnimation\n     * @param duration the duration to run in milliseconds, eg: 500\n     */\n    //% blockId=builtin_neopixel_show_animation block=\"show animation %animation=light_animation_picker|for %duration=timePicker|ms\"\n    //% help=\"light/show-animation\" blockGap=8\n    //% weight=81\n    export function showAnimation(animation: NeoPixelAnimation, duration: number) {\n        light.pixels.showAnimation(animation, duration);\n    }\n\n    /**\n      * Show a single animation frame\n      * @param animation the animation to run, eg: light.rainbowAnimation\n      */\n    //% blockId=builtin_neopixel_show_animation_frame block=\"show frame of %animation=light_animation_picker|animation\"\n    //% help=\"light/show-animation-frame\"\n    //% group=\"More\" weight=24 blockGap=8\n    export function showAnimationFrame(animation: NeoPixelAnimation) {\n        light.pixels.showAnimationFrame(animation);\n    }\n\n    /**\n     * Stop the current animation and any other animations ready to show.\n     */\n    //% blockId=builtin_neopixel_stop_all_animations block=\"stop all animations\"\n    //% help=\"light/stop-all-animations\"\n    //% group=\"More\" weight=23\n    export function stopAllAnimations() {\n        light.pixels.stopAllAnimations();\n    }\n\n    /**\n     * Creates a builtin animation\n     * @param kind the type of animation\n     */\n    //% kind.fieldEditor=\"imagedropdown\"\n    //% kind.fieldOptions.columns=3 blockGap=8\n    //% blockId=light_animation block=\"%kind\"\n    //% group=\"More\" weight=25\n    //% help=\"light/animation\" blockHidden=true deprecated=1\n    export function animation(kind: LightAnimation): NeoPixelAnimation {\n        switch (kind) {\n            case LightAnimation.RunningLights: return runningLightsAnimation;\n            case LightAnimation.Comet: return cometAnimation;\n            case LightAnimation.ColorWipe: return colorWipeAnimation;\n            case LightAnimation.TheaterChase: return theaterChaseAnimation;\n            case LightAnimation.Sparkle: return sparkleAnimation;\n            default: return rainbowAnimation;\n        }\n    }\n}",
            "defaultlightsoverrides.ts": "namespace light {\n    /**\n     * Create a range of pixels.\n     * @param start offset in the NeoPixel strip to start the range\n     * @param length number of pixels in the range, eg: 4\n     */\n    //% blockId=\"lightstrip_range\" block=\"range from %start|with %length|pixels\"\n    //% weight=1\n    //% blockHidden=1\n    export function range(start: number, length: number): NeoPixelStrip {\n        return pixels.range(start, length);\n    }\n\n    /**\n     * Sets the number of LEDS on the default light strip\n     */\n    //% blockId=lightds_setlength block=\"set pixels length to %numleds pixels\"\n    //% numleds.defl=30\n    //% numleds.shadow=lightLengthPicker\n    //% weight=0\n    //% blockHidden=1\n    export function setLength(numleds: number) {\n        light.pixels.setLength(numleds);\n    }\n\n    /**\n     * Sets the type of RGB light on the default strip\n     */\n    //% blockId=lightds_setmode block=\"set default strip mode to %mode\"\n    //% weight=0\n    //% blockHidden=1\n    export function setMode(mode: NeoPixelMode) {\n        light.pixels.setMode(mode);\n    }\n}",
            "defaultstrip.ts": "namespace light {\n    let _defaultStrip: NeoPixelStrip;\n    /**\n     * Gets the default light strip\n     */\n    //% help=light/default-strip\n    //% blockId=\"neopixel_default_strip\" block=\"default strip\"\n    //% weight=110 blockGap=8\n    //% parts=pixels\n    //% blockHidden=true\n    export function defaultStrip(): NeoPixelStrip {\n        if (_defaultStrip) return _defaultStrip;\n\n        const data = pins.pinByCfg(DAL.CFG_PIN_DOTSTAR_DATA);\n        const clk = pins.pinByCfg(DAL.CFG_PIN_DOTSTAR_CLOCK);\n        const dsnum = control.getConfigValue(DAL.CFG_NUM_DOTSTARS, 0);\n        const neo = pins.pinByCfg(DAL.CFG_PIN_NEOPIXEL);\n        const neonum = control.getConfigValue(DAL.CFG_NUM_NEOPIXELS, 0);\n        const mosi = pins.pinByCfg(DAL.CFG_PIN_MOSI);\n        const sck = pins.pinByCfg(DAL.CFG_PIN_SCK);\n\n        _defaultStrip = new NeoPixelStrip();\n        if (data && clk && dsnum > 1) {\n            _defaultStrip._mode = NeoPixelMode.APA102;\n            _defaultStrip._dataPin = data;\n            _defaultStrip._clkPin = clk;\n            _defaultStrip._length = dsnum;\n        } else if(neo && neonum > 1) {\n            _defaultStrip._mode = NeoPixelMode.RGB;\n            _defaultStrip._dataPin = neo;\n            _defaultStrip._length = neonum;\n        } else { // mount strip on SPI\n            _defaultStrip._mode = NeoPixelMode.RGB;\n            _defaultStrip._dataPin = mosi;\n            _defaultStrip._clkPin = sck;\n            _defaultStrip._length = 30;\n        }\n\n        return _defaultStrip;\n    }\n}",
            "neopixel.ts": "/**\n * Different modes for RGB or RGB+W NeoPixel strips\n */\nconst enum NeoPixelMode {\n    //% block=\"RGB (GRB format)\"\n    RGB = 1,\n    //% block=\"RGB+W\"\n    RGBW = 2,\n    //% block=\"RGB (RGB format)\"\n    RGB_RGB = 3,\n    //% block=\"APA102\"\n    APA102 = 4\n}\n\nconst enum LightMove {\n    //% block=\"rotate\"\n    Rotate,\n    //% block=\"shift\"\n    Shift\n}\n\n/**\n * A determines the mode of the photon\n */\nconst enum PhotonMode {\n    //% block=\"pen up\"\n    PenUp,\n    //% block=\"pen down\"\n    PenDown,\n    //% block=\"eraser\"\n    Eraser,\n    //% block=\"off\"\n    Off\n}\n\nconst enum LightAnimation {\n    //% blockImage=1\n    //% block=\"rainbow\"\n    Rainbow,\n    //% blockImage=1\n    //% block=\"running lights\"\n    RunningLights,\n    //% blockImage=1\n    //% block=\"comet\"\n    Comet,\n    //% blockImage=1\n    //% block=\"sparkle\"\n    Sparkle,\n    //% blockImage=1\n    //% block=\"theater chase\"\n    TheaterChase,\n    //% blockImage=1\n    //% block=\"color wipe\"\n    ColorWipe\n}\n\n/**\n * Functions to operate colored LEDs.\n */\n//% weight=100 color=\"#0078d7\" icon=\"\\uf00a\"\n//% groups='[\"other\", \"Color\", \"Photon\", \"More\"]'\n//% blockGap=8\nnamespace light {\n    export type LightStrip = NeoPixelStrip;\n    /**\n     * A NeoPixel strip\n     */\n    export class NeoPixelStrip {\n        _parent: NeoPixelStrip;\n        _dataPin: DigitalInOutPin;\n        _clkPin: DigitalInOutPin;\n        _buf: Buffer; // unscaled color buffer\n        // per pixel scaling. This buffer is allocated on-demand when per-pixel brightness is needed.\n        // when rendering, if this buffer is null, use _brightness instead\n        _brightnessBuf: Buffer;\n        _sendBuf: Buffer; // scaled color buffer\n        _brightness: number; // global brightness for this strip\n        _start: number; // start offset in LED strip\n        _length: number; // number of LEDs\n        _mode: NeoPixelMode;\n        _buffered: boolean;\n        _animationQueue: control.AnimationQueue;\n        // what's the current high value\n        _barGraphHigh: number;\n        // when was the current high value recorded\n        _barGraphHighLast: number;\n        // the current photon color, undefined = no photon\n        _photonMode: number;\n        _photonPos: number;\n        _photonDir: number;\n        _photonPenColor: number;\n        // last animation used by showAnimationFrame\n        _lastAnimation: NeoPixelAnimation;\n        _lastAnimationRenderer: () => boolean;\n        _transitionPlayer: BrightnessTransitionPlayer;\n\n        constructor() {\n            this._buffered = false;\n            this._mode = NeoPixelMode.RGB;\n            this._length = 0;\n            this._brightness = 16;\n            this._start = 0;\n            this._dataPin = undefined;\n            this._clkPin = undefined;\n            this._barGraphHigh = 0;\n            this._barGraphHighLast = 0;\n        }\n\n        /**\n         * Gets the underlying color buffer for the entire strip\n         */\n        get buf(): Buffer {\n            if (this._parent) return this._parent.buf;\n            if (!this._buf)\n                this.reallocateBuffer();\n            return this._buf;\n        }\n\n        get brightnessBuf(): Buffer {\n            if (this._parent) return this._parent.brightnessBuf;\n            if (!this._brightnessBuf) {\n                const b = this.buf; // force allocate buffer\n                this._brightnessBuf = control.createBuffer(this._length);\n                this._brightnessBuf.fill(this._brightness, 0, this._brightnessBuf.length);\n            }\n            return this._brightnessBuf;\n        }\n\n        /**\n         * Gets the LED data layout mode\n         */\n        get mode(): NeoPixelMode {\n            return this._mode;\n        }\n\n        /**\n         * Set all of the pixels on the strip to one RGB color.\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"light_set_strip_color\" block=\"set %strip all pixels to %rgb=colorNumberPicker\"\n        //% help=\"light/neopixelstrip/set-all\"\n        //% weight=80 blockGap=8\n        //% advanced=true\n        setAll(rgb: number) {\n            rgb = rgb | 0;\n            const red = color.unpackR(rgb);\n            const green = color.unpackG(rgb);\n            const blue = color.unpackB(rgb);\n\n            const end = this._start + this._length;\n            const stride = this.stride();\n            for (let i = this._start; i < end; ++i) {\n                this.setBufferRGB(i * stride, red, green, blue)\n            }\n            this.autoShow();\n        }\n\n        /**\n         * Sets a gradient between two colors\n         * @param startColor the start color\n         * @param endColor the end color\n         */\n        //% blockId=lightsetgradient block=\"set %strip gradient from %startColor=colorNumberPicker to %endColor=colorNumberPicker\"\n        //% weight=79 blockGap=8\n        //% group=\"More\" advanced=true\n        setGradient(startColor: number, endColor: number) {\n            const sr = color.unpackR(startColor);\n            const sg = color.unpackG(startColor);\n            const sb = color.unpackB(startColor);\n            const er = color.unpackR(endColor);\n            const eg = color.unpackG(endColor);\n            const eb = color.unpackB(endColor);\n\n            const end = this._start + this._length;\n            const n1 = this._length - 1;\n            const stride = this.stride();\n            for (let i = this._start; i < end; ++i) {\n                let x = (i - this._start) / n1;\n                const ox = 1 - x;\n                const r = (sr * ox + er * x) | 0;\n                const g = (sg * ox + eg * x) | 0;\n                const b = (sb * ox + eb * x) | 0;\n                this.setBufferRGB(i * stride, r, g, b);\n            }\n            this.autoShow();\n        }\n\n        /**\n         * Display a vertical bar graph based on the `value` and `high` value.\n         * If `high` is 0, the chart gets adjusted automatically.\n         * @param value current value to plot\n         * @param high maximum value, 0 to autoscale\n         */\n        //% blockId=light_show_bar_graph block=\"%strip|graph %value||up to %high\" icon=\"\\uf080\"\n        //% help=light/neopixelstrip/graph\n        //% weight=70 blockGap=8\n        //% advanced=true\n        graph(value: number, high?: number): void {\n            console.logValue(\"\", value);\n            value = Math.abs(value);\n\n            const now = control.millis();\n            if (high > 0) {\n                this._barGraphHigh = high;\n            }\n            else if (value > this._barGraphHigh || now - this._barGraphHighLast > 10000) {\n                this._barGraphHigh = value;\n                this._barGraphHighLast = now;\n            }\n\n            const bfr = this.buffered();\n            this.setBuffered(true);\n            const n = this._length;\n            const n1 = n - 1;\n            const nhalf = n / 2;\n            const v = Math.round((value * n) / this._barGraphHigh);\n            if (v == 0) {\n                this.setAll(0);\n            } else {\n                for (let i = 0; i < n; ++i) {\n                    if (i + 1 <= v) {\n                        if (i < nhalf) {\n                            const b = (i * 255 / nhalf) >> 0;\n                            this.setPixelColor(i, light.rgb(0, b, 255 - b));\n                        } else {\n                            const b = ((i - nhalf) * 255 / nhalf) >> 0;\n                            this.setPixelColor(i, light.rgb(b, 255 - b, 0));\n                        }\n                    }\n                    else {\n                        this.setPixelColor(i, 0);\n                    }\n                }\n            }\n            this.show();\n            this.setBuffered(bfr);\n        }\n\n        /**\n         * Set the pixel to a given color.\n         * You need to call ``show`` to make the changes visible.\n         * @param pixeloffset position of the NeoPixel in the strip\n         * @param color RGB color of the LED\n         */\n        //% blockId=\"light_set_pixel_color\" block=\"set %strip pixel color at %pixeloffset|to %rgb=colorNumberPicker\"\n        //% help=\"light/neopixelstrip/set-pixel-color\"\n        //% weight=79 blockGap=8\n        //% group=\"More\" advanced=true\n        setPixelColor(pixeloffset: number, c: number): void {\n            pixeloffset = pixeloffset | 0;\n            c = c | 0;\n\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            const stride = this.stride();\n            pixeloffset = (pixeloffset + this._start) * stride;\n            const red = color.unpackR(c);\n            const green = color.unpackG(c);\n            const blue = color.unpackB(c);\n            this.setBufferRGB(pixeloffset, red, green, blue)\n            this.autoShow();\n        }\n\n        /**\n         * Gets the pixel color.\n         * @param pixeloffset position of the NeoPixel in the strip\n         */\n        //% blockId=\"light_get_pixel_color\" block=\"%strip|pixel color at %pixeloffset\"\n        //% help=\"light/neopixelstrip/pixel-color\"\n        //% weight=9 blockGap=8\n        //% group=\"More\" advanced=true\n        pixelColor(pixeloffset: number): number {\n            pixeloffset = pixeloffset | 0;\n            if (pixeloffset < 0\n                || pixeloffset >= this._length) {\n                return 0;\n            }\n\n            const stride = this.stride();\n            const offset = (pixeloffset + this._start) * stride;\n            const b = this.buf;\n            let red = 0, green = 0, blue = 0;\n            switch (this._mode) {\n                case NeoPixelMode.RGB_RGB:\n                    red = this.buf[offset + 0];\n                    green = this.buf[offset + 1];\n                    blue = this.buf[offset + 2];\n                    break;\n                case NeoPixelMode.APA102:\n                    blue = this.buf[offset + 1];\n                    green = this.buf[offset + 2];\n                    red = this.buf[offset + 3];\n                    break;\n                default:\n                    green = this.buf[offset + 0];\n                    red = this.buf[offset + 1];\n                    blue = this.buf[offset + 2];\n                    break;\n            }\n\n            return color.rgb(red, green, blue);\n        }\n\n        /**\n         * Set the white brightness of a pixel in a NeoPixel strip of RGB+W LEDs.\n         * This only works for RGB+W NeoPixels.\n         * @param pixeloffset position of the LED in the strip\n         * @param white brightness of the white LED\n         */\n        //% blockId=\"light_set_pixel_white_led\" block=\"set %strip pixel white LED at %pixeloffset|to %white\"\n        //% help=\"light/neopixelstrip/set-pixel-white-led\"\n        //% weight=5 blockGap=8\n        //% group=\"More\" advanced=true\n        setPixelWhiteLED(pixeloffset: number, white: number): void {\n            if (this._mode != NeoPixelMode.RGBW) return;\n\n            pixeloffset = pixeloffset | 0;\n            if (pixeloffset < 0\n                || pixeloffset >= this._length)\n                return;\n\n            pixeloffset = (pixeloffset + this._start) * 4;\n            white = white & 0xff;\n            const buf = this.buf;\n            buf[pixeloffset + 3] = white;\n            this.autoShow();\n        }\n\n        /**\n         * Make the strip show all the new changes for the pixels.\n         */\n        //% blockId=\"light_show\" block=\"%strip|show\"\n        //% help=\"light/neopixelstrip/show\"\n        //% weight=86 blockGap=8\n        //% group=\"More\" advanced=true\n        show(): void {\n            if (this._parent) this._parent.show();\n            else if (this._dataPin) {\n                const b = this.buf;\n\n                // fast path: no processing\n                if (this._brightness == 0xff && !this._brightnessBuf && !this._photonPenColor) {\n                    // no need to process buffer\n                    light.sendBuffer(this._dataPin, this._clkPin, this._mode, b);\n                    return;\n                }\n\n                // bb may be undefined if the brightness\n                // is uniform over the strip and has not been allocated\n                const _bb = this._brightnessBuf;\n                if (!this._sendBuf) this._sendBuf = control.createBuffer(b.length);\n                const sb = this._sendBuf;\n                const stride = this.stride();\n                const strideOffset = this._mode == NeoPixelMode.APA102 ? 1 : 0;\n                // apply brightness\n                for (let i = 0; i < this._length; ++i) {\n                    const offset = (this._start + i) * stride;\n                    for (let j = 0; j < strideOffset; ++j)\n                        sb[offset + j] = 0xff;\n                    for (let j = strideOffset; j < stride; ++j)\n                        sb[offset + j] = (b[offset + j] * (_bb ? _bb[i] : this._brightness)) >> 8;\n                }\n                // apply photon\n                this.drawPhoton(sb, stride);\n                //console.log(`${!!this._dataPin} ${!!this._clkPin} ${this.mode} hex${sb.toHex()}`)\n                light.sendBuffer(this._dataPin, this._clkPin, this._mode, sb);\n            }\n        }\n\n        protected drawPhoton(sb: Buffer, stride: number) {\n            // apply photon\n            if (this._photonPenColor) {\n                // draw head and trail\n                const tailn = Math.max(1, Math.min(8, this._length >> 4));\n                let pi = this._photonPos * stride;\n                let c = Math.max(128, this._brightness);\n                let dc = (c - 32) / tailn;\n                for (let bi = 0; bi < tailn && c > 0; ++bi) {\n                    if (this._mode == NeoPixelMode.RGBW)\n                        sb[pi + 3] = c;\n                    else if (this._mode == NeoPixelMode.APA102)\n                        sb[pi + 1] = sb[pi + 2] = sb[pi + 3] = c;\n                    else\n                        sb[pi] = sb[pi + 1] = sb[pi + 2] = c;\n\n                    c -= dc;\n                    pi += (-this._photonDir * stride) % sb.length;\n                    if (pi < 0) pi += sb.length;\n                }\n            }\n        }\n\n        /**\n         * Turn off all pixel LEDs.\n         */\n        //% blockId=\"light_clear\" block=\"%strip|clear\"\n        //% help=\"light/neopixelstrip/clear\"\n        //% weight=85 blockGap=8\n        //% group=\"More\" advanced=true\n        clear(): void {\n            const stride = this.stride();\n            this.buf.fill(0, this._start * stride, this._length * stride);\n            this.autoShow();\n        }\n\n        /**\n         * Get the number of pixels on the strip\n         */\n        //% blockId=\"light_length\" block=\"%strip|length\"\n        //% help=\"light/neopixelstrip/length\"\n        //% weight=8 blockGap=8\n        //% group=\"More\" advanced=true\n        length() {\n            return this._length;\n        }\n\n        /**\n         * Set the brightness of the strip. This flag only applies to future operation.\n         * @param brightness a measure of LED brightness in 0-255. eg: 20\n         */\n        //% blockId=\"light_set_brightness\" block=\"set %strip brightness %brightness\"\n        //% brightness.min=0 brightness.max=255\n        //% help=\"light/neopixelstrip/set-brightness\"\n        //% weight=2 blockGap=8\n        //% advanced=true\n        setBrightness(brightness: number): void {\n            const b = Math.max(0, Math.min(0xff, brightness | 0));\n            if (b != this._brightness || this._brightnessBuf) {\n                this._brightness = b;\n                // if this is a top level strip clear any existing brightness buffer\n                if (!this._parent)\n                    this._brightnessBuf = undefined;\n                // if this is a NOT top-level strip or if brightness buff has been allocated,\n                else if (this._parent || this._brightnessBuf)\n                    this.brightnessBuf.fill(this._brightness, this._start, this._length);\n                this.autoShow();\n            }\n        }\n\n        /**\n         * Sets an individual pixel brightness\n         * @param index \n         * @param brightness \n         */\n        setPixelBrightness(index: number, brightness: number): void {\n            const i = (index | 0);\n            if (i < 0 || i > this._length) return;\n\n            const b = Math.max(0, Math.min(0xff, brightness | 0));\n            const bb = this.brightnessBuf;\n            if (bb[this._start + i] != b) {\n                bb[this._start + i] = b;\n                this.autoShow();\n            }\n        }\n\n        /**\n         * Get the brightness of the pixel strip.\n         */\n        //% blockId=\"light_get_brightness\" block=\"%strip|brightness\"\n        //% help=\"light/neopixelstrip/brightness\"\n        //% parts=neopixel\n        //% weight=7 blockGap=8\n        //% group=\"More\" advanced=true\n        brightness(): number {\n            return this._brightness;\n        }\n\n        /**\n         * Create a range of pixels.\n         * @param start offset in the NeoPixel strip to start the range\n         * @param length number of pixels in the range, eg: 4\n         */\n        //% blockId=\"light_range\" block=\"%strip|range from %start|with %length|pixels\"\n        //% help=\"light/neopixelstrip/range\"\n        //% weight=99 blockGap=30\n        //% blockSetVariable=strip\n        //% advanced=true\n        range(start: number, length: number): NeoPixelStrip {\n            start = start | 0;\n            length = length | 0;\n\n            let strip = new NeoPixelStrip();\n            strip._parent = this;\n            strip._dataPin = this._dataPin;\n            strip._clkPin = this._clkPin;\n            strip._brightness = this._brightness;\n            strip._start = this._start + Math.clamp(0, this._length - 1, start);\n            strip._length = Math.clamp(0, this._length - (strip._start - this._start), length);\n            return strip;\n        }\n\n        /**\n         * Shift LEDs forward and clear with zeros.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to shift forward, eg: 1\n         */\n        //% blockId=\"light_move_pixels\" block=\"%strip|%kind=MoveKind|by %offset\"\n        //% help=\"light/neopixelstrip/move\"\n        //% weight=87 blockGap=8\n        //% group=\"More\" advanced=true\n        move(kind: LightMove, offset: number = 1): void {\n            offset = offset | 0;\n\n            const stride = this.stride();\n            if (kind === LightMove.Shift) {\n                this.buf.shift(-offset * stride, this._start * stride, this._length * stride)\n            }\n            else {\n                this.buf.rotate(-offset * stride, this._start * stride, this._length * stride)\n            }\n            this.autoShow();\n        }\n\n        private stride(): number {\n            return this._mode === NeoPixelMode.RGBW || this._mode == NeoPixelMode.APA102 ? 4 : 3;\n        }\n\n        initPhoton() {\n            if (this._photonPos === undefined) {\n                this._photonMode = PhotonMode.PenDown;\n                this._photonPos = 0;\n                this._photonDir = 1;\n                this._photonPenColor = Colors.Red;\n            }\n        }\n\n        /**\n         * Move a photon effect along the pixel strip by a number of steps.\n         * @param steps number of steps (lights) to move, eg: 1\n         */\n        //% blockId=light_photon_fd block=\"%strip|photon forward by %steps\"\n        //% help=\"light/neopixelstrip/photon-forward\"\n        //% weight=41 blockGap=8\n        //% group=\"Photon\" advanced=true\n        photonForward(steps: number) {\n            steps = steps | 0;\n            this.setPhotonPosition(this._photonPos + this._photonDir * steps);\n        }\n\n        /**\n         * Switch the direction of the photon pulse.\n         */\n        //% blockId=light_photon_flip block=\"%strip|photon flip\"\n        //% help=\"light/neopixelstrip/photon-flip\"\n        //% weight=40 blockGap=8\n        //% group=\"Photon\" advanced=true\n        photonFlip() {\n            this.initPhoton();\n            this._photonDir *= -1;\n        }\n\n        /**\n         * Sets the photon position to a given light index\n         * @param index index of the light, if out of bound, the index is wrapped\n         */\n        //% blockId=light_photon_set_position block=\"%strip|photon set position %index\"\n        //% help=\"light/neopixelstrip/set-photon-position\"\n        //% weight=39 blockGap=8\n        //% group=\"Photon\" advanced=true\n        setPhotonPosition(index: number) {\n            index = index | 0;\n\n            this.initPhoton();\n\n            // disable buffering\n            const buffered = this.buffered();\n            this.setBuffered(false);\n\n            // move\n            this._photonPos = (index >> 0) % this._length;\n            if (this._photonPos < 0) this._photonPos += this._length;\n\n            // paint under photon\n            if (this._photonMode == PhotonMode.PenDown)\n                this.setPixelColor(this._photonPos, this._photonPenColor);\n            else if (this._photonMode == PhotonMode.Eraser)\n                this.setPixelColor(this._photonPos, 0); // erase led\n\n            // restoring buffer\n            this.setBuffered(buffered);\n\n            this.autoShow();\n        }\n\n        /**\n         * Set the photon color.\n         * @param color the color of the photon\n         */\n        //% blockId=light_photon_set_pen_color block=\"%strip=variables_get|photon set pen color %color=colorNumberPicker\"\n        //% help=\"light/neopixelstrip/set-photon-pen-color\"\n        //% weight=38 blockGap=8\n        //% group=\"Photon\" advanced=true\n        setPhotonPenColor(color: number) {\n            color = color | 0;\n            this.initPhoton();\n            this._photonPenColor = color;\n            this.photonForward(0);\n        }\n\n        /**\n         * Sets the photon hue.\n         * @param hue the hue of the photon color\n         */\n        //% blockId=light_photon_set_pen_hue block=\"%strip=variables_get|photon set pen hue %hue=colorWheelHsvPicker\"\n        //% help=\"light/neopixelstrip/set-photon-pen-hue\"\n        //% weight=39 blockGap=8\n        //% group=\"Photon\" advanced=true\n        setPhotonPenHue(hue: number) {\n            hue = hue | 0;\n            this.setPhotonPenColor(color.hsv(hue, 0xff, 0xff));\n        }\n\n        //% deprecated=1 blockHidden=1\n        //% group=\"Photon\" advanced=true\n        setPhotonColor(hue: number) {\n            this.setPhotonPenHue(hue);\n        }\n\n        /**\n         * Set the photon mode to pen up, pen down, or eraser.\n         * @param mode the desired mode\n         */\n        //% blockId=light_photon_set_photon block=\"%strip|photon %mode\"\n        //% help=\"light/neopixelstrip/set-photon-mode\"\n        //% weight=38\n        //% group=\"Photon\" advanced=true\n        setPhotonMode(mode: PhotonMode) {\n            if (mode == PhotonMode.Off) {\n                this._photonPos = undefined;\n                this.show();\n            } else {\n                this.initPhoton();\n                if (this._photonMode != mode) {\n                    this._photonMode = mode;\n                    this.photonForward(0);\n                }\n            }\n        }\n\n        /**\n         * Starts a brightness transition on the strip (and cancels any other running transition)\n         * @param transition \n         * @param duration \n         */\n        startBrightnessTransition(\n            startBrightness: number,\n            endBrightness: number,\n            duration: number,\n            repeat?: number,\n            yoyo?: boolean,\n            transition?: BrightnessTransition\n        ) {\n            const player = this._transitionPlayer = new BrightnessTransitionPlayer(\n                transition || new EasingBrightnessTransition(undefined),\n                startBrightness,\n                endBrightness,\n                duration,\n                repeat,\n                yoyo);\n            control.runInBackground(() => {\n                while (player == this._transitionPlayer) {\n                    const buf = this.buffered();\n                    this.setBuffered(true);\n                    const keepRendering = player.update(this);\n                    this.setBuffered(buf);\n                    this.show();\n                    pause(20);\n                    if (!keepRendering) break;\n                }\n            });\n        }\n\n        /**\n         * Stops any running brightness transition\n         */\n        stopBrightnessTransition() {\n            this._transitionPlayer = undefined;\n        }\n\n        /**\n         * Show an animation or queue an animation in the animation queue\n         * @param animation the animation to run\n         * @param duration the duration to run in milliseconds, eg: 500\n         */\n        //% blockId=light_show_animation block=\"%strip|show animation %animation=light_animation_picker|for %duration=timePicker|ms\"\n        //% help=\"light/neopixelstrip/show-animation\"\n        //% weight=90 blockGap=8\n        //% advanced=true\n        showAnimation(animation: NeoPixelAnimation, duration: number) {\n            if (!animation) return;\n\n            // if a previous renderer for the same animation was used, keep using it\n            let animationRenderer = this._lastAnimationRenderer;\n            if (!animationRenderer || this._lastAnimation != animation) {\n                animationRenderer = animation.createRenderer(this);\n                if (!animationRenderer) return;\n            }\n\n            let start = -1;\n            const render: () => boolean = () => {\n                // keep track of whose running\n                this._lastAnimation = animation;\n                this._lastAnimationRenderer = animationRenderer;\n                // execute animation\n                if (start < 0) start = control.millis();\n                const now = control.millis() - start;\n                const buf = this.buffered();\n                this.setBuffered(true);\n                const keepRendering = animationRenderer();\n                this.setBuffered(buf);\n                this.show();\n                pause(1);\n                return duration > 0\n                    ? now <= duration\n                    : keepRendering;\n            };\n            this.queueAnimation(render);\n        }\n\n        /**\n         * Show a single animation frame.\n         * @param animation the animation to run\n         */\n        //% blockId=light_show_animation_frame block=\"%strip|show frame of %animation=light_animation_picker|animation\"\n        //% help=\"light/neopixelstrip/show-animation-frame\"\n        //% weight=87 blockGap=8\n        //% group=\"More\" advanced=true\n        showAnimationFrame(animation: NeoPixelAnimation) {\n            if (!animation) {\n                this._lastAnimation = undefined;\n                this._lastAnimationRenderer = undefined;\n                return;\n            }\n            let renderer = this._lastAnimationRenderer;\n            if (!renderer || this._lastAnimation != animation) {\n                this._lastAnimation = animation;\n                renderer = this._lastAnimationRenderer = animation.createRenderer(this);\n            }\n            if (renderer) {\n                const buf = this.buffered();\n                this.setBuffered(true);\n                renderer();\n                this.setBuffered(buf);\n                this.autoShow();\n            }\n        }\n\n        /**\n         * Renders a pattern of colors on the strip\n         */\n        showColors(leds: string, interval: number = 400) {\n            const n = this._length;\n            let tempColor = \"\";\n            let i = 0;\n            let pi = 0;\n\n            this.queueAnimation(() => {\n                const bf = this.buffered();\n                this.setBuffered(true);\n\n                while (i < leds.length) {\n                    const currChar = leds.charAt(i++);\n                    const isSpace = currChar == ' ' || currChar == '\\n' || currChar == '\\r';\n                    if (!isSpace)\n                        tempColor += currChar;\n\n                    if ((isSpace || i == leds.length) && tempColor) {\n                        this.setPixelColor(pi++, color.parseColor(tempColor))\n                        tempColor = \"\";\n                        if (pi == n) {\n                            this.show();\n                            pause(interval);\n                            pi = 0;\n                            break;\n                        }\n                    }\n                }\n\n                this.setBuffered(bf);\n                return i < leds.length;\n            });\n        }\n\n        //%\n        private queueAnimation(render: () => boolean) {\n            if (!this._animationQueue) {\n                this._animationQueue = new control.AnimationQueue();\n                this._animationQueue.interval = 50;\n                this._lastAnimation = undefined;\n                this._lastAnimationRenderer = undefined;\n            }\n            this._animationQueue.runUntilDone(render);\n        }\n\n        /**\n         * Stop the current animation and any other animations ready to show.\n         */\n        //% blockId=light_stop_all_animations block=\"%strip|stop all animations\"\n        //% help=\"light/neopixelstrip/stop-all-animations\"\n        //% weight=85 blockGap=8\n        //% group=\"More\" advanced=true\n        stopAllAnimations() {\n            if (this._animationQueue) {\n                this._animationQueue.cancel();\n                this._lastAnimation = undefined;\n                this._lastAnimationRenderer = undefined;\n            }\n        }\n\n        /**\n         * Enables or disables automatically calling show when a change is made\n         * @param on call show whenever a light is modified\n         */\n        //% blockId=light_set_buffered block=\"set %strip buffered  %on\"\n        //% help=\"light/neopixelstrip/set-buffered\"\n        //% weight=86 blockGap=8\n        //% group=\"Configuration\" advanced=true\n        setBuffered(on: boolean): void {\n            if (this._parent) this._parent.setBuffered(on);\n            else this._buffered = on;\n        }\n\n        /**\n         * Gets a value indicated if the changes are buffered\n         */\n        //% weight=85 blockGap=8\n        //% group=\"Configuration\" advanced=true\n        buffered(): boolean {\n            return this._parent ? this._parent.buffered() : this._buffered;\n        }\n\n        /**\n         * Sets the color mode and clears the colors.\n         * @param mode the kind of color encoding required by the programmable lights\n         */\n        //% blockId=light_set_mode block=\"set %strip mode to %mode\"\n        //% help=\"light/neopixelstrip/set-mode\"\n        //% weight=1 blockGap=8\n        //% group=\"Configuration\" advanced=true\n        setMode(mode: NeoPixelMode): void {\n            if (this._parent)\n                this._parent.setMode(mode);\n            else if (this._mode != mode) {\n                this._mode = mode;\n                this.reallocateBuffer();\n            }\n        }\n\n        /**\n         * Sets the number of LEDs on a strip\n         * @param numleds \n         */\n        //% blockId=light_set_length block=\"set %strip length to %length pixels\"\n        //% weight=1 blockGap=8\n        //% length.shadow=lightLengthPicker\n        //% group=\"Configuration\" advanced=true\n        setLength(numleds: number): void {\n            const n = Math.max(0, numleds | 0);\n            // lazy update\n            if (n != this._length) {\n                if (this._parent)\n                    this._length = Math.min(n, this._parent.length() - this._start);\n                else {\n                    this._length = n;\n                    this.reallocateBuffer();\n                }\n            }\n        }\n\n        private autoShow() {\n            if (!this.buffered()) {\n                this.show();\n                pause(1);\n            }\n        }\n\n        private setBufferRGB(offset: number, red: number, green: number, blue: number): void {\n            const b = this.buf;\n            // https://cdn-shop.adafruit.com/datasheets/APA102.pdf\n            switch (this._mode) {\n                case NeoPixelMode.RGB_RGB:\n                    b[offset] = red;\n                    b[offset + 1] = green;\n                    b[offset + 2] = blue;\n                    break;\n                case NeoPixelMode.APA102:\n                    // https://cdn-shop.adafruit.com/datasheets/APA102.pdf\n                    b[offset] = 0xe0 | 0x1f; // full brightness\n                    b[offset + 1] = blue;\n                    b[offset + 2] = green;\n                    b[offset + 3] = red;\n                    break;\n                default:\n                    b[offset + 0] = green;\n                    b[offset + 1] = red;\n                    b[offset + 2] = blue;\n                    break;\n            }\n        }\n\n        private reallocateBuffer(): void {\n            if (this._parent) return; // not supported in ranges\n            const stride = this.stride();\n            this._buf = control.createBuffer(this._length * stride);\n            this._brightnessBuf = undefined;\n            this._sendBuf = undefined;\n        }\n\n        // From here onwards, these block definitions are there for compatibility with old blocks\n        // (that have the default instance logic)\n\n        /**\n         * Set all of the pixels on the strip to one RGB color.\n         * @param rgb RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_strip_color\" block=\"set all pixels to %rgb=colorNumberPicker\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setAll(rgb: number) {\n            this.setAll(rgb);\n        }\n\n        /**\n         * Display a vertical bar graph based on the `value` and `high` value.\n         * If `high` is 0, the chart gets adjusted automatically.\n         * @param value current value to plot\n         * @param high maximum value, 0 to autoscale\n         */\n        //% blockId=neopixel_show_bar_graph block=\"graph %value |up to %high\" icon=\"\\uf080\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __graph(value: number, high: number): void {\n            this.graph(value, high);\n        }\n\n        /**\n         * Set the pixel to a given color.\n         * You need to call ``show`` to make the changes visible.\n         * @param pixeloffset position of the NeoPixel in the strip\n         * @param color RGB color of the LED\n         */\n        //% blockId=\"neopixel_set_pixel_color\" block=\"set pixel color at %pixeloffset|to %rgb=colorNumberPicker\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setPixelColor(pixeloffset: number, color: number): void {\n            this.setPixelColor(pixeloffset, color);\n        }\n\n        /**\n         * Gets the pixel color.\n         * @param pixeloffset position of the NeoPixel in the strip\n         */\n        //% blockId=\"neopixel_get_pixel_color\" block=\"pixel color at %pixeloffset\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __pixelColor(pixeloffset: number): number {\n            return this.pixelColor(pixeloffset);\n        }\n\n        /**\n         * Set the white brightness of a pixel in a NeoPixel strip of RGB+W LEDs.\n         * This only works for RGB+W NeoPixels.\n         * @param pixeloffset position of the LED in the strip\n         * @param white brightness of the white LED\n         */\n        //% blockId=\"neopixel_set_pixel_white_led\" block=\"set pixel white LED at %pixeloffset|to %white\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setPixelWhiteLED(pixeloffset: number, white: number): void {\n            this.setPixelWhiteLED(pixeloffset, white);\n        }\n\n        /**\n         * Make the strip show all the new changes for the pixels.\n         */\n        //% blockId=\"neopixel_show\" block=\"show\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __show(): void {\n            this.show();\n        }\n\n        /**\n         * Turn off all pixel LEDs.\n         */\n        //% blockId=\"neopixel_clear\" block=\"clear\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __clear(): void {\n            this.clear();\n        }\n\n        /**\n         * Get the number of pixels on the strip\n         */\n        //% blockId=\"neopixel_length\" block=\"length\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __length() {\n            return this.length();\n        }\n\n        /**\n         * Set the brightness of the strip. This flag only applies to future operation.\n         * @param brightness a measure of LED brightness in 0-255. eg: 20\n         */\n        //% blockId=\"neopixel_set_brightness\" block=\"set brightness %brightness\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setBrightness(brightness: number): void {\n            this.setBrightness(brightness);\n        }\n\n        /**\n         * Get the brightness of the pixel strip.\n         */\n        //% blockId=\"neopixel_get_brightness\" block=\"brightness\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __brightness(): number {\n            return this.brightness();\n        }\n\n        /**\n         * Create a range of pixels.\n         * @param start offset in the NeoPixel strip to start the range\n         * @param length number of pixels in the range. eg: 4\n         */\n        //% blockId=\"neopixel_range\" block=\"range from %start|with %length|pixels\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __range(start: number, length: number): NeoPixelStrip {\n            return this.range(start, length);\n        }\n\n        /**\n         * Shift LEDs forward and clear with zeros.\n         * You need to call ``show`` to make the changes visible.\n         * @param offset number of pixels to shift forward, eg: 1\n         */\n        //% blockId=\"neopixel_move_pixels\" block=\"%kind=MoveKind|by %offset\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __move(kind: LightMove, offset: number = 1): void {\n            this.move(kind, offset);\n        }\n\n        /**\n         * Move a photon effect along the pixel strip by a number of steps.\n         * @param steps number of steps (lights) to move, eg: 1\n         */\n        //% blockId=neophoton_fd block=\"photon forward by %steps\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __photonForward(steps: number) {\n            this.photonForward(steps);\n        }\n\n        /**\n         * Switch the direction of the photon pulse.\n         */\n        //% blockId=neophoton_flip block=\"photon flip\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __photonFlip() {\n            this.photonFlip();\n        }\n\n        /**\n         * Set the photon color.\n         * @param color the color of the photon\n         */\n        //% blockId=neophoton_set_color block=\"photon set pen color %color\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setPhotonColor(color: number) {\n            // The photon color has since changed, and we now use setPhotonPenHue to set the hue of the photon color\n            this.setPhotonPenHue(color);\n        }\n\n        /**\n         * Set the photon mode to pen up, pen down, or eraser.\n         * @param mode the desired mode\n         */\n        //% blockId=neophoton_set_photon block=\"photon %mode\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setPhotonMode(mode: PhotonMode) {\n            this.setPhotonMode(mode);\n        }\n\n        /**\n         * Show an animation or queue an animation in the animation queue\n         * @param animation the animation to run\n         * @param duration the duration to run in milliseconds, eg: 500\n         */\n        //% blockId=neopixel_show_animation block=\"show %animation=light_animation|animation for %duration=timePicker|ms\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __showAnimation(animation: NeoPixelAnimation, duration: number) {\n            this.showAnimation(animation, duration);\n        }\n\n        /**\n         * Show a single animation frame\n         * @param animation the animation to run\n         */\n        //% blockId=neopixel_show_animation_frame block=\"show animation frame %animation=light_animation\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __showAnimationFrame(animation: NeoPixelAnimation) {\n            this.showAnimationFrame(animation);\n        }\n\n        /**\n         * Stop the current animation and any other animations ready to show.\n         */\n        //% blockId=neopixel_stop_all_animations block=\"stop all animations\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __stopAllAnimations() {\n            this.stopAllAnimations();\n        }\n\n        /**\n         * Enables or disables automatically calling show when a change is made\n         * @param on call show whenever a light is modified\n         */\n        //% blockId=neopixel_set_buffered block=\"set buffered  %on\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setBuffered(on: boolean): void {\n            this.setBuffered(on);\n        }\n\n        /**\n         * Sets the color mode and clears the colors.\n         * @param mode the kind of color encoding required by the programmable lights\n         */\n        //% blockId=neopixel_set_mode block=\"set mode %mode\"\n        //% deprecated=1\n        //% defaultInstance=light.pixels\n        __setMode(mode: NeoPixelMode): void {\n            this.setMode(mode);\n        }\n    }\n\n    /**\n     * Creates a strip of colored LEDs (WS2812b)\n     */\n    //% blockId=\"neopixel_create\" block=\"create WS2812 strip|pin %pin|with %numleds pixels\"\n    //% help=\"light/create-neo-pixel-strip\"\n    //% trackArgs=0,2\n    //% parts=\"neopixel\"\n    //% weight=100 blockSetVariable=strip\n    //% advanced=true blockHidden=1\n    export function createNeoPixelStrip(\n        pin: DigitalInOutPin,\n        numleds: number = 10,\n        mode?: NeoPixelMode\n    ): NeoPixelStrip {\n        if (!mode)\n            mode = NeoPixelMode.RGB;\n\n        const strip = new NeoPixelStrip();\n        strip._mode = mode;\n        strip._length = Math.max(0, numleds | 0);\n        strip._dataPin = pin;\n        if (strip._dataPin) // board with no-board LEDs won't have a default pin\n            strip._dataPin.digitalWrite(false);\n        return strip;\n    }\n\n    /**\n     * Converts red, green, blue channels into a RGB color\n     * @param red value of the red channel between 0 and 255. eg: 255\n     * @param green value of the green channel between 0 and 255. eg: 255\n     * @param blue value of the blue channel between 0 and 255. eg: 255\n     */\n    //% blockId=\"neopixel_rgb\" block=\"red %red|green %green|blue %blue\"\n    //% red.min=0 red.max=255 green.min=0 green.max=255 blue.min=0 blue.max=255\n    //% help=\"light/rgb\"\n    //% group=\"Color\" weight=19 blockGap=8\n    export function rgb(red: number, green: number, blue: number): number {\n        return color.rgb(red, green, blue);\n    }\n\n    /**\n     * Get the RGB value of a known color\n    */\n    //% blockId=neopixel_colors block=\"%color\"\n    //% help=\"light/colors\"\n    //% shim=TD_ID\n    //% group=\"Color\" weight=20 blockGap=8\n    export function colors(color: Colors): number {\n        return color;\n    }\n\n    /**\n     * Convert an HSV (hue, saturation, value) color to RGB\n     * @param hue value of the hue channel between 0 and 255. eg: 255\n     * @param sat value of the saturation channel between 0 and 255. eg: 255\n     * @param val value of the value channel between 0 and 255. eg: 255\n     */\n\n    //% blockId=\"neopixel_hsv\" block=\"hue %hue|sat %sat|val %val\"\n    //% hue.min=0 hue.max=255 sat.min=0 sat.max=255 val.min=0 val.max=255\n    //% help=\"light/hsv\"\n    //% group=\"Color\" weight=17\n    export function hsv(hue: number, sat: number = 255, val: number = 255): number {\n        return color.hsv(hue, sat, val);\n    }\n\n    /**\n     * Use color.fade instead\n     * @param color color to fade\n     * @param brightness the amount of brightness to apply to the color, eg: 128\n     */\n    //% blockId=\"neopixel_fade\" block=\"fade %color=neopixel_colors|by %brightness\"\n    //% brightness.min=0 brightness.max=255\n    //% help=\"light/fade\"\n    //% group=\"Color\" weight=18 blockGap=8\n    //% blockHidden=true deprecated\n    export function fade(c: number, brightness: number): number {\n        return color.fade(c, brightness);\n    }\n\n    /**\n     * An animation of a NeoPixel\n     */\n    //% fixedInstances\n    export class NeoPixelAnimation {\n        constructor() { }\n\n        /**\n         * Creates an animator instance\n         * @param strip the strip to execute on\n         */\n        createRenderer(strip: NeoPixelStrip): () => boolean {\n            return undefined;\n        }\n    }\n\n    export class RainbowCycleAnimation extends NeoPixelAnimation {\n        public delay: number;\n        constructor(delay: number) {\n            super();\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const n = strip.length();\n            let hueOffset = 0;\n            return () => {\n                for (let i = 0; i < n; i++) {\n                    strip.setPixelColor(i, color.hsv(((i * 256) / (n - 1) + hueOffset) % 0xff, 0xff, 0xff));\n                }\n                hueOffset += Math.ceil(128 / n);\n                if (hueOffset >= 0xff) {\n                    hueOffset = 0;\n                    return false;\n                } else {\n                    return true;\n                }\n            }\n        }\n    }\n\n    //% fixedInstance block=\"rainbow\" whenUsed jres blockIdentity=\"light._animationPicker\"\n    export const rainbowAnimation: NeoPixelAnimation = new RainbowCycleAnimation(50);\n\n    export class RunningLightsAnimation extends NeoPixelAnimation {\n        public red: number;\n        public green: number;\n        public blue: number;\n        public delay: number;\n\n        constructor(red: number, green: number, blue: number, delay: number) {\n            super();\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const l = strip.length();\n            let iteration = 0;\n            let step = 0;\n            return () => {\n                if (iteration < l * 2) {\n                    step++;\n                    for (let i = 0; i < l; i++) {\n                        const level = (Math.isin(i + step) * 127) + 128;\n                        strip.setPixelColor(i, color.rgb(level * this.red / 255, level * this.green / 255, level * this.blue / 255));\n                    }\n                    iteration++;\n                    return true;\n                } else {\n                    step = 0;\n                    iteration = 0;\n                    return false;\n                }\n            }\n        }\n    }\n\n    //% fixedInstance block=\"running lights\" jres blockIdentity=\"light._animationPicker\"\n    export const runningLightsAnimation: NeoPixelAnimation = new RunningLightsAnimation(0xff, 0, 0, 50);\n\n    class CometAnimation extends NeoPixelAnimation {\n        public red: number;\n        public green: number;\n        public blue: number;\n        public delay: number;\n\n        constructor(red: number, green: number, blue: number, delay: number) {\n            super();\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const l = strip.length();\n            const spacing = (255 / l) >> 0;\n            let start = -1;\n            let step = 0;\n            const offsets: number[] = [];\n            for (let i = 0; i < l; i++) {\n                offsets[i] = spacing * i;\n            }\n            return () => {\n                for (let i = 0; i < l; i++) {\n                    offsets[i] = (offsets[i] + (step * 2)) % 255\n                    strip.setPixelColor(i, color.rgb(255 - offsets[i], this.green, this.blue));\n                }\n                step++;\n                if (step * 2 > 0xff) {\n                    step = 0;\n                    return false;\n                }\n                return true;\n            }\n        }\n    }\n\n    //% fixedInstance block=\"comet\" jres blockIdentity=\"light._animationPicker\"\n    export const cometAnimation: NeoPixelAnimation = new CometAnimation(0xff, 0, 0xff, 50);\n\n    export class SparkleAnimation extends NeoPixelAnimation {\n        public rgb: number;\n        public delay: number;\n\n        constructor(red: number, green: number, blue: number, delay: number) {\n            super();\n            this.rgb = color.rgb(red, green, blue);\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const l = strip.length();\n            let count = 0;\n            let pixel = -1;\n            let pixelColor = 0;\n            return () => {\n                if (count == 0)\n                    strip.clear();\n                if (pixel < 0) {\n                    pixel = Math.randomRange(0, l - 1);\n                    pixelColor = strip.pixelColor(pixel);\n                    strip.setPixelColor(pixel, this.rgb);\n\n                } else {\n                    strip.setPixelColor(pixel, pixelColor);\n                    pixel = -1;\n                }\n                count++;\n                if (count > 50) {\n                    count = 0;\n                    return false;\n                } else {\n                    return true;\n                }\n            }\n        }\n    }\n\n    //% fixedInstance block=\"sparkle\" jres blockIdentity=\"light._animationPicker\"\n    export const sparkleAnimation: NeoPixelAnimation = new SparkleAnimation(0xff, 0xff, 0xff, 50);\n\n    class ColorWipeAnimation extends NeoPixelAnimation {\n        public rgb: number;\n        public delay: number;\n\n        constructor(rgb: number, delay: number) {\n            super();\n            this.rgb = rgb;\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const l = strip.length();\n            let i = 0;\n            let reveal = true;\n            return () => {\n                if (i < l) {\n                    if (reveal) {\n                        strip.setPixelColor(i, this.rgb);\n                    } else {\n                        strip.setPixelColor(i, 0);\n                    }\n                    i++;\n                } else {\n                    reveal = !reveal;\n                    i = 0;\n                    if (reveal)\n                        return false;\n                }\n                return true;\n            }\n        }\n    }\n\n    //% fixedInstance block=\"color wipe\" jres blockIdentity=\"light._animationPicker\"\n    export const colorWipeAnimation: NeoPixelAnimation = new ColorWipeAnimation(0x0000ff, 50);\n\n    class TheatreChaseAnimation extends NeoPixelAnimation {\n        public rgb: number;\n        public delay: number;\n\n        constructor(red: number, green: number, blue: number, delay: number) {\n            super();\n            this.rgb = color.rgb(red, green, blue);\n            this.delay = delay;\n        }\n\n        public createRenderer(strip: NeoPixelStrip): () => boolean {\n            const l = strip.length();\n            let j = 0;\n            let q = 0;\n            let on = false;\n            return () => {\n                if (j < 10) { // 10 cycles of chasing\n                    if (q < 3) {\n                        if (on) {\n                            for (let i = 0; i < l; i = i + 3) {\n                                strip.setPixelColor(i + q, this.rgb); // every third pixel on\n                            }\n                        }\n                        else {\n                            for (let i = 0; i < l; i = i + 3) {\n                                strip.setPixelColor(i + q, 0); // every third pixel off\n                            }\n                        }\n                        on = !on;\n                        q++;\n                    } else {\n                        q = 0;\n                    }\n                    j++;\n                } else {\n                    j = 0;\n                    return false;\n                }\n                return true;\n            }\n        }\n    }\n\n    //% fixedInstance block=\"theater chase\" jres blockIdentity=\"light._animationPicker\"\n    export const theaterChaseAnimation: NeoPixelAnimation = new TheatreChaseAnimation(0xff, 0, 0, 50);\n\n    /**\n     * An animation that can be shown on a light strip\n     * @param animation The animation type\n     */\n    //% blockId=light_animation_picker block=\"%animation\" shim=TD_ID\n    //% animation.fieldEditor=\"imagedropdown\"\n    //% animation.fieldOptions.columns=3\n    //% weight=0\n    //% group=\"More\"\n    export function _animationPicker(animation: NeoPixelAnimation): NeoPixelAnimation {\n        return animation;\n    }\n\n    /**\n  * Get the light length picker\n  * @param pixels number of LEDs\n  */\n    //% blockId=lightLengthPicker block=\"%pixels\"\n    //% blockHidden=true shim=TD_ID\n    //% colorSecondary=\"#FFFFFF\"\n    //% pixels.fieldEditor=\"numberdropdown\" pixels.fieldOptions.decompileLiterals=true\n    //% pixels.fieldOptions.data='[[\"7\", 7], [\"8\", 8], [\"12\", 12], [\"16\", 16], [\"24\", 24], [\"30\", 30], [\"60\", 60], [\"64\", 64], [\"90\", 90], [\"120\", 120], [\"144\", 144]]'\n    export function __lengthPicker(pixels: number): number {\n        return pixels;\n    }\n}\n",
            "neopixeloverrides.ts": "\ndeclare namespace light {\n    interface NeoPixelStrip {\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setAll(rgb: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setGradient(startColor: number, endColor: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        graph(value: number, high: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setPixelColor(pixeloffset: number, color: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        pixelColor(pixeloffset: number): number;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setPixelWhiteLED(pixeloffset: number, white: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        show(): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        clear(): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        length(): number;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setBrightness(brightness: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        brightness(): number;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        range(start: number, length: number): NeoPixelStrip;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        move(kind: LightMove, offset: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setPhotonPosition(index: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        photonForward(steps: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        photonFlip(): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setPhotonPenHue(hue: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setPhotonPenColor(color: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setPhotonMode(mode: PhotonMode): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        showAnimation(animation: NeoPixelAnimation, duration: number): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        showAnimationFrame(animation: NeoPixelAnimation): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        stopAllAnimations(): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setBuffered(on: boolean): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        buffered(): boolean;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setMode(mode: NeoPixelMode): void;\n\n        //% advanced=false\n        //% subcategory=\"NeoPixel\"\n        setLength(length: number): void;\n    }\n}",
            "ns.ts": "\n/**\n * Functions to operate colored LEDs.\n */\n//% weight=100 color=\"#0078d7\" icon=\"\\uf00a\"\nnamespace light {\n\n}",
            "onboardstrip.ts": "namespace light {\n    let _onboardStrip: light.LightStrip;\n    /**\n     * Get the default light strip.\n     */\n    //% help=light/onboard-strip\n    //% blockId=\"neopixel_onboard_strip\" block=\"onboard strip\"\n    //% weight=111 blockGap=8\n    //% subcategory=\"NeoPixel\"\n    export function onboardStrip(): NeoPixelStrip {\n        if (_onboardStrip) return _onboardStrip;\n\n        const data = pins.pinByCfg(DAL.CFG_PIN_DOTSTAR_DATA);\n        const clk = pins.pinByCfg(DAL.CFG_PIN_DOTSTAR_CLOCK);\n        const dsnum = control.getConfigValue(DAL.CFG_NUM_DOTSTARS, 0);\n        const neo = pins.pinByCfg(DAL.CFG_PIN_NEOPIXEL);\n        const neonum = control.getConfigValue(DAL.CFG_NUM_NEOPIXELS, 0);\n        if (data && clk && dsnum > 0) {\n            _onboardStrip = light.createAPA102Strip(data, clk, dsnum);\n            _onboardStrip.setBrightness(96);\n        } else if (neo) {\n            _onboardStrip = light.createNeoPixelStrip(neo, neonum, NeoPixelMode.RGB);\n        } else {\n            _onboardStrip = light.createNeoPixelStrip(undefined, 0);\n        }\n        return _onboardStrip;\n    }\n}",
            "pxt.json": "{\n    \"name\": \"light\",\n    \"description\": \"The programmable LED (WS2812b,APA102) driver.\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"color\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"neopixel.ts\",\n        \"transitions.ts\",\n        \"create.ts\",\n        \"defaultstrip.ts\",\n        \"onboardstrip.ts\",\n        \"defaultlights.ts\",\n        \"defaultlightsoverrides.ts\",\n        \"ns.ts\",\n        \"neopixeloverrides.ts\",\n        \"animations.jres\",\n        \"targetoverrides.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "targetoverrides.ts": "// define built-in strips here",
            "test.ts": "\nlet strip = light.createStrip()\nstrip.setBrightness(20)\n\nfunction flash(n: number) {\n    control.runInParallel(() => {\n        strip.setPixelColor(n, 0x0000ff)\n        pause(1000)\n        strip.setPixelColor(n, 0x000000)\n    })\n}\n\nflash(0)\n\n",
            "transitions.ts": "namespace easing {\n    export function linear(t: number): number { return t; }\n    export function inQuad(t: number): number { return t * t; }\n    export function outQuad(t: number): number { return t * (2 - t); }\n    export function inOutQuad(t: number): number { return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t; }\n    export function inCubic(t: number): number { return t * t * t; }\n    export function outCubic(t: number): number { return (--t) * t * t + 1; }\n    export function inOutCubic(t: number): number { return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1; }\n}\n\nnamespace light {\n    export class BrightnessTransition {\n        constructor() { }\n        apply(strip: LightStrip, t: number, start: number, end: number): void {\n\n        }\n    }\n\n    export class EasingBrightnessTransition extends BrightnessTransition {\n        private timeEasing: (t: number) => number;\n        private spatialEasing: (t: number) => number;\n\n        constructor(\n            timeEasing: (t: number) => number, \n            spatialEasing?: (t: number) => number) {\n            super();\n            this.timeEasing = timeEasing || easing.inOutQuad;\n            this.spatialEasing = spatialEasing;\n        }\n\n        apply(strip: LightStrip, t: number, start: number, end: number): void {\n            // t in [0..1]\n            const db = end - start;\n            const b = this.timeEasing(t); // [0..1]\n            if (!this.spatialEasing) {\n                strip.setBrightness(start + db * b);\n            }\n            else {\n                // convolve desired brightness with spacial easing function\n                const n = strip.length();\n                for (let i = 0; i < n; ++i) {\n                    const x = this.spatialEasing(i / (n - 1)); // [0..1]\n                    strip.setPixelBrightness(i, end - db * (1 - b) * x);\n                }\n            }\n        }\n    }\n\n    export class BrightnessTransitionPlayer {\n        private transition: BrightnessTransition;\n        private startBrightness: number;\n        private endBrightness: number;\n        private duration: number;\n        private startTime: number;\n        private repeat: number;\n        private yoyo: number;\n\n        constructor(\n            transition: BrightnessTransition,\n            startBrightness: number,\n            endBrightness: number,\n            duration: number,\n            repeat: number,\n            yoyo: boolean) {\n            this.transition = transition;\n            this.startBrightness = startBrightness;\n            this.endBrightness = endBrightness;\n            this.duration = duration;\n            this.startTime = control.millis();\n            this.repeat = repeat || 1;\n            this.yoyo = yoyo ? 1 : 0;\n        }\n\n        update(strip: LightStrip): boolean {\n            let elapsed = control.millis() - this.startTime;\n            if (elapsed > this.duration) {\n                this.yoyo = -this.yoyo;\n                if (this.repeat > 0)\n                    this.repeat--;\n                this.startTime = control.millis();\n                elapsed = 0;\n                return this.repeat != 0;\n            }\n\n            let t = elapsed / this.duration;\n            if (this.yoyo < 0)\n                t = 1 - t;\n            this.transition.apply(strip, t, this.startBrightness, this.endBrightness);\n            return true;\n        }\n    }\n}"
        },
        "touch": {
            "README.md": "# touch\n\nThe capacitive touch library.\n\n",
            "enums.d.ts": "\n",
            "pxt.json": "{\n    \"name\": \"touch\",\n    \"description\": \"The capacitive touch library\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"buttons\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"touch.h\",\n        \"touch.cpp\",\n        \"touch.ts\",\n        \"shims.d.ts\",\n        \"enums.d.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\n\n\ndeclare interface TouchButton {\n    /**\n     * Manually define the threshold use to detect a touch event. Any sensed value equal to or greater than this value will be interpreted as a touch.\n     * @param name button name\n     * @param threshold minimum value to consider a touch eg:200\n     */\n    //% blockId=touch_set_threshold block=\"button %button|set threshold %threshold\"\n    //% blockNamespace=input\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% threshold.min=0\n    //% threshold.max=1023\n    //% group=\"More\" weight=16 blockGap=8\n    //% help=input/touch/set-threshold shim=TouchButtonMethods::setThreshold\n    setThreshold(threshold: int32): void;\n\n    /**\n     * Gets the current threshold\n     * @param name button name\n     */\n    //% blockId=touch_threshold block=\"button %button|threshold\"\n    //% blockNamespace=input\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% group=\"More\" weight=16 blockGap=8\n    //% help=input/touch/threshold shim=TouchButtonMethods::threshold\n    threshold(): int32;\n\n    /**\n     * Reads the current value registered with the button.\n     * @param name button name\n     */\n    //% blockId=touch_value block=\"button %button|value\"\n    //% blockNamespace=input\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% group=\"More\" weight=49 blockGap=8\n    //% help=input/touch/value shim=TouchButtonMethods::value\n    value(): int32;\n\n    /**\n     * Calibrate the touch sensivity\n     */\n    //% blockId=touch_calibrate block=\"button %button calibrate\"\n    //% blockNamespace=input\n    //% name.fieldEditor=\"gridpicker\"\n    //% name.fieldOptions.width=220\n    //% name.fieldOptions.columns=4\n    //% group=\"More\" weight=49 blockGap=8\n    //% help=input/touch/calibrate shim=TouchButtonMethods::calibrate\n    calibrate(): void;\n}\n\n\ndeclare interface AnalogInOutPin {\n    /**\n     * Get the cap-touch sensor for given pin (if available)\n     */\n    //% shim=AnalogInOutPinMethods::touchButton\n    touchButton(): TouchButton;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "test.ts": "",
            "touch.cpp": "#include \"pxt.h\"\n#include \"touch.h\"\n\nnamespace pxt {\n//%\nTouchButton getTouchButton(int id) {\n    auto cpid = DEVICE_ID_FIRST_TOUCHBUTTON + id;\n    auto btn = (CapTouchButton*)lookupComponent(cpid);\n    if (btn == NULL) {\n        // GCTODO\n        // 'new' will add it to component list\n        btn = new CapTouchButton(*pxt::getPin(id));\n        btn->id = cpid;\n    }\n    return btn;\n}\n}\n\n\nnamespace TouchButtonMethods {\n\n/**\n * Manually define the threshold use to detect a touch event. Any sensed value equal to or greater than this value will be interpreted as a touch.\n * @param name button name\n * @param threshold minimum value to consider a touch eg:200\n */\n//% blockId=touch_set_threshold block=\"button %button|set threshold %threshold\"\n//% blockNamespace=input\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% threshold.min=0\n//% threshold.max=1023\n//% group=\"More\" weight=16 blockGap=8\n//% help=input/touch/set-threshold\nvoid setThreshold(TouchButton button, int threshold) {\n    button->setThreshold(max(0, min(1 << 12, threshold << 2)));\n}\n\n/**\n * Gets the current threshold\n * @param name button name\n */\n//% blockId=touch_threshold block=\"button %button|threshold\"\n//% blockNamespace=input\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% group=\"More\" weight=16 blockGap=8\n//% help=input/touch/threshold\nint threshold(TouchButton button) {\n    return button->threshold >> 2;\n}\n\n/**\n * Reads the current value registered with the button.\n * @param name button name\n */\n//% blockId=touch_value block=\"button %button|value\"\n//% blockNamespace=input\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% group=\"More\" weight=49 blockGap=8\n//% help=input/touch/value\nint value(TouchButton button) {\n    return button->getValue() >> 2;\n}\n\n/**\n* Calibrate the touch sensivity\n*/\n//% blockId=touch_calibrate block=\"button %button calibrate\"\n//% blockNamespace=input\n//% name.fieldEditor=\"gridpicker\"\n//% name.fieldOptions.width=220\n//% name.fieldOptions.columns=4\n//% group=\"More\" weight=49 blockGap=8\n//% help=input/touch/calibrate\nvoid calibrate(TouchButton button) {\n    button->calibrate();\n}\n\n}\n\nnamespace AnalogInOutPinMethods {\n    \n/**\n * Get the cap-touch sensor for given pin (if available)\n */\n//%\nTouchButton touchButton(AnalogInOutPin pin) {\n    if (PA02 <= pin->name && pin->name <= PA07)\n        ;\n    else if (PB02 <= pin->name && pin->name <= PB09)\n        ;\n    else\n        return NULL;\n    return pxt::getTouchButton(pin->name);\n}\n\n}\n",
            "touch.h": "#define TouchButton CapTouchButton *\n",
            "touch.ts": "//% noRefCounting fixedInstances\ninterface TouchButton extends Button {\n    // methods filled from C++\n}\n"
        },
        "switch": {
            "README.md": "# switch\n\nThe build-in slide switch library.\n",
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum SwitchDirection {\n    //% block=\"left\"\n    Left = 2,  // DEVICE_BUTTON_EVT_UP\n    //% block=\"right\"\n    Right = 1,  // DEVICE_BUTTON_EVT_DOWN\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "ns.ts": "//% color=\"#d65cd6\"\nnamespace input {\n}\n",
            "pxt.json": "{\n    \"name\": \"switch\",\n    \"description\": \"A slide switch\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"switch.cpp\",\n        \"ns.ts\",\n        \"shims.d.ts\",\n        \"enums.d.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace input {\n\n    /**\n     * Do something when the slide switch is moved left or right.\n     * @param direction the direction the switch must be moved to trigger the event\n     */\n    //% help=input/on-switch-moved\n    //% blockId=device_on_switch_moved block=\"on switch moved %direction\"\n    //% parts=\"switch\"\n    //% weight=80 shim=input::onSwitchMoved\n    function onSwitchMoved(direction: SwitchDirection, handler: () => void): void;\n\n    /**\n     * Gets a value indicating if the switch is positioned to the right\n     */\n    //% blockId=device_switch_direction block=\"switch right\"\n    //% parts=\"switch\"\n    //% group=\"Switch\" weight=10 blockGap=8 shim=input::switchRight\n    function switchRight(): boolean;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "switch.cpp": "#include \"pxt.h\"\n#include \"Button.h\"\n#include \"pins.h\"\n\nenum class SwitchDirection {\n    //% block=\"left\"\n    Left = DEVICE_BUTTON_EVT_UP,\n    //% block=\"right\"\n    Right = DEVICE_BUTTON_EVT_DOWN\n};\n\nnamespace pxt {\n\n// Wrapper classes\nclass WSwitch {\n  public:\n    Button slideSwitch;\n\n    WSwitch()\n        : slideSwitch(*LOOKUP_PIN(BTN_SLIDE), DEVICE_ID_BUTTON_SLIDE,\n                      DEVICE_BUTTON_SIMPLE_EVENTS, ACTIVE_LOW, PullMode::Up) {}\n};\nSINGLETON(WSwitch);\n\n}\n\nnamespace input {\n/**\n* Do something when the slide switch is moved left or right.\n* @param direction the direction the switch must be moved to trigger the event\n*/\n//% help=input/on-switch-moved\n//% blockId=device_on_switch_moved block=\"on switch moved %direction\"\n//% parts=\"switch\"\n//% weight=80\nvoid onSwitchMoved(SwitchDirection direction, Action handler) {\n    registerWithDal(getWSwitch()->slideSwitch.id, (int)direction, handler);\n}\n\n/**\n* Gets a value indicating if the switch is positioned to the right\n*/\n//% blockId=device_switch_direction block=\"switch right\"\n//% parts=\"switch\"\n//% group=\"Switch\" weight=10 blockGap=8\nbool switchRight() {\n    auto slide = getWSwitch();\n    return slide->slideSwitch.isPressed();\n}\n\n}\n"
        },
        "pulse": {
            "README.md": "# pulse\n\nThe Pulse library.\n\n",
            "bitvector.h": "#ifndef CABLE_BITVECTOR_H\n#define CABLE_BITVECTOR_H\n\nclass BitVector {\n    LLSegment data;\n    int len;\n\n    uint32_t get32(int idx) { return (uint32_t)data.get(idx >> 5); }\n\n  public:\n    BitVector() { len = 0; }\n    ~BitVector() { data.destroy(); }\n\n    int size() { return len; }\n\n    void print() {\n        char buf[size() + 1];\n        for (int i = 0; i < size(); ++i)\n            buf[i] = get(i) ? '#' : '.';\n        buf[size()] = 0;\n        DMESG(\"bits: %s\", buf);\n    }\n\n    int get(int pos) {\n        if (pos < 0 || pos >= len)\n            return 0;\n        return !!(get32(pos) & (1 << (pos & 31)));\n    }\n    uint32_t getBits(int pos, int num) {\n        uint32_t res = get32(pos);\n        int off = pos & 31;\n        res >>= off;\n        off = 32 - off;\n        if (num > off) {\n            res |= get32(pos + 32) << off;\n        }\n        if (num < 32)\n            res &= (1U << num) - 1;\n        return res;\n    }\n    void set(int pos, int v) {\n        if (pos < 0 || pos >= len)\n            return;\n        auto curr = get32(pos);\n        auto mask = 1 << (pos & 31);\n        if (v)\n            curr |= mask;\n        else\n            curr &= ~mask;\n        data.set(pos >> 5, (TValue)curr);\n    }\n    void setLength(uint32_t newLength) {\n        len = newLength;\n        data.setLength((len + 31) >> 5);\n    }\n    void push(int v) {\n        setLength(len + 1);\n        set(len - 1, v);\n    }\n};\n\n#endif",
            "ns.ts": "/**\n * Communication between devices\n */\n//% color=#E3008C weight=89 icon=\"\\uf086\"\n//% groups='[\"Infrared\", \"Cable\"]'\nnamespace network {\n}",
            "pulse.cpp": "#include \"pxt.h\"\n#include \"pulse.h\"\n\n#define IR_TIMER_CHANNEL 0\n\n// from samd21.cpp\nvoid setTCC0(int enabled);\n\n#ifdef SAMD21\nvoid setTCC0(int enabled) {\n    while (TCC0->STATUS.reg & TC_STATUS_SYNCBUSY)\n        ;\n    if (enabled)\n        TCC0->CTRLA.reg |= TC_CTRLA_ENABLE;\n    else\n        TCC0->CTRLA.reg &= ~TC_CTRLA_ENABLE;\n}\n#endif\n\nnamespace network {\n\nstatic const uint8_t hamming[16] = {\n    0b0000000, 0b1110000, 0b1001100, 0b0111100, 0b0101010, 0b1011010, 0b1100110, 0b0010110,\n    0b1101001, 0b0011001, 0b0100101, 0b1010101, 0b1000011, 0b0110011, 0b0001111, 0b1111111,\n};\n\nstatic const uint8_t invHamming[64] = {\n    0x00, 0x0c, 0x0a, 0x7e, 0x09, 0x4e, 0x2e, 0xee, 0x09, 0x7d, 0x7b, 0x77, 0x99, 0x59, 0x39, 0x7e,\n    0x0a, 0x4d, 0xaa, 0x6a, 0x48, 0x44, 0x3a, 0x4e, 0x1d, 0xdd, 0x3a, 0x7d, 0x39, 0x4d, 0x33, 0x3f,\n    0x0c, 0xcc, 0x2b, 0x6c, 0x28, 0x5c, 0x22, 0x2e, 0x1b, 0x5c, 0xbb, 0x7b, 0x59, 0x55, 0x2b, 0x5f,\n    0x18, 0x6c, 0x6a, 0x66, 0x88, 0x48, 0x28, 0x6f, 0x11, 0x1d, 0x1b, 0x6f, 0x18, 0x5f, 0x3f, 0xff};\n\nstatic const uint8_t bitsToGap[4] = {1, 2, 4, 3};\nstatic const uint8_t gapToBits[5] = {0b00, 0b00, 0b01, 0b11, 0b10};\n\nstatic int lookupInvHaming(int v) {\n    int k = invHamming[v >> 1];\n    if (v & 1)\n        return (k & 0xf);\n    else\n        return (k >> 4);\n}\n\nstatic void decodeHamming(uint32_t r, uint8_t *dst) {\n    int a0 = 0;\n    int a1 = 0;\n    int b0 = 0;\n    int b1 = 0;\n    int p = 0;\n\n    for (int i = 0; i < 7; ++i) {\n        a0 |= ((r >> p++) & 1) << i;\n        b0 |= ((r >> p++) & 1) << i;\n        a1 |= ((r >> p++) & 1) << i;\n        b1 |= ((r >> p++) & 1) << i;\n    }\n\n    dst[0] = (lookupInvHaming(a0) << 4) | lookupInvHaming(a1);\n    dst[1] = (lookupInvHaming(b0) << 4) | lookupInvHaming(b1);\n}\n\nstatic void pushTwo(BitVector &bv, uint8_t a, uint8_t b) {\n    int gap = bitsToGap[b * 2 + a];\n    bv.push(1);\n    while (gap--)\n        bv.push(0);\n}\n\nstatic void encodeHamming(BitVector &bv, uint8_t a, uint8_t b) {\n    int a0 = hamming[a >> 4];\n    int a1 = hamming[a & 0xf];\n    int b0 = hamming[b >> 4];\n    int b1 = hamming[b & 0xf];\n    for (int i = 0; i < 7; ++i) {\n        pushTwo(bv, (a0 >> i) & 1, (b0 >> i) & 1);\n        pushTwo(bv, (a1 >> i) & 1, (b1 >> i) & 1);\n    }\n}\n\nuint16_t crc16ccit(uint8_t *data, uint32_t len) {\n    uint16_t crc = 0xffff;\n\n    while (len--) {\n        crc ^= (*data++ << 8);\n        for (int i = 0; i < 8; ++i) {\n            if (crc & 0x8000)\n                crc = crc << 1 ^ 0x1021;\n            else\n                crc = crc << 1;\n        }\n    }\n\n    return crc;\n}\n\nstatic PulseBase* instance = NULL;\n\nstatic void timer_irq(uint16_t channels)\n{\n    if (instance)\n        instance->timerIRQ(channels);\n}\n\nPulseBase::PulseBase(uint16_t id, int pinOut, int pinIn, LowLevelTimer* t) {\n    this->id = id;\n    this->timer = t;\n\n    instance = this;\n\n    recvState = PULSE_RECV_ERROR;\n    sending = false;\n    outBuffer = NULL;\n    pin = lookupPin(pinOut);\n    if (pin) {\n        pin->setDigitalValue(0);\n\n        inpin = lookupPin(pinIn);\n\n        devMessageBus.listen(id, PULSE_PACKET_END_EVENT, this, &PulseBase::packetEnd);\n    }\n\n    timer->setIRQPriority(0);\n    timer->setIRQ(timer_irq);\n    timer->setBitMode(BitMode16);\n    timer->enable();\n}\n\nvoid PulseBase::setupGapEvents() {\n    devMessageBus.listen(inpin->id, DEVICE_PIN_EVT_PULSE_HI, this, &PulseBase::pulseGap,\n                         MESSAGE_BUS_LISTENER_IMMEDIATE);\n    devMessageBus.listen(inpin->id, DEVICE_PIN_EVT_PULSE_LO, this, &PulseBase::pulseMark,\n                         MESSAGE_BUS_LISTENER_IMMEDIATE);\n    listen();\n}\n\nvoid PulseBase::listen() {\n    inpin->getDigitalValue();\n    inpin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n}\n\nvoid PulseBase::setupPWM() {\n    pin->setAnalogPeriodUs(1000 / 38); // 38kHz\n    pin->setAnalogValue(333);\n    setPWM(1);\n}\n\nvoid PulseBase::setPWM(int enabled) {\n    setTCC0(enabled);\n    pwmstate = enabled;\n}\n\nvoid PulseBase::finishPWM() {\n    pin->setAnalogValue(0);\n    setPWM(1);\n}\n\nvoid PulseBase::send(Buffer d) {\n    if (sending)\n        return; // error code?\n\n    if (d->length > PULSE_MAX_MSG_SIZE - 2 || (d->length & 1))\n        return; // error code?\n\n    encodedMsg.setLength(0);\n    for (int i = 0; i < 25; ++i)\n        encodedMsg.push(1);\n\n    for (int i = 0; i < 8; ++i)\n        encodedMsg.push(0);\n\n    for (int i = 0; i < d->length; i += 2) {\n        encodeHamming(encodedMsg, d->data[i], d->data[i + 1]);\n    }\n\n    uint16_t crc = crc16ccit(d->data, d->length);\n    encodeHamming(encodedMsg, crc & 0xff, crc >> 8);\n\n    for (int i = 0; i < 15; ++i)\n        encodedMsg.push(1);\n\n    auto gap = system_timer_current_time_us() - lastSendTime;\n\n    // we require 200ms between sends\n    if (gap < 200000) {\n        gap = (200000 - gap) / 1000;\n        fiber_sleep(gap);\n    }\n\n    while (isReceiving())\n        fiber_sleep(10);\n\n    // encodedMsg.print();\n\n    sending = true;\n    sendStartTime = 0;\n    setupPWM();\n\n    sendPtr = 0;\n\n    lastSendTime = system_timer_current_time_us();\n\n    timer->setCompare(IR_TIMER_CHANNEL, timer->captureCounter() + PULSE_PULSE_LEN);\n\n    while (sending) {\n        fiber_sleep(10);\n    }\n    fiber_sleep(5);\n}\n\nvoid PulseBase::timerIRQ(uint16_t)\n{\n    process();\n}\n\nvoid PulseBase::finish(int code) {\n    if (recvState == PULSE_RECV_ERROR)\n        return;\n\n    if (code == 0) {\n        Event evt(id, PULSE_PACKET_END_EVENT);\n    } else {\n        Event evt(id, PULSE_PACKET_ERROR_EVENT);\n        PULSE_DMESG(\"IR ERROR %d [%s]\", code, dbg.get());\n    }\n    dbg.get();\n    recvState = PULSE_RECV_ERROR;\n}\n\nvoid PulseBase::addPulse(int v) {\n    if (this->pulsePtr < PULSE_MAX_PULSES - 1) {\n        pulses[this->pulsePtr++] = (int16_t)v;\n    } else {\n        finish(2);\n    }\n}\n\nint PulseBase::adjustShift() {\n    int pulseLen = (pulses[0] - pulses[1]) / 9;\n    PULSE_DMESG(\"prev: %d %d %d %d %d %d %d %d %d %d\", pulses[0], pulses[1], pulses[2], pulses[3],\n                pulses[4], pulses[5], pulses[6], pulses[7], pulses[8], pulses[9], pulses[10],\n                pulses[11]);\n    return pulseLen;\n}\n\nvoid PulseBase::pulseGap(Event ev) {\n    if (sending)\n        return;\n\n    if (ev.timestamp > 10000) {\n        dbg.put(\" BRK \");\n        finish(11);\n        return;\n    }\n\n    int tm = (int)ev.timestamp;\n\n    dbg.putNum(tm);\n\n    if (recvState == PULSE_WAIT_START_GAP) {\n        pulsePtr = 0;\n        startTime = system_timer_current_time_us() - tm;\n        addPulse(tm);\n        recvState = PULSE_WAIT_DATA;\n        dbg.put(\" *** \");\n        return;\n    }\n\n    if (recvState == PULSE_WAIT_DATA) {\n        addPulse(tm);\n        return;\n    }\n}\n\nvoid PulseBase::packetEnd(Event) {\n    if (pulsePtr < 5)\n        return;\n\n    int pulseLen = adjustShift();\n    int numBits = 0;\n    uint32_t r = 0;\n    uint8_t buf[PULSE_MAX_MSG_SIZE];\n    int ptr = 0;\n\n    for (int i = 2; i < pulsePtr; ++i) {\n        if (pulses[i] > 0) {\n            int len = (pulses[i] + pulseLen / 2) / pulseLen;\n            if (len > 4)\n                len = 4;\n            r |= (uint32_t)gapToBits[len] << numBits;\n            numBits += 2;\n            if (numBits == 28) {\n                decodeHamming(r, buf + ptr);\n                numBits = 0;\n                r = 0;\n                ptr += 2;\n            }\n        }\n    }\n\n    pulsePtr = 0;\n\n    if (numBits != 0) {\n        Event evt(id, PULSE_PACKET_ERROR_EVENT);\n        PULSE_DMESG(\"left over bits: %d\", numBits);\n        return;\n    }\n\n    if (ptr < 4) {\n        Event evt(id, PULSE_PACKET_ERROR_EVENT);\n        PULSE_DMESG(\"too short: %d\", ptr);\n        return; // too short\n    }\n\n    ptr -= 2;\n    uint16_t crc = crc16ccit(buf, ptr);\n    uint16_t pktCrc = (buf[ptr + 1] << 8) | buf[ptr];\n\n    if (!outBuffer)\n        registerGC((TValue*)&outBuffer);\n    outBuffer = pins::createBuffer(ptr);\n    memcpy(outBuffer->data, buf, ptr);\n    if (crc != pktCrc)\n        PULSE_DMESG(\"crc fail: %x %x len=%d\", crc, pktCrc, pulseLen);\n    Event evt(id, crc == pktCrc ? PULSE_PACKET_EVENT : PULSE_PACKET_ERROR_EVENT);\n}\n\nvoid PulseBase::pulseMark(Event ev) {\n    if (sending)\n        return;\n\n    if (ev.timestamp > 10000) {\n        dbg.put(\" -BRK \");\n        finish(10);\n        return;\n    }\n\n    int tm = (int)ev.timestamp;\n\n    dbg.putNum(-tm);\n\n    lastMarkTime = system_timer_current_time_us();\n\n    if (tm >= 20 * PULSE_PULSE_LEN) {\n        recvState = PULSE_WAIT_START_GAP;\n        return;\n    }\n\n    if (recvState == PULSE_WAIT_DATA) {\n        if (tm >= 12 * PULSE_PULSE_LEN) {\n            // finish\n            addPulse(-(40 * PULSE_PULSE_LEN)); // make sure we get all ones at the end\n            finish(0);\n        } else {\n            addPulse(-tm);\n        }\n    }\n}\n\nbool PulseBase::isReceiving() {\n    auto now = system_timer_current_time_us();\n    // inpin low means mark\n    if (inpin->getDigitalValue() == 0 || now - lastMarkTime < 10000) {\n        return true;\n    }\n    return false;\n}\n\nBuffer PulseBase::getBuffer() {\n    return outBuffer;\n}\n\nvoid PulseBase::process() {\n    // DMESG(\"PROC\");\n    if (!sending)\n        return;\n\n    auto now = system_timer_current_time_us();\n    if (sendStartTime == 0)\n        sendStartTime = now - (PULSE_PULSE_LEN / 2);\n\n    auto encodedMsgPtr = (int)(now - sendStartTime) / PULSE_PULSE_LEN;\n\n    encodedMsgPtr = sendPtr++;\n\n    if (encodedMsgPtr >= encodedMsg.size()) {\n        encodedMsg.setLength(0);\n        finishPWM();\n\n        sending = false;\n        return;\n    }\n\n    timer->offsetCompare(IR_TIMER_CHANNEL, PULSE_PULSE_LEN);\n\n    int curr = encodedMsg.get(encodedMsgPtr);\n    if (curr != pwmstate)\n        setPWM(curr);\n}\n}\n",
            "pulse.h": "#ifndef CABLE_PULSE_H\n#define CABLE_PULSE_H\n\n#include \"pxt.h\"\n#include \"bitvector.h\"\n#include \"LowLevelTimer.h\"\n\n#define PULSE_MAX_MSG_SIZE 34\n#define PULSE_PACKET_END_EVENT 0x1\n#define PULSE_PACKET_EVENT 0x2\n#define PULSE_PACKET_ERROR_EVENT 0x3\n#define PULSE_MAX_PULSES (PULSE_MAX_MSG_SIZE * 14 + 10)\n#define PULSE_PULSE_LEN 250\n\n#define PULSE_IR_COMPONENT_ID 0x2042\n#define PULSE_CABLE_COMPONENT_ID 0x2043\n\n#define PULSE_DEBUG 0\n\n#if PULSE_DEBUG\n#define PULSE_DMESG DMESG\n#else\n#define PULSE_DMESG(...)                                                                           \\\n    do {                                                                                           \\\n    } while (0)\n#endif\n\nnamespace network {\n\nclass DbgBuffer {\n  public:\n#if PULSE_DEBUG\n    char dbgBuf[1200];\n    int dbgPtr;\n    DbgBuffer() {\n        dbgBuf[0] = 0;\n        dbgPtr = 0;\n    }\n#endif\n\n    void put(const char *msg) {\n#if IR_DEBUG\n        int len = strlen(msg);\n        if (len + dbgPtr > (int)sizeof(dbgBuf) - 1) {\n            dbgPtr = 1;\n            dbgBuf[0] = '>';\n        }\n        memcpy(dbgBuf + dbgPtr, msg, len + 1);\n        dbgPtr += len;\n#endif\n    }\n\n    void putNum(int n) {\n#if IR_DEBUG\n        char buf[30];\n        itoa(n, buf);\n        put(\" \");\n        put(buf);\n#endif\n    }\n\n    const char *get() {\n#if IR_DEBUG\n        dbgPtr = 0;\n        return dbgBuf;\n#else\n        return \"NoDebug\";\n#endif\n    }\n};\n\nenum PulseRecvState : uint8_t {\n    PULSE_RECV_ERROR,\n    PULSE_WAIT_START_GAP,\n    PULSE_WAIT_DATA,\n};\n\nclass PulseBase {\n  protected:\n    DevicePin *pin;\n    DevicePin *inpin;\n    LowLevelTimer* timer;\n    BitVector encodedMsg;\n    uint16_t sendPtr;\n    int8_t pwmstate;\n    bool sending;\n    uint16_t id;\n    uint64_t startTime;\n    uint64_t sendStartTime;\n    uint64_t lastMarkTime;\n    uint64_t lastSendTime;\n\n    int16_t pulses[PULSE_MAX_PULSES + 1];\n    uint16_t pulsePtr;\n\n    PulseRecvState recvState;\n    Buffer outBuffer;\n\n    DbgBuffer dbg;\n\n  public:\n    PulseBase(uint16_t id, int pinOut, int pinIn, LowLevelTimer* t);\n    virtual void setupGapEvents();\n    virtual void listen();\n    virtual void setupPWM();\n    virtual void setPWM(int enabled);\n    virtual void finishPWM();\n    void send(Buffer d);\n    void finish(int code);\n    void addPulse(int v);\n    int adjustShift();\n    void pulseGap(Event ev);\n    int errorRate(int start, BitVector &bits);\n    void packetEnd(Event);\n    void pulseMark(Event ev);\n    Buffer getBuffer();\n    bool isReceiving();\n    void process();\n    void timerIRQ(uint16_t);\n};\n}\n#endif",
            "pxt.json": "{\n    \"name\": \"pulse\",\n    \"description\": \"Communication over pulses\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"pulse.cpp\",\n        \"pulse.h\",\n        \"bitvector.h\",\n        \"shims.d.ts\",\n        \"ns.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace network {\n\n    /**\n     * Send data over cable.\n     */\n    //% parts=\"cable\" shim=network::cableSendPacket\n    function cableSendPacket(buf: Buffer): void;\n\n    /**\n     * Get most recent packet received over cable.\n     */\n    //% parts=\"cable\" shim=network::cablePacket\n    function cablePacket(): Buffer;\n\n    /**\n     * Run action after a packet is recieved over cable.\n     */\n    //% parts=\"cable\" shim=network::onCablePacket\n    function onCablePacket(body: () => void): void;\n\n    /**\n     * Run action after there's an error reciving packet over cable.\n     */\n    //% shim=network::onCableError\n    function onCableError(body: () => void): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "cable": {
            "README.md": "# cable\n\nThe Cable library.\n\n",
            "cable.cpp": "#include \"pxt.h\"\n#include \"pulse.h\"\n#include \"SAMDTCTimer.h\"\n#include \"SAMDTCCTimer.h\"\n\nnamespace network {\n\nclass CableWrap : public PulseBase {\n  public:\n    virtual void setPWM(int enabled) {\n        pin->setDigitalValue(!enabled);\n        pwmstate = enabled;\n    }\n\n    virtual void setupPWM() { setPWM(1); }\n\n    virtual void finishPWM() { listen(); }\n\n    virtual void listen() {\n        inpin->setPull(codal::PullMode::Down);\n        inpin->getDigitalValue();\n        inpin->eventOn(DEVICE_PIN_EVENT_ON_PULSE);\n    }\n\n    CableWrap()\n        : PulseBase(PULSE_CABLE_COMPONENT_ID, PIN(TX), PIN(TX), new SAMDTCTimer(TC4, TC4_IRQn)) {\n        setupGapEvents();\n    }\n};\nSINGLETON(CableWrap);\n\n/**\n * Send data over cable.\n */\n//% parts=\"cable\"\nvoid cableSendPacket(Buffer buf) {\n    auto w = getCableWrap();\n    w->send(buf);\n}\n\n/**\n * Get most recent packet received over cable.\n */\n//% parts=\"cable\"\nBuffer cablePacket() {\n    auto w = getCableWrap();\n    return w->getBuffer();\n}\n\n/**\n * Run action after a packet is recieved over cable.\n */\n//% parts=\"cable\"\nvoid onCablePacket(Action body) {\n    getCableWrap(); // attach events\n    registerWithDal(PULSE_CABLE_COMPONENT_ID, PULSE_PACKET_EVENT, body);\n}\n\n/**\n * Run action after there's an error reciving packet over cable.\n */\n//%\nvoid onCableError(Action body) {\n    getCableWrap(); // attach events\n    registerWithDal(PULSE_CABLE_COMPONENT_ID, PULSE_PACKET_ERROR_EVENT, body);\n}\n\n} // namespace network\n",
            "cable.ts": "class CablePacket {\n    /**\n     * The first number in the payload.\n     */\n    public receivedNumber: number;\n    /**\n     * The array of numbers of received.\n     */\n    public receivedNumbers: number[];\n    /**\n     * The raw buffer of data received\n     */\n    public receivedBuffer: Buffer;\n}\n\nnamespace network {\n    /**\n     * Send a number over the cable.\n     * @param value number to send\n     */\n    //% blockId=\"cable_send_number\" block=\"cable send number %value\"\n    //% help=network/cable-send-number\n    //% parts=\"cable\" group=\"Cable\" weight=90\n    export function cableSendNumber(value: number) {\n        cableSendNumbers([value]);\n    }\n\n    /**\n     * Send an array of numbers over the cable. The array size has to be 32 bytes or less.\n     * @param values \n     */\n    //% parts=\"cable\" group=\"Cable\"\n    export function cableSendNumbers(values: number[]) {\n        let buf = msgpack.packNumberArray(values);\n        if (buf.length % 2) {\n            const buf2 = control.createBuffer(buf.length + 1);\n            buf2.write(0, buf);\n            buf2[buf2.length - 1] = 0xc1;\n            buf = buf2;\n        }\n        cableSendPacket(buf);\n    }\n\n    /**\n     * Run some code when a number value comes across the cable.\n     */\n    //% blockId=on_cable_received block=\"on cable received\" blockGap=8\n    //% help=network/on-cable-received-number\n    //% parts=\"cable\" group=\"Cable\"\n    export function onCableReceivedNumber(handler: (num: number) => void) {\n        onCablePacket(() => {\n            const buf: Buffer = cablePacket();\n            const nums: number[] = msgpack.unpackNumberArray(buf) || [];\n            const num = nums[0] || 0;\n            handler(num);\n        })\n    }\n\n    /**\n     * Run some code when the cable receives a list of numbers.\n     */\n    export function onCableReceivedNumbers(handler: (nums: number[]) => void) {\n        onCablePacket(() => {\n            const buf: Buffer = cablePacket();\n            const nums: number[] = msgpack.unpackNumberArray(buf) || [];\n            handler(nums);\n        })\n    }\n\n    /**\n     * Run some code when the cable receives data a buffer.\n     */\n    export function onCableReceivedBuffer(handler: (buf: Buffer) => void) {\n        onCablePacket(() => {\n            const buf: Buffer = cablePacket();\n            handler(buf);\n        })\n    }\n\n    /**\n     * Run some code when the cable receiver gets a packet.\n     */\n    //% mutate=objectdestructuring\n    //% mutateText=CablePacket\n    //% mutateDefaults=\"receivedNumber\"\n    //% blockId=cable_on_packet_received block=\"on cable received\" blockGap=8\n    //% parts=\"cable\" group=\"Cable\" blockHidden=1 deprecated=1\n    export function onCablePacketReceived(cb: (p: CablePacket) => void) {\n        onCablePacket(() => {\n            const buf: Buffer = cablePacket();\n            const nums: number[] = msgpack.unpackNumberArray(buf) || [];\n            const num = nums[0] || 0;\n\n            const packet = new CablePacket();\n            packet.receivedBuffer = buf;\n            packet.receivedNumbers = nums;\n            packet.receivedNumber = num;\n            cb(packet)\n        });\n    }\n}",
            "pxt.json": "{\n    \"name\": \"cable\",\n    \"description\": \"Communication over Wire\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"pulse\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"cable.cpp\",\n        \"cable.ts\",\n        \"shims.d.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"icon\": \"/docs/static/libs/cable.png\"\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace network {\n\n    /**\n     * Send data over cable.\n     */\n    //% parts=\"cable\" shim=network::cableSendPacket\n    function cableSendPacket(buf: Buffer): void;\n\n    /**\n     * Get most recent packet received over cable.\n     */\n    //% parts=\"cable\" shim=network::cablePacket\n    function cablePacket(): Buffer;\n\n    /**\n     * Run action after a packet is recieved over cable.\n     */\n    //% parts=\"cable\" shim=network::onCablePacket\n    function onCablePacket(body: () => void): void;\n\n    /**\n     * Run action after there's an error reciving packet over cable.\n     */\n    //% shim=network::onCableError\n    function onCableError(body: () => void): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "infrared": {
            "README.md": "# infrared\n\nThe Infra Red library.\n\n",
            "ir.cpp": "#include \"pxt.h\"\n#include \"pulse.h\"\n#include \"SAMDTCTimer.h\"\n#include \"SAMDTCCTimer.h\"\n\nnamespace network {\n\nclass IrWrap : public PulseBase {\n  public:\n    IrWrap()\n        : PulseBase(PULSE_IR_COMPONENT_ID, PIN(IR_OUT), PIN(IR_IN),\n                    new SAMDTCTimer(TC4, TC4_IRQn)) {\n        setupGapEvents();\n    }\n};\nSINGLETON(IrWrap);\n/**\n * Send data over IR.\n */\n//% parts=\"ir\"\nvoid infraredSendPacket(Buffer buf) {\n    auto w = getIrWrap();\n    w->send(buf);\n}\n\n/**\n * Get most recent packet received over IR.\n */\n//% parts=\"ir\"\nBuffer infraredPacket() {\n    auto w = getIrWrap();\n    return w->getBuffer();\n}\n\n/**\n * Run action after a packet is recieved over IR.\n */\n//% parts=\"ir\"\nvoid onInfraredPacket(Action body) {\n    getIrWrap(); // attach events\n    registerWithDal(PULSE_IR_COMPONENT_ID, PULSE_PACKET_EVENT, body);\n}\n\n/**\n * Run action after there's an error recieving packet over IR.\n */\n//%\nvoid onInfraredError(Action body) {\n    getIrWrap();\n    registerWithDal(PULSE_IR_COMPONENT_ID, PULSE_PACKET_ERROR_EVENT, body);\n}\n} // namespace network\n",
            "ir.ts": "class InfraredPacket {\n    /**\n     * The first number in the payload.\n     */\n    public receivedNumber: number;\n    /**\n     * The array of numbers of received.\n     */\n    public receivedNumbers: number[];\n    /**\n     * The raw buffer of data received\n     */\n    public receivedBuffer: Buffer;\n}\n\nnamespace network {\n    /**\n     * Send a number over the infrared transmitter.\n     * @param value number to send\n     */\n    //% blockId=\"ir_send_number\" block=\"infrared send number %value\"\n    //% help=network/infrared-send-number\n    //% parts=\"ir\" weight=90 group=\"Infrared\"\n    export function infraredSendNumber(value: number) {\n        infraredSendNumbers([value]);\n    }\n\n    /**\n     * Send an array of numbers over infrared. The array size has to be 32 bytes or less.\n     * @param values \n     */\n    //% parts=\"ir\" group=\"Infrared\"\n    export function infraredSendNumbers(values: number[]) {\n        let buf = msgpack.packNumberArray(values);\n        if (buf.length % 2) {\n            const buf2 = control.createBuffer(buf.length + 1);\n            buf2.write(0, buf);\n            buf2[buf2.length - 1] = 0xc1;\n            buf = buf2;\n        }\n        infraredSendPacket(buf);\n    }\n\n    /**\n     * Run some code when the infrared receiver gets a number.\n     */\n    //% blockId=ir_on_infrared_received block=\"on infrared received\" blockGap=8\n    //% help=network/on-infrared-received-number\n    //% parts=\"ir\" group=\"Infrared\"\n    export function onInfraredReceivedNumber(handler: (num: number) => void) {\n        onInfraredPacket(() => {\n            const buf: Buffer = infraredPacket();\n            const nums: number[] = msgpack.unpackNumberArray(buf) || [];\n            const num = nums[0] || 0;\n            handler(num);\n        });\n    }\n\n    /**\n     * Run some code when the infrared receiver gets a list of numbers.\n     */\n    export function onInfraredReceivedNumbers(handler: (nums: number[]) => void) {\n        onInfraredPacket(() => {\n            const buf: Buffer = infraredPacket();\n            const nums: number[] = msgpack.unpackNumberArray(buf) || [];\n            handler(nums);\n        });\n    }\n    \n    /**\n     * Run some code when the infrared receiver gets a buffer.\n     */\n    export function onInfraredReceivedBuffer(handler: (buf: Buffer) => void) {\n        onInfraredPacket(() => {\n            const buf: Buffer = infraredPacket();\n            handler(buf);\n        });\n    }\n    \n    /**\n     * Run some code when the infrared receiver gets a packet.\n     */\n    //% mutate=objectdestructuring\n    //% mutateText=InfraredPacket\n    //% mutateDefaults=\"receivedNumber\"\n    //% blockId=ir_on_packet_received block=\"on infrared received\" blockGap=8\n    //% parts=\"ir\" group=\"Infrared\" blockHidden=1 deprecated=1\n    export function onInfraredPacketReceived(cb: (p: InfraredPacket) => void) {\n        onInfraredPacket(() => {\n            const buf: Buffer = infraredPacket();\n            const nums: number[] = msgpack.unpackNumberArray(buf) || [];\n            const num = nums[0] || 0;\n\n            const packet = new InfraredPacket();\n            packet.receivedBuffer = buf;\n            packet.receivedNumbers = nums;\n            packet.receivedNumber = num;\n            cb(packet)\n        });\n    }\n}",
            "pxt.json": "{\n    \"name\": \"infrared\",\n    \"description\": \"Communication over Infra Red\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"pulse\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"ir.cpp\",\n        \"ir.ts\",\n        \"shims.d.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace network {\n\n    /**\n     * Send data over IR.\n     */\n    //% parts=\"ir\" shim=network::infraredSendPacket\n    function infraredSendPacket(buf: Buffer): void;\n\n    /**\n     * Get most recent packet received over IR.\n     */\n    //% parts=\"ir\" shim=network::infraredPacket\n    function infraredPacket(): Buffer;\n\n    /**\n     * Run action after a packet is recieved over IR.\n     */\n    //% parts=\"ir\" shim=network::onInfraredPacket\n    function onInfraredPacket(body: () => void): void;\n\n    /**\n     * Run action after there's an error recieving packet over IR.\n     */\n    //% shim=network::onInfraredError\n    function onInfraredError(body: () => void): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "circuit-playground": {
            "README.md": "# adafruit\n\nThe adafruit library.\n\n",
            "config.ts": "namespace config {\n    export const NUM_NEOPIXELS = 10;\n    export const DEFAULT_BUTTON_MODE = DAL.BUTTON_ACTIVE_HIGH_PULL_DOWN;\n\n    export const PIN_FLASH_MISO = DAL.PA16;\n    export const PIN_FLASH_MOSI = DAL.PA20;\n    export const PIN_FLASH_SCK = DAL.PA21;\n    export const PIN_FLASH_CS = DAL.PB22;\n    export const PIN_MIC_DATA = DAL.PA08;\n    export const PIN_MIC_CLOCK = DAL.PA10;\n    export const PIN_BTN_SLIDE = DAL.PA15;\n    export const PIN_NEOPIXEL = DAL.PB23;\n    export const PIN_SPEAKER_AMP = DAL.PA30;\n    export const PIN_MICROPHONE = DAL.PA08;\n    export const PIN_LIGHT = DAL.PA11;\n    export const ACCELEROMETER_TYPE = DAL.ACCELEROMETER_TYPE_LIS3DH;\n    export const PIN_ACCELEROMETER_SDA = DAL.PA00;\n    export const PIN_ACCELEROMETER_SCL = DAL.PA01;\n    export const PIN_ACCELEROMETER_INT = DAL.PA13;\n    export const PIN_TEMPERATURE = DAL.PA09;\n    export const PIN_IR_OUT = DAL.PA23;\n    export const PIN_IR_IN = DAL.PA12;\n    export const PIN_BTN_A = DAL.PA28;\n    export const PIN_BTN_B = DAL.PA14;\n\n    export const PIN_A0 = DAL.PA02;\n    export const PIN_A1 = DAL.PA05;\n    export const PIN_A2 = DAL.PA06;\n    export const PIN_A3 = DAL.PA07;\n    export const PIN_A4 = DAL.PB03;\n    export const PIN_A5 = DAL.PB02;\n    export const PIN_A6 = DAL.PB09;\n    export const PIN_A7 = DAL.PB08;\n    export const PIN_SCL = DAL.PB03;\n    export const PIN_SDA = DAL.PB02;\n    export const PIN_RX = DAL.PB09;\n    export const PIN_TX = DAL.PB08;\n    export const PIN_A8 = DAL.PA11;\n    export const PIN_A9 = DAL.PA09;\n    export const PIN_D4 = DAL.PA28;\n    export const PIN_D5 = DAL.PA14;\n    export const PIN_D7 = DAL.PA15;\n    export const PIN_D8 = DAL.PB23;\n    export const PIN_D13 = DAL.PA17;\n    export const PIN_LED = DAL.PA17;\n    export const PIN_A10 = DAL.PA08;\n}\n",
            "device.d.ts": "declare namespace pins {\n    // pin-pads\n    //% fixedInstance shim=pxt::getPin(PIN_A0)\n    const A0: AnalogOutPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A1)\n    const A1: PwmPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A2)\n    const A2: PwmPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A3)\n    const A3: AnalogInPin;\n\n    //% fixedInstance shim=pxt::getPin(PIN_A4)\n    const A4: AnalogInPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A5)\n    const A5: AnalogInPin;\n    \n    //% fixedInstance shim=pxt::getPin(PIN_A6)\n    const A6: AnalogInPin; // could be PwmPin when mbed fixed\n    //% fixedInstance shim=pxt::getPin(PIN_A7)\n    const A7: AnalogInPin; // could be PwmPin when mbed fixed\n\n    // Define aliases, as Digital Pins\n\n    //% fixedInstance shim=pxt::getPin(PIN_A4)\n    const SCL: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A5)\n    const SDA: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A6)\n    const RX: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPin(PIN_A7)\n    const TX: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPin(PIN_D13)\n    const LED: DigitalInOutPin;\n\n    //% fixedInstance shim=pxt::getPin(PIN_IR_OUT)\n    const IROut: DigitalInOutPin;\n    //% fixedInstance shim=pxt::getPin(PIN_IR_IN)\n    const IRIn: DigitalInOutPin;\n}\n\n\ndeclare namespace input {\n    /**\n     * Left button.\n     */\n    //% indexedInstanceNS=input indexedInstanceShim=pxt::getButton\n    //% block=\"button A\" weight=95 fixedInstance\n    //% shim=pxt::getButton(0)\n    const buttonA: Button;\n\n    /**\n     * Right button.\n     */\n    //% block=\"button B\" weight=94 fixedInstance\n    //% shim=pxt::getButton(1)\n    const buttonB: Button;\n\n    /**\n     * Left and Right button.\n     */\n    //% block=\"buttons A+B\" weight=93 fixedInstance\n    //% shim=pxt::getButton(2)\n    const buttonsAB: Button;\n}\n\ndeclare namespace input {\n    /**\n     * Capacitive pin A1\n     */\n    //% block=\"touch A1\" fixedInstance shim=pxt::getTouchButton(PIN_A1)\n    const touchA1: TouchButton;\n\n    /**\n     * Capacitive pin A2\n     */\n    //% block=\"touch A2\" fixedInstance shim=pxt::getTouchButton(PIN_A2)\n    const touchA2: TouchButton;\n\n    /**\n     * Capacitive pin A3\n     */\n    //% block=\"touch A3\" fixedInstance shim=pxt::getTouchButton(PIN_A3)\n    const touchA3: TouchButton;\n\n    /**\n     * Capacitive pin A4\n     */\n    //% block=\"touch A4\" fixedInstance shim=pxt::getTouchButton(PIN_A4)\n    const touchA4: TouchButton;\n\n    /**\n     * Capacitive pin A5\n     */\n    //% block=\"touch A5\" fixedInstance shim=pxt::getTouchButton(PIN_A5)\n    const touchA5: TouchButton;\n\n    /**\n     * Capacitive pin A6\n     */\n    //% block=\"touch A6\" fixedInstance shim=pxt::getTouchButton(PIN_A6)\n    const touchA6: TouchButton;\n\n    /**\n     * Capacitive pin A7\n     */\n    //% block=\"touch A7\" fixedInstance shim=pxt::getTouchButton(PIN_A7)\n    const touchA7: TouchButton;\n\n    /**\n     * Capacitive pin A1\n     */\n    //% block=\"pin A1\" fixedInstance shim=pxt::getTouchButton(PIN_A1)\n    const pinA1: TouchButton;\n\n    /**\n     * Capacitive pin A2\n     */\n    //% block=\"pin A2\" fixedInstance shim=pxt::getTouchButton(PIN_A2)\n    const pinA2: TouchButton;\n\n    /**\n     * Capacitive pin A3\n     */\n    //% block=\"pin A3\" fixedInstance shim=pxt::getTouchButton(PIN_A3)\n    const pinA3: TouchButton;\n\n    /**\n     * Capacitive pin A4\n     */\n    //% block=\"pin A4\" fixedInstance shim=pxt::getTouchButton(PIN_A4)\n    const pinA4: TouchButton;\n\n    /**\n     * Capacitive pin A5\n     */\n    //% block=\"pin A5\" fixedInstance shim=pxt::getTouchButton(PIN_A5)\n    const pinA5: TouchButton;\n\n    /**\n     * Capacitive pin A6\n     */\n    //% block=\"pin A6\" fixedInstance shim=pxt::getTouchButton(PIN_A6)\n    const pinA6: TouchButton;\n\n    /**\n     * Capacitive pin A7\n     */\n    //% block=\"pin A7\" fixedInstance shim=pxt::getTouchButton(PIN_A7)\n    const pinA7: TouchButton;\n}",
            "input.ts": "//% color=\"#B4009E\" weight=99 icon=\"\\uf192\"\nnamespace input {\n    /**\n     * Sense the ambient color using the LED pixel next to the LED sensor.\n     */\n    //% help=input/ambient-color\n    //% blockId=device_get_ambient_color block=\"ambient color\"\n    //% parts=\"rgbsensor\"\n    //% weight=29 blockGap=8\n    export function ambientColor(): number {\n        const LIGHT_SETTLE_MS = 100;\n        const PIXEL = 1;\n        // Save the current pixel color so it can later be restored.  Then bump\n        // the brightness to max to make sure the LED is as bright as possible for\n        // the color readings.\n        const strip: light.NeoPixelStrip = light.pixels;\n        const oldBrightness = strip.brightness();\n        const oldColor = strip.pixelColor(PIXEL);\n        const oldBuffered = strip.buffered();\n        strip.setBuffered(true);\n        strip.setBrightness(255);\n        // Set pixel 1 (next to the light sensor) to full red, green, blue\n        // color and grab a light sensor reading.  Make sure to wait a bit\n        // after changing pixel colors to let the light sensor change\n        // resistance!\n        strip.setPixelColor(PIXEL, Colors.Red);  // Red\n        strip.show();\n        pause(LIGHT_SETTLE_MS);\n        const red = input.lightLevel();\n\n        strip.setPixelColor(PIXEL, Colors.Green);  // Green\n        strip.show();\n        pause(LIGHT_SETTLE_MS);\n        const green = input.lightLevel();\n\n        strip.setPixelColor(PIXEL, Colors.Blue);  // Blue\n        strip.show();\n        pause(LIGHT_SETTLE_MS);\n        const blue = input.lightLevel();\n\n        // Turn off the pixel and restore brightness, we're done with readings.        \n        strip.setBrightness(oldBrightness);\n        strip.setPixelColor(PIXEL, oldColor);\n        strip.show();\n        strip.setBuffered(oldBuffered);\n\n        // find the closest known color to make it easier to handle the scanned color\n        let c = 0;\n        let mind = -1;\n        const colors = [\n            Colors.Red,\n            Colors.Green,\n            Colors.Blue,\n            Colors.Yellow,\n            Colors.White\n        ];\n        for(let i =0; i < colors.length; ++i) {\n            const kc = colors[i];\n            const dr = red - ((kc >> 16) & 0xFF);\n            const dg = green - ((kc >> 8) & 0xFF);\n            const db = blue - (kc & 0xff);\n            let d = (dr*dr) + (dg*dg) + (db*db);\n            if(mind < 0 || d < mind) {\n                mind = d;\n                c = kc;\n            }\n        }\n        return c;\n    }\n}",
            "ns.ts": "\n//% color=\"#d65cd6\"\nnamespace input {\n}\n\n//% color=\"#F55D3E\"\nnamespace music {\n\n}\n\n//% color=\"#1B998B\"\nnamespace control {\n\n}\n\n//% color=\"#EF2D56\"\nnamespace pins {\n\n}\n\n//% color=\"#006E90\"\nnamespace serial {\n\n}\n\n//% color=\"#006E90\"\nnamespace console {\n\n}\n\n//% color=\"#40bf4a\"\nnamespace loops {\n\n}\n\n//% color=\"#4c97ff\"\n//% groups='[\"other\", \"Color\", \"Photon\", \"More\"]'\nnamespace light {\n    /**\n     * Shows a pattern of colors on the pixel ring\n     * @param colors a string describing the colors, eg: \"red red red red red red red red red red\"\n     * @param interval the duration in milliseconds between frames, eg: 400\n     */\n    //% blockId=\"neopixel_show_ring_colors\" block=\"show ring |%colors\"\n    //% weight=100\n    //% help=\"light/show-ring\"\n    //% colors.fieldEditor=\"lights\"\n    //% colors.fieldOptions.onParentBlock=true\n    //% colors.fieldOptions.decompileLiterals=true\n    //% blockExternalInputs=\"true\" blockGap=8\n    export function showRing(colors: string, interval: number = 400) {\n        const strip = light.pixels;\n        return strip.showColors(colors, interval);\n    }\n}\n\n// Temporary fix for i2c https://github.com/lancaster-university/codal-samd/issues/13\npins.A0.digitalWrite(false);\n",
            "panic.cpp": "#include \"pxt.h\"\r\n#include \"neopixel.h\"\r\n\r\nstatic void showCode(int statusCode) {\r\n    auto neoPin = LOOKUP_PIN(NEOPIXEL);\r\n    if (!neoPin)\r\n        return;\r\n\r\n    int numNeopixels = getConfig(CFG_NUM_NEOPIXELS, 0);\r\n    if (numNeopixels <= 0)\r\n        return;\r\n    int size = numNeopixels * 3;\r\n    uint8_t neobuf[size];\r\n    memset(neobuf, 0, size);\r\n\r\n    for (int i = 0; i < 10; ++i) {\r\n        if (i < numNeopixels)\r\n            memcpy(&neobuf[i * 3], (statusCode & (1 << i)) ? \"\\x00\\x04\\x00\" : \"\\x00\\x00\\x01\",\r\n                   3);\r\n    }\r\n\r\n    neoPin->setDigitalValue(0);\r\n    target_wait(1);\r\n\r\n    neopixel_send_buffer(*neoPin, neobuf, size);\r\n    target_disable_irq();\r\n}\r\n\r\n__attribute__((weak)) void target_panic(int statusCode) {\r\n    target_disable_irq();\r\n    DMESG(\"*** CODAL PANIC : [%d]\", statusCode);\r\n    showCode(statusCode);\r\n\r\n#if DEVICE_DMESG_BUFFER_SIZE > 0\r\n    auto ledPin = LOOKUP_PIN(LED);\r\n    while (1) {\r\n        if (ledPin) {\r\n            ledPin->setDigitalValue(1);\r\n            target_wait(50);\r\n            ledPin->setDigitalValue(0);\r\n            target_wait(300);\r\n        }\r\n    }\r\n#else\r\n    Serial pc(USBTX, USBRX);\r\n    while (1) {\r\n        pc.printf(\"*** CODAL PANIC : [%.3d]\\n\", statusCode);\r\n        wait_ms(500);\r\n    }\r\n#endif\r\n}\r\n",
            "pxt.json": "{\n    \"name\": \"circuit-playground\",\n    \"description\": \"The Adafruit Circuit Playground Express library\",\n    \"dependencies\": {\n        \"base\": \"*\",\n        \"core---samd\": \"*\",\n        \"jc\": \"*\",\n        \"jcevent\": \"*\",\n        \"jcstubborn\": \"*\",\n        \"buttons\": \"*\",\n        \"accelerometer\": \"*\",\n        \"lightsensor\": \"*\",\n        \"thermometer\": \"*\",\n        \"mixer---samd\": \"*\",\n        \"color\": \"*\",\n        \"light\": \"*\",\n        \"switch\": \"*\",\n        \"pulse\": \"*\",\n        \"infrared\": \"*\",\n        \"microphone\": \"*\",\n        \"touch\": \"*\",\n        \"gamepad\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"panic.cpp\",\n        \"device.d.ts\",\n        \"config.ts\",\n        \"input.ts\",\n        \"ns.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"dalDTS\": {\n        \"corePackage\": \"../core---samd\"\n    },\n    \"yotta\": {\n        \"config\": {\n            \"HF2_HID\": 1,\n            \"DEVICE_USB\": 1,\n            \"PXT_SUPPORT_LIS3DH\": 1\n        }\n    }\n}\n"
        },
        "mouse": {
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum MouseButton {\n    //% block=\"left\" enumval=1\n    Left = 0x01,\n    //% block=\"right\" enumval=2\n    Right = 0x02,\n    //% block=\"middle\" enumval=4\n    Middle = 0x04,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "mouse.cpp": "// https://github.com/lancaster-university/codal-core/blob/master/source/drivers/HIDMouse.cpp\n\n#include \"pxt.h\"\n\nenum class MouseButton {\n    //% block=\"left\" enumval=1\n    Left = 0x01,\n    //% block=\"right\" enumval=2\n    Right = 0x02,\n    //% block=\"middle\" enumval=4\n    Middle = 0x04\n};\n\nnamespace mouse {\n    /** \n    * Set the mouse button state to up or down\n    */\n    //% help=mouse/set-button\n    //% blockId=mouseSetButton block=\"mouse button %index|%down=toggleDownUp\"\n    void setButton(MouseButton button, bool down) {\n        if (down)\n            pxt::mouse.buttonDown((codal::USBHIDMouseButton)button);\n        else\n            pxt::mouse.buttonUp((codal::USBHIDMouseButton)button);\n    }\n\n    /**\n    * Move the mouse in the X and Y direction\n    **/\n    //% help=mouse/move\n    //% blockId=mouseMove block=\"mouse move x %x|y %y\"\n    //% x.min=-128 x.max=127\n    //% y.min=-128 y.max=127\n    void move(int x, int y) {\n        pxt::mouse.move(x, y);\n    }\n\n    /**\n    * Turn the mouse wheel\n    **/\n    //% help=mouse/turn-wheel\n    //% blockId=mouseWheel block=\"mouse turn wheel %w\"\n    //% w.min=-128 w.max=127\n    void turnWheel(int w) {\n        pxt::mouse.moveWheel(w);\n    }\n}",
            "mouse.ts": "/**\n * Mouse emulation\n */\n//% icon=\"\\uf245\" color=\"#303030\"\nnamespace mouse {\n    /**\n     * Generates a mouse click\n     * @param button the button to click\n     */\n    //% help=mouse/click\n    //% blockId=mouseClick block=\"mouse click button $button\"\n    //% weight=100\n    export function click(button: MouseButton): void {\n        mouse.setButton(button, true)\n        mouse.setButton(button, false)\n    }\n}",
            "pxt.json": "{\n    \"name\": \"mouse\",\n    \"description\": \"Mouse emulation over HID\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"mouse.cpp\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"mouse.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"tests\": [\n        \"test.ts\"\n    ],\n    \"yotta\": {\n        \"config\": {\n            \"DEVICE_USB\": 1,\n            \"DEVICE_MOUSE\": 1\n        }\n    },\n    \"icon\": \"/docs/static/libs/mouse.png\"\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace mouse {\n\n    /** \n     * Set the mouse button state to up or down\n     */\n    //% help=mouse/set-button\n    //% blockId=mouseSetButton block=\"mouse button %index|%down=toggleDownUp\" shim=mouse::setButton\n    function setButton(button: MouseButton, down: boolean): void;\n\n    /**\n     * Move the mouse in the X and Y direction\n     **/\n    //% help=mouse/move\n    //% blockId=mouseMove block=\"mouse move x %x|y %y\"\n    //% x.min=-128 x.max=127\n    //% y.min=-128 y.max=127 shim=mouse::move\n    function move(x: int32, y: int32): void;\n\n    /**\n     * Turn the mouse wheel\n     **/\n    //% help=mouse/turn-wheel\n    //% blockId=mouseWheel block=\"mouse turn wheel %w\"\n    //% w.min=-128 w.max=127 shim=mouse::turnWheel\n    function turnWheel(w: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "keyboard": {
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum KeyboardKeyEvent {\n    //% block=\"press\"\n    Press = 0,\n    //% block=\"up\"\n    Up = 1,\n    //% block=\"down\"\n    Down = 2,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "keyboard.cpp": "// https://github.com/lancaster-university/codal-core/blob/master/source/drivers/HIDKeyboard.cpp\n\n#include \"pxt.h\"\n#include \"USB_HID_Keys.h\"\n\nenum class KeyboardKeyEvent {\n    //% block=\"press\"\n    Press,\n    //% block=\"up\"\n    Up,\n    //% block=\"down\"\n    Down\n};\n\nnamespace keyboard {\n    //%\n    void __flush() {\n        pxt::keyboard.flush();\n    }\n\n    //% \n    void __type(String text) {\n        if (NULL != text)\n            pxt::keyboard.type(text->getUTF8Data(), text->getUTF8Size());\n    }\n\n    //%\n    void __key(uint16_t ckey, KeyboardKeyEvent event) {\n       switch(event) {\n            case KeyboardKeyEvent::Down:\n                pxt::keyboard.keyDown(ckey);\n                break;\n            case KeyboardKeyEvent::Up:\n                pxt::keyboard.keyUp(ckey);\n                break;\n            case KeyboardKeyEvent::Press:\n                pxt::keyboard.press(ckey);\n                break;\n        }\n    }\n\n    //%\n    void __mediaKey(uint16_t key, KeyboardKeyEvent event) {\n        codal::MediaKey ckey = (codal::MediaKey)((int)codal::MediaKey::Mute + (int)key);\n        switch(event) {\n            case KeyboardKeyEvent::Down:\n                pxt::keyboard.keyDown(ckey);\n                break;\n            case KeyboardKeyEvent::Up:\n                pxt::keyboard.keyUp(ckey);\n                break;\n            case KeyboardKeyEvent::Press:\n                pxt::keyboard.press(ckey);\n                break;\n        }\n    }\n\n    //%\n    void __functionKey(uint16_t key, KeyboardKeyEvent event) {\n        codal::FunctionKey ckey = (codal::FunctionKey)key;\n        switch(event) {\n            case KeyboardKeyEvent::Down:\n                pxt::keyboard.keyDown(ckey);\n                break;\n            case KeyboardKeyEvent::Up:\n                pxt::keyboard.keyUp(ckey);\n                break;\n            case KeyboardKeyEvent::Press:\n                pxt::keyboard.press(ckey);\n                break;\n        }\n    }\n\n    //%\n    void __modifierKey(uint16_t modifier, KeyboardKeyEvent event) {\n       const Key key = { .reg = KEYMAP_KEY_DOWN | KEYMAP_MODIFIER_KEY | (uint8_t)modifier };\n        // send keys\n        switch(event) {\n            case KeyboardKeyEvent::Down:\n                pxt::keyboard.keyDown(key);\n                break;\n            case KeyboardKeyEvent::Up:\n                pxt::keyboard.keyUp(key);\n                break;\n            case KeyboardKeyEvent::Press:\n                pxt::keyboard.press(key);\n                break;\n        };\n    }\n}",
            "keyboard.ts": "\nconst enum KeyboardMediaKey\n{\n    //% block=\"mute\"\n    Mute,\n    //% block=\"volume up\"\n    VolumeUp,\n    //% block=\"volume down\"\n    VolumeDown,\n    //% block=\"play pause\"\n    PlayPause,\n    //% block=\"stop\"\n    Stop,\n    //% block=\"previous track\"\n    PreviousTrack,\n    //% block=\"next track\"\n    NextTrack,\n    //% block=\"mail\"\n    Mail,\n    //% block=\"calculator\"\n    Calculator,\n    //% block=\"web search\"\n    WebSearch,\n    //% block=\"web home\"\n    WebHome,\n    //% block=\"web favourites\"\n    WebFavourites,\n    //% block=\"web refresh\"\n    WebRefresh,\n    //% block=\"web stop\"\n    WebStop,\n    //% block=\"web forward\"\n    WebForward,\n    //% block=\"web back\"\n    WebBack\n}\n\nconst enum KeyboardFunctionKey\n{\n    //% block=\"F1\"\n    F1Key = DAL.KEY_F1,  \n    //% block=\"F2\"\n    F2Key = DAL.KEY_F2,\n    //% block=\"F3\"\n    F3Key = DAL.KEY_F3,\n    //% block=\"F4\"\n    F4Key = DAL.KEY_F4, \n    //% block=\"F5\"\n    F5Key = DAL.KEY_F5,\n    //% block=\"F6\"\n    F6Key = DAL.KEY_F6,\n    //% block=\"F7\"\n    F7Key = DAL.KEY_F7,\n    //% block=\"F8\"\n    F8Key = DAL.KEY_F8,\n    //% block=\"F9\"\n    F9Key = DAL.KEY_F9,\n    //% block=\"F0\"\n    F10Key = DAL.KEY_F10,\n    //% block=\"F11\"\n    F11Key = DAL.KEY_F11,\n    //% block=\"F12\"\n    F12Key = DAL.KEY_F12,\n    //% block=\"F13\"\n    F13Key = DAL.KEY_F13,\n    //% block=\"F14\"\n    F14Key = DAL.KEY_F14,\n    //% block=\"F15\"\n    F15Key = DAL.KEY_F15,\n    //% block=\"F16\"\n    F16Key = DAL.KEY_F16,\n    //% block=\"F17\"\n    F17Key = DAL.KEY_F17,\n    //% block=\"F18\"\n    F18Key = DAL.KEY_F18,\n    //% block=\"F19\"\n    F19Key = DAL.KEY_F19,\n    //% block=\"F20\"\n    F20Key = DAL.KEY_F20,\n    //% block=\"F21\"\n    F21Key = DAL.KEY_F21,\n    //% block=\"F22\"\n    F22Key = DAL.KEY_F22,\n    //% block=\"F23\"\n    F23Key = DAL.KEY_F23,\n    //% block=\"F24\"\n    F24Key = DAL.KEY_F24,\n\n\n    //% block=\"print screen\"\n    PrintScreen = DAL.KEY_SYSRQ,\n    //% block=\"scroll lock\"\n    ScrollLock = DAL.KEY_SCROLLLOCK,\n    //% block=\"pause\"\n    Pause = DAL.KEY_PAUSE,\n    //% block=\"insert\"\n    Insert = DAL.KEY_INSERT,\n    //% block=\"home\"\n    Home = DAL.KEY_HOME,\n    //% block=\"page up\"\n    PageUp = DAL.KEY_PAGEUP,\n    //% block=\"delete\"\n    DeleteForward = DAL.KEY_DELETE,\n    //% block=\"end\"\n    End = DAL.KEY_END,\n    //% block=\"page down\"\n    PageDown = DAL.KEY_PAGEDOWN,\n\n    //% block=\"right arrow\"\n    RightArrow = DAL.KEY_RIGHT,\n    //% block=\"left arrow\"\n    LeftArrow = DAL.KEY_LEFT,\n    //% block=\"down arrow\"\n    DownArrow = DAL.KEY_DOWN,\n    //% block=\"up arrow\"\n    UpArrow = DAL.KEY_UP\n}\n\nconst enum KeyboardModifierKey {\n    //% block=\"Ctrl\"\n    Control = DAL.KEY_MOD_LCTRL,\n    //% block=\"Shift\"\n    Shift = DAL.KEY_MOD_LSHIFT,\n    //% block=\"Alt\"\n    Alt = DAL.KEY_MOD_LALT,\n    //% block=\"Command\"\n    Meta = DAL.KEY_MOD_LMETA,\n    //% block=\"Ctrl+Shift\"\n    ControlShift = Control | Shift,\n    //% block=\"Ctrl+Alt\"\n    ControlAlt = Control | Alt,\n    //% block=\"Shift+Alt\"\n    ShiftAlt = Shift | Alt,\n    //% block=\"Ctrl+Cmd\"\n    ControlCommand = Control | Meta,\n    //% block=\"Ctrl+Cmd\"\n    ShiftCommand = Shift | Meta,\n    //% block=\"Alt+Cmd\"\n    AltCommand = Alt | Meta,\n    //% block=\"Ctrl+Shift+Alt\"\n    ControlShiftAlt = Control | Shift | Alt,\n    //% block=\"Ctrl+Cmd+Shift+Alt\"\n    ControlCommandShiftAlt = Control | Meta | Shift | Alt,\n    //% block=\"Right Ctrl\"\n    RightControl = DAL.KEY_MOD_RCTRL,\n    //% block=\"Right Shift\"\n    RightShift = DAL.KEY_MOD_RSHIFT,\n    //% block=\"Right Alt\"\n    RightAlt = DAL.KEY_MOD_RALT,\n    //% block=\"Right Command\"\n    RightMeta = DAL.KEY_MOD_RMETA\n}\n\n/**\n * Keyboard emulation\n */\n//% icon=\"\\uf11c\" color=\"#303030\"\nnamespace keyboard {\n    /**\n    * Send a sequence of keystrokes to the keyboard\n    */\n    //% blockId=keyboardType block=\"keyboard type $text||with $modifiers\"\n    //% blockGap=8 weight=100\n    //% text.shadowOptions.toString=true\n    //% help=keyboard/type\n    //% weight=100\n    export function type(text: string, modifiers?: KeyboardModifierKey) {\n        if (modifiers)\n            __modifierKey(modifiers, KeyboardKeyEvent.Down);\n        __type(text);\n        __flush();\n    }\n\n    /**\n    * Send a key command\n    */\n    //% blockId=keyboardStandardKey block=\"keyboard key %key|%event\"\n    //% blockGap=8 weight=99\n    //% help=keyboard/key\n    export function key(key: string, event: KeyboardKeyEvent) {\n        if (!key) return;\n        const c = key.charCodeAt(0);\n        __key(c, event);\n    }\n\n    /**\n    * Send a media key command\n    */\n    //% blockId=keyboardMediaKey block=\"keyboard media %key|%event\"\n    //% blockGap=8\n    //% help=keyboard/media-key\n    export function mediaKey(key: KeyboardMediaKey, event: KeyboardKeyEvent) {\n        __mediaKey(key, event);\n    }\n\n    /**\n    * Send a function key command\n    */\n    //% blockId=keyboardFunctionKey block=\"keyboard function %key|%event\"\n    //% blockGap=8\n    //% help=keyboard/function-key\n    export function functionKey(key: KeyboardFunctionKey, event: KeyboardKeyEvent) {\n        __functionKey(key, event)\n    }\n\n    /**\n    * Send a modifier key command\n    */\n    //% blockId=keyboardModiferKey block=\"keyboard modifier %key|%event\"\n    //% blockGap=8\n    //% help=keyboard/modifier-key\n    export function modifierKey(key: KeyboardModifierKey, event: KeyboardKeyEvent) {\n        __modifierKey(key, event)\n    }\n\n    /**\n     * Send up commands for any remaning down keys\n     */\n    //% blockId=keyboardClear block=\"keyboard clear all\"\n    //% blockGap=8\n    //% help=keyboard/clear-all-keys\n    //% weight=10\n    export function clearAllKeys() {\n        __flush()\n    }\n}",
            "pxt.json": "{\n    \"name\": \"keyboard\",\n    \"description\": \"Keyboard emulation over HID\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"keyboard.cpp\",\n        \"shims.d.ts\",\n        \"enums.d.ts\",\n        \"keyboard.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"tests\": [\n        \"test.ts\"\n    ],\n    \"yotta\": {\n        \"config\": {\n            \"DEVICE_USB\": 1,\n            \"DEVICE_KEYBOARD\": 1\n        }\n    },\n    \"icon\": \"/docs/static/libs/keyboard.png\"\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace keyboard {\n    //% shim=keyboard::__flush hidden=1\n    function __flush(): void;\n\n    //% shim=keyboard::__type hidden=1\n    function __type(text: string): void;\n\n    //% shim=keyboard::__key hidden=1\n    function __key(ckey: number, event: KeyboardKeyEvent): void;\n\n    //% shim=keyboard::__mediaKey hidden=1\n    function __mediaKey(key: uint16, event: KeyboardKeyEvent): void;\n\n    //% shim=keyboard::__functionKey hidden=1\n    function __functionKey(key: uint16, event: KeyboardKeyEvent): void;\n\n    //% shim=keyboard::__modifierKey hidden=1\n    function __modifierKey(modifier: uint16, event: KeyboardKeyEvent): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "gamepad": {
            "gamepad.cpp": "// https://github.com/lancaster-university/codal-core/blob/master/inc/drivers/HIDJoystick.h\r\n\r\n\r\n\r\n#include \"pxt.h\"\r\nnamespace gamepad {\r\n    /** \r\n    * Set the button state to down\r\n    */\r\n    //% help=gamepad/set-button\r\n    //% blockId=joystickSetButton block=\"gamepad button %index=joystickStandardButton|\"\r\n    //% weight=100\r\n    void setButton(int index) {\r\n        if (true)\r\n            pxt::joystick.buttonDown(index);\r\n        else\r\n            pxt::joystick.buttonUp(index);\r\n    }\r\n\r\n    /**\r\n    * Set the current move on the gamepad\r\n    **/\r\n    //% blockId=gamepadMove block=\"gamepad %index|move by x %x|y %y\"\r\n    //% help=gamepad/move\r\n    //% index.min=0 index.max=1\r\n    //% blockGap=8\r\n    void move(int index, int x, int y) {\r\n        pxt::joystick.move(index, x, y);        \r\n    }\r\n\r\n    /** \r\n    * Set the throttle state\r\n    */\r\n    //% blockId=gamepadSetThrottle block=\"gamepad set throttle %index|to %value\"\r\n    //% gamepad/set-throttle blockHidden=1\r\n    //% index.min=0 index.max=1\r\n    //% value.min=0 value.max=31\r\n    //%help=gamepad/set-throttle\r\n    void setThrottle(int index, int value) {\r\n        value = max(0, min(31, value));\r\n        pxt::joystick.setThrottle(index, value);\r\n    }\r\n}",
            "gamepad.ts": "enum GamepadButton {\n    //% blockIdentity=gamepad.button enumval=0\n    B = 0,\n    //% blockIdentity=gamepad.button enumval=1\n    A = 1,\n    //% blockIdentity=gamepad.button enumval=2\n    Y = 2,\n    //% blockIdentity=gamepad.button enumval=3\n    X = 3,\n    //% block=\"left bumper\"\n    //% blockIdentity=gamepad.button enumval=4\n    LeftBumper = 4,\n    //% block=\"right bumper\"\n    //% blockIdentity=gamepad.button enumval=5\n    RightBumper = 5,\n    //% block=\"left trigger\"\n    //% blockIdentity=gamepad.button enumval=6\n    LeftTrigger = 6,\n    //% block=\"right trigger\"\n    //% blockIdentity=gamepad.button enumval=7\n    RightTrigger = 7,\n    //% block=\"select\"\n    //% blockIdentity=gamepad.button enumval=8\n    Select = 8,\n    //% block=\"start\"\n    //% blockIdentity=gamepad.button enumval=9\n    Start = 9,\n    //% block=\"left stick\"\n    //% blockIdentity=gamepad.button enumval=10\n    LeftStick = 10,\n    //% block=\"right stick\"\n    //% blockIdentity=gamepad.button enumval=11\n    RightStick = 11,\n    //% block=\"up\"\n    //% blockIdentity=gamepad.button enumval=12\n    Up = 12,\n    //% block=\"down\"\n    //% blockIdentity=gamepad.button enumval=13\n    Down = 13,\n    //% block=\"left\"\n    //% blockIdentity=gamepad.button enumval=14\n    Left = 14,\n    //% block=\"right\"\n    //% blockIdentity=gamepad.button enumval=15\n    Right = 15\n}\n\n//% icon=\"\\uf11b\" color=\"#303030\"\nnamespace gamepad {\n    /**\n     * Maps to a standard layout button to the button index\n     * @param button the name of the button\n     */\n    //% blockId=joystickStandardButton block=\"%button\"\n    //% shim=TD_ID blockHidden=1\n    export function button(button: GamepadButton): number {\n        return button;\n    }\n}",
            "pxt.json": "{\n    \"name\": \"gamepad\",\n    \"description\": \"Gamepad controller over HID\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"gamepad.cpp\",\n        \"shims.d.ts\",\n        \"gamepad.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"tests\": [\n        \"test.ts\"\n    ],\n    \"yotta\": {\n        \"config\": {\n            \"DEVICE_USB\": 1,\n            \"DEVICE_JOYSTICK\": 1\n        }\n    },\n    \"icon\": \"/docs/static/libs/gamepad.png\"\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace gamepad {\n\n    /** \n     * Set the button state to down\n     */\n    //% help=gamepad/set-button\n    //% blockId=joystickSetButton block=\"gamepad button %index=joystickStandardButton|\"\n    //% weight=100 shim=gamepad::setButton\n    function setButton(index: int32): void;\n\n    /**\n     * Set the current move on the gamepad\n     **/\n    //% blockId=gamepadMove block=\"gamepad %index|move by x %x|y %y\"\n    //% help=gamepad/move\n    //% index.min=0 index.max=1\n    //% blockGap=8 shim=gamepad::move\n    function move(index: int32, x: int32, y: int32): void;\n\n    /** \n     * Set the throttle state\n     */\n    //% blockId=gamepadSetThrottle block=\"gamepad set throttle %index|to %value\"\n    //% gamepad/set-throttle blockHidden=1\n    //% index.min=0 index.max=1\n    //% value.min=0 value.max=31\n    //%help=gamepad/set-throttle shim=gamepad::setThrottle\n    function setThrottle(index: int32, value: int32): void;\n}\n\n// Auto-generated. Do not edit. Really.\n"
        },
        "servo": {
            "README.md": "# Servo\n\nA small micro-servo library.",
            "ns.ts": "/**\n * Control micro servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\"\nnamespace servos {\n}",
            "pxt.json": "{\n    \"name\": \"servo\",\n    \"description\": \"A micro-servo library\",\n    \"dependencies\": {\n        \"circuit-playground\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"servo.ts\",\n        \"ns.ts\",\n        \"targetoverrides.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"icon\": \"/docs/static/libs/servo.png\"\n}\n",
            "servo.ts": "/**\n * Control micro servos\n */\n//% color=\"#03AA74\" weight=88 icon=\"\\uf021\" blockGap=8\n//% groups='[\"Positional\", \"Continuous\", \"Configuration\"]'\nnamespace servos {\n    //% fixedInstances\n    export class Servo {\n        private _minAngle: number;\n        private _maxAngle: number;\n        private _stopOnNeutral: boolean;\n        private _angle: number;\n\n        constructor() {\n            this._angle = undefined;\n            this._minAngle = 0;\n            this._maxAngle = 180;\n            this._stopOnNeutral = false;\n        }\n\n        private clampDegrees(degrees: number): number {\n            degrees = degrees | 0;\n            degrees = Math.clamp(this._minAngle, this._maxAngle, degrees);\n            return degrees;\n        }\n\n        /**\n         * Set the servo angle\n         */\n        //% weight=100 help=servos/set-angle\n        //% blockId=servoservosetangle block=\"set %servo angle to %degrees=protractorPicker \"\n        //% degrees.defl=90\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% blockGap=8\n        //% parts=microservo trackArgs=0\n        //% group=\"Positional\"\n        setAngle(degrees: number) {\n            degrees = this.clampDegrees(degrees);\n            this.internalSetContinuous(false);\n            this._angle = this.internalSetAngle(degrees);\n        }\n\n        get angle() {\n            return this._angle || 90;\n        }\n\n        protected internalSetContinuous(continuous: boolean): void {\n\n        }\n\n        protected internalSetAngle(angle: number): number {\n            return 0;\n        }\n\n        /**\n         * Set the throttle on a continuous servo\n         * @param speed the throttle of the motor from -100% to 100%\n         */\n        //% weight=99 help=servos/run\n        //% blockId=servoservorun block=\"continuous %servo run at %speed=speedPicker \\\\%\"\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% parts=microservo trackArgs=0\n        //% group=\"Continuous\"\n        //% blockGap=8\n        run(speed: number): void {\n            const degrees = this.clampDegrees(Math.map(speed, -100, 100, this._minAngle, this._maxAngle));\n            const neutral = (this.maxAngle - this.minAngle) >> 1;\n            this.internalSetContinuous(true);\n            if (this._stopOnNeutral && degrees == neutral)\n                this.stop();\n            else\n                this._angle = this.internalSetAngle(degrees);\n        }\n\n        /**\n         * Set the pulse width to the servo in microseconds\n         * @param micros the width of the pulse in microseconds\n         */\n\n        //% weight=10 help=servos/set-pulse\n        //% blockId=servoservosetpulse block=\"set %servo pulse to %micros s\"\n        //% micros.min=500 micros.max=2500\n        //% micros.defl=1500\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% parts=microservo trackArgs=0\n        //% group=\"Configuration\"\n        //% blockGap=8\n        setPulse(micros: number) {\n            micros = micros | 0;\n            micros = Math.clamp(500, 2500, micros);\n            this.internalSetPulse(micros);\n        }\n\n        protected internalSetPulse(micros: number): void {\n\n        }\n\n        /**\n         * Stop sending commands to the servo so that its rotation will stop at the current position.\n         */\n        // On a normal servo this will stop the servo where it is, rather than return it to neutral position.\n        // It will also not provide any holding force.\n        //% weight=10 help=servos/stop\n        //% blockId=servoservostop block=\"stop %servo\"\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% parts=microservo trackArgs=0\n        //% group=\"Continuous\"\n        //% blockGap=8\n        stop() {\n            if (this._angle !== undefined)\n                this.internalStop();\n        }\n\n        /**\n         * Gets the minimum angle for the servo\n         */\n        public get minAngle() {\n            return this._minAngle;\n        }\n\n        /**\n         * Gets the maximum angle for the servo\n         */\n        public get maxAngle() {\n            return this._maxAngle;\n        }\n\n        /**\n         * Set the possible rotation range angles for the servo between 0 and 180\n         * @param minAngle the minimum angle from 0 to 90\n         * @param maxAngle the maximum angle from 90 to 180\n         */\n        //% help=servos/set-range\n        //% blockId=servosetrange block=\"set %servo range from %minAngle to %maxAngle\"\n        //% minAngle.min=0 minAngle.max=90\n        //% maxAngle.min=90 maxAngle.max=180 maxAngle.defl=180\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        //% parts=microservo trackArgs=0\n        //% group=\"Configuration\"\n        //% blockGap=8\n        public setRange(minAngle: number, maxAngle: number) {\n            this._minAngle = Math.max(0, Math.min(90, minAngle | 0));\n            this._maxAngle = Math.max(90, Math.min(180, maxAngle | 0));\n        }\n\n        /**\n         * Set a servo stop mode so it will stop when the rotation angle is in the neutral position, 90 degrees.\n         * @param on true to enable this mode\n         */\n        //% help=servos/set-stop-on-neutral\n        //% blockId=servostoponneutral block=\"set %servo stop on neutral %enabled\"\n        //% enabled.shadow=toggleOnOff\n        //% group=\"Configuration\"\n        //% blockGap=8\n        //% servo.fieldEditor=\"gridpicker\"\n        //% servo.fieldOptions.width=220\n        //% servo.fieldOptions.columns=2\n        public setStopOnNeutral(enabled: boolean) {\n            this._stopOnNeutral = enabled;\n        }\n\n        protected internalStop() { }\n    }\n\n    export class PinServo extends Servo {\n        private _pin: PwmOnlyPin;\n\n        constructor(pin: PwmOnlyPin) {\n            super();\n            this._pin = pin;\n        }\n\n        protected internalSetAngle(angle: number): number {\n            this._pin.servoWrite(angle);\n            return angle;\n        }\n\n        protected internalSetContinuous(continuous: boolean): void {\n            this._pin.servoSetContinuous(continuous);\n        }\n\n        protected internalSetPulse(micros: number): void {\n            this._pin.servoSetPulse(micros);\n        }\n\n        protected internalStop() {\n            this._pin.digitalRead();\n            this._pin.setPull(PinPullMode.PullNone);\n        }\n    }\n}\n",
            "targetoverrides.ts": "namespace servos {\n    //% block=\"servo A1\" fixedInstance\n    export const A1 = new servos.PinServo(pins.A1);\n    //% block=\"servo A2\" fixedInstance\n    export const A2 = new servos.PinServo(pins.A2);\n}"
        },
        "storage": {
            "GhostSNORFS.cpp": "#include \"GhostSNORFS.h\"\n\n#include \"CodalCompat.h\"\n#include \"CodalDmesg.h\"\n#include \"CodalDevice.h\"\n\n#define LOG DMESG\n\nusing namespace codal::snorfs;\n\nnamespace codal {\n\n\nGhostSNORFS::GhostSNORFS(FS &fs) : fs(fs)\n{\n    currFile = NULL;\n    currEntry = NULL;\n}\n\nvoid GhostSNORFS::readFlash(GFATEntry *ent, unsigned blockAddr, char *dst)\n{\n    auto th = (GhostSNORFS*)ent->userdata;\n    th->fs.readFlashBytes(blockAddr * 512, dst, 512);\n}\n\nvoid GhostSNORFS::readFile(GFATEntry *ent, unsigned blockAddr, char *dst)\n{\n    auto th = (GhostSNORFS*)ent->userdata;\n\n    if (th->currEntry != ent)\n    {\n        th->currEntry = ent;\n        if (th->currFile)\n            delete th->currFile;\n        th->currFile = th->fs.open(ent->filename);\n    }\n\n    th->currFile->seek(blockAddr * 512);\n    th->currFile->read(dst, 512);\n}\n\n\nvoid GhostSNORFS::addFiles()\n{\n    // reading SPI directory can take some time, so we delay USB start\n    CodalUSB::usbInstance->delayStart();\n\n    GhostFAT::addFiles();\n\n    addFile(readFlash, this, \"spiflash.bin\", fs.rawSize());\n    addDirectory(20, \"SPIFLASH\");\n\n    fs.dirRewind();\n    auto d = fs.dirRead();\n    while (d)\n    {\n        addFile(readFile, this, d->name, d->size, 20);\n        d = fs.dirRead();\n    }\n\n    CodalUSB::usbInstance->start();\n}\n\n}\n",
            "GhostSNORFS.h": "#ifndef DEVICE_GHOSTSNORFS_H\n#define DEVICE_GHOSTSNORFS_H\n\n#include \"GhostFAT.h\"\n#include \"SNORFS.h\"\n\nnamespace codal\n{\n    \nclass GhostSNORFS : public GhostFAT\n{\nprotected:\n    snorfs::FS &fs;\n    snorfs::File *currFile;\n    GFATEntry *currEntry;\n\n    static void readFlash(GFATEntry *ent, unsigned blockAddr, char *dst);\n    static void readFile(GFATEntry *ent, unsigned blockAddr, char *dst);\n\npublic:\n    GhostSNORFS(snorfs::FS &fs);\n    virtual void addFiles();\n};\n\n}\n\n#endif\n\n",
            "SNORFS.cpp": "#include \"SNORFS.h\"\n#include \"CodalDmesg.h\"\n#include \"NotifyEvents.h\"\n#include \"MessageBus.h\"\n#include \"pxtbase.h\"\n#include <stddef.h>\n\n#define oops() target_panic(DEVICE_FLASH_ERROR)\n\n#ifndef SNORFS_TEST\n#define LOG DMESG\n#define LOGV(...)                                                                                  \\\n    do                                                                                             \\\n    {                                                                                              \\\n    } while (0)\n#endif\n\nusing namespace codal::snorfs;\n\nstatic uint16_t snorfs_unlocked_event;\n\n#define SNORFS_LEVELING_THRESHOLD 100\n\n// The values below were picked at random\n#define SNORFS_MAGIC 0x3576348e\n#define SNORFS_FREE_FLAG 0xd09ff063\n#define SNORFS_COPIED_FLAG 0x4601c6dc\n#define SNORFS_COMPUTING_WRITE_PAGE 0x00ff\n#define SNORFS_TRY_MOUNT 0xfff0\n\nstruct BlockHeader\n{\n    uint32_t magic;\n    uint8_t version;\n    uint8_t numMetaRows;\n    uint16_t logicalBlockId;\n    uint32_t eraseCount;\n    uint32_t freeFlag;\n    uint32_t copiedFlag;\n};\n\nstatic uint8_t fnhash(const char *fn)\n{\n    uint32_t h = hash_fnv1(fn, strlen(fn));\n    h &= 0xff;\n    if (h <= 0x02 || h == 0xff)\n        return h + 0xf0;\n    return h;\n}\n\nFS::FS(SPIFlash &f) : flash(f)\n{\n    numRows = 0;\n    randomSeed = 1;\n    dirptr = 0;\n    files = NULL;\n    locked = false;\n\n    if (!snorfs_unlocked_event)\n        snorfs_unlocked_event = codal::allocateNotifyEvent();\n}\n\nvoid FS::feedRandom(uint32_t v)\n{\n    randomSeed ^= (v + 1) * 0x1000193;\n}\n\n// we need a deterministic PRNG - this one has period of 2^32\nuint32_t FS::random(uint32_t max)\n{\n    uint32_t mask = 1;\n    while (mask <= max)\n        mask = (mask << 1) | 1;\n    while (true)\n    {\n        randomSeed = randomSeed * 1664525 + 1013904223;\n        auto v = randomSeed & mask;\n        if (v < max)\n            return v;\n    }\n}\n\nint FS::firstFree(uint16_t pageIdx)\n{\n    flash.readBytes(indexAddr(pageIdx), buf, SPIFLASH_PAGE_SIZE);\n    for (int k = 1; k < SPIFLASH_PAGE_SIZE - 1; ++k)\n        if (buf[k] == 0xff)\n            return pageIdx | k;\n    return 0;\n}\n\nvoid FS::busy(bool)\n{\n    // blink LED or something\n}\n\nstatic void initBlockHeader(BlockHeader &hd, bool free)\n{\n    hd.magic = SNORFS_MAGIC;\n    hd.version = 0;\n    hd.numMetaRows = 2;\n    hd.eraseCount = 0;\n    if (free)\n    {\n        hd.logicalBlockId = 0xffff;\n        hd.freeFlag = SNORFS_FREE_FLAG;\n        hd.copiedFlag = 0xffffffff;\n    }\n    else\n    {\n        hd.freeFlag = 0;\n        hd.copiedFlag = SNORFS_COPIED_FLAG;\n    }\n}\n\nbool FS::pageErased(uint32_t addr)\n{\n    flash.readBytes(addr, buf, SPIFLASH_PAGE_SIZE);\n    for (int i = 0; i < SPIFLASH_PAGE_SIZE; ++i)\n        if (buf[i] != 0xff)\n            return false;\n    return true;\n}\n\nbool FS::rowErased(uint32_t addr, bool checkFull)\n{\n    if (!checkFull)\n        return pageErased(addr) && pageErased(addr + 512) && pageErased(addr + 1024);\n\n    for (uint32_t off = 0; off < SPIFLASH_BIG_ROW_SIZE; off += SPIFLASH_PAGE_SIZE)\n    {\n        if (!pageErased(addr + off))\n            return false;\n    }\n    return true;\n}\n\nvoid FS::format()\n{\n    if (files)\n        oops();\n\n    LOG(\"formatting SNORFS\");\n\n    uint32_t end = flash.numPages() * SPIFLASH_PAGE_SIZE;\n    uint16_t rowIdx = 0;\n    BlockHeader hd;\n    initBlockHeader(hd, false);\n    bool didErase = false;\n\n    for (uint32_t addr = 0; addr < end; addr += SPIFLASH_BIG_ROW_SIZE)\n    {\n        busy();\n        // in case we didn't need to do any erase yet, do a quick \"likely\" erasure test\n        if (dirptr != SNORFS_TRY_MOUNT && !rowErased(addr, didErase))\n        {\n            didErase = true;\n            flash.eraseBigRow(addr);\n            busy();\n        }\n\n        // the last empty row?\n        if (addr + SPIFLASH_BIG_ROW_SIZE >= end)\n        {\n            initBlockHeader(hd, true);\n        }\n        else\n        {\n            hd.logicalBlockId = rowIdx;\n        }\n        LOGV(\"format: %d\\n\", rowIdx);\n        flash.writeBytes(addr, &hd, sizeof(hd));\n        rowIdx++;\n    }\n    busy(false);\n}\n\nvoid FS::gcCore(bool force, bool isData)\n{\n    if (!force)\n    {\n        fullPages = 0;\n        deletedPages = 0;\n        freePages = 0;\n    }\n\n    uint16_t start = 0;\n    uint16_t end = numRows;\n\n    // in 'force' mode we're interested in specifically data or meta space\n    if (force)\n    {\n        if (isData)\n            start = numMetaRows;\n        else\n            end = numMetaRows;\n    }\n\n    uint32_t maxDelCnt = 0;\n    uint32_t maxDelIdx = 0;\n\n    for (unsigned row = start; row < end; ++row)\n    {\n        uint32_t addr = indexAddr(row << 8);\n        flash.readBytes(addr, buf, SPIFLASH_PAGE_SIZE);\n        uint16_t numDel = 0;\n        for (int i = 1; i < SPIFLASH_PAGE_SIZE - 1; i++)\n        {\n            if (buf[i] == 0x00)\n                numDel++;\n            if (!force)\n            {\n                if (buf[i] == 0x00)\n                    deletedPages++;\n                else if (buf[i] == 0xff)\n                    freePages++;\n                else\n                    fullPages++;\n            }\n        }\n\n        LOGV(\"GC: row=%d del=%d\\n\", row, numDel);\n\n        if (numDel > maxDelCnt)\n        {\n            maxDelCnt = numDel;\n            maxDelIdx = row;\n        }\n    }\n\n    if (force && !maxDelCnt)\n    {\n        if (isData)\n            LOG(\"out of data space\\n\");\n        else\n            LOG(\"out of meta space\\n\");\n        oops(); // really out of space!\n    }\n\n    LOGV(\"GC: \");\n\n    // we do a GC when either one is true:\n    //   * force is true (we desperately need space)\n    //   * there's a row that's more than 50% deleted\n    //   * clearing a row will increase free space by more than 20%\n    if (force || maxDelCnt > SPIFLASH_PAGE_SIZE / 2 || (maxDelCnt * 5 > freePages))\n    {\n        swapRow(rowRemapCache[maxDelIdx]);\n        if (!readHeaders()) // this will trigger levelling on the new free block\n            oops();         // but it should never fail\n    }\n\n    debugDump();\n}\n\nvoid FS::swapRow(int row)\n{\n    busy();\n    LOGV(\"[swap row: %d] \", row);\n    if (freeRow == row || row > numRows)\n        oops();\n    uint32_t trg = freeRow * SPIFLASH_BIG_ROW_SIZE;\n    uint32_t src = row * SPIFLASH_BIG_ROW_SIZE;\n\n    uint32_t skipmask[SPIFLASH_PAGE_SIZE / 32];\n    memset(skipmask, 0, sizeof(skipmask));\n    auto idxOff = SPIFLASH_BIG_ROW_SIZE - SPIFLASH_PAGE_SIZE;\n    flash.readBytes(src + idxOff, buf, SPIFLASH_PAGE_SIZE);\n    for (int i = 1; i < SPIFLASH_PAGE_SIZE - 1; i++)\n    {\n        if (buf[i] == 0x00)\n        {\n            skipmask[i / 32] |= 1U << (i % 32);\n            buf[i] = 0xff;\n            deletedPages--;\n            freePages++;\n        }\n    }\n\n#define setFlag(trg, flag, v)                                                                      \\\n    {                                                                                              \\\n        uint32_t flag = v;                                                                         \\\n        flash.writeBytes(trg + offsetof(BlockHeader, flag), &flag, sizeof(flag));                  \\\n    }\n\n    setFlag(trg, freeFlag, 0); // no longer free\n\n    flash.writeBytes(trg + idxOff, buf, SPIFLASH_PAGE_SIZE);\n    for (int i = 1; i < SPIFLASH_PAGE_SIZE - 1; ++i)\n    {\n        if (skipmask[i / 32] & (1U << (i % 32)))\n            continue;\n\n        flash.readBytes(src + SPIFLASH_PAGE_SIZE * i, buf, SPIFLASH_PAGE_SIZE);\n        flash.writeBytes(trg + SPIFLASH_PAGE_SIZE * i, buf, SPIFLASH_PAGE_SIZE);\n        busy();\n    }\n\n    flash.readBytes(src, buf, SPIFLASH_PAGE_SIZE);\n    auto hd = (BlockHeader *)(void *)buf;\n    flash.writeBytes(trg + offsetof(BlockHeader, logicalBlockId), &hd->logicalBlockId, 2);\n    setFlag(trg, copiedFlag, SNORFS_COPIED_FLAG);\n    setFlag(src, copiedFlag, 0);\n\n    hd->logicalBlockId = 0xffff;\n    hd->eraseCount++;\n    hd->freeFlag = 0xffffffff;\n    hd->copiedFlag = 0xffffffff;\n    flash.eraseBigRow(src);\n    busy();\n    int last = 0;\n    for (int i = 0; i < SPIFLASH_PAGE_SIZE; ++i)\n        if (buf[i] != 0xff)\n            last = i;\n    flash.writeBytes(src, buf, last + 1);\n    // everything done, mark as fully OK free row\n    setFlag(src, freeFlag, SNORFS_FREE_FLAG);\n\n    for (int i = 0; i < numRows; ++i)\n    {\n        if (rowRemapCache[i] == row)\n            rowRemapCache[i] = freeRow;\n    }\n    freeRow = row; // new free row\n    busy(false);\n}\n\nbool FS::readHeaders()\n{\n    memset(rowRemapCache, 0xff, numRows);\n\n    static BlockHeader hd; // can't be on stack!\n    int freeRow = -1;\n    bool freeDirty = false;\n    bool freeRandom = false;\n\n    int minEraseIdx = -1;\n    uint32_t minEraseCnt = 0;\n    uint32_t freeEraseCnt = 0;\n    uint32_t totalEraseCount = 0;\n\n    for (unsigned i = 0; i < (unsigned)numRows + 1; ++i)\n    {\n        auto addr = i * SPIFLASH_BIG_ROW_SIZE;\n        flash.readBytes(addr, &hd, sizeof(hd));\n        if (hd.magic != SNORFS_MAGIC || hd.version != 0)\n        {\n            // likely, we got a power failure during row erase - it now contains random data\n            if (freeRow == -1)\n            {\n                freeDirty = true;\n                freeRandom = true;\n                freeRow = i;\n                continue;\n            }\n            return false;\n        }\n\n        numMetaRows = hd.numMetaRows;\n\n        totalEraseCount += hd.eraseCount;\n\n        if (hd.logicalBlockId == 0xffff || hd.copiedFlag != SNORFS_COPIED_FLAG)\n            goto isFree;\n        else\n        {\n            if (hd.logicalBlockId >= numRows)\n                return false;\n            // if this is the first duplicate, it is liekly a duplicate left over from unfinished\n            // swapRow\n            if (rowRemapCache[hd.logicalBlockId] != 0xff)\n                goto isFree;\n            rowRemapCache[hd.logicalBlockId] = i;\n            if (minEraseIdx < 0 || hd.eraseCount < minEraseCnt)\n            {\n                minEraseCnt = hd.eraseCount;\n                minEraseIdx = i;\n            }\n        }\n        continue;\n\n    isFree:\n        if (freeRow == -1)\n        {\n            freeRow = i;\n            if (hd.freeFlag != SNORFS_FREE_FLAG)\n                freeDirty = true;\n        }\n        else\n            return false;\n        freeEraseCnt = hd.eraseCount;\n    }\n\n    feedRandom(totalEraseCount);\n\n    this->freeRow = freeRow;\n\n    if (freeRow == -1 || !numMetaRows || numMetaRows > numRows / 2)\n        return false;\n\n    if (freeDirty)\n    {\n        LOG(\"fixing free row: %d\\n\", freeRow);\n        busy();\n        initBlockHeader(hd, true);\n        hd.eraseCount = freeRandom ? totalEraseCount / numRows : freeEraseCnt;\n        flash.eraseBigRow(freeRow * SPIFLASH_BIG_ROW_SIZE);\n        busy();\n        flash.writeBytes(freeRow * SPIFLASH_BIG_ROW_SIZE, &hd, sizeof(hd));\n        busy(false);\n    }\n    else if (minEraseCnt + SNORFS_LEVELING_THRESHOLD < freeEraseCnt)\n    {\n        swapRow(minEraseIdx);\n        LOGV(\" for level\\n\");\n    }\n    else\n    {\n        LOGV(\"[no level swap: free %d, min %d]\", freeEraseCnt, minEraseCnt);\n    }\n\n    return true;\n}\n\nbool FS::tryMount()\n{\n    if (numRows == 0)\n    {\n        // we abuse dirptr as a flag\n        dirptr = SNORFS_TRY_MOUNT;\n        lock();\n        unlock();\n        dirptr = 0;\n    }\n    LOG(\"mount SNORFS, rows=%d\", numRows);\n    return numRows > 0;\n}\n\nvoid FS::mount()\n{\n    if (numRows > 0)\n        return;\n\n    numRows = (flash.numPages() / SPIFLASH_BIG_ROW_PAGES) - 1;\n    rowRemapCache = new uint8_t[numRows];\n\n    if (!readHeaders())\n    {\n        if (dirptr == SNORFS_TRY_MOUNT)\n        {\n            uint32_t end = flash.numPages() * SPIFLASH_PAGE_SIZE;\n            for (uint32_t addr = 0; addr < end; addr += SPIFLASH_BIG_ROW_SIZE)\n            {\n                if (!rowErased(addr, false))\n                {\n                    numRows = 0;\n                    delete rowRemapCache;\n                    rowRemapCache = NULL;\n                    return;\n                }\n            }\n        }\n\n        format();\n        if (!readHeaders())\n            oops();\n    }\n    gcCore(false, false);\n}\n\nuint16_t FS::findFreePage(bool isData, uint16_t hint)\n{\n    bool wrapped = false;\n    bool gc = false;\n    uint16_t start = isData ? numMetaRows : 0;\n    uint16_t end = isData ? numRows : numMetaRows;\n    uint16_t ptr = random(end - start) + start;\n\n    uint16_t fr;\n\n    if (hint != 0)\n    {\n        fr = firstFree(hint & 0xff00);\n        if (fr)\n            return fr;\n    }\n\n    for (;;)\n    {\n        fr = firstFree(ptr << 8);\n        if (fr)\n            return fr;\n        if (++ptr == end)\n        {\n            if (wrapped)\n            {\n                if (gc)\n                    oops();\n                gcCore(true, isData);\n                gc = true;\n            }\n            ptr = start;\n            wrapped = true;\n        }\n    }\n}\n\nFS::~FS()\n{\n    delete rowRemapCache;\n}\n\nvoid FS::markPage(uint16_t page, uint8_t flag)\n{\n    if (flag == 0xff)\n        oops();\n    if (flag == 0)\n    {\n        deletedPages++;\n        fullPages--;\n    }\n    else\n    {\n        fullPages++;\n        freePages--;\n    }\n\n    if (flag == 0 && (page >> 8) < numMetaRows)\n    {\n        flash.writeBytes(pageAddr(page), &flag, 1);\n    }\n    flash.writeBytes(indexAddr(page), &flag, 1);\n}\n\nuint8_t FS::dataPageSize()\n{\n    int markedLen = 0;\n    int i;\n    for (i = SPIFLASH_PAGE_SIZE - 1; i >= 0; --i)\n    {\n        if (buf[i] == 0xff)\n            break;\n        markedLen = buf[i];\n    }\n    while (i >= 0)\n    {\n        if (buf[i] != 0xff)\n            break;\n        i--;\n    }\n    i++;\n    return max(i, markedLen);\n}\n\nvoid File::rewind()\n{\n    readPage = 0;\n    readMetaPage = 0;\n    readOffset = 0;\n    readOffsetInPage = 0;\n    readPageSize = 0;\n}\n\nFile *FS::open(uint16_t fileID)\n{\n    lock();\n    auto r = new File(*this, fileID);\n    unlock();\n    return r;\n}\n\nFile *FS::open(const char *filename, bool create)\n{\n    lock();\n    auto page = findMetaEntry(filename);\n    if (page == 0)\n    {\n        if (create) {\n            page = createMetaPage(filename);\n        } else {\n            unlock();\n            return NULL;\n        }\n    }\n    auto r = new File(*this, page);\n    unlock();\n    return r;\n}\n\nbool FS::exists(const char *filename)\n{\n    lock();\n    auto r = findMetaEntry(filename) != 0;\n    unlock();\n    return r;\n}\n\nvoid FS::lock()\n{    \n    while (locked)        \n        fiber_wait_for_event(DEVICE_ID_NOTIFY, snorfs_unlocked_event);\n    locked = true;\n    mount();\n}\n\nvoid FS::unlock()\n{\n    if (!locked)\n        oops();\n    locked = false;\n#ifndef SNORFS_TEST\n    Event(DEVICE_ID_NOTIFY, snorfs_unlocked_event);\n#endif\n}\n\nvoid FS::maybeGC()\n{\n    lock();\n    gcCore(false, false);\n    unlock();\n}\n\nuint16_t FS::findMetaEntry(const char *filename)\n{\n    uint8_t h = fnhash(filename);\n    uint16_t buflen = strlen(filename) + 2;\n\n    if (buflen > 64)\n        oops();\n\n    auto tmp = new uint8_t[buflen];\n\n    for (int i = 0; i < numMetaRows; ++i)\n    {\n        flash.readBytes(indexAddr(i << 8), buf, SPIFLASH_PAGE_SIZE);\n        for (int j = 1; j < SPIFLASH_PAGE_SIZE - 1; ++j)\n        {\n            if (buf[j] == h)\n            {\n                uint16_t pageIdx = (i << 8) | j;\n                auto addr = pageAddr(pageIdx);\n                flash.readBytes(addr, tmp, buflen);\n                if (tmp[0] == 1 && memcmp(tmp + 1, filename, buflen - 1) == 0) {\n                    delete tmp;\n                    return pageIdx;\n                }\n            }\n        }\n    }\n\n    delete tmp;\n    return 0;\n}\n\nuint16_t FS::createMetaPage(const char *filename)\n{\n    uint8_t h = fnhash(filename);\n    feedRandom(h);\n    uint16_t page = findFreePage(false);\n    uint16_t buflen = strlen(filename) + 2;\n\n    memset(buf, 0xff, SPIFLASH_PAGE_SIZE);\n    buf[0] = 0x01;\n    memcpy(buf + 1, filename, buflen - 1);\n\n    flash.writeBytes(pageAddr(page), buf, buflen);\n    markPage(page, h);\n\n    return page;\n}\n\nFile::File(FS &f, uint16_t existing) : fs(f)\n{\n    metaPage = existing;\n    writePage = 0;\n    rewind();\n    next = fs.files;\n    fs.files = this;\n}\n\nFile::~File()\n{\n    if (this == fs.files)\n    {\n        fs.files = next;\n    }\n    else\n    {\n        auto p = fs.files;\n        while (p)\n        {\n            if (p->next == this)\n            {\n                p->next = this->next;\n                break;\n            }\n            p = p->next;\n        }\n        if (p == NULL)\n            oops();\n    }\n}\n\nvoid File::seek(uint32_t pos)\n{\n    if (pos == readOffset)\n        return;\n    if (pos < readOffset)\n        rewind();\n    read(NULL, pos - readOffset);\n}\n\nint FS::metaStart(uint16_t *nextPtr, uint16_t *nextPtrPtr)\n{\n    int start = 1;\n    while (start < 64 && buf[start])\n        start++;\n    start++;\n    if (nextPtr)\n        *nextPtr = read16(start);\n    if (nextPtrPtr)\n        *nextPtrPtr = start;\n    start += 2;\n    for (int i = start; i + 2 < SPIFLASH_PAGE_SIZE; i += 3)\n        if (buf[i] == 0x00 && buf[i + 1] == 0x00 && buf[i + 2] == 0x00)\n            start = i + 3;\n    return start;\n}\n\nuint32_t FS::fileSize(uint16_t metaPage)\n{\n    uint32_t sz = 0;\n    uint16_t lastPage = 0;\n    uint16_t currPage = metaPage;\n    for (;;)\n    {\n        flash.readBytes(pageAddr(currPage), buf, SPIFLASH_PAGE_SIZE);\n        if (buf[0] == 0x00)\n            return 0; // deleted\n        uint16_t nextPtr;\n        for (int i = metaStart(&nextPtr); i + 2 < SPIFLASH_PAGE_SIZE; i += 3)\n        {\n            uint16_t page = read16(i);\n            if (page == 0xffff)\n            {\n                if (nextPtr != 0xffff)\n                    oops();\n                break;\n            }\n            if (buf[i + 2] == 0xff)\n            {\n                lastPage = page;\n            }\n            else\n            {\n                sz += buf[i + 2] + 1;\n                if (lastPage)\n                    oops();\n            }\n        }\n        if (nextPtr == 0xffff)\n            break;\n\n        if (lastPage)\n            oops();\n        currPage = nextPtr;\n    }\n\n    if (lastPage)\n    {\n        flash.readBytes(pageAddr(lastPage), buf, SPIFLASH_PAGE_SIZE);\n        sz += dataPageSize();\n    }\n\n    if (lastPage || currPage != metaPage)\n    {\n        flash.readBytes(pageAddr(metaPage), buf, 64);\n    }\n\n    return sz;\n}\n\nuint16_t FS::read16(int off)\n{\n    return buf[off] | (buf[off + 1] << 8);\n}\n\n#define DIRCHUNK 32\nDirEntry *FS::dirRead()\n{\n    lock();\n    for (;;)\n    {\n        if ((dirptr >> 8) >= numMetaRows)\n        {\n            unlock();\n            return NULL;\n        }\n        int off = dirptr & 0xff;\n        int len = min(DIRCHUNK, SPIFLASH_PAGE_SIZE - off);\n        flash.readBytes(indexAddr(dirptr), buf, len);\n        for (int i = 0; i < len; ++i)\n        {\n            if (i + off >= 0x100)\n                oops();\n            if (0x02 < buf[i] && buf[i] < 0xff)\n            {\n                dirptr += i;\n                DirEntry tmp;\n                tmp.flags = 0;\n                tmp.fileID = dirptr;\n                tmp.size = fileSize(dirptr);\n                dirptr++;\n                if (buf[0] == 0x01)\n                {\n                    strcpy(tmp.name, (char *)buf + 1);\n                    memcpy(buf, &tmp, sizeof(tmp));\n                    unlock();\n                    return (DirEntry *)(void *)buf;\n                }\n            }\n        }\n        dirptr += len;\n    }\n}\n\nbool File::seekNextPage(uint16_t *cache)\n{\n    if (readMetaPage == 0)\n        readMetaPage = metaPage;\n\n    if (*cache != readMetaPage)\n    {\n        fs.flash.readBytes(fs.pageAddr(readMetaPage), fs.buf, SPIFLASH_PAGE_SIZE);\n        *cache = readMetaPage;\n    }\n\n    uint16_t nextPtr;\n    bool isNext = false;\n    uint16_t newReadPage = 0;\n\n    for (int i = fs.metaStart(&nextPtr); i + 2 < SPIFLASH_PAGE_SIZE; i += 3)\n    {\n        uint16_t page = fs.read16(i);\n        if (page == 0xffff)\n            return false;\n        if (isNext || readPage == 0)\n        {\n            newReadPage = page;\n            readPageSize = fs.buf[i + 2];\n            break;\n        }\n        if (page == readPage)\n            isNext = true;\n    }\n\n    if (newReadPage == 0)\n    {\n        if (!isNext)\n            oops();\n        if (nextPtr == 0xffff)\n            return false;\n        readMetaPage = nextPtr;\n        readPage = 0;\n        return seekNextPage(cache);\n    }\n\n    if (readPageSize == 0xff)\n    {\n        *cache = 0;\n        fs.flash.readBytes(fs.pageAddr(newReadPage), fs.buf, SPIFLASH_PAGE_SIZE);\n        readPageSize = fs.dataPageSize();\n    }\n    else\n        readPageSize++;\n\n    readPage = newReadPage;\n    readOffsetInPage = 0;\n    return true;\n}\n\nuint32_t File::size()\n{\n    primary()->computeWritePage();\n    return metaSize;\n}\n\nFile *File::primary()\n{\n    for (auto p = fs.files; p; p = p->next)\n        if (p->metaPage == metaPage)\n            return p;\n    oops();\n    return NULL;\n}\n\nint File::read(void *data, uint32_t len)\n{\n    if (!len)\n        return 0;\n\n    if (writePage != SNORFS_COMPUTING_WRITE_PAGE)\n        fs.lock();\n\n    if (len > 0x7fffffffU)\n        len = 0x7fffffffU;\n\n    uint16_t seekCache = 0;\n    int nread = 0;\n    while (len > 0)\n    {\n        if (readOffsetInPage >= readPageSize)\n        {\n            if (!seekNextPage(&seekCache))\n                break;\n        }\n\n        int n = min((int)len, readPageSize - readOffsetInPage);\n        if (data)\n        {\n            fs.flash.readBytes(fs.pageAddr(readPage) + readOffsetInPage, data, n);\n            data = (uint8_t *)data + n;\n        }\n        nread += n;\n        len -= n;\n        readOffset += n;\n        readOffsetInPage += n;\n    }\n\n    if (writePage != SNORFS_COMPUTING_WRITE_PAGE)\n        fs.unlock();\n\n    return nread;\n}\n\nvoid File::computeWritePage()\n{\n    if (isDeleted())\n        oops();\n    if (writePage)\n        return;\n    auto prevOff = readOffset;\n    writePage = SNORFS_COMPUTING_WRITE_PAGE;\n    seek(0xffffffff);\n    auto newWritePage = readPage;\n    writeMetaPage = readMetaPage;\n    writeOffsetInPage = readOffsetInPage;\n    writeNumExplicitSizes = 0;\n    if (writePage)\n    {\n        fs.flash.readBytes(fs.pageAddr(writePage), fs.buf, SPIFLASH_PAGE_SIZE);\n        for (int i = SPIFLASH_PAGE_SIZE - 1; i >= 0; --i)\n        {\n            if (fs.buf[i] == 0xff)\n                break;\n            writeNumExplicitSizes++;\n        }\n    }\n    for (auto p = fs.files; p; p = p->next)\n        if (p->metaPage == metaPage)\n            p->metaSize = readOffset;\n    seek(prevOff);\n    writePage = newWritePage;\n}\n\nvoid File::append(const void *data, uint32_t len)\n{\n    if (len == 0)\n        return;\n\n    auto prim = primary();\n    if (prim != this)\n    {\n        prim->append(data, len);\n        return;\n    }\n\n    fs.lock();\n\n    computeWritePage();\n\n    while (len > 0)\n    {\n        int nwrite =\n            min((int)len, SPIFLASH_PAGE_SIZE - (writeNumExplicitSizes + 2) - writeOffsetInPage);\n        if (nwrite <= 0 || writePage == 0)\n        {\n            allocatePage();\n            continue;\n        }\n\n        LOGV(\"write: left=%d page=0x%x nwr=%d off=%d\\n\", len, writePage, nwrite, writeOffsetInPage);\n\n        fs.flash.writeBytes(fs.pageAddr(writePage) + writeOffsetInPage, data, nwrite);\n\n        writeOffsetInPage += nwrite;\n\n        // if the last byte was 0xff, we need an end marker\n        if (((uint8_t *)data)[nwrite - 1] == 0xff)\n        {\n            fs.flash.writeBytes(fs.pageAddr(writePage) + SPIFLASH_PAGE_SIZE -\n                                    (writeNumExplicitSizes++ + 1),\n                                &writeOffsetInPage, 1);\n        }\n\n        len -= nwrite;\n        data = (uint8_t *)data + nwrite;\n\n        for (auto p = fs.files; p; p = p->next)\n            if (p->metaPage == metaPage)\n            {\n                if (writePage == p->readPage)\n                    p->readPageSize = writeOffsetInPage;\n                p->metaSize += nwrite;\n            }\n    }\n\n    fs.unlock();\n}\n\nvoid File::allocatePage()\n{\n    fs.feedRandom(fileID());\n\n    fs.flash.readBytes(fs.pageAddr(writeMetaPage), fs.buf, SPIFLASH_PAGE_SIZE);\n    int next = 0;\n    int last = 0;\n    uint16_t nextPP;\n    for (int i = fs.metaStart(NULL, &nextPP); i + 2 < SPIFLASH_PAGE_SIZE; i += 3)\n    {\n        if (fs.buf[i] == 0xff && fs.buf[i + 1] == 0xff)\n        {\n            next = i;\n            break;\n        }\n        last = i;\n    }\n\n    if (last && fs.buf[last + 2] != 0xff)\n        oops();\n\n    if (writePage && last)\n    {\n#ifdef SNORFS_TEST\n        fs.flash.readBytes(fs.pageAddr(writePage), fs.buf, SPIFLASH_PAGE_SIZE);\n        uint8_t len = fs.dataPageSize();\n        if (len != writeOffsetInPage)\n            oops();\n#endif\n        uint8_t v = writeOffsetInPage - 1;\n        fs.flash.writeBytes(fs.pageAddr(writeMetaPage) + last + 2, &v, 1);\n    }\n\n    if (!next)\n    {\n        uint16_t newMeta = fs.findFreePage(false);\n        fs.markPage(newMeta, 0x02);\n        uint8_t hd[] = {0x02, 0x00};\n        fs.flash.writeBytes(fs.pageAddr(newMeta), hd, 2);\n        fs.flash.writeBytes(fs.pageAddr(writeMetaPage) + nextPP, &newMeta, 2);\n        writeMetaPage = newMeta;\n        next = 4;\n    }\n\n    // if writePage is set, try to keep the new page on the same row - this helps with\n    // delete locality\n    writePage = fs.findFreePage(true, writePage);\n    fs.markPage(writePage, 1);\n    fs.flash.writeBytes(fs.pageAddr(writeMetaPage) + next, &writePage, 2);\n    writeOffsetInPage = 0;\n    writeNumExplicitSizes = 0;\n}\n\nvoid File::delCore(bool delMeta)\n{\n    rewind();\n    uint16_t cache = 0;\n    uint16_t prev = 0;\n    bool empty = true;\n\n    for (;;)\n    {\n        if (!seekNextPage(&cache))\n            break;\n        empty = false;\n        if (readMetaPage != prev)\n        {\n            if (delMeta)\n                fs.markPage(readMetaPage, 0);\n            prev = readMetaPage;\n        }\n        fs.markPage(readPage, 0);\n    }\n\n    if (delMeta && empty)\n    {\n        fs.markPage(metaPage, 0);\n    }\n\n    if (!delMeta && readMetaPage != metaPage)\n        oops();\n\n    for (auto p = fs.files; p; p = p->next)\n        if (p->metaPage == metaPage)\n        {\n            p->rewind();\n            p->metaSize = 0;\n            p->writePage = 0xffff;\n        }\n}\n\nvoid File::del()\n{\n    fs.lock();\n    primary()->delCore(true);\n    fs.unlock();\n}\n\nvoid File::overwrite(const void *data, uint32_t len)\n{\n\n    auto prim = primary();\n    if (prim != this)\n    {\n        prim->overwrite(data, len);\n        return;\n    }\n\n    fs.lock();\n\n    fs.flash.readBytes(metaPageAddr(), fs.buf, SPIFLASH_PAGE_SIZE);\n    int freePtr = 0;\n    for (int i = fs.metaStart(); i + 2 + 6 < SPIFLASH_PAGE_SIZE; i += 3)\n    {\n        if (fs.buf[i] == 0xff && fs.buf[i + 1] == 0xff)\n        {\n            freePtr = i;\n            break;\n        }\n    }\n\n    if (freePtr)\n    {\n        uint8_t clearMark[] = {0, 0, 0};\n        delCore(false);\n        fs.flash.writeBytes(metaPageAddr() + freePtr, clearMark, 3);\n    }\n    else\n    {\n        int len = strlen((char *)fs.buf + 1);\n        char tmp[len];\n        strcpy(tmp, (char *)fs.buf + 1);\n        delCore(true);\n        metaPage = fs.createMetaPage(tmp);\n    }\n    writePage = 0;\n    rewind();\n    fs.unlock();\n\n    append(data, len);\n}\n\nint FS::readFlashBytes(uint32_t addr, void *buffer, uint32_t len)\n{\n    lock();\n    int r = flash.readBytes(addr, buffer, len);\n    unlock();\n    return r;\n}\n\n#ifdef SNORFS_TEST\nvoid FS::dump()\n{\n    if (numRows == 0)\n    {\n        LOG(\"not mounted\\n\");\n        mount();\n    }\n    LOG(\"row#: %d; remap: \", numRows);\n\n    for (unsigned i = 0; i < numRows + 1; ++i)\n    {\n        BlockHeader hd;\n        auto addr = i * SPIFLASH_BIG_ROW_SIZE;\n        flash.readBytes(addr, &hd, sizeof(hd));\n        LOG(\"[%d: %d] \", (int16_t)hd.logicalBlockId, hd.eraseCount);\n    }\n\n    LOG(\"free: %d/%d, (junk: %d)\", freePages + deletedPages, fullPages + freePages + deletedPages,\n        deletedPages);\n    LOG(\"\\n\");\n}\n\nvoid FS::debugDump()\n{\n    // dump();\n}\n\nvoid File::debugDump()\n{\n    LOGV(\"fileID: 0x%x, rd: 0x%x/%d, wr: 0x%x/%d\\n\", fileID(), readPage, tell(), writePage,\n         metaSize);\n}\n#endif",
            "SNORFS.h": "#ifndef CODAL_SNORFS_H\n#define CODAL_SNORFS_H\n\n#include \"SPIFlash.h\"\n\n#define DEVICE_FLASH_ERROR 950\n\nnamespace codal\n{\nnamespace snorfs\n{\n\nclass File;\n\nstruct DirEntry\n{\n    uint32_t size;\n    uint16_t flags;\n    uint16_t fileID;\n    char name[65];\n};\n\n// Supported flash size: 1-16MB\nclass FS\n{\n    friend class File;\n\n    SPIFlash &flash;\n    uint8_t buf[SPIFLASH_PAGE_SIZE];\n\n    File *files;\n\n    uint8_t *rowRemapCache;\n    uint8_t numRows;\n    uint8_t numMetaRows;\n    uint8_t freeRow;\n    volatile bool locked;\n\n    uint32_t randomSeed;\n\n    // this is for data pages only\n    uint16_t fullPages;\n    uint16_t deletedPages;\n    uint16_t freePages;\n\n    uint16_t dirptr;\n\n    uint32_t rowAddr(uint8_t rowIdx)\n    {\n        if (rowIdx >= numRows)\n            target_panic(DEVICE_FLASH_ERROR);\n        return rowRemapCache[rowIdx] * SPIFLASH_BIG_ROW_SIZE;\n    }\n    uint32_t indexAddr(uint16_t ptr)\n    {\n        return rowAddr(ptr >> 8) + SPIFLASH_BIG_ROW_SIZE - SPIFLASH_PAGE_SIZE + (ptr & 0xff);\n    }\n    uint32_t pageAddr(uint16_t ptr)\n    {\n        // page zero is index, shouldn't be accessed through this\n        if (!(ptr & 0xff))\n            target_panic(DEVICE_FLASH_ERROR);\n        return rowAddr(ptr >> 8) + SPIFLASH_PAGE_SIZE * (ptr & 0xff);\n    }\n\n    int firstFree(uint16_t pageIdx);\n    uint16_t findFreePage(bool isData, uint16_t hint = 0);\n    uint32_t random(uint32_t max);\n    void feedRandom(uint32_t max);\n    void mount();\n    void format();\n    uint16_t findMetaEntry(const char *filename);\n    uint16_t createMetaPage(const char *filename);\n    bool readHeaders();\n    void gcCore(bool force, bool isData);\n    void swapRow(int row);\n    void markPage(uint16_t page, uint8_t flag);\n    uint8_t dataPageSize();\n    uint16_t read16(int off);\n    int metaStart(uint16_t *nextPtr = NULL, uint16_t *nextPtrPtr = NULL);\n    uint32_t fileSize(uint16_t metaPage);\n    void lock();\n    void unlock();\n    bool pageErased(uint32_t addr);\n    bool rowErased(uint32_t addr, bool checkFull);\n\npublic:\n    FS(SPIFlash &f);\n    ~FS();\n    // returns NULL if file doesn't exists and create==false\n    File *open(const char *filename, bool create = true);\n    File *open(uint16_t fileID);\n    bool exists(const char *filename);\n    uint32_t rawSize() { return flash.numPages() * SPIFLASH_PAGE_SIZE; }\n    uint32_t totalSize() { return (fullPages + deletedPages + freePages) * SPIFLASH_PAGE_SIZE; }\n    uint32_t freeSize() { return (deletedPages + freePages) * SPIFLASH_PAGE_SIZE; }\n    void busy(bool isBusy = true);\n    void maybeGC();\n    // this allow raw r/o access; will lock the instance as needed\n    int readFlashBytes(uint32_t addr, void *buffer, uint32_t len);\n    bool tryMount();\n\n    void dirRewind() { dirptr = 0; }\n    DirEntry *dirRead(); // data is only valid until next call to to any of File or FS function\n\n#ifdef SNORFS_TEST\n    void debugDump();\n    void dump();\n#else\n    void debugDump() {}\n#endif\n};\n\nclass File\n{\n    // Invariants:\n    // firstPage == 0 <==> no pages has been allocated\n    // readOffset % SPIFLASH_PAGE_SIZE == 0 && readPage != 0 ==>\n    //       readPage is on page for (readOffset - 1)\n    // writePage % SPIFLASH_PAGE_SIZE == 0 && writePage != 0 ==>\n    //       writePage is on page for (metaSize - 1)\n    // if readPage is 0 it needs to be recomputed\n    // if writePage is 0 it needs to be recomputed\n\n    friend class FS;\n\n    FS &fs;\n    File *next;\n    uint32_t metaSize;\n\n    uint16_t metaPage; // the address of main meta entry\n\n    // this is for reading\n    uint16_t readMetaPage;\n    uint16_t readPage;\n    uint8_t readOffsetInPage;\n    uint8_t readPageSize;\n    uint32_t readOffset;\n\n    // this is for writing (append)\n    uint16_t writeMetaPage;\n    uint16_t writePage;\n    uint8_t writeOffsetInPage;\n    uint8_t writeNumExplicitSizes;\n\n    uint32_t metaPageAddr() { return fs.pageAddr(metaPage); }\n\n    void rewind();\n    bool seekNextPage(uint16_t *cache);\n    void allocatePage();\n    void newMetaPage();\n    void findFreeMetaPage();\n    void computeWritePage();\n    void saveSizeDiff(int32_t sizeDiff);\n    void appendCore(const void *data, uint32_t len);\n    void delCore(bool delMeta);\n    File(FS &f, uint16_t filePage);\n    File(FS &f, const char *filename);\n    File *primary();\n\npublic:\n    int read(void *data, uint32_t len);\n    void append(const void *data, uint32_t len);\n    void seek(uint32_t pos);\n    uint32_t size();\n    uint32_t tell() { return readOffset; }\n    uint32_t fileID() { return metaPage; }\n    bool isDeleted() { return writePage == 0xffff; }\n    void overwrite(const void *data, uint32_t len);\n    void del();\n    void truncate() { overwrite(NULL, 0); }\n    ~File();\n#ifdef SNORFS_TEST\n    void debugDump();\n#endif\n};\n}\n}\n\n#endif\n",
            "pxt.json": "{\n    \"name\": \"storage\",\n    \"description\": \"USB Pen-drive support and flash storage\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"SNORFS.cpp\",\n        \"SNORFS.h\",\n        \"GhostSNORFS.cpp\",\n        \"GhostSNORFS.h\",\n        \"storage.cpp\",\n        \"storage.ts\",\n        \"shims.d.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"yotta\": {\n        \"config\": {\n            \"DEVICE_USB\": 1\n        }\n    },\n    \"icon\": \"/docs/static/libs/storage.png\"\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace storage {\n\n    /** \n     * Append a buffer to a new or existing file. \n     * @param filename name of the file, eg: \"log.txt\"\n     */\n    //% parts=\"storage\" shim=storage::appendBuffer\n    function appendBuffer(filename: string, data: Buffer): void;\n\n    /** \n     * Overwrite file with a buffer. \n     * @param filename name of the file, eg: \"log.txt\"\n     */\n    //% parts=\"storage\" shim=storage::overwriteWithBuffer\n    function overwriteWithBuffer(filename: string, data: Buffer): void;\n\n    /** \n     * Return true if the file already exists. \n     * @param filename name of the file, eg: \"log.txt\"\n     */\n    //% parts=\"storage\"\n    //% blockId=\"storage_exists\" block=\"file $filename exists\" shim=storage::exists\n    function exists(filename: string): boolean;\n\n    /** \n     * Delete a file, or do nothing if it doesn't exist. \n     * @param filename name of the file, eg: \"log.txt\"\n     */\n    //% parts=\"storage\"\n    //% blockId=\"storage_remove\" block=\"remove file $filename\" shim=storage::remove\n    function remove(filename: string): void;\n\n    /** \n     * Return the size of the file, or -1 if it doesn't exists. \n     * @param filename name of the file, eg: \"log.txt\"\n     */\n    //% parts=\"storage\"\n    //% blockId=\"storage_size\" block=\"size of file $filename\" shim=storage::size\n    function size(filename: string): int32;\n\n    /** \n     * Read contents of file as a buffer. \n     * @param filename name of the file, eg: \"log.txt\"\n     */\n    //% parts=\"storage\" shim=storage::readAsBuffer\n    function readAsBuffer(filename: string): Buffer;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "storage.cpp": "#include \"pxt.h\"\n#include \"SPI.h\"\n\n#include \"GhostSNORFS.h\"\n#include \"StandardSPIFlash.h\"\n\nnamespace storage {\n\nclass PXTMSC : public GhostSNORFS {\n  public:\n    virtual const char *volumeLabel() { return \"MAKECODE\"; }\n    PXTMSC(snorfs::FS &fs) : GhostSNORFS(fs) {}\n};\n\nclass WStorage {\n  public:\n    CODAL_SPI flashSPI;\n    StandardSPIFlash flash;\n    snorfs::FS fs;\n    PXTMSC msc;\n    bool mounted;\n\n    WStorage()\n        : flashSPI(*LOOKUP_PIN(FLASH_MOSI), *LOOKUP_PIN(FLASH_MISO), *LOOKUP_PIN(FLASH_SCK)),\n          flash(flashSPI, *LOOKUP_PIN(FLASH_CS),\n                getConfig(CFG_FLASH_BYTES, 2 * 1024 * 1024) / SPIFLASH_PAGE_SIZE),\n          fs(flash), msc(fs) {\n        // see if we can mount it\n        mounted = fs.tryMount();\n    }\n};\nSINGLETON_IF_PIN(WStorage, FLASH_MOSI);\n\nstatic WStorage *mountedStorage() {\n    auto s = getWStorage();\n    if (!s) \n        return NULL;\n\n    if (s->mounted)\n        return s;\n    \n    DMESG(\"formatting storage\");\n    s->fs.exists(\"foobar\"); // forces mount\n    s->mounted = true;\n\n    return s;\n\n/*\n    auto p = LOOKUP_PIN(LED);\n    // lock-up blinking LED\n    // TODO wait for A+B, erase SPI chip, and reset\n    while (1) {\n        p->setDigitalValue(1);\n        fiber_sleep(100);\n        p->setDigitalValue(0);\n        fiber_sleep(100);\n    }\n    */\n}\n\n//%\nvoid init() {\n    usb.delayStart();\n    auto s = getWStorage();\n    if (s && s->mounted) {\n        usb.add(s->msc);\n        s->msc.addFiles();\n    }\n    usb.start();\n}\n\nsnorfs::File *getFile(String filename) {\n    auto st = mountedStorage();\n    if (!st) \n        return NULL;\n\n    // maybe we want to keep say up to 5 files open?\n    static String currFilename;\n    static snorfs::File *currFile;\n\n    if (!currFilename) {\n        registerGC((TValue*)&currFilename);\n    } else {\n        if (filename && String_::compare(currFilename, filename) == 0)\n            return currFile;\n        delete currFile;\n    }\n    currFilename = filename;\n    // TODO: fix UTF8 encoding\n    currFile = filename == NULL ? NULL : st->fs.open(filename->getUTF8Data());\n    return currFile;\n}\n\n/** \n* Append a buffer to a new or existing file. \n* @param filename name of the file, eg: \"log.txt\"\n*/\n//% parts=\"storage\"\nvoid appendBuffer(String filename, Buffer data) {\n    auto f = getFile(filename);\n    if (NULL == f) return;\n    f->append(data->data, data->length);\n}\n\n/** \n* Overwrite file with a buffer. \n* @param filename name of the file, eg: \"log.txt\"\n*/\n//% parts=\"storage\"\nvoid overwriteWithBuffer(String filename, Buffer data) {\n    auto f = getFile(filename);\n    if (NULL == f) return;\n    f->overwrite(data->data, data->length);\n}\n\n/** \n* Return true if the file already exists. \n* @param filename name of the file, eg: \"log.txt\"\n*/\n//% parts=\"storage\"\n//% blockId=\"storage_exists\" block=\"file $filename exists\"\nbool exists(String filename) {\n    auto st = mountedStorage();\n    return !!st && st->fs.exists(filename->getUTF8Data());\n}\n\n/** \n* Delete a file, or do nothing if it doesn't exist. \n* @param filename name of the file, eg: \"log.txt\"\n*/\n//% parts=\"storage\"\n//% blockId=\"storage_remove\" block=\"remove file $filename\"\nvoid remove(String filename) {\n    if (!exists(filename))\n        return;\n    auto f = getFile(filename);\n    f->del();\n    getFile(NULL);\n}\n\n/** \n* Return the size of the file, or -1 if it doesn't exists. \n* @param filename name of the file, eg: \"log.txt\"\n*/\n//% parts=\"storage\"\n//% blockId=\"storage_size\" block=\"size of file $filename\"\nint size(String filename) {\n    if (!exists(filename))\n        return -1;\n    auto f = getFile(filename);    \n    return f->size();\n}\n\n/** \n* Read contents of file as a buffer. \n* @param filename name of the file, eg: \"log.txt\"\n*/\n//% parts=\"storage\"\nBuffer readAsBuffer(String filename) {\n    auto f = getFile(filename);\n    if (NULL == f) \n        return NULL;\n    auto sz = f->size();\n    if (sz > 0xffff)\n        return NULL;\n    auto res = mkBuffer(NULL, sz);\n    f->seek(0);\n    f->read(res->data, res->length);\n    return res;\n}\n\n} // namespace storage\n",
            "storage.ts": "/** \n * File storage operations\n*/\n//% weight=5 color=#00c0c0 icon=\"\\uf07b\"\nnamespace storage {\n    export let NEW_LINE = \"\\n\";\n\n    //% shim=storage::init\n    function init() { }\n\n    // init() needs to be called at the beginning of the program, so it gets a chance\n    // to register its USB handler\n    init();\n\n    /**\n     * Appends a new line to the file\n    * @param filename name of the file, eg: \"log.txt\"\n     */\n    //% parts=\"storage\" \n    //% blockId=\"storage_append_line\" block=\"append file $filename with line $data\"\n    export function appendLine(filename: string, data: string): void {\n        append(filename, data + NEW_LINE);\n    }\n\n    /** \n    * Append string data to a new or existing file. \n    * @param filename name of the file, eg: \"log.txt\"\n    */\n    //% parts=\"storage\" \n    //% blockId=\"storage_append\" block=\"append file $filename with $data\"\n    export function append(filename: string, data: string) {\n        appendBuffer(filename, control.createBufferFromUTF8(data));\n    }\n\n    /** \n    * Overwrite file with string data. \n    * @param filename name of the file, eg: \"log.txt\"\n    */\n    //% parts=\"storage\"\n    //% blockId=\"storage_overwrite\" block=\"overwrite file $filename with $data\"\n    export function overwrite(filename: string, data: string) {\n        overwriteWithBuffer(filename, control.createBufferFromUTF8(data));\n    }\n\n    /** \n    * Read contents of file as a string. \n    * @param filename name of the file, eg: \"log.txt\"\n    */\n    //% parts=\"storage\"\n    //% blockId=\"storage_read\" block=\"read file $filename\"\n    export function read(filename: string) {\n        const buf = readAsBuffer(filename);\n        if (!buf)\n            return null;\n        return buf.toString();\n    }\n}\n"
        },
        "datalogger": {
            "README.md": "# Data logger\n\nA tiny libraty to create CSV log files.",
            "datalogger.ts": "enum LogSeparator {\n    //% block=\"tab\"\n    Tab = 0x09,\n    //% block=\"comma\"\n    Comma = 0x2c,\n    //% block=\"semicolon\"\n    Semicolon = 0x3b\n};\n\n/**\n * A tiny data logging framework\n */\n//% weight=80 color=#00a0a0 icon=\"\" blockGap=8\n//% groups='[\"Data\", \"Configuration\"]'\nnamespace datalogger {\n    export let SEPARATOR = \"\\t\";\n    /**\n     * A storage for log data\n     */\n    export class Storage {\n        constructor() {\n        }\n        /**\n         * Initializes the storage\n         */\n        init(): void { }\n        /**\n         * Appends the headers in log\n         */\n        appendHeaders(headers: string[]): void { }\n        /**\n         * Appends a row of data\n         */\n        appendRow(values: number[]): void { }\n        /**\n         * Flushes any buffered data\n         */\n        flush(): void { }\n    }\n\n    let _headers: string[] = undefined;\n    let _headersWritten: boolean = false;\n    let _row: number[] = undefined;\n    let _start: number;\n    let _storage: Storage;\n    let _enabled = true;\n    let _samplingInterval = -1;\n    let _sampleCount = 0;\n    let _lastSampleTime = -1;\n    let _console = false;\n\n    function clear() {\n        _headers = undefined;\n        _row = undefined;\n    }\n\n    function initRow() {\n        if (!_storage || _row) return;\n\n        if (!_headers) {\n            _headers = [];\n            _headersWritten = false;\n            _start = control.millis();\n            _storage.init();\n        }\n        _row = [];\n        _sampleCount = 1;\n        _lastSampleTime = control.millis();\n        const s = (_lastSampleTime - _start) / 1000;\n        addValue(\"time (s)\", s);\n    }\n\n    function commitRow() {\n        // write row if any data\n        if (_row && _row.length > 0 && _storage) {\n            // write headers for the first row\n            if (!_headersWritten) {\n                _storage.appendHeaders(_headers);\n                if (_console)\n                    console.log(_headers.slice(1, _headers.length).join(', '));\n                _headersWritten = true;\n            }\n            // commit row data\n            if (_samplingInterval <= 0 || control.millis() - _lastSampleTime >= _samplingInterval) {\n                // average data\n                if (_sampleCount > 1) {\n                    for(let i = 1; i < _row.length; ++i) {\n                        _row[i] /= _sampleCount;\n                    }\n                }\n                // append row\n                _storage.appendRow(_row);\n                if (_console) {\n                    // drop time\n                    console.log(_row.slice(1, _row.length).join(','));\n                }\n                // clear values\n                _row = undefined;\n                _sampleCount = 1;\n                _lastSampleTime = -1;\n            } else {\n                // don't store the data yet\n                _sampleCount++;\n            }\n        }\n    }\n\n    /**\n     * Start a new row of data\n     */\n    //% group=\"Data\"\n    //% weight=100\n    //% blockId=datalogAddRow block=\"data logger add row\"\n    //% help=datalogger/add-row\n    export function addRow(): void {\n        if (!_enabled || !_storage) return;\n\n        commitRow();\n        initRow();\n    }\n\n    /**\n     * Add a named value to the row of data\n     * @param name name of the cell, eg: \"x\"\n     * @param value value of the cell, eg: 0\n     */\n    //% group=\"Data\"\n    //% weight=99\n    //% blockId=datalogAddValue block=\"data logger add %name|=%value\"\n    //% blockGap=12\n    //% help=datalogger/add-value\n    export function addValue(name: string, value: number) {\n        if (!_row) return;\n        // happy path\n        if (_headers[_row.length] === name)\n            _row.push(value);\n        else {\n            let i = _headers.indexOf(name);\n            if (i < 0) {\n                _headers.push(name);\n                i = _headers.length - 1;\n            }\n            _row[i] += value;\n        }\n    }\n\n    /**\n     * \n     * @param storage custom storage solution\n     */\n    //%\n    export function setStorage(storage: Storage) {\n        flush();\n        _storage = storage;\n        clear();\n    }\n\n    /**\n     * Commits any buffered row to disk\n     */\n    //%\n    export function flush() {\n        if (_headers && _storage)\n            _storage.flush();\n    }\n\n    /**\n     * Set the minimum number of milliseconds between rows\n     * @param millis milliseconds between each sample, eg: 50\n     */\n    //% group=\"Configuration\"\n    //% blockId=datalogSetSamplingInterval block=\"set data logger sampling interval to $millis|(ms)\"\n    //% millis.shadow=timePicker\n    //% help=datalogger/set-sample-interval\n    export function setSampleInterval(millis: number) {\n        _samplingInterval = millis >> 0;\n    }\n\n    /**\n     * Turn on or off datalogging\n     * @param enabled \n     */\n    //% group=\"Configuration\"\n    //% blockId=datalogEnabled block=\"data logger $enabled\"\n    //% enabled.shadow=toggleOnOff\n    //% help=datalogger/set-enabled\n    export function setEnabled(enabled: boolean) {\n        flush();\n        _enabled = enabled;\n    }\n\n    /**\n     * Send the data logger output to the console\n     * @param enabled \n     */\n    //% group=\"Configuration\"\n    //% blockId=\"datalogConsole\" block=\"data logger to console $enabled\"\n    //% enabled.shadow=toggleOnOff\n    //% help=datalogger/send-to-console\n    export function sendToConsole(enabled: boolean) {\n        _console = enabled;\n    }\n\n    /**\n     * Set the character used to separate values in a row.\n     * @param separator the value separator character, eg: \"\\t\"\n     */\n    //% group=\"Configuration\"\n    //% blockId=\"datalogSeparator\" block=\"data logger set separator $separator\"\n    //% help=datalogger/set-separator\n    export function setSeparator(separator: LogSeparator) {\n        if (!_enabled) {\n            SEPARATOR = String.fromCharCode(separator);\n        }\n    }\n}\n",
            "pxt.json": "{\n    \"name\": \"datalogger\",\n    \"description\": \"Tiny data logging framework\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"storage\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"datalogger.ts\",\n        \"storagedatalogger.ts\",\n        \"targetoverrides.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"icon\": \"/docs/static/libs/datalogger.png\"\n}\n",
            "storagedatalogger.ts": "namespace datalogger {\n    const FILENAME = \"datalog.csv\";\n    /**\n        * A storage for datalog data\n    */\n    export class FileStorage extends Storage {\n        filename: string;\n        constructor(filename: string) {\n            super()\n            this.filename = filename;\n        }\n        /**\n         * Initializes the storage\n         */\n        init(): void { \n\n        }\n        /**\n         * Appends the headers in datalog\n         */\n        appendHeaders(headers: string[]): void {\n            // skip this step if file already exists\n            if (storage.exists(this.filename))\n                return;\n            const line = headers.join(datalogger.SEPARATOR);\n            storage.appendLine(this.filename, `sep=${datalogger.SEPARATOR}`);\n            storage.appendLine(this.filename, line);\n        }\n        /**\n         * Appends a row of data\n         */\n        appendRow(values: number[]): void { \n            const line = values.join(datalogger.SEPARATOR);\n            storage.appendLine(this.filename, line);\n        }\n        /**\n         * Flushes any buffered data\n         */\n        flush(): void { \n\n        }\n    }\n}",
            "targetoverrides.ts": "// add target specific things here\nnamespace datalogger {\n    datalogger.setStorage(new FileStorage(\"log.csv\"));\n}",
            "test.ts": "let k = 0;\nforever(function () {\n    datalogger.addRow()\n    datalogger.addValue(\"x\", k)\n    datalogger.addValue(\"y\", 1 / k)\n})\n"
        },
        "serial": {
            "enums.d.ts": "// Auto-generated. Do not edit.\n\n\n    declare const enum BaudRate {\n    //% block=115200\n    BaudRate115200 = 115200,\n    //% block=57600\n    BaudRate57600 = 57600,\n    //% block=38400\n    BaudRate38400 = 38400,\n    //% block=31250\n    BaudRate31250 = 31250,\n    //% block=28800\n    BaudRate28800 = 28800,\n    //% block=19200\n    BaudRate19200 = 19200,\n    //% block=14400\n    BaudRate14400 = 14400,\n    //% block=9600\n    BaudRate9600 = 9600,\n    //% block=4800\n    BaudRate4800 = 4800,\n    //% block=2400\n    BaudRate2400 = 2400,\n    //% block=1200\n    BaudRate1200 = 1200,\n    //% block=300\n    BaudRate300 = 300,\n    }\n\n\n    declare const enum SerialEvent {\n    //% block=\"data received\"\n    DataReceived = 4,  // CODAL_SERIAL_EVT_DATA_RECEIVED\n    //% block=\"rx buffer full\"\n    RxBufferFull = 3,  // CODAL_SERIAL_EVT_RX_FULL\n    }\n\n\n    declare const enum Delimiters {\n    //% block=\"new line (\\n)\"\n    NewLine = 10,\n    //% block=\",\"\n    Comma = 44,\n    //% block=\"$\"\n    Dollar = 36,\n    //% block=\":\"\n    Colon = 58,\n    //% block=\".\"\n    Fullstop = 46,\n    //% block=\"#\"\n    Hash = 35,\n    //% block=\"carriage return (\\r)\"\n    CarriageReturn = 13,\n    //% block=\"space\"\n    Space = 32,\n    //% block=\"tab (\\t)\"\n    Tab = 9,\n    //% block=\"|\"\n    Pipe = 124,\n    //% block=\";\"\n    SemiColon = 59,\n    }\n\n// Auto-generated. Do not edit. Really.\n",
            "pxt.json": "{\n    \"name\": \"serial\",\n    \"description\": \"UART communication\",\n    \"dependencies\": {\n        \"core\": \"*\"\n    },\n    \"files\": [\n        \"serial-target.h\",\n        \"serial-common.h\",\n        \"serial-target.cpp\",\n        \"serial-common.cpp\",\n        \"serial-target.ts\",\n        \"serial.ts\",\n        \"enums.d.ts\",\n        \"shims.d.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"1.6.8\",\n        \"pxt\": \"6.8.38\"\n    },\n    \"icon\": \"/docs/static/libs/serial.png\"\n}\n",
            "serial-common.cpp": "#include \"pxt.h\"\n#include \"serial-target.h\"\n\nnamespace SerialDeviceMethods {\n/**\n * Sets the size of the RX buffer in bytes\n */\n//%\nvoid setRxBufferSize(SerialDevice device, uint8_t size) {\n    device->setRxBufferSize(size);\n}\n\n/**\n * Sets the size of the TX buffer in bytes\n */\n//%\nvoid setTxBufferSize(SerialDevice device, uint8_t size) {\n    device->setTxBufferSize(size);\n}\n\n/**\nSet the baud rate of the serial port\n*/\n//%\nvoid setBaudRate(SerialDevice device, BaudRate rate) {\n    device->setBaudRate((int)rate);\n}\n\n/**\n * Reads a single byte from the serial receive buffer. Negative if error, 0 if no data.\n */\n//%\nint read(SerialDevice device) {\n    return device->read();\n}\n\n/**\n * Read the buffered received data as a buffer\n */\n//%\nBuffer readBuffer(SerialDevice device) {\n    return device->readBuffer();\n}\n\n/**\n * Send a buffer across the serial connection.\n */\n//%\nvoid writeBuffer(SerialDevice device, Buffer buffer) {\n    device->writeBuffer(buffer);\n}\n\n/**\n * Register code when a serial event occurs\n */\n//%\nvoid onEvent(SerialDevice device, SerialEvent event, Action handler) {\n    device->onEvent(event, handler);\n}\n\n/**\n * Registers code when a delimiter is received\n **/\n//%\nvoid onDelimiterReceived(SerialDevice device, Delimiters delimiter, Action handler) {\n    device->onDelimiterReceived(delimiter, handler);\n}\n} // namespace SerialDeviceMethods\n",
            "serial-common.h": "#pragma once\n#include \"pxt.h\"\n#include \"serial-target.h\"\n\nenum class BaudRate {\n  //% block=115200\n  BaudRate115200 = 115200,\n  //% block=57600\n  BaudRate57600 = 57600,\n  //% block=38400\n  BaudRate38400 = 38400,\n  //% block=31250\n  BaudRate31250 = 31250,\n  //% block=28800\n  BaudRate28800 = 28800,\n  //% block=19200\n  BaudRate19200 = 19200,\n  //% block=14400\n  BaudRate14400 = 14400,\n  //% block=9600\n  BaudRate9600 = 9600,\n  //% block=4800\n  BaudRate4800 = 4800,\n  //% block=2400\n  BaudRate2400 = 2400,\n  //% block=1200\n  BaudRate1200 = 1200,\n  //% block=300\n  BaudRate300 = 300\n};\n\nenum class SerialEvent {\n    //% block=\"data received\"\n    DataReceived = CODAL_SERIAL_EVT_DATA_RECEIVED,\n    //% block=\"rx buffer full\"\n    RxBufferFull = CODAL_SERIAL_EVT_RX_FULL\n};\n\nenum class Delimiters {\n    //% block=\"new line (\\n)\"\n    NewLine = 10,\n    //% block=\",\"\n    Comma = 44,\n    //% block=\"$\"\n    Dollar = 36,\n    //% block=\":\"\n    Colon = 58,\n    //% block=\".\"\n    Fullstop = 46,\n    //% block=\"#\"\n    Hash = 35,\n    //% block=\"carriage return (\\r)\"\n    CarriageReturn = 13,\n    //% block=\"space\"\n    Space = 32,\n    //% block=\"tab (\\t)\"\n    Tab = 9,\n    //% block=\"|\"\n    Pipe = 124,\n    //% block=\";\"\n    SemiColon = 59,\n};\n\n",
            "serial-target.cpp": "#include \"pxt.h\"\n#include \"serial-target.h\"\n\nnamespace serial {\n\nstatic SerialDevice serialDevices(NULL);\n/**\n * Opens a Serial communication driver\n */\n//%\nSerialDevice internalCreateSerialDevice(DigitalInOutPin tx, DigitalInOutPin rx, int id) {\n    auto dev = serialDevices;\n    while (dev) {\n        if (dev->matchPins(tx, rx))\n            return dev;\n        dev = dev->next;\n    }\n\n    // allocate new one\n    auto ser = new CodalSerialDeviceProxy(tx, rx, id);\n    ser->next = serialDevices;\n    serialDevices = ser;\n    return ser;\n}\n\n} // namespace serial\n\nnamespace SerialDeviceMethods {\n\n/**\n */\n//%\nvoid redirect(SerialDevice device, DigitalInOutPin tx, DigitalInOutPin rx, BaudRate rate) {\n    device->redirect(tx, rx, rate);\n}\n\n} // namespace SerialDeviceMethods\n",
            "serial-target.h": "#pragma once\n#include \"pxt.h\"\n#include \"Serial.h\"\n\nenum class SerialEvent;\nenum class BaudRate;\nenum class Delimiters;\n\nnamespace serial {\n\nclass CodalSerialDeviceProxy {\n  private:\n    DevicePin *tx;\n    DevicePin *rx;\n\n  public:\n    CODAL_SERIAL ser;\n    CodalSerialDeviceProxy *next;\n\n    CodalSerialDeviceProxy(DevicePin *_tx, DevicePin *_rx, uint16_t id)\n        : tx(_tx), rx(_rx), ser(*tx, *rx), next(NULL) {\n        if (id <= 0)\n            id = allocateNotifyEvent();\n        ser.id = id;\n        ser.setBaud(115200);\n    }\n\n    bool matchPins(DevicePin *_tx, DevicePin *_rx) { return this->tx == _tx && this->rx == _rx; }\n\n    void setRxBufferSize(uint8_t size) { ser.setRxBufferSize(size); }\n\n    void setTxBufferSize(uint8_t size) { ser.setTxBufferSize(size); }\n\n    void setBaudRate(int rate) { ser.setBaud(rate); }\n\n    int read() {\n        uint8_t buf[1];\n        auto r = ser.read(buf, 1, codal::SerialMode::ASYNC);\n        // r < 0 => error\n        if (r < 0)\n            return r;\n        // r == 0, nothing read\n        if (r == 0)\n            return DEVICE_NO_DATA;\n        // read 1 char\n        return buf[0];\n    }\n\n    Buffer readBuffer() {\n        int n = ser.getRxBufferSize();\n        // n maybe 0 but we still call read to force\n        // to initialize rx\n        auto buf = mkBuffer(NULL, n);\n        auto read = ser.read(buf->data, buf->length, SerialMode::ASYNC);\n        if (read == DEVICE_SERIAL_IN_USE || read == 0) { // someone else is reading\n            return mkBuffer(NULL, 0);\n        }\n        if (buf->length != read) {\n            registerGCObj(buf);\n            auto buf2 = mkBuffer(buf->data, read);\n            unregisterGCObj(buf);\n            buf = buf2;\n        }\n        return buf;\n    }\n\n    void writeBuffer(Buffer buffer) {\n        if (NULL == buffer)\n            return;\n        ser.send(buffer->data, buffer->length);\n    }\n\n    void redirect(DevicePin *tx, DevicePin *rx, BaudRate rate) {\n        this->tx = tx;\n        this->rx = rx;\n        this->ser.redirect(*tx, *rx);\n        this->setBaudRate((int)rate);\n    }\n\n    void onEvent(SerialEvent event, Action handler) {\n        ser.setRxBufferSize(ser.getRxBufferSize()); // turn on reading\n        registerWithDal(ser.id, (int)event, handler);\n    }\n\n    void onDelimiterReceived(Delimiters delimiter, Action handler) {\n        registerWithDal(ser.id, CODAL_SERIAL_EVT_DELIM_MATCH, handler);\n        ManagedString d((char)delimiter);\n        ser.eventOn(d);\n    }\n};\n\ntypedef CodalSerialDeviceProxy *SerialDevice;\n\n} // namespace serial\n",
            "serial-target.ts": "namespace serial {\n    /**\n     * Creates a serial comm device\n     * @param tx \n     * @param rx \n     * @param id \n     */\n    //% help=serial/create-serial\n    //% parts=serial\n    export function createSerial(tx: DigitalInOutPin, rx: DigitalInOutPin, id?: number): Serial {\n        const dev = serial.internalCreateSerialDevice(tx, rx, id || 0);\n        return new Serial(dev);\n    }\n\n    let _device: Serial;\n    export function device(): Serial {\n        if (!_device) {\n            const tx = pins.pinByCfg(DAL.CFG_PIN_TX);\n            const rx = pins.pinByCfg(DAL.CFG_PIN_RX);\n            if (!tx || !rx) return undefined;\n            _device = serial.createSerial(tx, rx, DAL.DEVICE_ID_SERIAL);\n        }\n        return _device;\n    }\n\n\n    /**\n    * Set the serial input and output to use pins instead of the USB connection.\n    * @param tx the new transmission pin\n    * @param rx the new reception pin\n    * @param rate the new baud rate\n    */\n    //% weight=10\n    //% help=serial/redirect\n    //% blockId=serial_redirect block=\"serial|redirect to|TX %tx|RX %rx at rate %rate\"\n    //% tx.fieldEditor=\"gridpicker\" tx.fieldOptions.columns=3\n    //% tx.fieldOptions.tooltips=\"false\"\n    //% rx.fieldEditor=\"gridpicker\" rx.fieldOptions.columns=3\n    //% rx.fieldOptions.tooltips=\"false\"\n    //% blockGap=8 inlineInputMode=inline\n    //% group=\"Configuration\"\n    export function redirect(tx: DigitalInOutPin, rx: DigitalInOutPin, rate: BaudRate) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.redirect(tx, rx, rate);\n    }\n}\n",
            "serial.ts": "/**\n * Reading and writing data over a serial connection.\n */\n//% weight=2 color=#002050 icon=\"\\uf287\"\n//% advanced=true blockGap=8\n//% groups='[\"Write\", \"Read\", \"Events\", \"Configuration\"]'\nnamespace serial {\n    export let NEW_LINE = \"\\r\\n\"; // \\r require or Putty really unhappy on windows\n    export let NEW_LINE_DELIMITER: Delimiters = Delimiters.NewLine;\n\n    export class Serial {\n        serialDevice: SerialDevice;\n        decoder: UTF8Decoder;\n        constructor(serialDevice: SerialDevice) {\n            this.serialDevice = serialDevice;\n            this.decoder = new UTF8Decoder();\n        }\n\n        readString(): string {\n            const buf = this.serialDevice.readBuffer();\n            this.decoder.add(buf);\n            return this.decoder.decode();\n        }\n\n        readLine(timeOut?: number): string {\n            return this.readUntil(NEW_LINE_DELIMITER, timeOut);\n        }\n\n        readUntil(delimiter: Delimiters, timeOut?: number): string {\n            const start = control.millis();\n            do {\n                const s = this.decoder.decodeUntil(delimiter);\n                if (s !== undefined)\n                    return s;\n                const b = this.serialDevice.readBuffer()\n                this.decoder.add(b);\n                pause(1);\n            }\n            while (timeOut === undefined || (control.millis() - start < timeOut));\n            // giving up\n            return \"\";\n        }\n\n        writeString(text: string) {\n            if (!text) return;\n            const buf = control.createBufferFromUTF8(text);\n            this.serialDevice.writeBuffer(buf);\n        }\n\n        writeLine(text: string) {\n            this.writeString(text);\n            this.writeString(serial.NEW_LINE);\n        }\n    }\n\n    /**\n    * Read the buffered received data as a string\n    */\n    //% help=serial/read-string\n    //% blockId=serial_read_string block=\"serial|read string\"\n    //% weight=18\n    //% group=\"Read\"\n    export function readString(): string {\n        const d = device();\n        return d ? d.readString() : \"\";\n    }\n\n    /**\n     * Read a line of text from the serial port.\n     */\n    //% help=serial/read-line\n    //% blockId=serial_read_line block=\"serial|read line\"\n    //% weight=20 blockGap=8\n    //% group=\"Read\"\n    export function readLine(): string {\n        const d = device();\n        return d ? d.readLine() : \"\";\n    }\n\n    /**\n     * Read a line of text from the serial port and return the buffer when the delimiter is met.\n     * @param delimiter text delimiter that separates each text chunk\n     */\n    //% help=serial/read-until\n    //% blockId=serial_read_until block=\"serial|read until %delimiter=serial_delimiter_conv\"\n    //% weight=19\n    //% group=\"Read\"    \n    export function readUntil(delimiter: Delimiters, timeOut?: number): string {\n        const d = device();\n        return d ? d.readUntil(delimiter, timeOut) : \"\";\n    }\n\n    /**\n     * Write some text to the serial port.\n     */\n    //% help=serial/write-string\n    //% weight=87\n    //% blockId=serial_writestring block=\"serial|write string %text\"\n    //% group=\"Write\"\n    export function writeString(text: string) {\n        const d = device();\n        if (d) d.writeString(text);\n    }\n\n    /**\n     * Write a line of text to the serial port.\n     * @param value to send over serial\n     */\n    //% weight=90\n    //% help=serial/write-line blockGap=8\n    //% blockId=serial_writeline block=\"serial|write line %text\"\n    //% group=\"Write\"\n    export function writeLine(text: string): void {\n        const d = device();\n        if (d) d.writeLine(text);\n    }\n\n    /**\n     * Write a number to the serial port.\n     */\n    //% help=serial/write-number\n    //% weight=89 blockGap=8\n    //% blockId=serial_writenumber block=\"serial|write number %value\"\n    //% group=\"Write\"\n    export function writeNumber(value: number): void {\n        writeString(value.toString());\n    }\n\n    /**\n     * Write a name:value pair as a line of text to the serial port.\n     * @param name name of the value stream, eg: \"x\"\n     * @param value to write\n     */\n    //% weight=88 blockGap=8\n    //% help=serial/write-value\n    //% blockId=serial_writevalue block=\"serial|write value %name|= %value\"\n    //% group=\"Write\"\n    export function writeValue(name: string, value: number): void {\n        if (name) {\n            writeString(name);\n            writeString(\":\");\n        }\n        writeNumber(value);\n        writeString(NEW_LINE);\n    }\n\n    /**\n    * Sets the size of the RX buffer in bytes\n    */\n    //% help=serial/set-rx-buffer-size\n    //% blockId=serialsetrxbuffersize block=\"serial set rx buffer size to $size\"\n    //% weight=10\n    //% group=\"Configuration\"\n    export function setRxBufferSize(size: number) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.setRxBufferSize(size);\n    }\n\n    /**\n    * Sets the size of the TX buffer in bytes\n    */\n    //% help=serial/set-tx-buffer-size\n    //% blockId=serialsettxbuffersize block=\"serial set tx buffer size to $size\"\n    //% weight=9\n    //% group=\"Configuration\"\n    export function setTxBufferSize(size: number) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.setTxBufferSize(size);\n    }\n\n    /**\n    * Reads a single byte from the serial receive buffer. Negative if error, 0 if no data.\n    */\n    //% Group=\"Read\"\n    export function read(): number {\n        const ser = device();\n        if (ser)\n            return ser.serialDevice.read();\n        else return DAL.DEVICE_NOT_SUPPORTED;\n    }\n\n    /**\n    * Read the buffered received data as a buffer\n    */\n    //% help=serial/read-buffer\n    //% blockId=serial_read_buffer block=\"serial|read buffer\"\n    //% weight=17\n    //% group=\"Read\"\n    export function readBuffer(): Buffer {\n        const ser = device();\n        if (ser)\n            return ser.serialDevice.readBuffer();\n        else\n            return control.createBuffer(0);\n    }\n\n\n    /**\n    * Send a buffer across the serial connection.\n    */\n    //% help=serial/write-buffer weight=6\n    //% blockId=serial_writebuffer block=\"serial|write buffer %buffer\"\n    //% group=\"Write\"\n    export function writeBuffer(buffer: Buffer) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.writeBuffer(buffer);\n    }\n\n    /**\n    Set the baud rate of the serial port\n    */\n    //% weight=10\n    //% blockId=serial_setbaudrate block=\"serial|set baud rate %rate\"\n    //% blockGap=8 inlineInputMode=inline\n    //% help=serial/set-baud-rate\n    //% group=\"Configuration\"\n    export function setBaudRate(rate: BaudRate) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.setBaudRate(rate);\n    }\n\n    /**\n      Send console messages through the TX, RX pins\n      **/\n    //% blockId=serialsendtoconsole block=\"serial attach to console\"\n    //% group=\"Configuration\"\n    //% help=serial/attach-to-console\n    export function attachToConsole() {\n        console.addListener(logListener)\n    }\n\n    function logListener(priority: ConsolePriority, text: string) {\n        switch (priority) {\n            case ConsolePriority.Debug: writeString(\"dbg> \"); break;\n            case ConsolePriority.Error: writeString(\"err> \"); break;\n            case ConsolePriority.Warning: writeString(\"wrn> \"); break;\n        }\n        writeLine(text);\n    }\n\n\n    /**\n    * Registers code when serial events happen\n    **/\n    //% weight=9\n    //% help=serial/on-event\n    //% blockId=serial_onevent block=\"serial on %event\"\n    //% blockGap=8\n    //% group=\"Events\"\n    export function onEvent(event: SerialEvent, handler: () => void) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.onEvent(event, handler);\n    }\n\n    /**\n    * Registers code when a delimiter is received\n    **/\n    //% weight=10\n    //% help=serial/on-delimiter-received\n    //% blockId=serial_ondelimiter block=\"serial on delimiter $delimiter received\"\n    //% blockGap=8\n    //% group=\"Events\"\n    export function onDelimiterReceived(delimiter: Delimiters, handler: () => void) {\n        const ser = device();\n        if (ser)\n            ser.serialDevice.onDelimiterReceived(delimiter, handler);\n    }\n\n    /**\n     * Return the corresponding delimiter string\n     */\n    //% blockId=\"serial_delimiter_conv\" block=\"%del\"\n    //% weight=1 blockHidden=true hidden=true\n    export function delimiters(del: Delimiters): string {\n        return String.fromCharCode(del as number);\n    }\n}\n",
            "shims.d.ts": "// Auto-generated. Do not edit.\ndeclare namespace serial {\n\n    /**\n     * Opens a Serial communication driver\n     */\n    //% shim=serial::internalCreateSerialDevice\n    function internalCreateSerialDevice(tx: DigitalInOutPin, rx: DigitalInOutPin, id: int32): SerialDevice;\n}\n\n\ndeclare interface SerialDevice {\n    /**\n     */\n    //% shim=SerialDeviceMethods::redirect\n    redirect(tx: DigitalInOutPin, rx: DigitalInOutPin, rate: BaudRate): void;\n}\n\n\ndeclare interface SerialDevice {\n    /**\n     * Sets the size of the RX buffer in bytes\n     */\n    //% shim=SerialDeviceMethods::setRxBufferSize\n    setRxBufferSize(size: uint8): void;\n\n    /**\n     * Sets the size of the TX buffer in bytes\n     */\n    //% shim=SerialDeviceMethods::setTxBufferSize\n    setTxBufferSize(size: uint8): void;\n\n    /**\n    Set the baud rate of the serial port\n     */\n    //% shim=SerialDeviceMethods::setBaudRate\n    setBaudRate(rate: BaudRate): void;\n\n    /**\n     * Reads a single byte from the serial receive buffer. Negative if error, 0 if no data.\n     */\n    //% shim=SerialDeviceMethods::read\n    read(): int32;\n\n    /**\n     * Read the buffered received data as a buffer\n     */\n    //% shim=SerialDeviceMethods::readBuffer\n    readBuffer(): Buffer;\n\n    /**\n     * Send a buffer across the serial connection.\n     */\n    //% shim=SerialDeviceMethods::writeBuffer\n    writeBuffer(buffer: Buffer): void;\n\n    /**\n     * Register code when a serial event occurs\n     */\n    //% shim=SerialDeviceMethods::onEvent\n    onEvent(event: SerialEvent, handler: () => void): void;\n\n    /**\n     * Registers code when a delimiter is received\n     **/\n    //% shim=SerialDeviceMethods::onDelimiterReceived\n    onDelimiterReceived(delimiter: Delimiters, handler: () => void): void;\n}\n\n// Auto-generated. Do not edit. Really.\n",
            "test.ts": "for(let i = 0; i < 10; ++i) {\n    serial.writeLine((++i).toString())\n}"
        }
    },
    "apiInfo": {
        "libs/jc": {
            "apis": {
                "byQName": {}
            },
            "sha": "71d0173603e2e86f4a8f91a5ca3e265732deb80afb1f8144558ee0fe838fdecf"
        },
        "libs/jcevent": {
            "apis": {
                "byQName": {}
            },
            "sha": "27276dcb1a0fb48fffbe207926a86c1a5955998f61e3142b815c36521175ad29"
        },
        "libs/jcstubborn": {
            "apis": {
                "byQName": {}
            },
            "sha": "46cf5c0a3fec3d94587eb5eef78214b5fcb8bc444804f45ed56fc028aeec21a9"
        },
        "libs/base": {
            "apis": {
                "byQName": {}
            },
            "sha": "dd8a856861da8b3d8c2cbf8ca62b6f7fc45492f3671cd8c5436109bdbc35ac87"
        },
        "libs/core": {
            "apis": {
                "byQName": {
                    "control": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 90,
                            "color": "#FF5722",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Program controls and events."
                        }
                    },
                    "pins": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#A80000",
                            "weight": 85,
                            "icon": "",
                            "advanced": true,
                            "groups": [
                                "other",
                                "Servo",
                                "i2c"
                            ],
                            "jsDoc": "Control currents in Pins for analog/digital signals, servos, i2c, ..."
                        }
                    },
                    "loops": {
                        "kind": 5,
                        "retType": ""
                    },
                    "input": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#B4009E",
                            "weight": 98,
                            "icon": "",
                            "groups": [
                                "other",
                                "More"
                            ],
                            "jsDoc": "Respond to and read data from buttons and sensors.\n\nEvents and data from sensors."
                        }
                    },
                    "console": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 12,
                            "color": "#002050",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Reading and writing data to the console output."
                        }
                    },
                    "AnalogInOutPin": {
                        "kind": 9,
                        "retType": "AnalogInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInOutPin",
                            "AnalogInPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "light": {
                        "kind": 5,
                        "retType": ""
                    }
                }
            },
            "sha": "b049c118afd85dd61afbade2c401f83d0b2e7908939b5d6a81544187317c75ee"
        },
        "libs/core---samd": {
            "apis": {
                "byQName": {}
            },
            "sha": "b049c118afd85dd61afbade2c401f83d0b2e7908939b5d6a81544187317c75ee"
        },
        "libs/settings": {
            "apis": {
                "byQName": {
                    "control": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 90,
                            "color": "#FF5722",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Program controls and events."
                        }
                    },
                    "pins": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#A80000",
                            "weight": 85,
                            "icon": "",
                            "advanced": true,
                            "groups": [
                                "other",
                                "Servo",
                                "i2c"
                            ],
                            "jsDoc": "Control currents in Pins for analog/digital signals, servos, i2c, ..."
                        }
                    },
                    "loops": {
                        "kind": 5,
                        "retType": ""
                    },
                    "input": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#B4009E",
                            "weight": 98,
                            "icon": "",
                            "groups": [
                                "other",
                                "More"
                            ],
                            "jsDoc": "Respond to and read data from buttons and sensors.\n\nEvents and data from sensors."
                        }
                    },
                    "console": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 12,
                            "color": "#002050",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Reading and writing data to the console output."
                        }
                    },
                    "AnalogInOutPin": {
                        "kind": 9,
                        "retType": "AnalogInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInOutPin",
                            "AnalogInPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "light": {
                        "kind": 5,
                        "retType": ""
                    },
                    "settings": {
                        "kind": 5,
                        "retType": ""
                    },
                    "settings.runNumber": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [],
                        "pyQName": "settings.run_number"
                    },
                    "settings.clear": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Delete all non-system settings."
                        },
                        "parameters": []
                    },
                    "settings.writeBuffer": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Set named setting to a given buffer."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            },
                            {
                                "name": "value",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "settings.write_buffer"
                    },
                    "settings.writeString": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Set named settings to a given string."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            },
                            {
                                "name": "value",
                                "type": "string"
                            }
                        ],
                        "pyQName": "settings.write_string"
                    },
                    "settings.writeNumber": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Set named settings to a given number."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            },
                            {
                                "name": "value"
                            }
                        ],
                        "pyQName": "settings.write_number"
                    },
                    "settings.writeNumberArray": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Set named settings to a given array of numbers."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            },
                            {
                                "name": "value",
                                "type": "number[]"
                            }
                        ],
                        "pyQName": "settings.write_number_array"
                    },
                    "settings.readBuffer": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "jsDoc": "Read named setting as a buffer. Returns undefined when setting not found."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            }
                        ],
                        "pyQName": "settings.read_buffer"
                    },
                    "settings.readString": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "jsDoc": "Read named setting as a string."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            }
                        ],
                        "pyQName": "settings.read_string"
                    },
                    "settings.readNumber": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Read named setting as a number."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            }
                        ],
                        "pyQName": "settings.read_number"
                    },
                    "settings.readNumberArray": {
                        "kind": -3,
                        "retType": "number[]",
                        "attributes": {
                            "jsDoc": "Read named setting as a number."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            }
                        ],
                        "pyQName": "settings.read_number_array"
                    },
                    "settings.list": {
                        "kind": -3,
                        "retType": "string[]",
                        "attributes": {
                            "jsDoc": "Return a list of settings starting with a given prefix."
                        },
                        "parameters": [
                            {
                                "name": "prefix",
                                "type": "string",
                                "initializer": "undefined"
                            }
                        ]
                    },
                    "settings.remove": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Remove named setting."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            }
                        ]
                    },
                    "settings.exists": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "jsDoc": "Check if a named setting exists."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            }
                        ]
                    },
                    "settings.SecretStore": {
                        "kind": 8,
                        "retType": "settings.SecretStore",
                        "attributes": {
                            "fixedInstances": "true"
                        },
                        "extendsTypes": []
                    },
                    "settings.SecretStore.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            }
                        ],
                        "isInstance": true
                    },
                    "settings.SecretStore.setSecret": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "name",
                                "type": "string"
                            },
                            {
                                "name": "value",
                                "type": "any"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "settings.SecretStore.set_secret"
                    },
                    "settings.SecretStore.updateSecret": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "name",
                                "type": "string"
                            },
                            {
                                "name": "value",
                                "type": "any"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "settings.SecretStore.update_secret"
                    },
                    "settings.SecretStore.readSecret": {
                        "kind": -1,
                        "retType": "any",
                        "parameters": [
                            {
                                "name": "name",
                                "type": "string"
                            },
                            {
                                "name": "ensure",
                                "type": "boolean",
                                "initializer": "false"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "settings.SecretStore.read_secret"
                    },
                    "settings.SecretStore.clearSecrets": {
                        "kind": -1,
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "settings.SecretStore.clear_secrets"
                    },
                    "settings.SecretStore.readSecrets": {
                        "kind": -1,
                        "retType": "any",
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "settings.SecretStore.read_secrets"
                    },
                    "settings.deviceSecrets": {
                        "kind": 4,
                        "retType": "settings.SecretStore",
                        "attributes": {
                            "fixedInstance": "true",
                            "whenUsed": "true",
                            "block": "device secrets",
                            "jsDoc": "Secrets shared by any program on the device",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "device secrets",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "settings.device_secrets"
                    },
                    "settings.programSecrets": {
                        "kind": 4,
                        "retType": "settings.SecretStore",
                        "attributes": {
                            "fixedInstance": "true",
                            "whenUsed": "true",
                            "block": "program secrets",
                            "jsDoc": "Program secrets",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "program secrets",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "settings.program_secrets"
                    }
                }
            },
            "sha": "2efb75d7dd33baf293da1a87a25d705c5016005ba1acef4dfe01d0981234dbda"
        },
        "libs/buttons": {
            "apis": {
                "byQName": {}
            },
            "sha": "c62b9d9b2fd87ffd2cbad14c7f34d3a8af923104f5bb5c3ef3f744a45ccf495e"
        },
        "libs/accelerometer": {
            "apis": {
                "byQName": {}
            },
            "sha": "a66c8b9d44dbfb3ea078a1f5a9af29e23abf96ae49e8800720b34f9ed0012dea"
        },
        "libs/music": {
            "apis": {
                "byQName": {
                    "control": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 90,
                            "color": "#FF5722",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Program controls and events."
                        }
                    },
                    "pins": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#A80000",
                            "weight": 85,
                            "icon": "",
                            "advanced": true,
                            "groups": [
                                "other",
                                "Servo",
                                "i2c"
                            ],
                            "jsDoc": "Control currents in Pins for analog/digital signals, servos, i2c, ..."
                        }
                    },
                    "loops": {
                        "kind": 5,
                        "retType": ""
                    },
                    "input": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#B4009E",
                            "weight": 98,
                            "icon": "",
                            "groups": [
                                "other",
                                "More"
                            ],
                            "jsDoc": "Respond to and read data from buttons and sensors.\n\nEvents and data from sensors."
                        }
                    },
                    "console": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 12,
                            "color": "#002050",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Reading and writing data to the console output."
                        }
                    },
                    "AnalogInOutPin": {
                        "kind": 9,
                        "retType": "AnalogInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInOutPin",
                            "AnalogInPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "light": {
                        "kind": 5,
                        "retType": ""
                    },
                    "SoundOutputDestination": {
                        "kind": 6,
                        "retType": "SoundOutputDestination",
                        "extendsTypes": [
                            "SoundOutputDestination",
                            "Number"
                        ]
                    },
                    "SoundOutputDestination.Pin": {
                        "retType": "SoundOutputDestination.Pin",
                        "attributes": {
                            "block": "pin",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pin",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "SoundOutputDestination.Pin",
                            "Number"
                        ],
                        "pyQName": "SoundOutputDestination.PIN"
                    },
                    "SoundOutputDestination.Speaker": {
                        "retType": "SoundOutputDestination.Speaker",
                        "attributes": {
                            "block": "speaker",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "speaker",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "SoundOutputDestination.Speaker",
                            "Number"
                        ],
                        "pyQName": "SoundOutputDestination.SPEAKER"
                    },
                    "music": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#E30FC0",
                            "weight": 90,
                            "icon": "",
                            "blockGap": "8",
                            "groups": [
                                "Sounds",
                                "Melody",
                                "Tone",
                                "Volume",
                                "Tempo"
                            ],
                            "jsDoc": "Generation of music tones."
                        }
                    },
                    "music.setTone": {
                        "kind": -3,
                        "attributes": {
                            "help": "music/set-tone",
                            "weight": 1,
                            "group": "Tones",
                            "deprecated": "true",
                            "blockHidden": true,
                            "blockId": "music_set_tone",
                            "block": "set tone %buffer",
                            "jsDoc": "This function is deprecated.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set tone ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "buffer",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "buffer",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "buffer",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "music.set_tone"
                    },
                    "music.setVolume": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "volume": "128"
                            },
                            "blockId": "synth_set_volume",
                            "block": "set volume %volume",
                            "parts": "speaker",
                            "paramMin": {
                                "volume": "0"
                            },
                            "paramMax": {
                                "volume": "256"
                            },
                            "help": "music/set-volume",
                            "weight": 70,
                            "group": "Volume",
                            "paramHelp": {
                                "volume": "the volume 0...256, eg: 128"
                            },
                            "jsDoc": "Set the output volume of the sound synthesizer.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set volume ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "volume",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "volume",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "volume",
                                "description": "the volume 0...256, eg: 128",
                                "default": "128",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "256"
                                    }
                                }
                            }
                        ],
                        "pyQName": "music.set_volume"
                    },
                    "music.playTone": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "frequency": "Note.C",
                                "ms": "BeatFraction.Half"
                            },
                            "callingConvention": 1,
                            "help": "music/play-tone",
                            "blockId": "music_play_note",
                            "block": "play tone|at %note=device_note|for %duration=device_beat",
                            "parts": "headphone",
                            "async": "true",
                            "blockNamespace": "music",
                            "weight": 76,
                            "blockGap": "8",
                            "group": "Tone",
                            "paramHelp": {
                                "frequency": "pitch of the tone to play in Hertz (Hz), eg: Note.C",
                                "ms": "tone duration in milliseconds (ms), eg: BeatFraction.Half"
                            },
                            "jsDoc": "Play a tone through the speaker for some amount of time.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "play tone",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "note",
                                        "shadowBlockId": "device_note",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "for ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "device_beat",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "note",
                                        "shadowBlockId": "device_note",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "device_beat",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "frequency",
                                "description": "pitch of the tone to play in Hertz (Hz), eg: Note.C",
                                "default": "Note.C"
                            },
                            {
                                "name": "ms",
                                "description": "tone duration in milliseconds (ms), eg: BeatFraction.Half",
                                "default": "BeatFraction.Half"
                            }
                        ],
                        "pyQName": "music.play_tone"
                    },
                    "Sounds": {
                        "kind": 6,
                        "retType": "Sounds",
                        "extendsTypes": [
                            "Sounds",
                            "Number"
                        ]
                    },
                    "Sounds.PewPew": {
                        "retType": "Sounds.PewPew",
                        "attributes": {
                            "block": "pew pew",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pew pew",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Sounds.PewPew",
                            "Number"
                        ],
                        "pyQName": "Sounds.PEW_PEW"
                    },
                    "music.playSound": {
                        "kind": -3,
                        "attributes": {
                            "help": "music/play-sound",
                            "blockId": "music_play_sound",
                            "block": "play sound %sound=music_sounds",
                            "parts": "headphone",
                            "weight": 95,
                            "blockGap": "8",
                            "paramHelp": {
                                "sound": "the melody to play"
                            },
                            "jsDoc": "Start playing a sound and don't wait for it to finish.\nNotes are expressed as a string of characters with this format: NOTE[octave][:duration]",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "play sound ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "shadowBlockId": "music_sounds",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "shadowBlockId": "music_sounds",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "sound",
                                "description": "the melody to play",
                                "type": "string"
                            }
                        ],
                        "pyQName": "music.play_sound"
                    },
                    "music.playSoundUntilDone": {
                        "kind": -3,
                        "attributes": {
                            "help": "music/play-sound-until-done",
                            "blockId": "music_play_sound_until_done",
                            "block": "play sound %sound=music_sounds|until done",
                            "parts": "headphone",
                            "weight": 94,
                            "blockGap": "8",
                            "paramHelp": {
                                "sound": "the melody to play"
                            },
                            "jsDoc": "Play a sound and wait until the sound is done.\nNotes are expressed as a string of characters with this format: NOTE[octave][:duration]",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "play sound ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "shadowBlockId": "music_sounds",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "until done",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "shadowBlockId": "music_sounds",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "sound",
                                "description": "the melody to play",
                                "type": "string"
                            }
                        ],
                        "pyQName": "music.play_sound_until_done"
                    },
                    "music.stopAllSounds": {
                        "kind": -3,
                        "attributes": {
                            "help": "music/stop-all-sounds",
                            "blockId": "music_stop_all_sounds",
                            "block": "stop all sounds",
                            "weight": 93,
                            "jsDoc": "Stop all sounds from playing.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "stop all sounds",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "music.stop_all_sounds"
                    }
                }
            },
            "sha": "e2adc685855d91471c99944afa923dbc51ebcf44b56aa6a15a3b96f3effa7ec7"
        },
        "libs/mixer": {
            "apis": {
                "byQName": {
                    "control": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 90,
                            "color": "#FF5722",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Program controls and events."
                        }
                    },
                    "pins": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#A80000",
                            "weight": 85,
                            "icon": "",
                            "advanced": true,
                            "groups": [
                                "other",
                                "Servo",
                                "i2c"
                            ],
                            "jsDoc": "Control currents in Pins for analog/digital signals, servos, i2c, ..."
                        }
                    },
                    "loops": {
                        "kind": 5,
                        "retType": ""
                    },
                    "input": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#B4009E",
                            "weight": 98,
                            "icon": "",
                            "groups": [
                                "other",
                                "More"
                            ],
                            "jsDoc": "Respond to and read data from buttons and sensors.\n\nEvents and data from sensors."
                        }
                    },
                    "console": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 12,
                            "color": "#002050",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Reading and writing data to the console output."
                        }
                    },
                    "AnalogInOutPin": {
                        "kind": 9,
                        "retType": "AnalogInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInOutPin",
                            "AnalogInPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "light": {
                        "kind": 5,
                        "retType": ""
                    },
                    "music": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#E30FC0",
                            "weight": 90,
                            "icon": "",
                            "blockGap": "8",
                            "groups": [
                                "Sounds",
                                "Melody",
                                "Tone",
                                "Volume",
                                "Tempo"
                            ],
                            "jsDoc": "Generation of music tones."
                        }
                    }
                }
            },
            "sha": "c3eea41d5734bb97c3bbf33cfeafc387c9dd930a7b1d6cf6bd6196e7c9888dc3"
        },
        "libs/mixer---samd": {
            "apis": {
                "byQName": {}
            },
            "sha": "c3eea41d5734bb97c3bbf33cfeafc387c9dd930a7b1d6cf6bd6196e7c9888dc3"
        },
        "libs/microphone": {
            "apis": {
                "byQName": {}
            },
            "sha": "4ebb1a90e1f8dd6f80076179c3833f19febcf35efa4158e2504d8dfde7adb0c6"
        },
        "libs/lightsensor": {
            "apis": {
                "byQName": {}
            },
            "sha": "1430e116081698b630c2b236d40f2c3fb9576e5eae82e28cbd79d072d04c110f"
        },
        "libs/thermometer": {
            "apis": {
                "byQName": {}
            },
            "sha": "d3f1c890d47e8dabc4b9ad6289cf91fb39c3373dd11e37b57bdb28c35a050582"
        },
        "libs/color": {
            "apis": {
                "byQName": {}
            },
            "sha": "6aaa8dfd8ea29364e8dc704ff2f3140bee565a2ca96ab3d143214e209049e0a8"
        },
        "libs/light": {
            "apis": {
                "byQName": {}
            },
            "sha": "2798e6cb19d688ab459a2bd16fd3179896622148ed672194e677677b159b2bf0"
        },
        "libs/touch": {
            "apis": {
                "byQName": {}
            },
            "sha": "01ce5a24b18a7532748d8376e1383d24815b357523d480251eb799b7d3b3e452"
        },
        "libs/switch": {
            "apis": {
                "byQName": {}
            },
            "sha": "885284c52f41a4589ddf41150a618c3a0b26f27dec7bd5fcc47e398843188f6a"
        },
        "libs/pulse": {
            "apis": {
                "byQName": {}
            },
            "sha": "335a03686fd647793de2e8081c447ec611618379ba5f2d889560f7aeb7a1a710"
        },
        "libs/cable": {
            "apis": {
                "byQName": {
                    "control": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 90,
                            "color": "#FF5722",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Program controls and events."
                        }
                    },
                    "pins": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#A80000",
                            "weight": 85,
                            "icon": "",
                            "advanced": true,
                            "groups": [
                                "other",
                                "Servo",
                                "i2c"
                            ],
                            "jsDoc": "Control currents in Pins for analog/digital signals, servos, i2c, ..."
                        }
                    },
                    "loops": {
                        "kind": 5,
                        "retType": ""
                    },
                    "input": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#B4009E",
                            "weight": 98,
                            "icon": "",
                            "groups": [
                                "other",
                                "More"
                            ],
                            "jsDoc": "Respond to and read data from buttons and sensors.\n\nEvents and data from sensors."
                        }
                    },
                    "console": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 12,
                            "color": "#002050",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Reading and writing data to the console output."
                        }
                    },
                    "AnalogInOutPin": {
                        "kind": 9,
                        "retType": "AnalogInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInOutPin",
                            "AnalogInPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "light": {
                        "kind": 5,
                        "retType": ""
                    },
                    "network.cableSendPacket": {
                        "kind": -3,
                        "attributes": {
                            "parts": "cable",
                            "jsDoc": "Send data over cable."
                        },
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "network.cable_send_packet"
                    },
                    "network.cablePacket": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "parts": "cable",
                            "jsDoc": "Get most recent packet received over cable."
                        },
                        "parameters": [],
                        "pyQName": "network.cable_packet"
                    },
                    "network.onCablePacket": {
                        "kind": -3,
                        "attributes": {
                            "parts": "cable",
                            "jsDoc": "Run action after a packet is recieved over cable."
                        },
                        "parameters": [
                            {
                                "name": "body",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "network.on_cable_packet"
                    },
                    "network.onCableError": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Run action after there's an error reciving packet over cable."
                        },
                        "parameters": [
                            {
                                "name": "body",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "network.on_cable_error"
                    },
                    "CablePacket": {
                        "kind": 8,
                        "retType": "CablePacket",
                        "extendsTypes": []
                    },
                    "CablePacket.receivedNumber": {
                        "kind": 2,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "The first number in the payload."
                        },
                        "isInstance": true,
                        "pyQName": "CablePacket.received_number"
                    },
                    "CablePacket.receivedNumbers": {
                        "kind": 2,
                        "retType": "number[]",
                        "attributes": {
                            "jsDoc": "The array of numbers of received."
                        },
                        "isInstance": true,
                        "pyQName": "CablePacket.received_numbers"
                    },
                    "CablePacket.receivedBuffer": {
                        "kind": 2,
                        "retType": "Buffer",
                        "attributes": {
                            "jsDoc": "The raw buffer of data received"
                        },
                        "isInstance": true,
                        "pyQName": "CablePacket.received_buffer"
                    },
                    "network.cableSendNumber": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "cable_send_number",
                            "block": "cable send number %value",
                            "help": "network/cable-send-number",
                            "parts": "cable",
                            "group": "Cable",
                            "weight": 90,
                            "paramHelp": {
                                "value": "number to send"
                            },
                            "jsDoc": "Send a number over the cable.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "cable send number ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "number to send"
                            }
                        ],
                        "pyQName": "network.cable_send_number"
                    },
                    "network.cableSendNumbers": {
                        "kind": -3,
                        "attributes": {
                            "parts": "cable",
                            "group": "Cable",
                            "paramHelp": {
                                "values": ""
                            },
                            "jsDoc": "Send an array of numbers over the cable. The array size has to be 32 bytes or less."
                        },
                        "parameters": [
                            {
                                "name": "values",
                                "type": "number[]"
                            }
                        ],
                        "pyQName": "network.cable_send_numbers"
                    },
                    "network.onCableReceivedNumber": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "on_cable_received",
                            "block": "on cable received",
                            "blockGap": "8",
                            "help": "network/on-cable-received-number",
                            "parts": "cable",
                            "group": "Cable",
                            "jsDoc": "Run some code when a number value comes across the cable.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on cable received",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "(num: number) => void",
                                "handlerParameters": [
                                    {
                                        "name": "num",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "network.on_cable_received_number"
                    },
                    "network.onCableReceivedNumbers": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Run some code when the cable receives a list of numbers."
                        },
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "(nums: number[]) => void",
                                "handlerParameters": [
                                    {
                                        "name": "nums",
                                        "type": "number[]"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "network.on_cable_received_numbers"
                    },
                    "network.onCableReceivedBuffer": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Run some code when the cable receives data a buffer."
                        },
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "(buf: Buffer) => void",
                                "handlerParameters": [
                                    {
                                        "name": "buf",
                                        "type": "Buffer"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "network.on_cable_received_buffer"
                    },
                    "network.onCablePacketReceived": {
                        "kind": -3,
                        "attributes": {
                            "mutate": "objectdestructuring",
                            "mutateText": "CablePacket",
                            "mutateDefaults": "receivedNumber",
                            "blockId": "cable_on_packet_received",
                            "block": "on cable received",
                            "blockGap": "8",
                            "parts": "cable",
                            "group": "Cable",
                            "blockHidden": true,
                            "deprecated": "1",
                            "jsDoc": "Run some code when the cable receiver gets a packet.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on cable received",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [
                            {
                                "name": "cb",
                                "type": "(p: CablePacket) => void"
                            }
                        ],
                        "pyQName": "network.on_cable_packet_received"
                    }
                }
            },
            "sha": "cdf8a724481f2a75ddbe4a7305fd741da7c044baeb0159fa3498d76f0f26fadb"
        },
        "libs/infrared": {
            "apis": {
                "byQName": {}
            },
            "sha": "f1066547a1cddcb620ef1b10db1a41b662172d89b6d91c2f3a53e9b928234e46"
        },
        "libs/circuit-playground": {
            "apis": {
                "byQName": {
                    "Array": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "blockNamespace": "Arrays",
                            "jsDoc": "Add, remove, and replace items in lists."
                        }
                    },
                    "Array.length": {
                        "kind": 2,
                        "retType": "number",
                        "attributes": {
                            "weight": 84,
                            "blockId": "lists_length",
                            "block": "length of %VALUE",
                            "blockBuiltin": "true",
                            "blockNamespace": "arrays",
                            "jsDoc": "Get or set the length of an array. This number is one more than the index of the last element the array.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "length of ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "VALUE",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "VALUE",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "isInstance": true
                    },
                    "Array.push": {
                        "kind": -1,
                        "attributes": {
                            "help": "arrays/push",
                            "weight": 50,
                            "blockId": "array_push",
                            "block": "%list| add value %value| to end",
                            "blockNamespace": "arrays",
                            "group": "Modify",
                            "paramHelp": {
                                "items": "New elements of the Array."
                            },
                            "jsDoc": "Append a new element to an array.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " add value ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " to end",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "item",
                                "type": "T"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Array.append"
                    },
                    "Array.concat": {
                        "kind": -1,
                        "retType": "T[]",
                        "attributes": {
                            "helper": "arrayConcat",
                            "weight": 40,
                            "paramHelp": {
                                "arr": "The other array that is being concatenated with"
                            },
                            "jsDoc": "Concatenates the values with another array."
                        },
                        "parameters": [
                            {
                                "name": "arr",
                                "description": "The other array that is being concatenated with",
                                "type": "T[]"
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.pop": {
                        "kind": -1,
                        "retType": "T",
                        "attributes": {
                            "help": "arrays/pop",
                            "weight": 45,
                            "blockId": "array_pop",
                            "block": "get and remove last value from %list",
                            "blockNamespace": "arrays",
                            "group": "Read",
                            "jsDoc": "Remove the last element from an array and return it.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "get and remove last value from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "Array.reverse": {
                        "kind": -1,
                        "attributes": {
                            "help": "arrays/reverse",
                            "helper": "arrayReverse",
                            "weight": 10,
                            "blockId": "array_reverse",
                            "block": "reverse %list",
                            "blockNamespace": "arrays",
                            "group": "Operations",
                            "jsDoc": "Reverse the elements in an array. The first array element becomes the last, and the last array element becomes the first.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "reverse ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "Array.shift": {
                        "kind": -1,
                        "retType": "T",
                        "attributes": {
                            "help": "arrays/shift",
                            "helper": "arrayShift",
                            "weight": 30,
                            "blockId": "array_shift",
                            "block": "get and remove first value from %list",
                            "blockNamespace": "arrays",
                            "group": "Read",
                            "jsDoc": "Remove the first element from an array and return it. This method changes the length of the array.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "get and remove first value from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "Array.unshift": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "help": "arrays/unshift",
                            "helper": "arrayUnshift",
                            "weight": 25,
                            "blockId": "array_unshift",
                            "block": "%list| insert %value| at beginning",
                            "blockNamespace": "arrays",
                            "group": "Modify",
                            "paramHelp": {
                                "element": "to insert at the start of the Array."
                            },
                            "jsDoc": "Add one element to the beginning of an array and return the new length of the array.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " insert ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " at beginning",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "type": "T"
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.slice": {
                        "kind": -1,
                        "retType": "T[]",
                        "attributes": {
                            "paramDefl": {
                                "start": "0",
                                "end": "0"
                            },
                            "help": "arrays/slice",
                            "helper": "arraySlice",
                            "weight": 41,
                            "blockNamespace": "arrays",
                            "paramHelp": {
                                "start": "The beginning of the specified portion of the array. eg: 0",
                                "end": "The end of the specified portion of the array. eg: 0"
                            },
                            "jsDoc": "Return a section of an array."
                        },
                        "parameters": [
                            {
                                "name": "start",
                                "description": "The beginning of the specified portion of the array. eg: 0",
                                "initializer": "undefined",
                                "default": "0"
                            },
                            {
                                "name": "end",
                                "description": "The end of the specified portion of the array. eg: 0",
                                "initializer": "undefined",
                                "default": "0"
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.splice": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "start": "0",
                                "deleteCount": "0"
                            },
                            "helper": "arraySplice",
                            "weight": 40,
                            "paramHelp": {
                                "start": "The zero-based location in the array from which to start removing elements. eg: 0",
                                "deleteCount": "The number of elements to remove. eg: 0"
                            },
                            "jsDoc": "Remove elements from an array."
                        },
                        "parameters": [
                            {
                                "name": "start",
                                "description": "The zero-based location in the array from which to start removing elements. eg: 0",
                                "default": "0"
                            },
                            {
                                "name": "deleteCount",
                                "description": "The number of elements to remove. eg: 0",
                                "default": "0"
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.join": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "helper": "arrayJoin",
                            "weight": 40,
                            "paramHelp": {
                                "sep": "the string separator"
                            },
                            "jsDoc": "joins all elements of an array into a string and returns this string."
                        },
                        "parameters": [
                            {
                                "name": "sep",
                                "description": "the string separator",
                                "type": "string",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.some": {
                        "kind": -1,
                        "retType": "boolean",
                        "attributes": {
                            "helper": "arraySome",
                            "weight": 40,
                            "paramHelp": {
                                "callbackfn": "A function that accepts up to two arguments. The some method calls the callbackfn function one time for each element in the array."
                            },
                            "jsDoc": "Tests whether at least one element in the array passes the test implemented by the provided function."
                        },
                        "parameters": [
                            {
                                "name": "callbackfn",
                                "description": "A function that accepts up to two arguments. The some method calls the callbackfn function one time for each element in the array.",
                                "type": "(value: T, index: number) => boolean",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.every": {
                        "kind": -1,
                        "retType": "boolean",
                        "attributes": {
                            "helper": "arrayEvery",
                            "weight": 40,
                            "paramHelp": {
                                "callbackfn": "A function that accepts up to two arguments. The every method calls the callbackfn function one time for each element in the array."
                            },
                            "jsDoc": "Tests whether all elements in the array pass the test implemented by the provided function."
                        },
                        "parameters": [
                            {
                                "name": "callbackfn",
                                "description": "A function that accepts up to two arguments. The every method calls the callbackfn function one time for each element in the array.",
                                "type": "(value: T, index: number) => boolean",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.sort": {
                        "kind": -1,
                        "retType": "T[]",
                        "attributes": {
                            "helper": "arraySort",
                            "weight": 40,
                            "paramHelp": {
                                "specifies": "a function that defines the sort order. If omitted, the array is sorted according to the prmitive type"
                            },
                            "jsDoc": "Sort the elements of an array in place and returns the array. The sort is not necessarily stable."
                        },
                        "parameters": [
                            {
                                "name": "callbackfn",
                                "type": "(value1: T, value2: T) => number",
                                "initializer": "undefined",
                                "handlerParameters": [
                                    {
                                        "name": "value1",
                                        "type": "T"
                                    },
                                    {
                                        "name": "value2",
                                        "type": "T"
                                    }
                                ]
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.map": {
                        "kind": -1,
                        "retType": "U[]",
                        "attributes": {
                            "helper": "arrayMap",
                            "weight": 40,
                            "paramHelp": {
                                "callbackfn": "A function that accepts up to two arguments. The map method calls the callbackfn function one time for each element in the array."
                            },
                            "jsDoc": "Call a defined callback function on each element of an array, and return an array containing the results."
                        },
                        "parameters": [
                            {
                                "name": "callbackfn",
                                "description": "A function that accepts up to two arguments. The map method calls the callbackfn function one time for each element in the array.",
                                "type": "(value: T, index: number) => U",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.forEach": {
                        "kind": -1,
                        "attributes": {
                            "helper": "arrayForEach",
                            "weight": 40,
                            "paramHelp": {
                                "callbackfn": "A function that accepts up to two arguments. The forEach method calls the callbackfn function one time for each element in the array."
                            },
                            "jsDoc": "Call a defined callback function on each element of an array."
                        },
                        "parameters": [
                            {
                                "name": "callbackfn",
                                "description": "A function that accepts up to two arguments. The forEach method calls the callbackfn function one time for each element in the array.",
                                "type": "(value: T, index: number) => void",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Array.for_each"
                    },
                    "Array.filter": {
                        "kind": -1,
                        "retType": "T[]",
                        "attributes": {
                            "helper": "arrayFilter",
                            "weight": 40,
                            "paramHelp": {
                                "callbackfn": "A function that accepts up to two arguments. The filter method calls the callbackfn function one time for each element in the array."
                            },
                            "jsDoc": "Return the elements of an array that meet the condition specified in a callback function."
                        },
                        "parameters": [
                            {
                                "name": "callbackfn",
                                "description": "A function that accepts up to two arguments. The filter method calls the callbackfn function one time for each element in the array.",
                                "type": "(value: T, index: number) => boolean",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.fill": {
                        "kind": -1,
                        "retType": "T[]",
                        "attributes": {
                            "helper": "arrayFill",
                            "weight": 39,
                            "jsDoc": "Fills all the elements of an array from a start index to an end index with a static value. The end index is not included."
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "type": "T"
                            },
                            {
                                "name": "start",
                                "initializer": "undefined"
                            },
                            {
                                "name": "end",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.find": {
                        "kind": -1,
                        "retType": "T",
                        "attributes": {
                            "helper": "arrayFind",
                            "weight": 40,
                            "paramHelp": {
                                "callbackfn": ""
                            },
                            "jsDoc": "Returns the value of the first element in the array that satisfies the provided testing function. Otherwise undefined is returned."
                        },
                        "parameters": [
                            {
                                "name": "callbackfn",
                                "type": "(value: T, index: number) => boolean",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.reduce": {
                        "kind": -1,
                        "retType": "U",
                        "attributes": {
                            "helper": "arrayReduce",
                            "weight": 40,
                            "paramHelp": {
                                "callbackfn": "A function that accepts up to three arguments. The reduce method calls the callbackfn function one time for each element in the array.",
                                "initialValue": "Initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value."
                            },
                            "jsDoc": "Call the specified callback function for all the elements in an array. The return value of the callback function is the accumulated result, and is provided as an argument in the next call to the callback function."
                        },
                        "parameters": [
                            {
                                "name": "callbackfn",
                                "description": "A function that accepts up to three arguments. The reduce method calls the callbackfn function one time for each element in the array.",
                                "type": "(previousValue: U, currentValue: T, currentIndex: number) => U",
                                "handlerParameters": [
                                    {
                                        "name": "previousValue",
                                        "type": "U"
                                    },
                                    {
                                        "name": "currentValue",
                                        "type": "T"
                                    },
                                    {
                                        "name": "currentIndex",
                                        "type": "number"
                                    }
                                ]
                            },
                            {
                                "name": "initialValue",
                                "description": "Initial value to start the accumulation. The first call to the callbackfn function provides this value as an argument instead of an array value.",
                                "type": "U"
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.removeElement": {
                        "kind": -1,
                        "retType": "boolean",
                        "attributes": {
                            "weight": 48,
                            "jsDoc": "Remove the first occurence of an object. Returns true if removed."
                        },
                        "parameters": [
                            {
                                "name": "element",
                                "type": "T"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Array.remove_element"
                    },
                    "Array.removeAt": {
                        "kind": -1,
                        "retType": "T",
                        "attributes": {
                            "help": "arrays/remove-at",
                            "weight": 47,
                            "blockId": "array_removeat",
                            "block": "%list| get and remove value at %index",
                            "blockNamespace": "arrays",
                            "group": "Read",
                            "jsDoc": "Remove the element at a certain index.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " get and remove value at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "index"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Array.remove_at"
                    },
                    "Array.insertAt": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "index": "0",
                                "the": "0"
                            },
                            "help": "arrays/insert-at",
                            "weight": 20,
                            "blockId": "array_insertAt",
                            "block": "%list| insert at %index| value %value",
                            "blockNamespace": "arrays",
                            "group": "Modify",
                            "paramHelp": {
                                "index": "the zero-based position in the list to insert the value, eg: 0",
                                "the": "value to insert, eg: 0"
                            },
                            "jsDoc": "Insert the value at a particular index, increases length by 1",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " insert at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " value ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "index",
                                "description": "the zero-based position in the list to insert the value, eg: 0",
                                "default": "0"
                            },
                            {
                                "name": "value",
                                "type": "T"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Array.insert_at"
                    },
                    "Array.indexOf": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "help": "arrays/index-of",
                            "weight": 40,
                            "blockId": "array_indexof",
                            "block": "%list| find index of %value",
                            "blockNamespace": "arrays",
                            "group": "Operations",
                            "paramHelp": {
                                "item": "The value to locate in the array.",
                                "fromIndex": "The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0."
                            },
                            "jsDoc": "Return the index of the first occurrence of a value in an array.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " find index of ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "item",
                                "description": "The value to locate in the array.",
                                "type": "T"
                            },
                            {
                                "name": "fromIndex",
                                "description": "The array index at which to begin the search. If fromIndex is omitted, the search starts at index 0.",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Array.index"
                    },
                    "Array.get": {
                        "kind": -1,
                        "retType": "T",
                        "attributes": {
                            "paramDefl": {
                                "index": "0"
                            },
                            "help": "arrays/get",
                            "weight": 85,
                            "paramHelp": {
                                "index": "the zero-based position in the list of the item, eg: 0"
                            },
                            "jsDoc": "Get the value at a particular index"
                        },
                        "parameters": [
                            {
                                "name": "index",
                                "description": "the zero-based position in the list of the item, eg: 0",
                                "default": "0"
                            }
                        ],
                        "isInstance": true
                    },
                    "Array.set": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "index": "0",
                                "value": "0"
                            },
                            "help": "arrays/set",
                            "weight": 84,
                            "paramHelp": {
                                "index": "the zero-based position in the list to store the value, eg: 0",
                                "value": "the value to insert, eg: 0"
                            },
                            "jsDoc": "Store a value at a particular index"
                        },
                        "parameters": [
                            {
                                "name": "index",
                                "description": "the zero-based position in the list to store the value, eg: 0",
                                "default": "0"
                            },
                            {
                                "name": "value",
                                "description": "the value to insert, eg: 0",
                                "type": "T",
                                "default": "0"
                            }
                        ],
                        "isInstance": true
                    },
                    "Array._pickRandom": {
                        "kind": -1,
                        "retType": "T",
                        "attributes": {
                            "help": "arrays/pick-random",
                            "helper": "arrayPickRandom",
                            "weight": 25,
                            "blockId": "array_pickRandom",
                            "block": "get random value from %list",
                            "blockNamespace": "arrays",
                            "group": "Read",
                            "jsDoc": "Return a random value from the array",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "get random value from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "Array._pick_random"
                    },
                    "Array._unshiftStatement": {
                        "kind": -1,
                        "attributes": {
                            "help": "arrays/unshift",
                            "helper": "arrayUnshift",
                            "weight": 24,
                            "blockId": "array_unshift_statement",
                            "block": "%list| insert %value| at beginning",
                            "blockNamespace": "arrays",
                            "blockAliasFor": "Array.unshift",
                            "group": "Modify",
                            "paramHelp": {
                                "element": "to insert at the start of the Array."
                            },
                            "jsDoc": "Add one element to the beginning of an array and return the new length of the array.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " insert ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " at beginning",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "type": "T"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Array._unshift_statement"
                    },
                    "Array._popStatement": {
                        "kind": -1,
                        "attributes": {
                            "help": "arrays/pop",
                            "weight": 44,
                            "blockId": "array_pop_statement",
                            "block": "remove last value from %list",
                            "blockNamespace": "arrays",
                            "blockAliasFor": "Array.pop",
                            "group": "Modify",
                            "jsDoc": "Remove the last element from an array and return it.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "remove last value from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "Array._pop_statement"
                    },
                    "Array._shiftStatement": {
                        "kind": -1,
                        "attributes": {
                            "help": "arrays/shift",
                            "helper": "arrayShift",
                            "weight": 29,
                            "blockId": "array_shift_statement",
                            "block": "remove first value from %list",
                            "blockNamespace": "arrays",
                            "blockAliasFor": "Array.shift",
                            "group": "Modify",
                            "jsDoc": "Remove the first element from an array and return it. This method changes the length of the array.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "remove first value from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "Array._shift_statement"
                    },
                    "Array._removeAtStatement": {
                        "kind": -1,
                        "attributes": {
                            "help": "arrays/remove-at",
                            "weight": 14,
                            "blockId": "array_removeat_statement",
                            "block": "%list| remove value at %index",
                            "blockNamespace": "arrays",
                            "blockAliasFor": "Array.removeAt",
                            "group": "Modify",
                            "jsDoc": "Remove the element at a certain index.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " remove value at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "list",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "index"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Array._remove_at_statement"
                    },
                    "String": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "blockNamespace": "text",
                            "jsDoc": "Combine, split, and search text strings."
                        }
                    },
                    "String.concat": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "weight": 49,
                            "blockId": "string_concat",
                            "blockNamespace": "text",
                            "paramHelp": {
                                "other": "The string to append to the end of the string."
                            },
                            "jsDoc": "Returns a string that contains the concatenation of two or more strings."
                        },
                        "parameters": [
                            {
                                "name": "other",
                                "description": "The string to append to the end of the string.",
                                "type": "string"
                            }
                        ],
                        "isInstance": true
                    },
                    "String.charAt": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "weight": 48,
                            "help": "text/char-at",
                            "blockId": "string_get",
                            "block": "char from %this=text|at %pos",
                            "blockNamespace": "text",
                            "paramHelp": {
                                "index": "The zero-based index of the desired character."
                            },
                            "jsDoc": "Return the character at the specified index.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "char from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pos",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pos",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "index",
                                "description": "The zero-based index of the desired character."
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "String.char_at"
                    },
                    "String.length": {
                        "kind": 2,
                        "retType": "number",
                        "attributes": {
                            "property": "true",
                            "weight": 47,
                            "blockId": "text_length",
                            "block": "length of %VALUE",
                            "blockBuiltin": "true",
                            "blockNamespace": "text",
                            "jsDoc": "Returns the length of a String object.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "length of ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "VALUE",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "VALUE",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "isInstance": true
                    },
                    "String.charCodeAt": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "index": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
                            },
                            "jsDoc": "Return the Unicode value of the character at the specified location."
                        },
                        "parameters": [
                            {
                                "name": "index",
                                "description": "The zero-based index of the desired character. If there is no character at the specified index, NaN is returned."
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "String.char_code_at"
                    },
                    "String.compare": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "help": "text/compare",
                            "blockId": "string_compare",
                            "block": "compare %this=text| to %that",
                            "blockNamespace": "text",
                            "paramHelp": {
                                "that": "String to compare to target string"
                            },
                            "jsDoc": "See how the order of characters in two strings is different (in ASCII encoding).",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "compare ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "that",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "that",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "that",
                                "description": "String to compare to target string",
                                "type": "string"
                            }
                        ],
                        "isInstance": true
                    },
                    "String.substr": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "paramDefl": {
                                "start": "0",
                                "length": "10"
                            },
                            "helper": "stringSubstr",
                            "help": "text/substr",
                            "blockId": "string_substr",
                            "block": "substring of %this=text|from %start|of length %length",
                            "blockNamespace": "text",
                            "paramHelp": {
                                "start": "first character index; can be negative from counting from the end, eg:0",
                                "length": "number of characters to extract, eg: 10"
                            },
                            "jsDoc": "Return a substring of the current string.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "substring of ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "start",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "of length ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "length",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "start",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "length",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "start",
                                "description": "first character index; can be negative from counting from the end, eg:0",
                                "default": "0"
                            },
                            {
                                "name": "length",
                                "description": "number of characters to extract, eg: 10",
                                "initializer": "undefined",
                                "default": "10"
                            }
                        ],
                        "isInstance": true
                    },
                    "String.replace": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "helper": "stringReplace",
                            "paramHelp": {
                                "toReplace": "the substring to replace in the current string",
                                "replacer": "either the string that replaces toReplace in the current string,"
                            },
                            "jsDoc": "Return the current string with the first occurence of toReplace\nreplaced with the replacer\n\n\nor a function that accepts the substring and returns the replacement string."
                        },
                        "parameters": [
                            {
                                "name": "toReplace",
                                "description": "the substring to replace in the current string",
                                "type": "string"
                            },
                            {
                                "name": "replacer",
                                "description": "either the string that replaces toReplace in the current string,",
                                "type": "string | ((sub: string) => string)"
                            }
                        ],
                        "isInstance": true
                    },
                    "String.replaceAll": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "helper": "stringReplaceAll",
                            "paramHelp": {
                                "toReplace": "the substring to replace in the current string",
                                "replacer": "either the string that replaces toReplace in the current string,"
                            },
                            "jsDoc": "Return the current string with each occurence of toReplace\nreplaced with the replacer\n\n\nor a function that accepts the substring and returns the replacement string."
                        },
                        "parameters": [
                            {
                                "name": "toReplace",
                                "description": "the substring to replace in the current string",
                                "type": "string"
                            },
                            {
                                "name": "replacer",
                                "description": "either the string that replaces toReplace in the current string,",
                                "type": "string | ((sub: string) => string)"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "String.replace_all"
                    },
                    "String.slice": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "paramDefl": {
                                "start": "0"
                            },
                            "helper": "stringSlice",
                            "paramHelp": {
                                "start": "first character index; can be negative from counting from the end, eg:0",
                                "end": "one-past-last character index"
                            },
                            "jsDoc": "Return a substring of the current string."
                        },
                        "parameters": [
                            {
                                "name": "start",
                                "description": "first character index; can be negative from counting from the end, eg:0",
                                "default": "0"
                            },
                            {
                                "name": "end",
                                "description": "one-past-last character index",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true
                    },
                    "String.isEmpty": {
                        "kind": -1,
                        "retType": "boolean",
                        "attributes": {
                            "helper": "stringEmpty",
                            "help": "text/is-empty",
                            "blockId": "string_isempty",
                            "blockNamespace": "text",
                            "block": "%this=text| is empty",
                            "jsDoc": "Returns a value indicating if the string is empty",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " is empty",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "String.is_empty"
                    },
                    "String.indexOf": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "help": "text/index-of",
                            "blockId": "string_indexof",
                            "blockNamespace": "text",
                            "block": "%this=text|find index of %searchValue",
                            "paramHelp": {
                                "searchValue": "the text to find",
                                "start": "optional start index for the search"
                            },
                            "jsDoc": "Returns the position of the first occurrence of a specified value in a string.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "find index of ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "searchValue",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "searchValue",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "searchValue",
                                "description": "the text to find",
                                "type": "string"
                            },
                            {
                                "name": "start",
                                "description": "optional start index for the search",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "String.index_of"
                    },
                    "String.includes": {
                        "kind": -1,
                        "retType": "boolean",
                        "attributes": {
                            "help": "text/includes",
                            "blockId": "string_includes",
                            "blockNamespace": "text",
                            "block": "%this=text|includes %searchValue",
                            "paramHelp": {
                                "searchValue": "the text to find",
                                "start": "optional start index for the search"
                            },
                            "jsDoc": "Determines whether a string contains the characters of a specified string.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "includes ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "searchValue",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "searchValue",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "searchValue",
                                "description": "the text to find",
                                "type": "string"
                            },
                            {
                                "name": "start",
                                "description": "optional start index for the search",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true
                    },
                    "String.split": {
                        "kind": -1,
                        "retType": "string[]",
                        "attributes": {
                            "helper": "stringSplit",
                            "help": "text/split",
                            "blockId": "string_split",
                            "blockNamespace": "text",
                            "block": "split %this=text|at %separator",
                            "paramHelp": {
                                "separator": "@param limit"
                            },
                            "jsDoc": "Splits the string according to the separators",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "split ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "separator",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "this",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "separator",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "separator",
                                "description": "@param limit",
                                "type": "string",
                                "initializer": "undefined"
                            },
                            {
                                "name": "limit",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true
                    },
                    "String.trim": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "helper": "stringTrim",
                            "jsDoc": "Return a substring of the current string with whitespace removed from both ends"
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "String.toLowerCase": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "helper": "stringToLowerCase",
                            "help": "text/to-lower-case",
                            "jsDoc": "Converts the string to lower case characters."
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "String.to_lower_case"
                    },
                    "parseFloat": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "text": "123",
                                "s": "123"
                            },
                            "help": "text/parse-float",
                            "blockId": "string_parsefloat",
                            "block": "parse to number %text",
                            "blockNamespace": "text",
                            "explicitDefaults": [
                                "text"
                            ],
                            "paramHelp": {
                                "s": "A string to convert into a number. eg: 123"
                            },
                            "jsDoc": "Convert a string to a number.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "parse to number ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "text",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "text",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "text",
                                "type": "string",
                                "initializer": "123",
                                "default": "123"
                            }
                        ],
                        "pyQName": "parse_float"
                    },
                    "randint": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "min": "0",
                                "max": "10"
                            },
                            "blockId": "device_random",
                            "block": "pick random %min|to %limit",
                            "blockNamespace": "Math",
                            "help": "math/randint",
                            "paramHelp": {
                                "min": "the lower inclusive bound, eg: 0",
                                "max": "the upper inclusive bound, eg: 10"
                            },
                            "jsDoc": "Returns a pseudorandom number between min and max included.\nIf both numbers are integral, the result is integral.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pick random ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "min",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "limit",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "min",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "limit",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "min",
                                "description": "the lower inclusive bound, eg: 0",
                                "default": "0"
                            },
                            {
                                "name": "max",
                                "description": "the upper inclusive bound, eg: 10",
                                "default": "10"
                            }
                        ]
                    },
                    "Object": {
                        "kind": 5,
                        "retType": ""
                    },
                    "Function": {
                        "kind": 9,
                        "retType": "Function",
                        "extendsTypes": []
                    },
                    "Function.__assignableToFunction": {
                        "kind": 2,
                        "retType": "Function",
                        "isInstance": true
                    },
                    "IArguments": {
                        "kind": 9,
                        "retType": "IArguments",
                        "extendsTypes": []
                    },
                    "IArguments.__assignableToIArguments": {
                        "kind": 2,
                        "retType": "IArguments",
                        "isInstance": true
                    },
                    "RegExp": {
                        "kind": 9,
                        "retType": "RegExp",
                        "extendsTypes": []
                    },
                    "RegExp.__assignableToRegExp": {
                        "kind": 2,
                        "retType": "RegExp",
                        "isInstance": true
                    },
                    "Boolean": {
                        "kind": 9,
                        "retType": "Boolean",
                        "extendsTypes": []
                    },
                    "Boolean.toString": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "jsDoc": "Returns a string representation of an object."
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "Boolean.to_string"
                    },
                    "String@type": {
                        "kind": 9,
                        "retType": "String",
                        "attributes": {
                            "blockNamespace": "text",
                            "jsDoc": "Combine, split, and search text strings."
                        },
                        "extendsTypes": [],
                        "pyQName": "String"
                    },
                    "String.fromCharCode": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "help": "math/from-char-code",
                            "weight": 1,
                            "blockNamespace": "text",
                            "blockId": "stringFromCharCode",
                            "block": "text from char code %code",
                            "jsDoc": "Make a string from the given ASCII character code.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "text from char code ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "code",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "code",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "code"
                            }
                        ],
                        "pyQName": "String.from_char_code"
                    },
                    "Number": {
                        "kind": 5,
                        "retType": "",
                        "extendsTypes": [
                            "Number"
                        ]
                    },
                    "Number.toString": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "jsDoc": "Returns a string representation of a number."
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "Number.to_string"
                    },
                    "Array@type": {
                        "kind": 9,
                        "retType": "T[]",
                        "attributes": {
                            "blockNamespace": "Arrays",
                            "jsDoc": "Add, remove, and replace items in lists."
                        },
                        "extendsTypes": [],
                        "pyQName": "Array"
                    },
                    "Array.isArray": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "jsDoc": "Check if a given object is an array."
                        },
                        "parameters": [
                            {
                                "name": "obj",
                                "type": "any"
                            }
                        ],
                        "pyQName": "Array.is_array"
                    },
                    "Object@type": {
                        "kind": 9,
                        "retType": "Object",
                        "extendsTypes": [],
                        "pyQName": "Object"
                    },
                    "Object.keys": {
                        "kind": -3,
                        "retType": "string[]",
                        "attributes": {
                            "jsDoc": "Return the field names in an object."
                        },
                        "parameters": [
                            {
                                "name": "obj",
                                "type": "any"
                            }
                        ]
                    },
                    "Math": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "jsDoc": "More complex operations with numbers."
                        }
                    },
                    "Math.pow": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "The base value of the expression.",
                                "y": "The exponent value of the expression."
                            },
                            "jsDoc": "Returns the value of a base expression taken to a specified power."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "The base value of the expression."
                            },
                            {
                                "name": "y",
                                "description": "The exponent value of the expression."
                            }
                        ]
                    },
                    "Math.random": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math/random",
                            "jsDoc": "Returns a pseudorandom number between 0 and 1."
                        },
                        "parameters": []
                    },
                    "Math.randomRange": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "min": "0",
                                "max": "10"
                            },
                            "blockId": "device_random_deprecated",
                            "block": "pick random %min|to %limit",
                            "help": "math/random-range",
                            "deprecated": "true",
                            "paramHelp": {
                                "min": "the lower inclusive bound, eg: 0",
                                "max": "the upper inclusive bound, eg: 10"
                            },
                            "jsDoc": "Returns a pseudorandom number between min and max included.\nIf both numbers are integral, the result is integral.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pick random ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "min",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "limit",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "min",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "limit",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "min",
                                "description": "the lower inclusive bound, eg: 0",
                                "default": "0"
                            },
                            {
                                "name": "max",
                                "description": "the upper inclusive bound, eg: 10",
                                "default": "10"
                            }
                        ],
                        "pyQName": "Math.random_range"
                    },
                    "Math.log": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "A number"
                            },
                            "jsDoc": "Returns the natural logarithm (base e) of a number."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "A number"
                            }
                        ]
                    },
                    "Math.exp": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "A number"
                            },
                            "jsDoc": "Returns returns ``e^x``."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "A number"
                            }
                        ]
                    },
                    "Math.sin": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math/trigonometry",
                            "paramHelp": {
                                "x": "An angle in radians"
                            },
                            "jsDoc": "Returns the sine of a number."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "An angle in radians"
                            }
                        ]
                    },
                    "Math.cos": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math/trigonometry",
                            "paramHelp": {
                                "x": "An angle in radians"
                            },
                            "jsDoc": "Returns the cosine of a number."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "An angle in radians"
                            }
                        ]
                    },
                    "Math.tan": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "An angle in radians"
                            },
                            "jsDoc": "Returns the tangent of a number."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "An angle in radians"
                            }
                        ]
                    },
                    "Math.asin": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "A number"
                            },
                            "jsDoc": "Returns the arcsine (in radians) of a number"
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "A number"
                            }
                        ]
                    },
                    "Math.acos": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "A number"
                            },
                            "jsDoc": "Returns the arccosine (in radians) of a number"
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "A number"
                            }
                        ]
                    },
                    "Math.atan": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "A number"
                            },
                            "jsDoc": "Returns the arctangent (in radians) of a number"
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "A number"
                            }
                        ]
                    },
                    "Math.atan2": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "y": "A number",
                                "x": "A number"
                            },
                            "jsDoc": "Returns the arctangent of the quotient of its arguments."
                        },
                        "parameters": [
                            {
                                "name": "y",
                                "description": "A number"
                            },
                            {
                                "name": "x",
                                "description": "A number"
                            }
                        ]
                    },
                    "Math.sqrt": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "A numeric expression."
                            },
                            "jsDoc": "Returns the square root of a number."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "A numeric expression."
                            }
                        ]
                    },
                    "Math.ceil": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math",
                            "paramHelp": {
                                "x": "A numeric expression."
                            },
                            "jsDoc": "Returns the smallest number greater than or equal to its numeric argument."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "A numeric expression."
                            }
                        ]
                    },
                    "Math.floor": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math",
                            "paramHelp": {
                                "x": "A numeric expression."
                            },
                            "jsDoc": "Returns the greatest number less than or equal to its numeric argument."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "A numeric expression."
                            }
                        ]
                    },
                    "Math.trunc": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math",
                            "paramHelp": {
                                "x": "A numeric expression."
                            },
                            "jsDoc": "Returns the number with the decimal part truncated."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "A numeric expression."
                            }
                        ],
                        "pyQName": "int"
                    },
                    "Math.round": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math",
                            "paramHelp": {
                                "x": "The value to be rounded to the nearest number."
                            },
                            "jsDoc": "Returns a supplied numeric expression rounded to the nearest number."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "The value to be rounded to the nearest number."
                            }
                        ]
                    },
                    "Math.imul": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "The first number",
                                "y": "The second number"
                            },
                            "jsDoc": "Returns the value of integer signed 32 bit multiplication of two numbers."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "The first number"
                            },
                            {
                                "name": "y",
                                "description": "The second number"
                            }
                        ]
                    },
                    "Math.idiv": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "The first number",
                                "y": "The second number"
                            },
                            "jsDoc": "Returns the value of integer signed 32 bit division of two numbers."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "The first number"
                            },
                            {
                                "name": "y",
                                "description": "The second number"
                            }
                        ]
                    },
                    "control": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 90,
                            "color": "#1B998B",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Program controls and events."
                        }
                    },
                    "control._onCodeStart": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "arg",
                                "type": "any"
                            }
                        ],
                        "pyQName": "control._on_code_start"
                    },
                    "control._onCodeStop": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "arg",
                                "type": "any"
                            }
                        ],
                        "pyQName": "control._on_code_stop"
                    },
                    "NaN": {
                        "kind": 4,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Constant representing Not-A-Number."
                        },
                        "pyQName": "na_n"
                    },
                    "Infinity": {
                        "kind": 4,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Constant representing positive infinity."
                        },
                        "pyQName": "infinity"
                    },
                    "isNaN": {
                        "kind": -3,
                        "retType": "boolean",
                        "parameters": [
                            {
                                "name": "x"
                            }
                        ],
                        "pyQName": "is_na_n"
                    },
                    "Number@type": {
                        "kind": 9,
                        "retType": "Number",
                        "extendsTypes": [],
                        "pyQName": "Number"
                    },
                    "Number.isNaN": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "jsDoc": "Check if a given value is of type Number and it is a NaN."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "type": "any"
                            }
                        ],
                        "pyQName": "Number.is_na_n"
                    },
                    "StringMap": {
                        "kind": 9,
                        "retType": "StringMap",
                        "attributes": {
                            "jsDoc": "A dictionary from string key to string values"
                        },
                        "extendsTypes": []
                    },
                    "parseInt": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "text": "123"
                            },
                            "help": "text/parse-int",
                            "blockId": "string_parseint",
                            "block": "parse to integer %text",
                            "blockNamespace": "text",
                            "explicitDefaults": [
                                "text"
                            ],
                            "blockHidden": true,
                            "paramHelp": {
                                "text": "A string to convert into an integral number. eg: \"123\"",
                                "radix": "optional A value between 2 and 36 that specifies the base of the number in text."
                            },
                            "jsDoc": "Convert a string to an integer.\n\n\nIf this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal.\nAll other strings are considered decimal.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "parse to integer ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "text",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "text",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "text",
                                "description": "A string to convert into an integral number. eg: \"123\"",
                                "type": "string",
                                "initializer": "123",
                                "default": "123"
                            },
                            {
                                "name": "radix",
                                "description": "optional A value between 2 and 36 that specifies the base of the number in text.",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "int"
                    },
                    "helpers": {
                        "kind": 5,
                        "retType": ""
                    },
                    "helpers.arrayFill": {
                        "kind": -3,
                        "retType": "T[]",
                        "parameters": [
                            {
                                "name": "O",
                                "type": "T[]"
                            },
                            {
                                "name": "value",
                                "type": "T"
                            },
                            {
                                "name": "start",
                                "initializer": "undefined"
                            },
                            {
                                "name": "end",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "helpers.array_fill"
                    },
                    "helpers.arraySplice": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "start"
                            },
                            {
                                "name": "len"
                            }
                        ],
                        "pyQName": "helpers.array_splice"
                    },
                    "helpers.arrayReverse": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            }
                        ],
                        "pyQName": "helpers.array_reverse"
                    },
                    "helpers.arrayShift": {
                        "kind": -3,
                        "retType": "T",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            }
                        ],
                        "pyQName": "helpers.array_shift"
                    },
                    "helpers.arrayJoin": {
                        "kind": -3,
                        "retType": "string",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "sep",
                                "type": "string",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "helpers.array_join"
                    },
                    "helpers.arrayUnshift": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "value",
                                "type": "T"
                            }
                        ],
                        "pyQName": "helpers.array_unshift"
                    },
                    "helpers.arraySort": {
                        "kind": -3,
                        "retType": "T[]",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "callbackfn",
                                "type": "(value1: T, value2: T) => number",
                                "initializer": "undefined",
                                "handlerParameters": [
                                    {
                                        "name": "value1",
                                        "type": "T"
                                    },
                                    {
                                        "name": "value2",
                                        "type": "T"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "helpers.array_sort"
                    },
                    "helpers.arrayMap": {
                        "kind": -3,
                        "retType": "U[]",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "callbackfn",
                                "type": "(value: T, index: number) => U",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "helpers.array_map"
                    },
                    "helpers.arraySome": {
                        "kind": -3,
                        "retType": "boolean",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "callbackfn",
                                "type": "(value: T, index: number) => boolean",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "helpers.array_some"
                    },
                    "helpers.arrayEvery": {
                        "kind": -3,
                        "retType": "boolean",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "callbackfn",
                                "type": "(value: T, index: number) => boolean",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "helpers.array_every"
                    },
                    "helpers.arrayForEach": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "callbackfn",
                                "type": "(value: T, index: number) => void",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "helpers.array_for_each"
                    },
                    "helpers.arrayFilter": {
                        "kind": -3,
                        "retType": "T[]",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "callbackfn",
                                "type": "(value: T, index: number) => boolean",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "helpers.array_filter"
                    },
                    "helpers.arrayFind": {
                        "kind": -3,
                        "retType": "T",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "callbackfn",
                                "type": "(value: T, index: number) => boolean",
                                "handlerParameters": [
                                    {
                                        "name": "value",
                                        "type": "T"
                                    },
                                    {
                                        "name": "index",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "helpers.array_find"
                    },
                    "helpers.arrayReduce": {
                        "kind": -3,
                        "retType": "U",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "callbackfn",
                                "type": "(previousValue: U, currentValue: T, currentIndex: number) => U",
                                "handlerParameters": [
                                    {
                                        "name": "previousValue",
                                        "type": "U"
                                    },
                                    {
                                        "name": "currentValue",
                                        "type": "T"
                                    },
                                    {
                                        "name": "currentIndex",
                                        "type": "number"
                                    }
                                ]
                            },
                            {
                                "name": "initialValue",
                                "type": "U"
                            }
                        ],
                        "pyQName": "helpers.array_reduce"
                    },
                    "helpers.arrayConcat": {
                        "kind": -3,
                        "retType": "T[]",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "otherArr",
                                "type": "T[]"
                            }
                        ],
                        "pyQName": "helpers.array_concat"
                    },
                    "helpers.arrayPickRandom": {
                        "kind": -3,
                        "retType": "T",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            }
                        ],
                        "pyQName": "helpers.array_pick_random"
                    },
                    "helpers.arraySlice": {
                        "kind": -3,
                        "retType": "T[]",
                        "parameters": [
                            {
                                "name": "arr",
                                "type": "T[]"
                            },
                            {
                                "name": "start",
                                "initializer": "undefined"
                            },
                            {
                                "name": "end",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "helpers.array_slice"
                    },
                    "helpers.stringReplace": {
                        "kind": -3,
                        "retType": "string",
                        "parameters": [
                            {
                                "name": "s",
                                "type": "string"
                            },
                            {
                                "name": "toReplace",
                                "type": "string"
                            },
                            {
                                "name": "replacer",
                                "type": "string | ((sub: string) => string)"
                            }
                        ],
                        "pyQName": "helpers.string_replace"
                    },
                    "helpers.stringReplaceAll": {
                        "kind": -3,
                        "retType": "string",
                        "parameters": [
                            {
                                "name": "s",
                                "type": "string"
                            },
                            {
                                "name": "toReplace",
                                "type": "string"
                            },
                            {
                                "name": "replacer",
                                "type": "string | ((sub: string) => string)"
                            }
                        ],
                        "pyQName": "helpers.string_replace_all"
                    },
                    "helpers.stringSubstr": {
                        "kind": -3,
                        "retType": "string",
                        "parameters": [
                            {
                                "name": "s",
                                "type": "string"
                            },
                            {
                                "name": "start"
                            },
                            {
                                "name": "length",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "helpers.string_substr"
                    },
                    "helpers.stringSlice": {
                        "kind": -3,
                        "retType": "string",
                        "parameters": [
                            {
                                "name": "s",
                                "type": "string"
                            },
                            {
                                "name": "start"
                            },
                            {
                                "name": "end",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "helpers.string_slice"
                    },
                    "helpers.stringToLowerCase": {
                        "kind": -3,
                        "retType": "string",
                        "parameters": [
                            {
                                "name": "s",
                                "type": "string"
                            }
                        ],
                        "pyQName": "helpers.string_to_lower_case"
                    },
                    "helpers.stringSplit": {
                        "kind": -3,
                        "retType": "string[]",
                        "parameters": [
                            {
                                "name": "S",
                                "type": "string"
                            },
                            {
                                "name": "separator",
                                "type": "string",
                                "initializer": "undefined"
                            },
                            {
                                "name": "limit",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "helpers.string_split"
                    },
                    "helpers.stringTrim": {
                        "kind": -3,
                        "retType": "string",
                        "parameters": [
                            {
                                "name": "s",
                                "type": "string"
                            }
                        ],
                        "pyQName": "helpers.string_trim"
                    },
                    "helpers.isWhitespace": {
                        "kind": -3,
                        "retType": "boolean",
                        "parameters": [
                            {
                                "name": "c"
                            }
                        ],
                        "pyQName": "helpers.is_whitespace"
                    },
                    "helpers.stringEmpty": {
                        "kind": -3,
                        "retType": "boolean",
                        "parameters": [
                            {
                                "name": "S",
                                "type": "string"
                            }
                        ],
                        "pyQName": "helpers.string_empty"
                    },
                    "Math.clamp": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "min"
                            },
                            {
                                "name": "max"
                            },
                            {
                                "name": "value"
                            }
                        ]
                    },
                    "Math.abs": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math/abs",
                            "paramHelp": {
                                "x": "A numeric expression for which the absolute value is needed."
                            },
                            "jsDoc": "Returns the absolute value of a number (the value without regard to whether it is positive or negative).\nFor example, the absolute value of -5 is the same as the absolute value of 5."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "A numeric expression for which the absolute value is needed."
                            }
                        ],
                        "pyQName": "abs"
                    },
                    "Math.sign": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "The numeric expression to test"
                            },
                            "jsDoc": "Returns the sign of the x, indicating whether x is positive, negative or zero."
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "The numeric expression to test"
                            }
                        ]
                    },
                    "Math.max": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math/max",
                            "jsDoc": "Returns the larger of two supplied numeric expressions."
                        },
                        "parameters": [
                            {
                                "name": "a"
                            },
                            {
                                "name": "b"
                            }
                        ],
                        "pyQName": "max"
                    },
                    "Math.min": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math/min",
                            "jsDoc": "Returns the smaller of two supplied numeric expressions."
                        },
                        "parameters": [
                            {
                                "name": "a"
                            },
                            {
                                "name": "b"
                            }
                        ],
                        "pyQName": "min"
                    },
                    "Math.roundWithPrecision": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "x": "the number to round",
                                "digits": "the number of resulting digits"
                            },
                            "jsDoc": "Rounds ``x`` to a number with the given number of ``digits``"
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "description": "the number to round"
                            },
                            {
                                "name": "digits",
                                "description": "the number of resulting digits"
                            }
                        ],
                        "pyQName": "Math.round_with_precision"
                    },
                    "__internal": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "blockHidden": true
                        }
                    },
                    "__internal.__downUp": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "shim": "TD_ID",
                            "blockHidden": true,
                            "blockId": "toggleDownUp",
                            "block": "%down",
                            "paramFieldEditor": {
                                "down": "toggledownup"
                            },
                            "paramFieldEditorOptions": {
                                "down": {
                                    "decompileLiterals": "true"
                                }
                            },
                            "jsDoc": "A shim to render a boolean as a down/up toggle",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "down",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "down",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "down",
                                "type": "boolean"
                            }
                        ]
                    },
                    "__internal.__upDown": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "shim": "TD_ID",
                            "blockHidden": true,
                            "blockId": "toggleUpDown",
                            "block": "%up",
                            "paramFieldEditor": {
                                "up": "toggleupdown"
                            },
                            "paramFieldEditorOptions": {
                                "up": {
                                    "decompileLiterals": "true"
                                }
                            },
                            "jsDoc": "A shim to render a boolean as a up/down toggle",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "up",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "up",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "up",
                                "type": "boolean"
                            }
                        ]
                    },
                    "__internal.__highLow": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "shim": "TD_ID",
                            "blockHidden": true,
                            "blockId": "toggleHighLow",
                            "block": "%high",
                            "paramFieldEditor": {
                                "high": "togglehighlow"
                            },
                            "paramFieldEditorOptions": {
                                "high": {
                                    "decompileLiterals": "true"
                                }
                            },
                            "jsDoc": "A shim to render a boolean as a high/low toggle",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "high",
                                "type": "boolean"
                            }
                        ]
                    },
                    "__internal.__onOff": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "shim": "TD_ID",
                            "blockHidden": true,
                            "blockId": "toggleOnOff",
                            "block": "%on",
                            "paramFieldEditor": {
                                "on": "toggleonoff"
                            },
                            "paramFieldEditorOptions": {
                                "on": {
                                    "decompileLiterals": "true"
                                }
                            },
                            "jsDoc": "A shim to render a boolean as a on/off toggle",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "on",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "on",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "on",
                                "type": "boolean"
                            }
                        ]
                    },
                    "__internal.__yesNo": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "shim": "TD_ID",
                            "blockHidden": true,
                            "blockId": "toggleYesNo",
                            "block": "%yes",
                            "paramFieldEditor": {
                                "yes": "toggleyesno"
                            },
                            "paramFieldEditorOptions": {
                                "yes": {
                                    "decompileLiterals": "true"
                                }
                            },
                            "jsDoc": "A shim to render a boolean as a yes/no toggle",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "yes",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "yes",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "yes",
                                "type": "boolean"
                            }
                        ]
                    },
                    "__internal.__winLose": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "shim": "TD_ID",
                            "blockHidden": true,
                            "blockId": "toggleWinLose",
                            "block": "%win",
                            "paramFieldEditor": {
                                "win": "togglewinlose"
                            },
                            "paramFieldEditorOptions": {
                                "win": {
                                    "decompileLiterals": "true"
                                }
                            },
                            "jsDoc": "A shim to render a boolean as a win/lose toggle",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "win",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "win",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "win",
                                "type": "boolean"
                            }
                        ]
                    },
                    "__internal.__colorNumberPicker": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "value": "#ff0000",
                                "color": "#ff0000"
                            },
                            "blockId": "colorNumberPicker",
                            "block": "%value",
                            "blockHidden": true,
                            "shim": "TD_ID",
                            "colorSecondary": "#FFFFFF",
                            "paramFieldEditor": {
                                "value": "colornumber"
                            },
                            "paramFieldEditorOptions": {
                                "value": {
                                    "decompileLiterals": "true",
                                    "colours": "[\"#ff0000\",\"#ff8000\",\"#ffff00\",\"#ff9da5\",\"#00ff00\",\"#b09eff\",\"#00ffff\",\"#007fff\",\"#65471f\",\"#0000ff\",\"#7f00ff\",\"#ff0080\",\"#ff00ff\",\"#ffffff\",\"#999999\",\"#000000\"]",
                                    "columns": "4",
                                    "className": "rgbColorPicker"
                                }
                            },
                            "explicitDefaults": [
                                "value"
                            ],
                            "paramHelp": {
                                "color": "color, eg: #ff0000"
                            },
                            "jsDoc": "Get the color wheel field editor",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "initializer": "#ff0000",
                                "default": "#ff0000"
                            }
                        ]
                    },
                    "__internal.__colorWheelPicker": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "value": "10"
                            },
                            "blockId": "colorWheelPicker",
                            "block": "%value",
                            "blockHidden": true,
                            "shim": "TD_ID",
                            "colorSecondary": "#FFFFFF",
                            "paramFieldEditor": {
                                "value": "colorwheel"
                            },
                            "paramFieldEditorOptions": {
                                "value": {
                                    "decompileLiterals": "true",
                                    "sliderWidth": "200",
                                    "min": "0",
                                    "max": "255"
                                }
                            },
                            "paramHelp": {
                                "value": "value between 0 to 255 to get a color value, eg: 10"
                            },
                            "jsDoc": "Get the color wheel field editor",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "value between 0 to 255 to get a color value, eg: 10",
                                "default": "10"
                            }
                        ]
                    },
                    "__internal.__colorWheelHsvPicker": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "value": "10"
                            },
                            "blockId": "colorWheelHsvPicker",
                            "block": "%value",
                            "blockHidden": true,
                            "shim": "TD_ID",
                            "colorSecondary": "#FFFFFF",
                            "paramFieldEditor": {
                                "value": "colorwheel"
                            },
                            "paramFieldEditorOptions": {
                                "value": {
                                    "decompileLiterals": "true",
                                    "sliderWidth": "200",
                                    "min": "0",
                                    "max": "255",
                                    "channel": "hsvfast"
                                }
                            },
                            "paramHelp": {
                                "value": "value between 0 to 255 to get a color value, eg: 10"
                            },
                            "jsDoc": "Get the color wheel field editor using HSV values",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "value between 0 to 255 to get a color value, eg: 10",
                                "default": "10"
                            }
                        ]
                    },
                    "__internal.__speedPicker": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "speed": "50"
                            },
                            "blockId": "speedPicker",
                            "block": "%speed",
                            "shim": "TD_ID",
                            "paramFieldEditor": {
                                "speed": "speed"
                            },
                            "colorSecondary": "#FFFFFF",
                            "weight": 0,
                            "blockHidden": true,
                            "paramFieldEditorOptions": {
                                "speed": {
                                    "decompileLiterals": "1"
                                }
                            },
                            "paramHelp": {
                                "speed": "the speed, eg: 50"
                            },
                            "jsDoc": "A speed picker",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "speed",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "speed",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "speed",
                                "description": "the speed, eg: 50",
                                "default": "50"
                            }
                        ]
                    },
                    "__internal.__turnRatioPicker": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "turnratio": "0"
                            },
                            "blockId": "turnRatioPicker",
                            "block": "%turnratio",
                            "shim": "TD_ID",
                            "paramFieldEditor": {
                                "turnratio": "turnratio"
                            },
                            "colorSecondary": "#FFFFFF",
                            "weight": 0,
                            "blockHidden": true,
                            "paramFieldEditorOptions": {
                                "turnRatio": {
                                    "decompileLiterals": "1"
                                }
                            },
                            "paramHelp": {
                                "turnratio": "the turn ratio, eg: 0"
                            },
                            "jsDoc": "A turn ratio picker",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "turnratio",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "turnratio",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "turnratio",
                                "description": "the turn ratio, eg: 0",
                                "default": "0"
                            }
                        ]
                    },
                    "__internal.__protractor": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "blockId": "protractorPicker",
                            "block": "%angle",
                            "shim": "TD_ID",
                            "paramFieldEditor": {
                                "angle": "protractor"
                            },
                            "paramFieldEditorOptions": {
                                "angle": {
                                    "decompileLiterals": "1"
                                }
                            },
                            "colorSecondary": "#FFFFFF",
                            "blockHidden": true,
                            "jsDoc": "A field editor that displays a protractor",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "angle",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "angle",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "angle"
                            }
                        ]
                    },
                    "__internal.__timePicker": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "ms": "500"
                            },
                            "blockId": "timePicker",
                            "block": "%ms",
                            "blockHidden": true,
                            "shim": "TD_ID",
                            "colorSecondary": "#FFFFFF",
                            "paramFieldEditor": {
                                "ms": "numberdropdown"
                            },
                            "paramFieldEditorOptions": {
                                "ms": {
                                    "decompileLiterals": "true",
                                    "data": "[[\"100 ms\", 100], [\"200 ms\", 200], [\"500 ms\", 500], [\"1 second\", 1000], [\"2 seconds\", 2000], [\"5 seconds\", 5000]]"
                                }
                            },
                            "paramHelp": {
                                "ms": "time duration in milliseconds, eg: 500, 1000"
                            },
                            "jsDoc": "Get the time field editor",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "ms",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "ms",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "ms",
                                "description": "time duration in milliseconds, eg: 500, 1000",
                                "default": "500"
                            }
                        ]
                    },
                    "Fx8": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "v"
                            }
                        ],
                        "pyQName": "fx8"
                    },
                    "Fx8._dummyFx8": {
                        "kind": 2,
                        "retType": "string",
                        "isInstance": true,
                        "pyQName": "fx8._dummy_fx8"
                    },
                    "Fx8@type": {
                        "kind": 9,
                        "retType": "Fx8",
                        "extendsTypes": [],
                        "pyQName": "Fx8"
                    },
                    "Fx": {
                        "kind": 5,
                        "retType": ""
                    },
                    "Fx.zeroFx8": {
                        "kind": 4,
                        "retType": "Fx8",
                        "pyQName": "Fx.zero_fx8"
                    },
                    "Fx.oneHalfFx8": {
                        "kind": 4,
                        "retType": "Fx8",
                        "pyQName": "Fx.one_half_fx8"
                    },
                    "Fx.oneFx8": {
                        "kind": 4,
                        "retType": "Fx8",
                        "pyQName": "Fx.one_fx8"
                    },
                    "Fx.twoFx8": {
                        "kind": 4,
                        "retType": "Fx8",
                        "pyQName": "Fx.two_fx8"
                    },
                    "Fx.neg": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            }
                        ]
                    },
                    "Fx.toIntShifted": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "n"
                            }
                        ],
                        "pyQName": "Fx.to_int_shifted"
                    },
                    "Fx.add": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "b",
                                "type": "Fx8"
                            }
                        ]
                    },
                    "Fx.iadd": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a"
                            },
                            {
                                "name": "b",
                                "type": "Fx8"
                            }
                        ]
                    },
                    "Fx.sub": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "b",
                                "type": "Fx8"
                            }
                        ]
                    },
                    "Fx.mul": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "b",
                                "type": "Fx8"
                            }
                        ]
                    },
                    "Fx.imul": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "b"
                            }
                        ]
                    },
                    "Fx.div": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "b",
                                "type": "Fx8"
                            }
                        ]
                    },
                    "Fx.idiv": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "b"
                            }
                        ]
                    },
                    "Fx.compare": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "b",
                                "type": "Fx8"
                            }
                        ]
                    },
                    "Fx.abs": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            }
                        ]
                    },
                    "Fx.min": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "b",
                                "type": "Fx8"
                            }
                        ]
                    },
                    "Fx.max": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "b",
                                "type": "Fx8"
                            }
                        ]
                    },
                    "Fx.leftShift": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "n"
                            }
                        ],
                        "pyQName": "Fx.left_shift"
                    },
                    "Fx.rightShift": {
                        "kind": -3,
                        "retType": "Fx8",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Fx8"
                            },
                            {
                                "name": "n"
                            }
                        ],
                        "pyQName": "Fx.right_shift"
                    },
                    "Fx.toInt": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "v",
                                "type": "Fx8"
                            }
                        ],
                        "pyQName": "Fx.to_int"
                    },
                    "Fx.toFloat": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "v",
                                "type": "Fx8"
                            }
                        ],
                        "pyQName": "Fx.to_float"
                    },
                    "pins": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#EF2D56",
                            "weight": 85,
                            "icon": "",
                            "advanced": true,
                            "groups": [
                                "other",
                                "Servo",
                                "i2c"
                            ],
                            "jsDoc": "Control currents in Pins for analog/digital signals, servos, i2c, ..."
                        }
                    },
                    "pins.sizeOf": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "deprecated": "1"
                        },
                        "parameters": [
                            {
                                "name": "format",
                                "type": "NumberFormat",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "pins.size_of"
                    },
                    "pins.createBufferFromArray": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "deprecated": "1"
                        },
                        "parameters": [
                            {
                                "name": "bytes",
                                "type": "number[]"
                            }
                        ],
                        "pyQName": "bytes"
                    },
                    "pins.packedSize": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "deprecated": "1"
                        },
                        "parameters": [
                            {
                                "name": "format",
                                "type": "string"
                            }
                        ],
                        "pyQName": "pins.packed_size"
                    },
                    "pins.packBuffer": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "deprecated": "1"
                        },
                        "parameters": [
                            {
                                "name": "format",
                                "type": "string"
                            },
                            {
                                "name": "nums",
                                "type": "number[]"
                            }
                        ],
                        "pyQName": "pins.pack_buffer"
                    },
                    "pins.packIntoBuffer": {
                        "kind": -3,
                        "attributes": {
                            "deprecated": "1"
                        },
                        "parameters": [
                            {
                                "name": "format",
                                "type": "string"
                            },
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "offset"
                            },
                            {
                                "name": "nums",
                                "type": "number[]"
                            }
                        ],
                        "pyQName": "pins.pack_into_buffer"
                    },
                    "pins.unpackBuffer": {
                        "kind": -3,
                        "retType": "number[]",
                        "attributes": {
                            "deprecated": "1"
                        },
                        "parameters": [
                            {
                                "name": "format",
                                "type": "string"
                            },
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "offset",
                                "initializer": "0"
                            }
                        ],
                        "pyQName": "pins.unpack_buffer"
                    },
                    "pins.concatBuffers": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "deprecated": "1"
                        },
                        "parameters": [
                            {
                                "name": "bufs",
                                "type": "Buffer[]"
                            }
                        ],
                        "pyQName": "pins.concat_buffers"
                    },
                    "msgpack": {
                        "kind": 5,
                        "retType": ""
                    },
                    "msgpack.unpackNumberArray": {
                        "kind": -3,
                        "retType": "number[]",
                        "attributes": {
                            "jsDoc": "Unpacks a buffer into a number array."
                        },
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "offset",
                                "initializer": "0"
                            }
                        ],
                        "pyQName": "msgpack.unpack_number_array"
                    },
                    "msgpack.packNumberArray": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "paramHelp": {
                                "nums": "the numbers to be packed"
                            },
                            "jsDoc": "Pack a number array into a buffer."
                        },
                        "parameters": [
                            {
                                "name": "nums",
                                "description": "the numbers to be packed",
                                "type": "number[]"
                            }
                        ],
                        "pyQName": "msgpack.pack_number_array"
                    },
                    "helpers.bufferConcat": {
                        "kind": -3,
                        "retType": "Buffer",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Buffer"
                            },
                            {
                                "name": "b",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "helpers.buffer_concat"
                    },
                    "helpers.bufferEquals": {
                        "kind": -3,
                        "retType": "boolean",
                        "parameters": [
                            {
                                "name": "l",
                                "type": "Buffer"
                            },
                            {
                                "name": "r",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "helpers.buffer_equals"
                    },
                    "helpers.bufferIndexOf": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "a",
                                "type": "Buffer"
                            },
                            {
                                "name": "b",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "helpers.buffer_index_of"
                    },
                    "helpers.bufferUnpack": {
                        "kind": -3,
                        "retType": "number[]",
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "format",
                                "type": "string"
                            },
                            {
                                "name": "offset",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "helpers.buffer_unpack"
                    },
                    "helpers.bufferPackAt": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "offset"
                            },
                            {
                                "name": "format",
                                "type": "string"
                            },
                            {
                                "name": "nums",
                                "type": "number[]"
                            }
                        ],
                        "pyQName": "helpers.buffer_pack_at"
                    },
                    "helpers.bufferChunked": {
                        "kind": -3,
                        "retType": "Buffer[]",
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "maxBytes"
                            }
                        ],
                        "pyQName": "helpers.buffer_chunked"
                    },
                    "helpers.bufferToArray": {
                        "kind": -3,
                        "retType": "number[]",
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "format",
                                "type": "NumberFormat",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "helpers.buffer_to_array"
                    },
                    "Buffer": {
                        "kind": 5,
                        "retType": ""
                    },
                    "Buffer.concat": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "helper": "bufferConcat",
                            "jsDoc": "Return concatenation of current buffer and the given buffer\n\nConcatenates all buffers in the list"
                        },
                        "parameters": [
                            {
                                "name": "buffers",
                                "type": "Buffer[]"
                            }
                        ]
                    },
                    "Buffer.indexOf": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "helper": "bufferIndexOf",
                            "jsDoc": "Return position of other buffer in current buffer"
                        },
                        "parameters": [
                            {
                                "name": "other",
                                "type": "Buffer"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Buffer.index_of"
                    },
                    "Buffer.unpack": {
                        "kind": -1,
                        "retType": "number[]",
                        "attributes": {
                            "helper": "bufferUnpack",
                            "jsDoc": "Reads numbers from the buffer according to the format"
                        },
                        "parameters": [
                            {
                                "name": "format",
                                "type": "string"
                            },
                            {
                                "name": "offset",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true
                    },
                    "Buffer.packAt": {
                        "kind": -1,
                        "attributes": {
                            "helper": "bufferPackAt",
                            "jsDoc": "Writes numbers to the buffer according to the format"
                        },
                        "parameters": [
                            {
                                "name": "offset"
                            },
                            {
                                "name": "format",
                                "type": "string"
                            },
                            {
                                "name": "nums",
                                "type": "number[]"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Buffer.pack_at"
                    },
                    "Buffer.equals": {
                        "kind": -1,
                        "retType": "boolean",
                        "attributes": {
                            "helper": "bufferEquals",
                            "jsDoc": "Returns true if this and the other buffer hold the same data"
                        },
                        "parameters": [
                            {
                                "name": "other",
                                "type": "Buffer"
                            }
                        ],
                        "isInstance": true
                    },
                    "Buffer.chunked": {
                        "kind": -1,
                        "retType": "Buffer[]",
                        "attributes": {
                            "helper": "bufferChunked",
                            "jsDoc": "Splits buffer into parts no larger than specified"
                        },
                        "parameters": [
                            {
                                "name": "maxSize"
                            }
                        ],
                        "isInstance": true
                    },
                    "Buffer.toArray": {
                        "kind": -1,
                        "retType": "number[]",
                        "attributes": {
                            "helper": "bufferToArray",
                            "jsDoc": "Read contents of buffer as an array in specified format"
                        },
                        "parameters": [
                            {
                                "name": "format",
                                "type": "NumberFormat",
                                "isEnum": true
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Buffer.to_array"
                    },
                    "Buffer@type": {
                        "kind": 9,
                        "retType": "Buffer",
                        "attributes": {
                            "indexerGet": "BufferMethods::getByte",
                            "indexerSet": "BufferMethods::setByte"
                        },
                        "extendsTypes": [],
                        "pyQName": "Buffer"
                    },
                    "Buffer.create": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "paramHelp": {
                                "size": "number of bytes in the buffer"
                            },
                            "jsDoc": "Allocate a new buffer."
                        },
                        "parameters": [
                            {
                                "name": "size",
                                "description": "number of bytes in the buffer"
                            }
                        ]
                    },
                    "Buffer.fromHex": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "jsDoc": "Create a new buffer, decoding a hex string"
                        },
                        "parameters": [
                            {
                                "name": "hex",
                                "type": "string"
                            }
                        ],
                        "pyQName": "Buffer.from_hex"
                    },
                    "Buffer.fromUTF8": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "paramHelp": {
                                "str": "the string to put in the buffer"
                            },
                            "jsDoc": "Create a new buffer with UTF8-encoded string"
                        },
                        "parameters": [
                            {
                                "name": "str",
                                "description": "the string to put in the buffer",
                                "type": "string"
                            }
                        ],
                        "pyQName": "Buffer.from_utf8"
                    },
                    "Buffer.chunkedFromUTF8": {
                        "kind": -3,
                        "retType": "Buffer[]",
                        "parameters": [
                            {
                                "name": "str",
                                "type": "string"
                            },
                            {
                                "name": "maxBytes"
                            }
                        ],
                        "pyQName": "Buffer.chunked_from_utf8"
                    },
                    "Buffer.fromArray": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "paramHelp": {
                                "bytes": "data to initialize with"
                            },
                            "jsDoc": "Create a new buffer initialized to bytes from given array."
                        },
                        "parameters": [
                            {
                                "name": "bytes",
                                "description": "data to initialize with",
                                "type": "number[]"
                            }
                        ],
                        "pyQName": "Buffer.from_array"
                    },
                    "Buffer.packedSize": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "format",
                                "type": "string"
                            }
                        ],
                        "pyQName": "Buffer.packed_size"
                    },
                    "Buffer.pack": {
                        "kind": -3,
                        "retType": "Buffer",
                        "parameters": [
                            {
                                "name": "format",
                                "type": "string"
                            },
                            {
                                "name": "nums",
                                "type": "number[]"
                            }
                        ]
                    },
                    "Buffer.__packUnpackCore": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "format",
                                "type": "string"
                            },
                            {
                                "name": "nums",
                                "type": "number[]"
                            },
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "isPack",
                                "type": "boolean"
                            },
                            {
                                "name": "off",
                                "initializer": "0"
                            }
                        ]
                    },
                    "Buffer.sizeOfNumberFormat": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Get the size in bytes of specified number format."
                        },
                        "parameters": [
                            {
                                "name": "format",
                                "type": "NumberFormat",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "Buffer.size_of_number_format"
                    },
                    "Buffer.getUint8": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Reads an unsigned byte at a particular location"
                        },
                        "parameters": [
                            {
                                "name": "off"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Buffer.get_uint8"
                    },
                    "Buffer.isReadOnly": {
                        "kind": -1,
                        "retType": "boolean",
                        "attributes": {
                            "jsDoc": "Returns false when the buffer can be written to."
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "Buffer.is_read_only"
                    },
                    "Buffer.setUint8": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Writes an unsigned byte at a particular location"
                        },
                        "parameters": [
                            {
                                "name": "off"
                            },
                            {
                                "name": "v"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Buffer.set_uint8"
                    },
                    "Buffer.setNumber": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Write a number in specified format in the buffer."
                        },
                        "parameters": [
                            {
                                "name": "format",
                                "type": "NumberFormat",
                                "isEnum": true
                            },
                            {
                                "name": "offset"
                            },
                            {
                                "name": "value"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Buffer.set_number"
                    },
                    "Buffer.getNumber": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Read a number in specified format from the buffer."
                        },
                        "parameters": [
                            {
                                "name": "format",
                                "type": "NumberFormat",
                                "isEnum": true
                            },
                            {
                                "name": "offset"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Buffer.get_number"
                    },
                    "Buffer.length": {
                        "kind": 2,
                        "retType": "number",
                        "attributes": {
                            "property": "true",
                            "jsDoc": "Returns the length of a Buffer object."
                        },
                        "isInstance": true
                    },
                    "Buffer.fill": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "offset": "0",
                                "length": "-1"
                            },
                            "explicitDefaults": [
                                "offset",
                                "length"
                            ],
                            "jsDoc": "Fill (a fragment) of the buffer with given value."
                        },
                        "parameters": [
                            {
                                "name": "value"
                            },
                            {
                                "name": "offset",
                                "initializer": "0",
                                "default": "0"
                            },
                            {
                                "name": "length",
                                "initializer": "-1",
                                "default": "-1"
                            }
                        ],
                        "isInstance": true
                    },
                    "Buffer.slice": {
                        "kind": -1,
                        "retType": "Buffer",
                        "attributes": {
                            "paramDefl": {
                                "offset": "0",
                                "length": "-1"
                            },
                            "explicitDefaults": [
                                "offset",
                                "length"
                            ],
                            "jsDoc": "Return a copy of a fragment of a buffer."
                        },
                        "parameters": [
                            {
                                "name": "offset",
                                "initializer": "0",
                                "default": "0"
                            },
                            {
                                "name": "length",
                                "initializer": "-1",
                                "default": "-1"
                            }
                        ],
                        "isInstance": true
                    },
                    "Buffer.shift": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "start": "0",
                                "length": "-1"
                            },
                            "explicitDefaults": [
                                "start",
                                "length"
                            ],
                            "paramHelp": {
                                "offset": "number of bytes to shift; use negative value to shift right",
                                "start": "start offset in buffer. Default is 0.",
                                "length": "number of elements in buffer. If negative, length is set as the buffer length minus"
                            },
                            "jsDoc": "Shift buffer left in place, with zero padding.\n\n\n\nstart. eg: -1"
                        },
                        "parameters": [
                            {
                                "name": "offset",
                                "description": "number of bytes to shift; use negative value to shift right"
                            },
                            {
                                "name": "start",
                                "description": "start offset in buffer. Default is 0.",
                                "initializer": "0",
                                "default": "0"
                            },
                            {
                                "name": "length",
                                "description": "number of elements in buffer. If negative, length is set as the buffer length minus",
                                "initializer": "-1",
                                "default": "-1"
                            }
                        ],
                        "isInstance": true
                    },
                    "Buffer.toString": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "jsDoc": "Convert a buffer to string assuming UTF8 encoding"
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "Buffer.to_string"
                    },
                    "Buffer.toHex": {
                        "kind": -1,
                        "retType": "string",
                        "attributes": {
                            "jsDoc": "Convert a buffer to its hexadecimal representation."
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "Buffer.to_hex"
                    },
                    "Buffer.rotate": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "start": "0",
                                "length": "-1"
                            },
                            "explicitDefaults": [
                                "start",
                                "length"
                            ],
                            "paramHelp": {
                                "offset": "number of bytes to shift; use negative value to shift right",
                                "start": "start offset in buffer. Default is 0.",
                                "length": "number of elements in buffer. If negative, length is set as the buffer length minus"
                            },
                            "jsDoc": "Rotate buffer left in place.\n\n\n\nstart. eg: -1"
                        },
                        "parameters": [
                            {
                                "name": "offset",
                                "description": "number of bytes to shift; use negative value to shift right"
                            },
                            {
                                "name": "start",
                                "description": "start offset in buffer. Default is 0.",
                                "initializer": "0",
                                "default": "0"
                            },
                            {
                                "name": "length",
                                "description": "number of elements in buffer. If negative, length is set as the buffer length minus",
                                "initializer": "-1",
                                "default": "-1"
                            }
                        ],
                        "isInstance": true
                    },
                    "Buffer.write": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Write contents of `src` at `dstOffset` in current buffer."
                        },
                        "parameters": [
                            {
                                "name": "dstOffset"
                            },
                            {
                                "name": "src",
                                "type": "Buffer"
                            }
                        ],
                        "isInstance": true
                    },
                    "Buffer.hash": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Compute k-bit FNV-1 non-cryptographic hash of the buffer."
                        },
                        "parameters": [
                            {
                                "name": "bits"
                            }
                        ],
                        "isInstance": true
                    },
                    "control.createBuffer": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "deprecated": "1",
                            "paramHelp": {
                                "size": "number of bytes in the buffer"
                            },
                            "jsDoc": "Create a new zero-initialized buffer."
                        },
                        "parameters": [
                            {
                                "name": "size",
                                "description": "number of bytes in the buffer"
                            }
                        ],
                        "pyQName": "bytearray"
                    },
                    "control.createBufferFromUTF8": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "deprecated": "1",
                            "paramHelp": {
                                "str": "the string to put in the buffer"
                            },
                            "jsDoc": "Create a new buffer with UTF8-encoded string"
                        },
                        "parameters": [
                            {
                                "name": "str",
                                "description": "the string to put in the buffer",
                                "type": "string"
                            }
                        ],
                        "pyQName": "control.create_buffer_from_utf8"
                    },
                    "loops": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#40bf4a"
                        }
                    },
                    "loops.forever": {
                        "kind": -3,
                        "attributes": {
                            "help": "loops/forever",
                            "weight": 100,
                            "afterOnStart": true,
                            "deprecated": "true",
                            "blockId": "forever_deprecated",
                            "block": "forever",
                            "blockAllowMultiple": "1",
                            "paramHelp": {
                                "body": "code to execute"
                            },
                            "jsDoc": "Repeats the code forever in the background. On each iteration, allows other codes to run.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "forever",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [
                            {
                                "name": "a",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ]
                    },
                    "loops.pause": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "ms": "100"
                            },
                            "callingConvention": 1,
                            "help": "loops/pause",
                            "weight": 99,
                            "deprecated": "true",
                            "async": "true",
                            "block": "pause %pause=timePicker|ms",
                            "blockId": "device_pause_deprecated",
                            "paramHelp": {
                                "ms": "how long to pause for, eg: 100, 200, 500, 1000, 2000"
                            },
                            "jsDoc": "Pause for the specified time in milliseconds",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pause ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pause",
                                        "shadowBlockId": "timePicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "ms",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pause",
                                        "shadowBlockId": "timePicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "ms",
                                "description": "how long to pause for, eg: 100, 200, 500, 1000, 2000",
                                "default": "100"
                            }
                        ]
                    },
                    "control.millis": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "control/millis",
                            "weight": 50,
                            "blockId": "control_running_time",
                            "block": "millis (ms)",
                            "jsDoc": "Gets the number of milliseconds elapsed since power on.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "millis (ms)",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": []
                    },
                    "control.micros": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Gets current time in microseconds. Overflows every ~18 minutes."
                        },
                        "parameters": []
                    },
                    "control.internalOnEvent": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "flags": "16"
                            },
                            "explicitDefaults": [
                                "flags"
                            ],
                            "jsDoc": "Used internally"
                        },
                        "parameters": [
                            {
                                "name": "src"
                            },
                            {
                                "name": "value"
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            },
                            {
                                "name": "flags",
                                "initializer": "16",
                                "default": "16"
                            }
                        ],
                        "pyQName": "control.internal_on_event"
                    },
                    "control.reset": {
                        "kind": -3,
                        "attributes": {
                            "callingConvention": 1,
                            "weight": 30,
                            "async": "true",
                            "help": "control/reset",
                            "blockGap": "8",
                            "blockId": "control_reset",
                            "block": "reset",
                            "jsDoc": "Reset the device.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "reset",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": []
                    },
                    "control.waitMicros": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "micros": "4"
                            },
                            "callingConvention": 1,
                            "help": "control/wait-micros",
                            "weight": 29,
                            "async": "true",
                            "blockId": "control_wait_us",
                            "block": "wait (s)%micros",
                            "paramHelp": {
                                "micros": "number of micro-seconds to wait. eg: 4"
                            },
                            "jsDoc": "Block the current fiber for the given microseconds",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "wait (s)",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "micros",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "micros",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "micros",
                                "description": "number of micro-seconds to wait. eg: 4",
                                "default": "4"
                            }
                        ],
                        "pyQName": "control.wait_micros"
                    },
                    "control.runInParallel": {
                        "kind": -3,
                        "attributes": {
                            "help": "control/run-in-parallel",
                            "handlerStatement": true,
                            "blockId": "control_run_in_parallel",
                            "block": "run in parallel",
                            "blockGap": "8",
                            "jsDoc": "Run other code in the parallel.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "run in parallel",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [
                            {
                                "name": "a",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "control.run_in_parallel"
                    },
                    "control.waitForEvent": {
                        "kind": -3,
                        "attributes": {
                            "callingConvention": 1,
                            "help": "control/wait-for-event",
                            "async": "true",
                            "blockId": "control_wait_for_event",
                            "block": "wait for event|from %src|with value %value",
                            "jsDoc": "Blocks the calling thread until the specified event is raised.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "wait for event",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "src",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "with value ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "src",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "src"
                            },
                            {
                                "name": "value"
                            }
                        ],
                        "pyQName": "control.wait_for_event"
                    },
                    "control.deviceSerialNumber": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "blockId": "control_device_serial_number",
                            "block": "device serial number",
                            "weight": 9,
                            "help": "control/device-serial-number",
                            "jsDoc": "Derive a unique, consistent serial number of this device from internal data.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "device serial number",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "control.device_serial_number"
                    },
                    "control.deviceLongSerialNumber": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "blockId": "control_device_long_serial_number",
                            "block": "device long serial number",
                            "weight": 9,
                            "help": "control/device-long-serial-number",
                            "jsDoc": "Derive a unique, consistent 64-bit serial number of this device from internal data.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "device long serial number",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "control.device_long_serial_number"
                    },
                    "control.__log": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "prority"
                            },
                            {
                                "name": "text",
                                "type": "string"
                            }
                        ]
                    },
                    "control.dmesgValue": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Dump internal information about a value."
                        },
                        "parameters": [
                            {
                                "name": "v",
                                "type": "any"
                            }
                        ],
                        "pyQName": "control.dmesg_value"
                    },
                    "control.gc": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Force GC and dump basic information about heap."
                        },
                        "parameters": []
                    },
                    "control.heapDump": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Force GC and halt waiting for debugger to do a full heap dump."
                        },
                        "parameters": [],
                        "pyQName": "control.heap_dump"
                    },
                    "control.setDebugFlags": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Set flags used when connecting an external debugger."
                        },
                        "parameters": [
                            {
                                "name": "flags"
                            }
                        ],
                        "pyQName": "control.set_debug_flags"
                    },
                    "control.heapSnapshot": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Record a heap snapshot to debug memory leaks."
                        },
                        "parameters": [],
                        "pyQName": "control.heap_snapshot"
                    },
                    "control.profilingEnabled": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "jsDoc": "Return true if profiling is enabled in the current build."
                        },
                        "parameters": [],
                        "pyQName": "control.profiling_enabled"
                    },
                    "NumberFormat": {
                        "kind": 6,
                        "retType": "NumberFormat",
                        "extendsTypes": [
                            "NumberFormat",
                            "Number"
                        ]
                    },
                    "NumberFormat.Int8LE": {
                        "retType": "NumberFormat.Int8LE",
                        "extendsTypes": [
                            "NumberFormat.Int8LE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.INT8_LE"
                    },
                    "NumberFormat.UInt8LE": {
                        "retType": "NumberFormat.UInt8LE",
                        "extendsTypes": [
                            "NumberFormat.UInt8LE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.UINT8_LE"
                    },
                    "NumberFormat.Int16LE": {
                        "retType": "NumberFormat.Int16LE",
                        "extendsTypes": [
                            "NumberFormat.Int16LE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.INT16_LE"
                    },
                    "NumberFormat.UInt16LE": {
                        "retType": "NumberFormat.UInt16LE",
                        "extendsTypes": [
                            "NumberFormat.UInt16LE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.UINT16_LE"
                    },
                    "NumberFormat.Int32LE": {
                        "retType": "NumberFormat.Int32LE",
                        "extendsTypes": [
                            "NumberFormat.Int32LE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.INT32_LE"
                    },
                    "NumberFormat.Int8BE": {
                        "retType": "NumberFormat.Int8BE",
                        "extendsTypes": [
                            "NumberFormat.Int8BE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.INT8_BE"
                    },
                    "NumberFormat.UInt8BE": {
                        "retType": "NumberFormat.UInt8BE",
                        "extendsTypes": [
                            "NumberFormat.UInt8BE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.UINT8_BE"
                    },
                    "NumberFormat.Int16BE": {
                        "retType": "NumberFormat.Int16BE",
                        "extendsTypes": [
                            "NumberFormat.Int16BE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.INT16_BE"
                    },
                    "NumberFormat.UInt16BE": {
                        "retType": "NumberFormat.UInt16BE",
                        "extendsTypes": [
                            "NumberFormat.UInt16BE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.UINT16_BE"
                    },
                    "NumberFormat.Int32BE": {
                        "retType": "NumberFormat.Int32BE",
                        "extendsTypes": [
                            "NumberFormat.Int32BE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.INT32_BE"
                    },
                    "NumberFormat.UInt32LE": {
                        "retType": "NumberFormat.UInt32LE",
                        "extendsTypes": [
                            "NumberFormat.UInt32LE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.UINT32_LE"
                    },
                    "NumberFormat.UInt32BE": {
                        "retType": "NumberFormat.UInt32BE",
                        "extendsTypes": [
                            "NumberFormat.UInt32BE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.UINT32_BE"
                    },
                    "NumberFormat.Float32LE": {
                        "retType": "NumberFormat.Float32LE",
                        "extendsTypes": [
                            "NumberFormat.Float32LE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.FLOAT32_LE"
                    },
                    "NumberFormat.Float64LE": {
                        "retType": "NumberFormat.Float64LE",
                        "extendsTypes": [
                            "NumberFormat.Float64LE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.FLOAT64_LE"
                    },
                    "NumberFormat.Float32BE": {
                        "retType": "NumberFormat.Float32BE",
                        "extendsTypes": [
                            "NumberFormat.Float32BE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.FLOAT32_BE"
                    },
                    "NumberFormat.Float64BE": {
                        "retType": "NumberFormat.Float64BE",
                        "extendsTypes": [
                            "NumberFormat.Float64BE",
                            "Number"
                        ],
                        "pyQName": "NumberFormat.FLOAT64_BE"
                    },
                    "PerfCounters": {
                        "kind": 6,
                        "retType": "PerfCounters",
                        "extendsTypes": [
                            "PerfCounters",
                            "Number"
                        ]
                    },
                    "PerfCounters.GC": {
                        "retType": "PerfCounters",
                        "extendsTypes": [
                            "PerfCounters.GC",
                            "Number"
                        ]
                    },
                    "Math.E": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "Math.LN2": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "Math.LN10": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "Math.LOG2E": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "Math.LOG10E": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "Math.PI": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "Math.SQRT1_2": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "Math.SQRT2": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "Math.map": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "fromHigh": "1023",
                                "toHigh": "4"
                            },
                            "help": "math/map",
                            "weight": 10,
                            "blockGap": "8",
                            "blockId": "math_map",
                            "block": "map %value|from low %fromLow|high %fromHigh|to low %toLow|high %toHigh",
                            "inlineInputMode": "inline",
                            "paramHelp": {
                                "value": "value to map in ranges",
                                "fromLow": "the lower bound of the value's current range",
                                "fromHigh": "the upper bound of the value's current range, eg: 1023",
                                "toLow": "the lower bound of the value's target range",
                                "toHigh": "the upper bound of the value's target range, eg: 4"
                            },
                            "jsDoc": "Re-maps a number from one range to another. That is, a value of ``from low`` would get mapped to ``to low``, a value of ``from high`` to ``to high``, values in-between to values in-between, etc.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "map ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "from low ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "fromLow",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "high ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "fromHigh",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to low ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "toLow",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "high ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "toHigh",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "fromLow",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "fromHigh",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "toLow",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "toHigh",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "value to map in ranges"
                            },
                            {
                                "name": "fromLow",
                                "description": "the lower bound of the value's current range"
                            },
                            {
                                "name": "fromHigh",
                                "description": "the upper bound of the value's current range, eg: 1023",
                                "default": "1023"
                            },
                            {
                                "name": "toLow",
                                "description": "the lower bound of the value's target range"
                            },
                            {
                                "name": "toHigh",
                                "description": "the upper bound of the value's target range, eg: 4",
                                "default": "4"
                            }
                        ]
                    },
                    "Math.constrain": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math/constrain",
                            "weight": 11,
                            "blockGap": "8",
                            "blockId": "math_constrain_value",
                            "block": "constrain %value|between %low|and %high",
                            "paramHelp": {
                                "x": "the number to constrain, all data types",
                                "y": "the lower end of the range, all data types",
                                "z": "the upper end of the range, all data types"
                            },
                            "jsDoc": "Constrains a number to be within a range",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "constrain ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "between ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "low",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "and ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "low",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value"
                            },
                            {
                                "name": "low"
                            },
                            {
                                "name": "high"
                            }
                        ]
                    },
                    "Math.isin": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math/isin",
                            "weight": 11,
                            "advanced": true,
                            "blockGap": "8",
                            "paramHelp": {
                                "theta": "input angle from 0-255"
                            },
                            "jsDoc": "Returns the sine of an input angle. This is an 8-bit approximation."
                        },
                        "parameters": [
                            {
                                "name": "theta",
                                "description": "input angle from 0-255"
                            }
                        ]
                    },
                    "Math.icos": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "math/icos",
                            "weight": 10,
                            "advanced": true,
                            "blockGap": "8",
                            "paramHelp": {
                                "theta": "input angle from 0-255"
                            },
                            "jsDoc": "Returns the cosine of an input angle. This is an 8-bit approximation."
                        },
                        "parameters": [
                            {
                                "name": "theta",
                                "description": "input angle from 0-255"
                            }
                        ]
                    },
                    "Number.EPSILON": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "input": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#B4009E",
                            "weight": 99,
                            "icon": "",
                            "groups": [
                                "other",
                                "More"
                            ],
                            "jsDoc": "Respond to and read data from buttons and sensors.\n\nEvents and data from sensors."
                        }
                    },
                    "control.runInBackground": {
                        "kind": -3,
                        "attributes": {
                            "deprecated": "1",
                            "hidden": "1",
                            "help": "control/run-in-background",
                            "blockAllowMultiple": "1",
                            "afterOnStart": true,
                            "blockId": "control_run_in_background",
                            "block": "run in background",
                            "blockGap": "8",
                            "weight": 0,
                            "jsDoc": "Deprecated, use ``control.runInParallel`` instead.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "run in background",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [
                            {
                                "name": "a",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "control.run_in_background"
                    },
                    "control.PXT_PANIC": {
                        "kind": 6,
                        "retType": "control.PXT_PANIC",
                        "extendsTypes": [
                            "control.PXT_PANIC",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CODAL_OOM": {
                        "retType": "control.PXT_PANIC.CODAL_OOM",
                        "extendsTypes": [
                            "control.PXT_PANIC.CODAL_OOM",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.GC_OOM": {
                        "retType": "control.PXT_PANIC.GC_OOM",
                        "extendsTypes": [
                            "control.PXT_PANIC.GC_OOM",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.GC_TOO_BIG_ALLOCATION": {
                        "retType": "control.PXT_PANIC.GC_TOO_BIG_ALLOCATION",
                        "extendsTypes": [
                            "control.PXT_PANIC.GC_TOO_BIG_ALLOCATION",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CODAL_HEAP_ERROR": {
                        "retType": "control.PXT_PANIC.CODAL_HEAP_ERROR",
                        "extendsTypes": [
                            "control.PXT_PANIC.CODAL_HEAP_ERROR",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CODAL_NULL_DEREFERENCE": {
                        "retType": "control.PXT_PANIC.CODAL_NULL_DEREFERENCE",
                        "extendsTypes": [
                            "control.PXT_PANIC.CODAL_NULL_DEREFERENCE",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CODAL_USB_ERROR": {
                        "retType": "control.PXT_PANIC.CODAL_USB_ERROR",
                        "extendsTypes": [
                            "control.PXT_PANIC.CODAL_USB_ERROR",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CODAL_HARDWARE_CONFIGURATION_ERROR": {
                        "retType": "control.PXT_PANIC.CODAL_HARDWARE_CONFIGURATION_ERROR",
                        "extendsTypes": [
                            "control.PXT_PANIC.CODAL_HARDWARE_CONFIGURATION_ERROR",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.INVALID_BINARY_HEADER": {
                        "retType": "control.PXT_PANIC.INVALID_BINARY_HEADER",
                        "extendsTypes": [
                            "control.PXT_PANIC.INVALID_BINARY_HEADER",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.OUT_OF_BOUNDS": {
                        "retType": "control.PXT_PANIC.OUT_OF_BOUNDS",
                        "extendsTypes": [
                            "control.PXT_PANIC.OUT_OF_BOUNDS",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.REF_DELETED": {
                        "retType": "control.PXT_PANIC.REF_DELETED",
                        "extendsTypes": [
                            "control.PXT_PANIC.REF_DELETED",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.SIZE": {
                        "retType": "control.PXT_PANIC.SIZE",
                        "extendsTypes": [
                            "control.PXT_PANIC.SIZE",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.INVALID_VTABLE": {
                        "retType": "control.PXT_PANIC.INVALID_VTABLE",
                        "extendsTypes": [
                            "control.PXT_PANIC.INVALID_VTABLE",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.INTERNAL_ERROR": {
                        "retType": "control.PXT_PANIC.INTERNAL_ERROR",
                        "extendsTypes": [
                            "control.PXT_PANIC.INTERNAL_ERROR",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.NO_SUCH_CONFIG": {
                        "retType": "control.PXT_PANIC.NO_SUCH_CONFIG",
                        "extendsTypes": [
                            "control.PXT_PANIC.NO_SUCH_CONFIG",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.NO_SUCH_PIN": {
                        "retType": "control.PXT_PANIC.NO_SUCH_PIN",
                        "extendsTypes": [
                            "control.PXT_PANIC.NO_SUCH_PIN",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.INVALID_ARGUMENT": {
                        "retType": "control.PXT_PANIC.INVALID_ARGUMENT",
                        "extendsTypes": [
                            "control.PXT_PANIC.INVALID_ARGUMENT",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.MEMORY_LIMIT_EXCEEDED": {
                        "retType": "control.PXT_PANIC.MEMORY_LIMIT_EXCEEDED",
                        "extendsTypes": [
                            "control.PXT_PANIC.MEMORY_LIMIT_EXCEEDED",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.SCREEN_ERROR": {
                        "retType": "control.PXT_PANIC.SCREEN_ERROR",
                        "extendsTypes": [
                            "control.PXT_PANIC.SCREEN_ERROR",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.MISSING_PROPERTY": {
                        "retType": "control.PXT_PANIC.MISSING_PROPERTY",
                        "extendsTypes": [
                            "control.PXT_PANIC.MISSING_PROPERTY",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.INVALID_IMAGE": {
                        "retType": "control.PXT_PANIC.INVALID_IMAGE",
                        "extendsTypes": [
                            "control.PXT_PANIC.INVALID_IMAGE",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CALLED_FROM_ISR": {
                        "retType": "control.PXT_PANIC.CALLED_FROM_ISR",
                        "extendsTypes": [
                            "control.PXT_PANIC.CALLED_FROM_ISR",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.HEAP_DUMPED": {
                        "retType": "control.PXT_PANIC.HEAP_DUMPED",
                        "extendsTypes": [
                            "control.PXT_PANIC.HEAP_DUMPED",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.STACK_OVERFLOW": {
                        "retType": "control.PXT_PANIC.STACK_OVERFLOW",
                        "extendsTypes": [
                            "control.PXT_PANIC.STACK_OVERFLOW",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.BLOCKING_TO_STRING": {
                        "retType": "control.PXT_PANIC.BLOCKING_TO_STRING",
                        "extendsTypes": [
                            "control.PXT_PANIC.BLOCKING_TO_STRING",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.VM_ERROR": {
                        "retType": "control.PXT_PANIC.VM_ERROR",
                        "extendsTypes": [
                            "control.PXT_PANIC.VM_ERROR",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.SETTINGS_CLEARED": {
                        "retType": "control.PXT_PANIC.SETTINGS_CLEARED",
                        "extendsTypes": [
                            "control.PXT_PANIC.SETTINGS_CLEARED",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.SETTINGS_OVERLOAD": {
                        "retType": "control.PXT_PANIC.SETTINGS_OVERLOAD",
                        "extendsTypes": [
                            "control.PXT_PANIC.SETTINGS_OVERLOAD",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.SETTINGS_SECRET_MISSING": {
                        "retType": "control.PXT_PANIC.SETTINGS_SECRET_MISSING",
                        "extendsTypes": [
                            "control.PXT_PANIC.SETTINGS_SECRET_MISSING",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.DELETE_ON_CLASS": {
                        "retType": "control.PXT_PANIC.DELETE_ON_CLASS",
                        "extendsTypes": [
                            "control.PXT_PANIC.DELETE_ON_CLASS",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CAST_FIRST": {
                        "retType": "control.PXT_PANIC.CAST_FIRST",
                        "extendsTypes": [
                            "control.PXT_PANIC.CAST_FIRST",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CAST_FROM_UNDEFINED": {
                        "retType": "control.PXT_PANIC.CAST_FIRST",
                        "extendsTypes": [
                            "control.PXT_PANIC.CAST_FROM_UNDEFINED",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CAST_FROM_BOOLEAN": {
                        "retType": "control.PXT_PANIC.CAST_FROM_BOOLEAN",
                        "extendsTypes": [
                            "control.PXT_PANIC.CAST_FROM_BOOLEAN",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CAST_FROM_NUMBER": {
                        "retType": "control.PXT_PANIC.CAST_FROM_NUMBER",
                        "extendsTypes": [
                            "control.PXT_PANIC.CAST_FROM_NUMBER",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CAST_FROM_STRING": {
                        "retType": "control.PXT_PANIC.CAST_FROM_STRING",
                        "extendsTypes": [
                            "control.PXT_PANIC.CAST_FROM_STRING",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CAST_FROM_OBJECT": {
                        "retType": "control.PXT_PANIC.CAST_FROM_OBJECT",
                        "extendsTypes": [
                            "control.PXT_PANIC.CAST_FROM_OBJECT",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CAST_FROM_FUNCTION": {
                        "retType": "control.PXT_PANIC.CAST_FROM_FUNCTION",
                        "extendsTypes": [
                            "control.PXT_PANIC.CAST_FROM_FUNCTION",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.CAST_FROM_NULL": {
                        "retType": "control.PXT_PANIC.CAST_FROM_NULL",
                        "extendsTypes": [
                            "control.PXT_PANIC.CAST_FROM_NULL",
                            "Number"
                        ]
                    },
                    "control.PXT_PANIC.UNHANDLED_EXCEPTION": {
                        "retType": "control.PXT_PANIC.UNHANDLED_EXCEPTION",
                        "extendsTypes": [
                            "control.PXT_PANIC.UNHANDLED_EXCEPTION",
                            "Number"
                        ]
                    },
                    "control.panic": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "code": "5"
                            },
                            "help": "control/panic",
                            "weight": 29,
                            "blockId": "control_panic",
                            "block": "panic %code",
                            "paramHelp": {
                                "code": "an error number to display. eg: 5"
                            },
                            "jsDoc": "Display an error code and stop the program.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "panic ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "code",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "code",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "code",
                                "description": "an error number to display. eg: 5",
                                "default": "5"
                            }
                        ]
                    },
                    "control.enablePerfCounter": {
                        "kind": -3,
                        "attributes": {
                            "shim": "TD_NOOP",
                            "shimArgument": "perfCounter",
                            "jsDoc": "Enable profiling for current function."
                        },
                        "parameters": [
                            {
                                "name": "name",
                                "type": "string",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "control.enable_perf_counter"
                    },
                    "control.dmesgPerfCounters": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Dump values of profiling performance counters."
                        },
                        "parameters": [],
                        "pyQName": "control.dmesg_perf_counters"
                    },
                    "control.assert": {
                        "kind": -3,
                        "attributes": {
                            "help": "control/assert",
                            "weight": 30,
                            "blockId": "control_assert",
                            "block": "assert %cond|with value %code",
                            "jsDoc": "Display an error code and stop the program when the assertion is `false`.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "assert ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "cond",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "with value ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "code",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "cond",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "code",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "cond",
                                "type": "boolean"
                            },
                            {
                                "name": "code"
                            }
                        ]
                    },
                    "control.fail": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "message",
                                "type": "string"
                            }
                        ]
                    },
                    "control.AnimationQueue": {
                        "kind": 8,
                        "retType": "control.AnimationQueue",
                        "extendsTypes": []
                    },
                    "control.AnimationQueue.running": {
                        "kind": 2,
                        "retType": "boolean",
                        "isInstance": true
                    },
                    "control.AnimationQueue.eventID": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "control.AnimationQueue.event_id"
                    },
                    "control.AnimationQueue.interval": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "control.AnimationQueue.__constructor": {
                        "kind": -3,
                        "parameters": [],
                        "isInstance": true
                    },
                    "control.AnimationQueue.runUntilDone": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Runs 'render' in a loop until it returns false or the 'stop' function is called"
                        },
                        "parameters": [
                            {
                                "name": "render",
                                "type": "() => boolean",
                                "handlerParameters": []
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "control.AnimationQueue.run_until_done"
                    },
                    "control.AnimationQueue.isCancelled": {
                        "kind": -1,
                        "retType": "boolean",
                        "parameters": [
                            {
                                "name": "evid"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "control.AnimationQueue.is_cancelled"
                    },
                    "control.AnimationQueue.cancel": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Cancels the current running animation and clears the queue"
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "control.getConfigValue": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "key"
                            },
                            {
                                "name": "defl"
                            }
                        ],
                        "pyQName": "control.get_config_value"
                    },
                    "control.programHash": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [],
                        "pyQName": "control.program_hash"
                    },
                    "control.programName": {
                        "kind": -3,
                        "retType": "string",
                        "parameters": [],
                        "pyQName": "control.program_name"
                    },
                    "control.ramSize": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Returns estimated size of memory in bytes."
                        },
                        "parameters": [],
                        "pyQName": "control.ram_size"
                    },
                    "control.benchmark": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Runs the function and returns run time in microseconds."
                        },
                        "parameters": [
                            {
                                "name": "f",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ]
                    },
                    "convertToText": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "help": "text/convert-to-text",
                            "weight": 1,
                            "block": "convert $value=math_number to text",
                            "blockId": "variable_to_text",
                            "blockNamespace": "text",
                            "paramHelp": {
                                "value": "value to be converted to text"
                            },
                            "jsDoc": "Convert any value to text",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "convert ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "shadowBlockId": "math_number",
                                        "ref": true
                                    },
                                    {
                                        "kind": "label",
                                        "text": " to text",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "shadowBlockId": "math_number",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "value to be converted to text",
                                "type": "any"
                            }
                        ],
                        "pyQName": "convert_to_text"
                    },
                    "control.IntervalMode": {
                        "kind": 6,
                        "retType": "control.IntervalMode",
                        "extendsTypes": [
                            "control.IntervalMode",
                            "Number"
                        ]
                    },
                    "control.IntervalMode.Interval": {
                        "retType": "control.IntervalMode.Interval",
                        "extendsTypes": [
                            "control.IntervalMode.Interval",
                            "Number"
                        ],
                        "pyQName": "control.IntervalMode.INTERVAL"
                    },
                    "control.IntervalMode.Timeout": {
                        "retType": "control.IntervalMode.Timeout",
                        "extendsTypes": [
                            "control.IntervalMode.Timeout",
                            "Number"
                        ],
                        "pyQName": "control.IntervalMode.TIMEOUT"
                    },
                    "control.IntervalMode.Immediate": {
                        "retType": "control.IntervalMode.Immediate",
                        "extendsTypes": [
                            "control.IntervalMode.Immediate",
                            "Number"
                        ],
                        "pyQName": "control.IntervalMode.IMMEDIATE"
                    },
                    "control.setInterval": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "func",
                                "type": "() => void",
                                "handlerParameters": []
                            },
                            {
                                "name": "delay"
                            },
                            {
                                "name": "mode",
                                "type": "control.IntervalMode",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "control.set_interval"
                    },
                    "control.clearInterval": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "intervalId"
                            },
                            {
                                "name": "mode",
                                "type": "control.IntervalMode",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "control.clear_interval"
                    },
                    "control.GCStats": {
                        "kind": 9,
                        "retType": "control.GCStats",
                        "extendsTypes": []
                    },
                    "control.GCStats.numGC": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "control.GCStats.num_gc"
                    },
                    "control.GCStats.numBlocks": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "control.GCStats.num_blocks"
                    },
                    "control.GCStats.totalBytes": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "control.GCStats.total_bytes"
                    },
                    "control.GCStats.lastFreeBytes": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "control.GCStats.last_free_bytes"
                    },
                    "control.GCStats.lastMaxBlockBytes": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "control.GCStats.last_max_block_bytes"
                    },
                    "control.GCStats.minFreeBytes": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "control.GCStats.min_free_bytes"
                    },
                    "control.gcStats": {
                        "kind": -3,
                        "retType": "control.GCStats",
                        "attributes": {
                            "jsDoc": "Get various statistics about the garbage collector (GC)"
                        },
                        "parameters": [],
                        "pyQName": "control.gc_stats"
                    },
                    "control.__queuePollEvent": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "timeOut"
                            },
                            {
                                "name": "condition",
                                "type": "() => boolean",
                                "handlerParameters": []
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ]
                    },
                    "pauseUntil": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "pxt_pause_until",
                            "paramHelp": {
                                "condition": "condition to test for",
                                "timeOut": "if positive, maximum duration to wait for in milliseconds"
                            },
                            "jsDoc": "Busy wait for a condition to be true"
                        },
                        "parameters": [
                            {
                                "name": "condition",
                                "description": "condition to test for",
                                "type": "() => boolean",
                                "handlerParameters": []
                            },
                            {
                                "name": "timeOut",
                                "description": "if positive, maximum duration to wait for in milliseconds",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "pause_until"
                    },
                    "ConsolePriority": {
                        "kind": 6,
                        "retType": "ConsolePriority",
                        "extendsTypes": [
                            "ConsolePriority",
                            "Number"
                        ]
                    },
                    "ConsolePriority.Debug": {
                        "retType": "ConsolePriority.Debug",
                        "extendsTypes": [
                            "ConsolePriority.Debug",
                            "Number"
                        ],
                        "pyQName": "ConsolePriority.DEBUG"
                    },
                    "ConsolePriority.Log": {
                        "retType": "ConsolePriority.Log",
                        "extendsTypes": [
                            "ConsolePriority.Log",
                            "Number"
                        ],
                        "pyQName": "ConsolePriority.LOG"
                    },
                    "ConsolePriority.Warning": {
                        "retType": "ConsolePriority.Warning",
                        "extendsTypes": [
                            "ConsolePriority.Warning",
                            "Number"
                        ],
                        "pyQName": "ConsolePriority.WARNING"
                    },
                    "ConsolePriority.Error": {
                        "retType": "ConsolePriority.Error",
                        "extendsTypes": [
                            "ConsolePriority.Error",
                            "Number"
                        ],
                        "pyQName": "ConsolePriority.ERROR"
                    },
                    "ConsolePriority.Silent": {
                        "retType": "ConsolePriority.Silent",
                        "extendsTypes": [
                            "ConsolePriority.Silent",
                            "Number"
                        ],
                        "pyQName": "ConsolePriority.SILENT"
                    },
                    "console": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 12,
                            "color": "#006E90",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Reading and writing data to the console output."
                        }
                    },
                    "console.minPriority": {
                        "kind": 4,
                        "retType": "ConsolePriority",
                        "attributes": {
                            "jsDoc": "Minimum priority to send messages to listeners"
                        },
                        "pyQName": "console.min_priority"
                    },
                    "console.add": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "priority",
                                "type": "ConsolePriority",
                                "isEnum": true
                            },
                            {
                                "name": "message",
                                "type": "any"
                            }
                        ]
                    },
                    "console.debug": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "text",
                                "type": "any"
                            }
                        ]
                    },
                    "console.warn": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "text",
                                "type": "any"
                            }
                        ]
                    },
                    "console.error": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "text",
                                "type": "any"
                            }
                        ]
                    },
                    "console.log": {
                        "kind": -3,
                        "attributes": {
                            "weight": 90,
                            "help": "console/log",
                            "blockGap": "8",
                            "blockId": "console_log",
                            "block": "console log $value",
                            "_shadowOverrides": {
                                "value": "text"
                            },
                            "paramHelp": {
                                "value": "to send"
                            },
                            "jsDoc": "Write a line of text to the console output.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "console log ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "shadowBlockId": "text",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "shadowBlockId": "text",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "to send",
                                "type": "any"
                            }
                        ],
                        "pyQName": "print"
                    },
                    "console.logValue": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "name": "x"
                            },
                            "weight": 88,
                            "blockGap": "8",
                            "help": "console/log-value",
                            "blockId": "console_log_value",
                            "block": "console|log value %name|= %value",
                            "_shadowOverrides": {
                                "name": "text",
                                "value": "math_number"
                            },
                            "paramHelp": {
                                "name": "name of the value stream, eg: \"x\"",
                                "value": "to write"
                            },
                            "jsDoc": "Write a name:value pair as a line of text to the console output.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "console",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "log value ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "= ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "shadowBlockId": "math_number",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "shadowBlockId": "text",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "shadowBlockId": "math_number",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "name",
                                "description": "name of the value stream, eg: \"x\"",
                                "type": "any",
                                "default": "x"
                            },
                            {
                                "name": "value",
                                "description": "to write",
                                "type": "any"
                            }
                        ],
                        "pyQName": "console.log_value"
                    },
                    "console.inspect": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "paramHelp": {
                                "obj": "value to be converted to a string",
                                "maxElements": "[optional] max number values in an object to include in output"
                            },
                            "jsDoc": "Convert any object or value to a string representation"
                        },
                        "parameters": [
                            {
                                "name": "obj",
                                "description": "value to be converted to a string",
                                "type": "any"
                            },
                            {
                                "name": "maxElements",
                                "description": "[optional] max number values in an object to include in output",
                                "initializer": "20"
                            }
                        ]
                    },
                    "console.addListener": {
                        "kind": -3,
                        "attributes": {
                            "paramHelp": {
                                "listener": ""
                            },
                            "jsDoc": "Adds a listener for the log messages"
                        },
                        "parameters": [
                            {
                                "name": "listener",
                                "type": "(priority: ConsolePriority, text: string) => void",
                                "handlerParameters": [
                                    {
                                        "name": "priority",
                                        "type": "ConsolePriority"
                                    },
                                    {
                                        "name": "text",
                                        "type": "string"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "console.add_listener"
                    },
                    "console.removeListener": {
                        "kind": -3,
                        "attributes": {
                            "paramHelp": {
                                "listener": ""
                            },
                            "jsDoc": "Removes a listener"
                        },
                        "parameters": [
                            {
                                "name": "listener",
                                "type": "(priority: ConsolePriority, text: string) => void",
                                "handlerParameters": [
                                    {
                                        "name": "priority",
                                        "type": "ConsolePriority"
                                    },
                                    {
                                        "name": "text",
                                        "type": "string"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "console.remove_listener"
                    },
                    "JSON": {
                        "kind": 5,
                        "retType": ""
                    },
                    "JSON.parseIntRadix": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "s",
                                "type": "string"
                            },
                            {
                                "name": "base",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "JSON.parse_int_radix"
                    },
                    "JSON.stringify": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "paramHelp": {
                                "value": "A JavaScript value, usually an object or array, to be converted.",
                                "replacer": "Not supported; use null.",
                                "indent": "Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read."
                            },
                            "jsDoc": "Converts a JavaScript value to a JavaScript Object Notation (JSON) string."
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "A JavaScript value, usually an object or array, to be converted.",
                                "type": "any"
                            },
                            {
                                "name": "replacer",
                                "description": "Not supported; use null.",
                                "type": "any",
                                "initializer": "null"
                            },
                            {
                                "name": "indent",
                                "description": "Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.",
                                "initializer": "0"
                            }
                        ]
                    },
                    "JSON.parse": {
                        "kind": -3,
                        "retType": "any",
                        "attributes": {
                            "paramHelp": {
                                "text": "A valid JSON string."
                            },
                            "jsDoc": "Converts a JavaScript Object Notation (JSON) string into an object."
                        },
                        "parameters": [
                            {
                                "name": "s",
                                "type": "string"
                            }
                        ]
                    },
                    "hex": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "shim": "@hex",
                            "jsDoc": "Tagged hex literal converter"
                        },
                        "parameters": [
                            {
                                "name": "lits",
                                "type": "any"
                            },
                            {
                                "name": "args",
                                "type": "any[]"
                            }
                        ]
                    },
                    "control.onEvent": {
                        "kind": -3,
                        "attributes": {
                            "weight": 20,
                            "blockGap": "8",
                            "blockId": "control_on_event",
                            "block": "on event|from %src|with value %value",
                            "blockExternalInputs": "1",
                            "help": "control/on-event",
                            "inlineInputMode": "external",
                            "paramHelp": {
                                "id": "the event compoent id",
                                "value": "the event value to match"
                            },
                            "jsDoc": "Run code when a registered event happens.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on event",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "src",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "with value ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "src",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "src"
                            },
                            {
                                "name": "value",
                                "description": "the event value to match"
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            },
                            {
                                "name": "flags",
                                "initializer": "16"
                            }
                        ],
                        "pyQName": "control.on_event"
                    },
                    "control.FrameCallback": {
                        "kind": 8,
                        "retType": "control.FrameCallback",
                        "extendsTypes": []
                    },
                    "control.FrameCallback.order": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "control.FrameCallback.handler": {
                        "kind": 2,
                        "retType": "() => void",
                        "isInstance": true
                    },
                    "control.EventContext": {
                        "kind": 8,
                        "retType": "control.EventContext",
                        "extendsTypes": []
                    },
                    "control.EventContext.deltaTimeMillis": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "control.EventContext.delta_time_millis"
                    },
                    "control.EventContext.lastStats": {
                        "kind": 2,
                        "retType": "string",
                        "pyQName": "control.EventContext.last_stats"
                    },
                    "control.EventContext.onStats": {
                        "kind": 2,
                        "retType": "(stats: string) => void",
                        "pyQName": "control.EventContext.on_stats"
                    },
                    "control.EventContext.__constructor": {
                        "kind": -3,
                        "parameters": [],
                        "isInstance": true
                    },
                    "control.EventContext.deltaTime": {
                        "kind": -2,
                        "retType": "number",
                        "isInstance": true,
                        "isReadOnly": true,
                        "pyQName": "control.EventContext.delta_time"
                    },
                    "control.EventContext.register": {
                        "kind": -1,
                        "parameters": [],
                        "isInstance": true
                    },
                    "control.EventContext.unregister": {
                        "kind": -1,
                        "parameters": [],
                        "isInstance": true
                    },
                    "control.EventContext.registerFrameHandler": {
                        "kind": -1,
                        "retType": "control.FrameCallback",
                        "parameters": [
                            {
                                "name": "order"
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "control.EventContext.register_frame_handler"
                    },
                    "control.EventContext.unregisterFrameHandler": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "fn",
                                "type": "control.FrameCallback"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "control.EventContext.unregister_frame_handler"
                    },
                    "control.EventContext.registerHandler": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "src"
                            },
                            {
                                "name": "value"
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            },
                            {
                                "name": "flags"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "control.EventContext.register_handler"
                    },
                    "control.EventContext.addIdleHandler": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "control.EventContext.add_idle_handler"
                    },
                    "control.EventContext.removeIdleHandler": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "control.EventContext.remove_idle_handler"
                    },
                    "control.eventContext": {
                        "kind": -3,
                        "retType": "control.EventContext",
                        "attributes": {
                            "jsDoc": "Gets the current event context if any"
                        },
                        "parameters": [],
                        "pyQName": "control.event_context"
                    },
                    "control.pushEventContext": {
                        "kind": -3,
                        "retType": "control.EventContext",
                        "attributes": {
                            "jsDoc": "Pushes a new event context and clears all handlers"
                        },
                        "parameters": [],
                        "pyQName": "control.push_event_context"
                    },
                    "control.popEventContext": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Pops the current event context and restore handlers if any previous context"
                        },
                        "parameters": [],
                        "pyQName": "control.pop_event_context"
                    },
                    "control.onIdle": {
                        "kind": -3,
                        "attributes": {
                            "paramHelp": {
                                "handler": ""
                            },
                            "jsDoc": "Registers a function to run when the device is idling"
                        },
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "control.on_idle"
                    },
                    "control.removeIdleHandler": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "control.remove_idle_handler"
                    },
                    "pause": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "ms": "100"
                            },
                            "callingConvention": 1,
                            "help": "loops/pause",
                            "weight": 99,
                            "async": "true",
                            "block": "pause %pause=timePicker|ms",
                            "blockId": "device_pause",
                            "blockNamespace": "loops",
                            "paramHelp": {
                                "ms": "how long to pause for, eg: 100, 200, 500, 1000, 2000"
                            },
                            "jsDoc": "Pause for the specified time in milliseconds",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pause ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pause",
                                        "shadowBlockId": "timePicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "ms",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pause",
                                        "shadowBlockId": "timePicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "ms",
                                "description": "how long to pause for, eg: 100, 200, 500, 1000, 2000",
                                "default": "100"
                            }
                        ]
                    },
                    "basic": {
                        "kind": 5,
                        "retType": ""
                    },
                    "basic.pause": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "millis"
                            }
                        ]
                    },
                    "forever": {
                        "kind": -3,
                        "attributes": {
                            "help": "loops/forever",
                            "weight": 100,
                            "afterOnStart": true,
                            "blockNamespace": "loops",
                            "blockId": "forever",
                            "block": "forever",
                            "blockAllowMultiple": "1",
                            "paramHelp": {
                                "body": "code to execute"
                            },
                            "jsDoc": "Repeats the code forever in the background. On each iteration, allows other codes to run.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "forever",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [
                            {
                                "name": "a",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ]
                    },
                    "basic.forever": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "a",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ]
                    },
                    "UTF8Decoder": {
                        "kind": 8,
                        "retType": "UTF8Decoder",
                        "extendsTypes": []
                    },
                    "UTF8Decoder.__constructor": {
                        "kind": -3,
                        "parameters": [],
                        "isInstance": true
                    },
                    "UTF8Decoder.add": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "Buffer"
                            }
                        ],
                        "isInstance": true
                    },
                    "UTF8Decoder.decodeUntil": {
                        "kind": -1,
                        "retType": "string",
                        "parameters": [
                            {
                                "name": "delimiter"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "UTF8Decoder.decode_until"
                    },
                    "UTF8Decoder.decode": {
                        "kind": -1,
                        "retType": "string",
                        "parameters": [],
                        "isInstance": true
                    },
                    "setInterval": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "func": "@param delay "
                            },
                            "jsDoc": "Calls a function with a fixed time delay between each call to that function."
                        },
                        "parameters": [
                            {
                                "name": "func",
                                "description": "@param delay ",
                                "type": "() => void",
                                "handlerParameters": []
                            },
                            {
                                "name": "delay"
                            }
                        ],
                        "pyQName": "set_interval"
                    },
                    "clearInterval": {
                        "kind": -3,
                        "attributes": {
                            "paramHelp": {
                                "intervalId": ""
                            },
                            "jsDoc": "Cancels repeated action which was set up using setInterval()."
                        },
                        "parameters": [
                            {
                                "name": "intervalId"
                            }
                        ],
                        "pyQName": "clear_interval"
                    },
                    "setTimeout": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "func": "@param delay "
                            },
                            "jsDoc": "Calls a function after specified delay."
                        },
                        "parameters": [
                            {
                                "name": "func",
                                "description": "@param delay ",
                                "type": "() => void",
                                "handlerParameters": []
                            },
                            {
                                "name": "delay"
                            }
                        ],
                        "pyQName": "set_timeout"
                    },
                    "clearTimeout": {
                        "kind": -3,
                        "attributes": {
                            "paramHelp": {
                                "intervalId": ""
                            },
                            "jsDoc": "Clears the delay set by setTimeout()."
                        },
                        "parameters": [
                            {
                                "name": "intervalId"
                            }
                        ],
                        "pyQName": "clear_timeout"
                    },
                    "setImmediate": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramHelp": {
                                "func": ""
                            },
                            "jsDoc": "Calls a function as soon as possible."
                        },
                        "parameters": [
                            {
                                "name": "func",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "set_immediate"
                    },
                    "clearImmediate": {
                        "kind": -3,
                        "attributes": {
                            "paramHelp": {
                                "intervalId": ""
                            },
                            "jsDoc": "Cancels the immediate actions."
                        },
                        "parameters": [
                            {
                                "name": "intervalId"
                            }
                        ],
                        "pyQName": "clear_immediate"
                    },
                    "control.simmessages": {
                        "kind": 5,
                        "retType": ""
                    },
                    "control.simmessages.CONTROL_MESSAGE_EVT_ID": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "control.simmessages.CONTROL_MESSAGE_RECEIVED": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "control.simmessages.send": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "channel",
                                "type": "string"
                            },
                            {
                                "name": "message",
                                "type": "Buffer"
                            },
                            {
                                "name": "parentOnly",
                                "type": "boolean",
                                "initializer": "undefined"
                            }
                        ]
                    },
                    "control.simmessages.onReceived": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Registers the handler for a message on a given channel"
                        },
                        "parameters": [
                            {
                                "name": "channel",
                                "type": "string"
                            },
                            {
                                "name": "handler",
                                "type": "(msg: Buffer) => void",
                                "handlerParameters": [
                                    {
                                        "name": "msg",
                                        "type": "Buffer"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "control.simmessages.on_received"
                    },
                    "DAL": {
                        "kind": 6,
                        "retType": "DAL",
                        "extendsTypes": [
                            "DAL",
                            "Number"
                        ]
                    },
                    "DigitalInOutPin": {
                        "kind": 9,
                        "retType": "DigitalInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "DigitalInOutPin"
                        ]
                    },
                    "AnalogInPin": {
                        "kind": 9,
                        "retType": "AnalogInPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInPin",
                            "DigitalInOutPin"
                        ]
                    },
                    "AnalogOutPin": {
                        "kind": 9,
                        "retType": "AnalogOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogOutPin",
                            "DigitalInOutPin"
                        ]
                    },
                    "AnalogInOutPin": {
                        "kind": 9,
                        "retType": "AnalogInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInOutPin",
                            "AnalogInPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "PwmOnlyPin": {
                        "kind": 9,
                        "retType": "PwmOnlyPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "PwmOnlyPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "PwmPin": {
                        "kind": 9,
                        "retType": "PwmPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "PwmPin",
                            "PwmOnlyPin",
                            "DigitalInOutPin",
                            "AnalogOutPin",
                            "AnalogInOutPin",
                            "AnalogInPin"
                        ]
                    },
                    "pins.i2cReadNumber": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "pins/i2c-read-number",
                            "weight": 5,
                            "group": "i2c",
                            "inlineInputMode": "external",
                            "blockId": "pins_i2c_readnumber",
                            "block": "i2c read number at address %address|of format %format|repeated %repeated",
                            "jsDoc": "Read one number from an I2C address.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "i2c read number at address ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "address",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "of format ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "format",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "repeated ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "repeated",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "address",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "format",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "repeated",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "address"
                            },
                            {
                                "name": "format",
                                "type": "NumberFormat",
                                "isEnum": true
                            },
                            {
                                "name": "repeated",
                                "type": "boolean",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "pins.i2c_read_number"
                    },
                    "pins.i2cWriteNumber": {
                        "kind": -3,
                        "attributes": {
                            "help": "pins/i2c-write-number",
                            "weight": 4,
                            "group": "i2c",
                            "blockId": "i2c_writenumber",
                            "block": "i2c write number|at address %address|with value %value|of format %format|repeated %repeated",
                            "jsDoc": "Write one number to an I2C address.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "i2c write number",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "at address ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "address",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "with value ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "of format ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "format",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "repeated ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "repeated",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "address",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "format",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "repeated",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "address"
                            },
                            {
                                "name": "value"
                            },
                            {
                                "name": "format",
                                "type": "NumberFormat",
                                "initializer": "undefined",
                                "isEnum": true
                            },
                            {
                                "name": "repeated",
                                "type": "boolean",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "pins.i2c_write_number"
                    },
                    "pins.i2cWriteRegister": {
                        "kind": -3,
                        "attributes": {
                            "weight": 3,
                            "group": "i2c",
                            "help": "pins/i2c-write-register",
                            "blockId": "i2c_writereg",
                            "block": "i2c write register|at address $address|at register $register|value $value",
                            "paramHelp": {
                                "address": "I2c address of the device",
                                "register": "register index",
                                "value": "value to write",
                                "valueFormat": "format of the value, default is UInt8LE"
                            },
                            "jsDoc": "Write a value in a I2C register.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "i2c write register",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "at address ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "address",
                                        "ref": true
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "at register ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "register",
                                        "ref": true
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "value ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "address",
                                        "ref": true
                                    },
                                    {
                                        "kind": "param",
                                        "name": "register",
                                        "ref": true
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "address",
                                "description": "I2c address of the device"
                            },
                            {
                                "name": "register",
                                "description": "register index"
                            },
                            {
                                "name": "value",
                                "description": "value to write"
                            },
                            {
                                "name": "valueFormat",
                                "description": "format of the value, default is UInt8LE",
                                "type": "NumberFormat",
                                "initializer": "undefined",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "pins.i2c_write_register"
                    },
                    "pins.i2cReadRegister": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "weight": 3,
                            "group": "i2c",
                            "help": "pins/i2c-read-register",
                            "blockId": "i2c_readreg",
                            "block": "i2c read register|at address $address|at register $register",
                            "paramHelp": {
                                "address": "I2c address of the device",
                                "register": "register index",
                                "valueFormat": "format of the value, default is UInt8LE"
                            },
                            "jsDoc": "Read the value from a I2C register.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "i2c read register",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "at address ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "address",
                                        "ref": true
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "at register ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "register",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "address",
                                        "ref": true
                                    },
                                    {
                                        "kind": "param",
                                        "name": "register",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "address",
                                "description": "I2c address of the device"
                            },
                            {
                                "name": "register",
                                "description": "register index"
                            },
                            {
                                "name": "valueFormat",
                                "description": "format of the value, default is UInt8LE",
                                "type": "NumberFormat",
                                "initializer": "undefined",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "pins.i2c_read_register"
                    },
                    "pins.i2cReadBuffer": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "jsDoc": "Read `size` bytes from a 7-bit I2C `address`."
                        },
                        "parameters": [
                            {
                                "name": "address"
                            },
                            {
                                "name": "size"
                            },
                            {
                                "name": "repeat",
                                "type": "boolean",
                                "initializer": "false"
                            }
                        ],
                        "pyQName": "pins.i2c_read_buffer"
                    },
                    "pins.i2cWriteBuffer": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Write bytes to a 7-bit I2C `address`."
                        },
                        "parameters": [
                            {
                                "name": "address"
                            },
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "repeat",
                                "type": "boolean",
                                "initializer": "false"
                            }
                        ],
                        "pyQName": "pins.i2c_write_buffer"
                    },
                    "pins.i2c": {
                        "kind": -3,
                        "retType": "I2C",
                        "attributes": {
                            "jsDoc": "Gets the default I2C bus"
                        },
                        "parameters": []
                    },
                    "pins.I2CDevice": {
                        "kind": 8,
                        "retType": "pins.I2CDevice",
                        "extendsTypes": []
                    },
                    "pins.I2CDevice.address": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "pins.I2CDevice.bus": {
                        "kind": 2,
                        "retType": "I2C",
                        "isInstance": true
                    },
                    "pins.I2CDevice.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "address"
                            },
                            {
                                "name": "bus",
                                "type": "I2C",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true
                    },
                    "pins.I2CDevice.readInto": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "repeat",
                                "type": "boolean",
                                "initializer": "false"
                            },
                            {
                                "name": "start",
                                "initializer": "0"
                            },
                            {
                                "name": "end",
                                "initializer": "null"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "pins.I2CDevice.read_into"
                    },
                    "pins.I2CDevice.write": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "repeat",
                                "type": "boolean",
                                "initializer": "false"
                            }
                        ],
                        "isInstance": true
                    },
                    "pins.I2CDevice.begin": {
                        "kind": -1,
                        "retType": "pins.I2CDevice",
                        "parameters": [],
                        "isInstance": true
                    },
                    "pins.I2CDevice.end": {
                        "kind": -1,
                        "parameters": [],
                        "isInstance": true
                    },
                    "pins.I2CDevice.ok": {
                        "kind": -1,
                        "retType": "boolean",
                        "parameters": [],
                        "isInstance": true
                    },
                    "pins.I2CDevice.transfer": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "command",
                                "type": "Buffer"
                            },
                            {
                                "name": "response",
                                "type": "Buffer"
                            },
                            {
                                "name": "responseStart",
                                "initializer": "undefined"
                            },
                            {
                                "name": "responseEnd",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true
                    },
                    "pins.spi": {
                        "kind": -3,
                        "retType": "SPI",
                        "attributes": {
                            "jsDoc": "Gets the default SPI driver"
                        },
                        "parameters": []
                    },
                    "pins.spiWrite": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "pins/spi-write",
                            "weight": 5,
                            "advanced": true,
                            "blockId": "spi_write",
                            "block": "spi write %value",
                            "paramHelp": {
                                "value": "Data to be sent to the SPI slave"
                            },
                            "jsDoc": "Write to the SPI slave and return the response",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "spi write ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "Data to be sent to the SPI slave"
                            }
                        ],
                        "pyQName": "pins.spi_write"
                    },
                    "pins.spiTransfer": {
                        "kind": -3,
                        "attributes": {
                            "help": "pins/spi-transfer",
                            "weight": 4,
                            "advanced": true,
                            "blockId": "spi_transfer",
                            "block": "spi transfer %command into %response",
                            "jsDoc": "Write a given command to SPI bus, and at the same time read the response.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "spi transfer ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "command",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " into ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "response",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "command",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "response",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "command",
                                "type": "Buffer"
                            },
                            {
                                "name": "response",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "pins.spi_transfer"
                    },
                    "pins.spiFrequency": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "frequency": "1000000"
                            },
                            "help": "pins/spi-frequency",
                            "weight": 4,
                            "advanced": true,
                            "blockId": "spi_frequency",
                            "block": "spi frequency %frequency",
                            "paramHelp": {
                                "frequency": "the clock frequency, eg: 1000000"
                            },
                            "jsDoc": "Set the SPI frequency",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "spi frequency ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "frequency",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "frequency",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "frequency",
                                "description": "the clock frequency, eg: 1000000",
                                "default": "1000000"
                            }
                        ],
                        "pyQName": "pins.spi_frequency"
                    },
                    "pins.spiMode": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "mode": "3"
                            },
                            "help": "pins/spi-mode",
                            "weight": 3,
                            "advanced": true,
                            "blockId": "spi_mode",
                            "block": "spi mode %mode",
                            "paramHelp": {
                                "mode": "the mode, eg: 3"
                            },
                            "jsDoc": "Set the SPI signal mode",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "spi mode ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "mode",
                                "description": "the mode, eg: 3",
                                "default": "3"
                            }
                        ],
                        "pyQName": "pins.spi_mode"
                    },
                    "light": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 100,
                            "color": "#4c97ff",
                            "icon": "",
                            "groups": [
                                "other",
                                "Color",
                                "Photon",
                                "More"
                            ],
                            "blockGap": "8",
                            "jsDoc": "Functions to operate colored LEDs."
                        }
                    },
                    "light.sendBuffer": {
                        "kind": -3,
                        "attributes": {
                            "paramHelp": {
                                "data": "The pin that the lights are connected to",
                                "clk": "the clock line if any",
                                "mode": "the color encoding mode",
                                "buf": "The buffer to send to the pin"
                            },
                            "jsDoc": "Send a programmable light buffer to the specified digital pin"
                        },
                        "parameters": [
                            {
                                "name": "data",
                                "description": "The pin that the lights are connected to",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "clk",
                                "description": "the clock line if any",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "mode",
                                "description": "the color encoding mode"
                            },
                            {
                                "name": "buf",
                                "description": "The buffer to send to the pin",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "light.send_buffer"
                    },
                    "control.isUSBInitialized": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "jsDoc": "Determines if the USB has been enumerated."
                        },
                        "parameters": [],
                        "pyQName": "control.is_usb_initialized"
                    },
                    "pins.pinByCfg": {
                        "kind": -3,
                        "retType": "DigitalInOutPin",
                        "attributes": {
                            "jsDoc": "Get a pin by configuration id (DAL.CFG_PIN...)"
                        },
                        "parameters": [
                            {
                                "name": "key"
                            }
                        ],
                        "pyQName": "pins.pin_by_cfg"
                    },
                    "pins.createBuffer": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "paramHelp": {
                                "size": "number of bytes in the buffer"
                            },
                            "jsDoc": "Create a new zero-initialized buffer."
                        },
                        "parameters": [
                            {
                                "name": "size",
                                "description": "number of bytes in the buffer"
                            }
                        ],
                        "pyQName": "bytearray"
                    },
                    "pins.pulseDuration": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "pins/pulse-duration",
                            "blockGap": "8",
                            "blockId": "pins_pulse_duration",
                            "block": "pulse duration (s)",
                            "weight": 19,
                            "jsDoc": "Get the duration of the last pulse in microseconds. This function should be called from a\n``onPulsed`` handler.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pulse duration (s)",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "pins.pulse_duration"
                    },
                    "AnalogInPin.analogRead": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "help": "pins/analog-read",
                            "weight": 53,
                            "blockId": "device_get_analog_pin",
                            "block": "analog read|pin %name",
                            "blockGap": "8",
                            "blockNamespace": "pins",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "paramHelp": {
                                "name": "pin to write to"
                            },
                            "jsDoc": "Read the connector value as analog, that is, as a value comprised between 0 and 1023.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "analog read",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "AnalogInPin.analog_read"
                    },
                    "AnalogOutPin.analogWrite": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "value": "1023"
                            },
                            "help": "pins/analog-write",
                            "weight": 52,
                            "blockId": "device_set_analog_pin",
                            "block": "analog write|pin %name|to %value",
                            "blockGap": "8",
                            "blockNamespace": "pins",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "paramMin": {
                                "value": "0"
                            },
                            "paramMax": {
                                "value": "1023"
                            },
                            "paramHelp": {
                                "name": "pin name to write to",
                                "value": "value to write to the pin between ``0`` and ``1023``. eg:1023,0"
                            },
                            "jsDoc": "Set the connector value as analog. Value must be comprised between 0 and 1023.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "analog write",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "value to write to the pin between ``0`` and ``1023``. eg:1023,0",
                                "default": "1023",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "1023"
                                    }
                                }
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "AnalogOutPin.analog_write"
                    },
                    "DigitalInOutPin.digitalRead": {
                        "kind": -1,
                        "retType": "boolean",
                        "attributes": {
                            "help": "pins/digital-read",
                            "weight": 61,
                            "blockId": "device_get_digital_pin",
                            "block": "digital read|pin %name",
                            "blockGap": "8",
                            "blockNamespace": "pins",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "paramHelp": {
                                "name": "pin to read from"
                            },
                            "jsDoc": "Read a pin or connector as either 0 or 1",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "digital read",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "DigitalInOutPin.digital_read"
                    },
                    "DigitalInOutPin.digitalWrite": {
                        "kind": -1,
                        "attributes": {
                            "help": "pins/digital-write",
                            "weight": 60,
                            "blockId": "device_set_digital_pin",
                            "block": "digital write|pin %name|to %value=toggleHighLow",
                            "blockNamespace": "pins",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "paramHelp": {
                                "name": "pin to write to",
                                "value": "value to set on the pin"
                            },
                            "jsDoc": "Set a pin or connector value to either 0 or 1.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "digital write",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "shadowBlockId": "toggleHighLow",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "shadowBlockId": "toggleHighLow",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "value to set on the pin",
                                "type": "boolean"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "DigitalInOutPin.digital_write"
                    },
                    "DigitalInOutPin.onPulsed": {
                        "kind": -1,
                        "attributes": {
                            "help": "pins/on-pulsed",
                            "weight": 16,
                            "blockGap": "8",
                            "blockId": "pins_on_pulsed",
                            "block": "on|pin %pin|pulsed %pulse",
                            "blockNamespace": "pins",
                            "paramFieldEditor": {
                                "pin": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "pin": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "deprecated": "1",
                            "hidden": "1",
                            "jsDoc": "Make this pin a digital input, and create events where the timestamp is the duration\nthat this pin was either ``high`` or ``low``.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pulsed ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pulse",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pulse",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pulse",
                                "type": "PulseValue",
                                "isEnum": true
                            },
                            {
                                "name": "body",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "DigitalInOutPin.on_pulsed"
                    },
                    "DigitalInOutPin.onEvent": {
                        "kind": -1,
                        "attributes": {
                            "help": "pins/on-event",
                            "weight": 20,
                            "blockGap": "8",
                            "blockId": "pinsonevent",
                            "block": "on|pin %pin|%event",
                            "blockNamespace": "pins",
                            "paramFieldEditor": {
                                "pin": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "pin": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "jsDoc": "Register code to run when a pin event occurs.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "event",
                                "type": "PinEvent",
                                "isEnum": true
                            },
                            {
                                "name": "body",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "DigitalInOutPin.on_event"
                    },
                    "DigitalInOutPin.pulseIn": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "maxDuration": "2000000"
                            },
                            "blockId": "pins_pulse_in",
                            "block": "pulse in (s)|pin %name|pulsed %high||timeout %maxDuration (s)",
                            "weight": 18,
                            "blockGap": "8",
                            "help": "pins/pulse-in",
                            "blockNamespace": "pins",
                            "paramFieldEditor": {
                                "pin": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "pin": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "explicitDefaults": [
                                "maxDuration"
                            ],
                            "paramHelp": {
                                "name": "the pin which measures the pulse",
                                "value": "the value of the pulse (default high)",
                                "maximum": "duration in micro-seconds"
                            },
                            "jsDoc": "Return the duration of a pulse in microseconds",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pulse in (s)",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pulsed ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ]
                            },
                            "_expandedDef": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "timeout ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "maxDuration",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " (s)",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "maxDuration",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "the value of the pulse (default high)",
                                "type": "PulseValue",
                                "isEnum": true
                            },
                            {
                                "name": "maxDuration",
                                "initializer": "2000000",
                                "default": "2000000"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "DigitalInOutPin.pulse_in"
                    },
                    "DigitalInOutPin.setPull": {
                        "kind": -1,
                        "attributes": {
                            "help": "pins/set-pull",
                            "weight": 17,
                            "blockGap": "8",
                            "blockId": "device_set_pull",
                            "block": "set pull|pin %pin|to %pull",
                            "blockNamespace": "pins",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "paramHelp": {
                                "name": "pin to set the pull mode on",
                                "pull": "one of the mbed pull configurations: PullUp, PullDown, PullNone"
                            },
                            "jsDoc": "Set the pull direction of this pin.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set pull",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pull",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pull",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pull",
                                "description": "one of the mbed pull configurations: PullUp, PullDown, PullNone",
                                "type": "PinPullMode",
                                "isEnum": true
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "DigitalInOutPin.set_pull"
                    },
                    "PwmOnlyPin.analogSetPeriod": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "micros": "20000"
                            },
                            "help": "pins/analog-set-period",
                            "weight": 51,
                            "blockId": "device_set_analog_period",
                            "block": "analog set period|pin %pin|to (s)%period",
                            "blockNamespace": "pins",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "paramHelp": {
                                "name": "analog pin to set period to",
                                "micros": "period in micro seconds. eg:20000"
                            },
                            "jsDoc": "Set the Pulse-width modulation (PWM) period of the analog output. The period is in\n**microseconds** or `1/1000` milliseconds.\nIf this pin is not configured as an analog output (using `analog write pin`), the operation has\nno effect.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "analog set period",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to (s)",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "period",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "period",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "period"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "PwmOnlyPin.analog_set_period"
                    },
                    "PwmOnlyPin.servoWrite": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "value": "90"
                            },
                            "help": "pins/servo-write",
                            "weight": 41,
                            "group": "Servo",
                            "blockId": "device_set_servo_pin",
                            "block": "servo write|pin %name|to %value=protractorPicker",
                            "blockGap": "8",
                            "parts": "microservo",
                            "trackArgs": [
                                0
                            ],
                            "blockNamespace": "pins",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "explicitDefaults": [
                                "value"
                            ],
                            "paramHelp": {
                                "name": "pin to write to",
                                "value": "angle or rotation speed"
                            },
                            "jsDoc": "Write a value to the servo to control the rotation of the shaft. On a standard servo, this will\nset the angle of the shaft (in degrees), moving the shaft to that orientation. On a continuous\nrotation servo, this will set the speed of the servo (with ``0`` being full-speed in one\ndirection, ``180`` being full speed in the other, and a value near ``90`` being no movement).",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "servo write",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "shadowBlockId": "protractorPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "shadowBlockId": "protractorPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "angle or rotation speed",
                                "initializer": "90",
                                "default": "90"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "PwmOnlyPin.servo_write"
                    },
                    "PwmOnlyPin.servoSetPulse": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "duration": "1500"
                            },
                            "help": "pins/servo-set-pulse",
                            "weight": 40,
                            "group": "Servo",
                            "blockGap": "8",
                            "blockId": "device_set_servo_pulse",
                            "block": "servo set pulse|pin %value|to (s) %duration",
                            "parts": "microservo",
                            "blockNamespace": "pins",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "paramHelp": {
                                "name": "pin name",
                                "duration": "pulse duration in micro seconds, eg:1500"
                            },
                            "jsDoc": "Set the pin for PWM analog output, make the period be 20 ms, and set the pulse width.\nThe pulse width is based on the value it is given **microseconds** or `1/1000` milliseconds.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "servo set pulse",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to (s) ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "duration",
                                "description": "pulse duration in micro seconds, eg:1500",
                                "default": "1500"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "PwmOnlyPin.servo_set_pulse"
                    },
                    "PwmOnlyPin.servoSetContinuous": {
                        "kind": -1,
                        "attributes": {
                            "blockHidden": true,
                            "jsDoc": "Indicates if the servo is running continuously"
                        },
                        "parameters": [
                            {
                                "name": "continuous",
                                "type": "boolean"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "PwmOnlyPin.servo_set_continuous"
                    },
                    "control.raiseEvent": {
                        "kind": -3,
                        "attributes": {
                            "weight": 21,
                            "blockGap": "12",
                            "blockId": "control_raise_event",
                            "help": "control/raise-event",
                            "block": "raise event|from %src|with value %value",
                            "blockExternalInputs": "1",
                            "inlineInputMode": "external",
                            "paramHelp": {
                                "src": "ID of the MicroBit Component that generated the event",
                                "value": "Component specific code indicating the cause of the event."
                            },
                            "jsDoc": "Announce that an event happened to registered handlers.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "raise event",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "src",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "with value ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "src",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "src",
                                "description": "ID of the MicroBit Component that generated the event"
                            },
                            {
                                "name": "value",
                                "description": "Component specific code indicating the cause of the event."
                            }
                        ],
                        "pyQName": "control.raise_event"
                    },
                    "control.deviceDalVersion": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "blockId": "control_device_dal_version",
                            "block": "device dal version",
                            "help": "control/device-dal-version",
                            "jsDoc": "Determine the version of system software currently running.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "device dal version",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "control.device_dal_version"
                    },
                    "control.allocateNotifyEvent": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "control/allocate-notify-event",
                            "jsDoc": "Allocates the next user notification event"
                        },
                        "parameters": [],
                        "pyQName": "control.allocate_notify_event"
                    },
                    "control.dmesg": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Write a message to DMESG debugging buffer."
                        },
                        "parameters": [
                            {
                                "name": "s",
                                "type": "string"
                            }
                        ]
                    },
                    "control.dmesgPtr": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Write a message and value (pointer) to DMESG debugging buffer."
                        },
                        "parameters": [
                            {
                                "name": "str",
                                "type": "string"
                            },
                            {
                                "name": "ptr",
                                "type": "Object"
                            }
                        ],
                        "pyQName": "control.dmesg_ptr"
                    },
                    "I2C": {
                        "kind": 9,
                        "retType": "I2C",
                        "extendsTypes": []
                    },
                    "I2C.readBuffer": {
                        "kind": -1,
                        "retType": "Buffer",
                        "attributes": {
                            "paramDefl": {
                                "repeat": "0"
                            },
                            "explicitDefaults": [
                                "repeat"
                            ],
                            "jsDoc": "Read `size` bytes from a 7-bit I2C `address`."
                        },
                        "parameters": [
                            {
                                "name": "address"
                            },
                            {
                                "name": "size"
                            },
                            {
                                "name": "repeat",
                                "type": "boolean",
                                "initializer": "0",
                                "default": "0"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "I2C.read_buffer"
                    },
                    "I2C.writeBuffer": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "repeat": "0"
                            },
                            "explicitDefaults": [
                                "repeat"
                            ],
                            "jsDoc": "Write bytes to a 7-bit I2C `address`."
                        },
                        "parameters": [
                            {
                                "name": "address"
                            },
                            {
                                "name": "buf",
                                "type": "Buffer"
                            },
                            {
                                "name": "repeat",
                                "type": "boolean",
                                "initializer": "0",
                                "default": "0"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "I2C.write_buffer"
                    },
                    "pins.createI2C": {
                        "kind": -3,
                        "retType": "I2C",
                        "attributes": {
                            "help": "pins/create-i2c",
                            "parts": "i2c",
                            "jsDoc": "Opens a Serial communication driver"
                        },
                        "parameters": [
                            {
                                "name": "sda",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "scl",
                                "type": "DigitalInOutPin"
                            }
                        ],
                        "pyQName": "pins.create_i2c"
                    },
                    "pins.createSPI": {
                        "kind": -3,
                        "retType": "SPI",
                        "attributes": {
                            "help": "pins/create-spi",
                            "parts": "spi",
                            "jsDoc": "Opens a SPI driver"
                        },
                        "parameters": [
                            {
                                "name": "mosiPin",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "misoPin",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "sckPin",
                                "type": "DigitalInOutPin"
                            }
                        ],
                        "pyQName": "pins.create_spi"
                    },
                    "pins.createSlaveSPI": {
                        "kind": -3,
                        "retType": "SPI",
                        "attributes": {
                            "parts": "spi",
                            "jsDoc": "Opens a slave SPI driver"
                        },
                        "parameters": [
                            {
                                "name": "mosiPin",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "misoPin",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "sckPin",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "csPin",
                                "type": "DigitalInOutPin"
                            }
                        ],
                        "pyQName": "pins.create_slave_spi"
                    },
                    "SPI": {
                        "kind": 9,
                        "retType": "SPI",
                        "extendsTypes": []
                    },
                    "SPI.write": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Write to the SPI bus"
                        },
                        "parameters": [
                            {
                                "name": "value"
                            }
                        ],
                        "isInstance": true
                    },
                    "SPI.transfer": {
                        "kind": -1,
                        "attributes": {
                            "argsNullable": true,
                            "jsDoc": "Transfer buffers over the SPI bus"
                        },
                        "parameters": [
                            {
                                "name": "command",
                                "type": "Buffer"
                            },
                            {
                                "name": "response",
                                "type": "Buffer"
                            }
                        ],
                        "isInstance": true
                    },
                    "SPI.setFrequency": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Sets the SPI clock frequency"
                        },
                        "parameters": [
                            {
                                "name": "frequency"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "SPI.set_frequency"
                    },
                    "SPI.setMode": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Sets the SPI bus mode"
                        },
                        "parameters": [
                            {
                                "name": "mode"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "SPI.set_mode"
                    },
                    "configStorage": {
                        "kind": 5,
                        "retType": ""
                    },
                    "configStorage.setBuffer": {
                        "kind": -3,
                        "attributes": {
                            "paramHelp": {
                                "key": "the identifier (max 16 characters)",
                                "value": "the data (max 32 characters)"
                            },
                            "jsDoc": "Puts an entry in the device storage. Key may have up to 16 characters (bytes)."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "description": "the identifier (max 16 characters)",
                                "type": "string"
                            },
                            {
                                "name": "value",
                                "description": "the data (max 32 characters)",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "configStorage.set_buffer"
                    },
                    "configStorage.getBuffer": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "paramHelp": {
                                "key": "the identifier (max 16 characters)"
                            },
                            "jsDoc": "Gets an entry from the device storage. Key may have up to 16 characters (bytes)."
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "description": "the identifier (max 16 characters)",
                                "type": "string"
                            }
                        ],
                        "pyQName": "configStorage.get_buffer"
                    },
                    "configStorage.removeItem": {
                        "kind": -3,
                        "attributes": {
                            "paramHelp": {
                                "key": "the identifier (max 16 characters)"
                            },
                            "jsDoc": "Removes the key from local storage"
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "description": "the identifier (max 16 characters)",
                                "type": "string"
                            }
                        ],
                        "pyQName": "configStorage.remove_item"
                    },
                    "configStorage.clear": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Clears the local storage"
                        },
                        "parameters": []
                    },
                    "PulseValue": {
                        "kind": 6,
                        "retType": "PulseValue",
                        "extendsTypes": [
                            "PulseValue",
                            "Number"
                        ]
                    },
                    "PulseValue.High": {
                        "retType": "PulseValue.High",
                        "attributes": {
                            "block": "high",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "high",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PulseValue.High",
                            "Number"
                        ],
                        "pyQName": "PulseValue.HIGH"
                    },
                    "PulseValue.Low": {
                        "retType": "PulseValue.Low",
                        "attributes": {
                            "block": "low",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "low",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PulseValue.Low",
                            "Number"
                        ],
                        "pyQName": "PulseValue.LOW"
                    },
                    "PinEvent": {
                        "kind": 6,
                        "retType": "PinEvent",
                        "extendsTypes": [
                            "PinEvent",
                            "Number"
                        ]
                    },
                    "PinEvent.PulseHigh": {
                        "retType": "PinEvent.PulseHigh",
                        "attributes": {
                            "block": "pulse high",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pulse high",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PinEvent.PulseHigh",
                            "Number"
                        ],
                        "pyQName": "PinEvent.PULSE_HIGH"
                    },
                    "PinEvent.PulseLow": {
                        "retType": "PinEvent.PulseLow",
                        "attributes": {
                            "block": "pulse low",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pulse low",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PinEvent.PulseLow",
                            "Number"
                        ],
                        "pyQName": "PinEvent.PULSE_LOW"
                    },
                    "PinEvent.Rise": {
                        "retType": "PinEvent.Rise",
                        "attributes": {
                            "block": "rise",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "rise",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PinEvent.Rise",
                            "Number"
                        ],
                        "pyQName": "PinEvent.RISE"
                    },
                    "PinEvent.Fall": {
                        "retType": "PinEvent.Fall",
                        "attributes": {
                            "block": "fall",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "fall",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PinEvent.Fall",
                            "Number"
                        ],
                        "pyQName": "PinEvent.FALL"
                    },
                    "PinPullMode": {
                        "kind": 6,
                        "retType": "PinPullMode",
                        "extendsTypes": [
                            "PinPullMode",
                            "Number"
                        ]
                    },
                    "PinPullMode.PullDown": {
                        "retType": "PinPullMode.PullDown",
                        "attributes": {
                            "block": "down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PinPullMode.PullDown",
                            "Number"
                        ],
                        "pyQName": "PinPullMode.PULL_DOWN"
                    },
                    "PinPullMode.PullUp": {
                        "retType": "PinPullMode.PullUp",
                        "attributes": {
                            "block": "up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PinPullMode.PullUp",
                            "Number"
                        ],
                        "pyQName": "PinPullMode.PULL_UP"
                    },
                    "PinPullMode.PullNone": {
                        "retType": "PinPullMode.PullNone",
                        "attributes": {
                            "block": "none",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "none",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PinPullMode.PullNone",
                            "Number"
                        ],
                        "pyQName": "PinPullMode.PULL_NONE"
                    },
                    "servos": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#03AA74",
                            "weight": 88,
                            "icon": "",
                            "jsDoc": "Servos"
                        }
                    },
                    "jacdac": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#E79251",
                            "weight": 1,
                            "icon": "",
                            "groups": [
                                "Broadcast",
                                "Console",
                                "Control"
                            ],
                            "blockGap": "8",
                            "jsDoc": "A Joint Asynchronous Communications, Device Agnostic Control."
                        }
                    },
                    "control.Timer": {
                        "kind": 8,
                        "retType": "control.Timer",
                        "attributes": {
                            "fixedInstances": "true",
                            "jsDoc": "A timer"
                        },
                        "extendsTypes": []
                    },
                    "control.Timer.start": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "control.Timer.__constructor": {
                        "kind": -3,
                        "parameters": [],
                        "isInstance": true
                    },
                    "control.Timer.millis": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "blockId": "timerMillis",
                            "block": "%timer|millis",
                            "jsDoc": "Gets the elapsed time in millis since the last reset",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "timer",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "millis",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "timer",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "control.Timer.seconds": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "blockId": "timerSeconds",
                            "block": "%timer|seconds",
                            "jsDoc": "Gets the elapsed time in seconds since the last reset",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "timer",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "seconds",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "timer",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "control.Timer.reset": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "timerRest",
                            "block": "%timer|reset",
                            "jsDoc": "Resets the timer",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "timer",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "reset",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "timer",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "control.Timer.pauseUntil": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "ms": "5"
                            },
                            "blockId": "timerPauseUntil",
                            "block": "%timer|pause until (ms) %ms",
                            "paramHelp": {
                                "ms": "how long to pause for, eg: 5, 100, 200, 500, 1000, 2000"
                            },
                            "jsDoc": "Pauses until the timer reaches the given amount of milliseconds",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "timer",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pause until (ms) ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "ms",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "timer",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "ms",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "ms",
                                "description": "how long to pause for, eg: 5, 100, 200, 500, 1000, 2000",
                                "default": "5"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "control.Timer.pause_until"
                    },
                    "control.timer1": {
                        "kind": 4,
                        "retType": "control.Timer",
                        "attributes": {
                            "whenUsed": "true",
                            "fixedInstance": "true",
                            "block": "timer 1",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "timer 1",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "control.timer2": {
                        "kind": 4,
                        "retType": "control.Timer",
                        "attributes": {
                            "whenUsed": "true",
                            "fixedInstance": "true",
                            "block": "timer 2",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "timer 2",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "control.timer3": {
                        "kind": 4,
                        "retType": "control.Timer",
                        "attributes": {
                            "whenUsed": "true",
                            "fixedInstance": "true",
                            "block": "timer 3",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "timer 3",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "control.timer4": {
                        "kind": 4,
                        "retType": "control.Timer",
                        "attributes": {
                            "whenUsed": "true",
                            "fixedInstance": "true",
                            "block": "timer 4",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "timer 4",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "control.timer5": {
                        "kind": 4,
                        "retType": "control.Timer",
                        "attributes": {
                            "whenUsed": "true",
                            "fixedInstance": "true",
                            "block": "timer 5",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "timer 5",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "control.timer6": {
                        "kind": 4,
                        "retType": "control.Timer",
                        "attributes": {
                            "whenUsed": "true",
                            "fixedInstance": "true",
                            "block": "timer 6",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "timer 6",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "control.timer7": {
                        "kind": 4,
                        "retType": "control.Timer",
                        "attributes": {
                            "whenUsed": "true",
                            "fixedInstance": "true",
                            "block": "timer 7",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "timer 7",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "control.timer8": {
                        "kind": 4,
                        "retType": "control.Timer",
                        "attributes": {
                            "whenUsed": "true",
                            "fixedInstance": "true",
                            "block": "timer 8",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "timer 8",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "configStorage.setItem": {
                        "kind": -3,
                        "attributes": {
                            "paramHelp": {
                                "key": "identifier of the key (max 16 characters)",
                                "value": "identifier of the value (max 32 characters)"
                            },
                            "jsDoc": "Stores the value at the key entry"
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "description": "identifier of the key (max 16 characters)",
                                "type": "string"
                            },
                            {
                                "name": "value",
                                "description": "identifier of the value (max 32 characters)",
                                "type": "string"
                            }
                        ],
                        "pyQName": "configStorage.set_item"
                    },
                    "configStorage.getItem": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "paramHelp": {
                                "key": "identifier of the key (max 16 characters)"
                            },
                            "jsDoc": "Retrieves the value at the key entry"
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "description": "identifier of the key (max 16 characters)",
                                "type": "string"
                            }
                        ],
                        "pyQName": "configStorage.get_item"
                    },
                    "pins.LevelDetector": {
                        "kind": 8,
                        "retType": "pins.LevelDetector",
                        "extendsTypes": []
                    },
                    "pins.LevelDetector.id": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "pins.LevelDetector.min": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "pins.LevelDetector.max": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "pins.LevelDetector.lowThreshold": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "pins.LevelDetector.low_threshold"
                    },
                    "pins.LevelDetector.highThreshold": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "pins.LevelDetector.high_threshold"
                    },
                    "pins.LevelDetector.onHigh": {
                        "kind": 2,
                        "retType": "() => void",
                        "isInstance": true,
                        "pyQName": "pins.LevelDetector.on_high"
                    },
                    "pins.LevelDetector.onLow": {
                        "kind": 2,
                        "retType": "() => void",
                        "isInstance": true,
                        "pyQName": "pins.LevelDetector.on_low"
                    },
                    "pins.LevelDetector.onNeutral": {
                        "kind": 2,
                        "retType": "() => void",
                        "isInstance": true,
                        "pyQName": "pins.LevelDetector.on_neutral"
                    },
                    "pins.LevelDetector.transitionWindow": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "pins.LevelDetector.transition_window"
                    },
                    "pins.LevelDetector.transitionInterval": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "pins.LevelDetector.transition_interval"
                    },
                    "pins.LevelDetector.LEVEL_THRESHOLD_NEUTRAL": {
                        "kind": 2,
                        "retType": "number"
                    },
                    "pins.LevelDetector.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "id"
                            },
                            {
                                "name": "min"
                            },
                            {
                                "name": "max"
                            },
                            {
                                "name": "lowThreshold"
                            },
                            {
                                "name": "highThreshold"
                            }
                        ],
                        "isInstance": true
                    },
                    "pins.LevelDetector.reset": {
                        "kind": -1,
                        "parameters": [],
                        "isInstance": true
                    },
                    "pins.LevelDetector.level": {
                        "kind": -2,
                        "retType": "number",
                        "isInstance": true,
                        "isReadOnly": true
                    },
                    "pins.LevelDetector.level@set": {
                        "kind": -2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "pins.LevelDetector.setLowThreshold": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "value"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "pins.LevelDetector.set_low_threshold"
                    },
                    "pins.LevelDetector.setHighThreshold": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "value"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "pins.LevelDetector.set_high_threshold"
                    },
                    "input.onCustomGesture": {
                        "kind": -3,
                        "attributes": {
                            "paramHelp": {
                                "id": "@param update true if gesture detected",
                                "handler": ""
                            },
                            "jsDoc": "Registers a custom gesture recognizer"
                        },
                        "parameters": [
                            {
                                "name": "id",
                                "description": "@param update true if gesture detected"
                            },
                            {
                                "name": "update",
                                "type": "() => boolean",
                                "handlerParameters": []
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "input.on_custom_gesture"
                    },
                    "input.onGesture": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "gesture": "Gesture.Shake"
                            },
                            "help": "input/on-gesture",
                            "blockId": "device_gesture_event",
                            "block": "on |%NAME",
                            "parts": "accelerometer",
                            "paramFieldEditor": {
                                "gesture": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "gesture": {
                                    "width": "220",
                                    "columns": "3"
                                }
                            },
                            "weight": 92,
                            "blockGap": "12",
                            "paramHelp": {
                                "gesture": "the type of gesture to track, eg: Gesture.Shake",
                                "body": "code to run when gesture is raised"
                            },
                            "jsDoc": "Do something when a gesture happens (like shaking the board).",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on ",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "NAME",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "NAME",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "gesture",
                                "description": "the type of gesture to track, eg: Gesture.Shake",
                                "type": "Gesture",
                                "default": "Gesture.Shake",
                                "isEnum": true
                            },
                            {
                                "name": "body",
                                "description": "code to run when gesture is raised",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "input.on_gesture"
                    },
                    "input.acceleration": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "input/acceleration",
                            "blockId": "device_acceleration",
                            "block": "acceleration (mg)|%NAME",
                            "parts": "accelerometer",
                            "paramFieldEditor": {
                                "dimension": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "dimension": {
                                    "width": "180",
                                    "columns": "2"
                                }
                            },
                            "weight": 42,
                            "blockGap": "8",
                            "paramHelp": {
                                "dimension": "TODO"
                            },
                            "jsDoc": "Get the acceleration value in milli-gravitys (when the board is laying flat with the screen up,\nx=0, y=0 and z=-1023)",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "acceleration (mg)",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "NAME",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "NAME",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "dimension",
                                "description": "TODO",
                                "type": "Dimension",
                                "isEnum": true
                            }
                        ]
                    },
                    "input.rotation": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "input/rotation",
                            "blockId": "device_get_rotation",
                            "block": "rotation ()|%NAME",
                            "parts": "accelerometer",
                            "group": "More",
                            "weight": 38,
                            "paramHelp": {
                                "kind": "TODO"
                            },
                            "jsDoc": "The pitch or roll of the device, rotation along the ``x-axis`` or ``y-axis``, in degrees.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "rotation ()",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "NAME",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "NAME",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "kind",
                                "description": "TODO",
                                "type": "Rotation",
                                "isEnum": true
                            }
                        ]
                    },
                    "input.setAccelerometerRange": {
                        "kind": -3,
                        "attributes": {
                            "help": "input/set-accelerometer-range",
                            "blockId": "device_set_accelerometer_range",
                            "block": "set accelerometer|range %range",
                            "weight": 15,
                            "parts": "accelerometer",
                            "group": "More",
                            "blockGap": "8",
                            "paramHelp": {
                                "range": "a value describe the maximum strengh of acceleration measured"
                            },
                            "jsDoc": "Sets the accelerometer sample range in gravities.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set accelerometer",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "range ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "range",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "range",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "range",
                                "description": "a value describe the maximum strengh of acceleration measured",
                                "type": "AcceleratorRange",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "input.set_accelerometer_range"
                    },
                    "Dimension": {
                        "kind": 6,
                        "retType": "Dimension",
                        "extendsTypes": [
                            "Dimension",
                            "Number"
                        ]
                    },
                    "Dimension.X": {
                        "retType": "Dimension.X",
                        "attributes": {
                            "block": "x",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "x",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Dimension.X",
                            "Number"
                        ]
                    },
                    "Dimension.Y": {
                        "retType": "Dimension.Y",
                        "attributes": {
                            "block": "y",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "y",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Dimension.Y",
                            "Number"
                        ]
                    },
                    "Dimension.Z": {
                        "retType": "Dimension.Z",
                        "attributes": {
                            "block": "z",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "z",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Dimension.Z",
                            "Number"
                        ]
                    },
                    "Dimension.Strength": {
                        "retType": "Dimension.Strength",
                        "attributes": {
                            "block": "strength",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "strength",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Dimension.Strength",
                            "Number"
                        ],
                        "pyQName": "Dimension.STRENGTH"
                    },
                    "Rotation": {
                        "kind": 6,
                        "retType": "Rotation",
                        "extendsTypes": [
                            "Rotation",
                            "Number"
                        ]
                    },
                    "Rotation.Pitch": {
                        "retType": "Rotation.Pitch",
                        "attributes": {
                            "block": "pitch",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pitch",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Rotation.Pitch",
                            "Number"
                        ],
                        "pyQName": "Rotation.PITCH"
                    },
                    "Rotation.Roll": {
                        "retType": "Rotation.Roll",
                        "attributes": {
                            "block": "roll",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "roll",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Rotation.Roll",
                            "Number"
                        ],
                        "pyQName": "Rotation.ROLL"
                    },
                    "AcceleratorRange": {
                        "kind": 6,
                        "retType": "AcceleratorRange",
                        "extendsTypes": [
                            "AcceleratorRange",
                            "Number"
                        ]
                    },
                    "AcceleratorRange.OneG": {
                        "retType": "AcceleratorRange.OneG",
                        "attributes": {
                            "block": "1g",
                            "jsDoc": "The accelerator measures forces up to 1 gravity",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "1g",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "AcceleratorRange.OneG",
                            "Number"
                        ],
                        "pyQName": "AcceleratorRange.ONE_G"
                    },
                    "AcceleratorRange.TwoG": {
                        "retType": "AcceleratorRange.TwoG",
                        "attributes": {
                            "block": "2g",
                            "jsDoc": "The accelerator measures forces up to 2 gravity",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "2g",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "AcceleratorRange.TwoG",
                            "Number"
                        ],
                        "pyQName": "AcceleratorRange.TWO_G"
                    },
                    "AcceleratorRange.FourG": {
                        "retType": "AcceleratorRange.FourG",
                        "attributes": {
                            "block": "4g",
                            "jsDoc": "The accelerator measures forces up to 4 gravity",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "4g",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "AcceleratorRange.FourG",
                            "Number"
                        ],
                        "pyQName": "AcceleratorRange.FOUR_G"
                    },
                    "AcceleratorRange.EightG": {
                        "retType": "AcceleratorRange.EightG",
                        "attributes": {
                            "block": "8g",
                            "jsDoc": "The accelerator measures forces up to 8 gravity",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "8g",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "AcceleratorRange.EightG",
                            "Number"
                        ],
                        "pyQName": "AcceleratorRange.EIGHT_G"
                    },
                    "Gesture": {
                        "kind": 6,
                        "retType": "Gesture",
                        "extendsTypes": [
                            "Gesture",
                            "Number"
                        ]
                    },
                    "Gesture.Shake": {
                        "retType": "Gesture.Shake",
                        "attributes": {
                            "block": "shake",
                            "jsDoc": "Raised when shaken",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "shake",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.Shake",
                            "Number"
                        ],
                        "pyQName": "Gesture.SHAKE"
                    },
                    "Gesture.TiltUp": {
                        "retType": "Gesture.TiltUp",
                        "attributes": {
                            "block": "tilt up",
                            "jsDoc": "Raised when the device tilts up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "tilt up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.TiltUp",
                            "Number"
                        ],
                        "pyQName": "Gesture.TILT_UP"
                    },
                    "Gesture.TiltDown": {
                        "retType": "Gesture.TiltDown",
                        "attributes": {
                            "block": "tilt down",
                            "jsDoc": "Raised when the device tilts down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "tilt down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.TiltDown",
                            "Number"
                        ],
                        "pyQName": "Gesture.TILT_DOWN"
                    },
                    "Gesture.TiltLeft": {
                        "retType": "Gesture.TiltLeft",
                        "attributes": {
                            "block": "tilt left",
                            "jsDoc": "Raised when the screen is pointing left",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "tilt left",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.TiltLeft",
                            "Number"
                        ],
                        "pyQName": "Gesture.TILT_LEFT"
                    },
                    "Gesture.TiltRight": {
                        "retType": "Gesture.TiltRight",
                        "attributes": {
                            "block": "tilt right",
                            "jsDoc": "Raised when the screen is pointing right",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "tilt right",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.TiltRight",
                            "Number"
                        ],
                        "pyQName": "Gesture.TILT_RIGHT"
                    },
                    "Gesture.FaceUp": {
                        "retType": "Gesture.FaceUp",
                        "attributes": {
                            "block": "face up",
                            "jsDoc": "Raised when the screen faces up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "face up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.FaceUp",
                            "Number"
                        ],
                        "pyQName": "Gesture.FACE_UP"
                    },
                    "Gesture.FaceDown": {
                        "retType": "Gesture.FaceDown",
                        "attributes": {
                            "block": "face down",
                            "jsDoc": "Raised when the screen is pointing up and the board is horizontal",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "face down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.FaceDown",
                            "Number"
                        ],
                        "pyQName": "Gesture.FACE_DOWN"
                    },
                    "Gesture.FreeFall": {
                        "retType": "Gesture.FreeFall",
                        "attributes": {
                            "block": "free fall",
                            "jsDoc": "Raised when the board is falling!",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "free fall",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.FreeFall",
                            "Number"
                        ],
                        "pyQName": "Gesture.FREE_FALL"
                    },
                    "Gesture.TwoG": {
                        "retType": "Gesture.TwoG",
                        "attributes": {
                            "block": "2g (step)",
                            "jsDoc": "Raised when a 2G shock is detected",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "2g (step)",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.TwoG",
                            "Number"
                        ],
                        "pyQName": "Gesture.TWO_G"
                    },
                    "Gesture.ThreeG": {
                        "retType": "Gesture.ThreeG",
                        "attributes": {
                            "block": "3g",
                            "jsDoc": "Raised when a 3G shock is detected",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "3g",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.ThreeG",
                            "Number"
                        ],
                        "pyQName": "Gesture.THREE_G"
                    },
                    "Gesture.SixG": {
                        "retType": "Gesture.SixG",
                        "attributes": {
                            "block": "6g",
                            "jsDoc": "Raised when a 6G shock is detected",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "6g",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.SixG",
                            "Number"
                        ],
                        "pyQName": "Gesture.SIX_G"
                    },
                    "Gesture.EightG": {
                        "retType": "Gesture.EightG",
                        "attributes": {
                            "block": "8g",
                            "jsDoc": "Raised when a 8G shock is detected",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "8g",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Gesture.EightG",
                            "Number"
                        ],
                        "pyQName": "Gesture.EIGHT_G"
                    },
                    "DigitalInOutPin.pushButton": {
                        "kind": -1,
                        "retType": "Button",
                        "attributes": {
                            "jsDoc": "Get the push button (connected to GND) for given pin"
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "DigitalInOutPin.push_button"
                    },
                    "Button": {
                        "kind": 9,
                        "retType": "Button",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "Button"
                        ]
                    },
                    "Button.onEvent": {
                        "kind": -1,
                        "attributes": {
                            "help": "input/button/on-event",
                            "blockId": "buttonEvent",
                            "block": "on %button|%event",
                            "blockNamespace": "input",
                            "paramFieldEditor": {
                                "button": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "button": {
                                    "width": "220",
                                    "columns": "3"
                                }
                            },
                            "weight": 96,
                            "blockGap": "12",
                            "trackArgs": [
                                0
                            ],
                            "paramHelp": {
                                "button": "the button that needs to be clicked or used",
                                "event": "the kind of button gesture that needs to be detected",
                                "body": "code to run when the event is raised"
                            },
                            "jsDoc": "Do something when a button (`A`, `B` or both `A` + `B`) is clicked, double clicked, etc...",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "ev",
                                "type": "ButtonEvent",
                                "isEnum": true
                            },
                            {
                                "name": "body",
                                "description": "code to run when the event is raised",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "Button.on_event"
                    },
                    "Button.isPressed": {
                        "kind": -1,
                        "retType": "boolean",
                        "attributes": {
                            "help": "input/button/is-pressed",
                            "block": "%button|is pressed",
                            "blockId": "buttonIsPressed",
                            "blockNamespace": "input",
                            "paramFieldEditor": {
                                "button": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "button": {
                                    "width": "220",
                                    "columns": "3"
                                }
                            },
                            "weight": 50,
                            "blockGap": "8",
                            "trackArgs": [
                                0
                            ],
                            "paramHelp": {
                                "button": "the button to query the request"
                            },
                            "jsDoc": "Check if a button is pressed or not.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "is pressed",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "Button.is_pressed"
                    },
                    "Button.wasPressed": {
                        "kind": -1,
                        "retType": "boolean",
                        "attributes": {
                            "help": "input/button/was-pressed",
                            "block": "%button|was pressed",
                            "blockId": "buttonWasPressed",
                            "blockNamespace": "input",
                            "paramFieldEditor": {
                                "button": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "button": {
                                    "width": "220",
                                    "columns": "3"
                                }
                            },
                            "group": "More",
                            "weight": 46,
                            "blockGap": "8",
                            "trackArgs": [
                                0
                            ],
                            "paramHelp": {
                                "button": "the button to query the request"
                            },
                            "jsDoc": "See if the button was pressed again since the last time you checked.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "was pressed",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "Button.was_pressed"
                    },
                    "Button.id": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Gets the component identifier for the button"
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "ButtonEvent": {
                        "kind": 6,
                        "retType": "ButtonEvent",
                        "attributes": {
                            "jsDoc": "User interaction on buttons"
                        },
                        "extendsTypes": [
                            "ButtonEvent",
                            "Number"
                        ]
                    },
                    "ButtonEvent.Click": {
                        "retType": "ButtonEvent.Click",
                        "attributes": {
                            "block": "click",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "click",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ButtonEvent.Click",
                            "Number"
                        ],
                        "pyQName": "ButtonEvent.CLICK"
                    },
                    "ButtonEvent.LongClick": {
                        "retType": "ButtonEvent.LongClick",
                        "attributes": {
                            "block": "long click",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "long click",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ButtonEvent.LongClick",
                            "Number"
                        ],
                        "pyQName": "ButtonEvent.LONG_CLICK"
                    },
                    "ButtonEvent.Up": {
                        "retType": "ButtonEvent.Up",
                        "attributes": {
                            "block": "up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ButtonEvent.Up",
                            "Number"
                        ],
                        "pyQName": "ButtonEvent.UP"
                    },
                    "ButtonEvent.Down": {
                        "retType": "ButtonEvent.Down",
                        "attributes": {
                            "block": "down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ButtonEvent.Down",
                            "Number"
                        ],
                        "pyQName": "ButtonEvent.DOWN"
                    },
                    "Colors": {
                        "kind": 6,
                        "retType": "Colors",
                        "attributes": {
                            "jsDoc": "Well known colors"
                        },
                        "extendsTypes": [
                            "Colors",
                            "Number"
                        ]
                    },
                    "Colors.Red": {
                        "retType": "Colors.Red",
                        "attributes": {
                            "block": "red",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "red",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Colors.Red",
                            "Number"
                        ],
                        "pyQName": "Colors.RED"
                    },
                    "Colors.Orange": {
                        "retType": "Colors.Orange",
                        "attributes": {
                            "block": "orange",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "orange",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Colors.Orange",
                            "Number"
                        ],
                        "pyQName": "Colors.ORANGE"
                    },
                    "Colors.Yellow": {
                        "retType": "Colors.Yellow",
                        "attributes": {
                            "block": "yellow",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "yellow",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Colors.Yellow",
                            "Number"
                        ],
                        "pyQName": "Colors.YELLOW"
                    },
                    "Colors.Green": {
                        "retType": "Colors.Green",
                        "attributes": {
                            "block": "green",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "green",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Colors.Green",
                            "Number"
                        ],
                        "pyQName": "Colors.GREEN"
                    },
                    "Colors.Blue": {
                        "retType": "Colors.Blue",
                        "attributes": {
                            "block": "blue",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "blue",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Colors.Blue",
                            "Number"
                        ],
                        "pyQName": "Colors.BLUE"
                    },
                    "Colors.Indigo": {
                        "retType": "Colors.Indigo",
                        "attributes": {
                            "block": "indigo",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "indigo",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Colors.Indigo",
                            "Number"
                        ],
                        "pyQName": "Colors.INDIGO"
                    },
                    "Colors.Violet": {
                        "retType": "Colors.Violet",
                        "attributes": {
                            "block": "violet",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "violet",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Colors.Violet",
                            "Number"
                        ],
                        "pyQName": "Colors.VIOLET"
                    },
                    "Colors.Purple": {
                        "retType": "Colors.Purple",
                        "attributes": {
                            "block": "purple",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "purple",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Colors.Purple",
                            "Number"
                        ],
                        "pyQName": "Colors.PURPLE"
                    },
                    "Colors.Pink": {
                        "retType": "Colors.Pink",
                        "attributes": {
                            "block": "pink",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pink",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Colors.Pink",
                            "Number"
                        ],
                        "pyQName": "Colors.PINK"
                    },
                    "Colors.White": {
                        "retType": "Colors.White",
                        "attributes": {
                            "block": "white",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "white",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Colors.White",
                            "Number"
                        ],
                        "pyQName": "Colors.WHITE"
                    },
                    "Colors.Black": {
                        "retType": "Colors.Black",
                        "attributes": {
                            "block": "black",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "black",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Colors.Black",
                            "Number"
                        ],
                        "pyQName": "Colors.BLACK"
                    },
                    "ColorHues": {
                        "kind": 6,
                        "retType": "ColorHues",
                        "attributes": {
                            "jsDoc": "Well known color hues"
                        },
                        "extendsTypes": [
                            "ColorHues",
                            "Number"
                        ]
                    },
                    "ColorHues.Red": {
                        "retType": "ColorHues.Red",
                        "attributes": {
                            "block": "red",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "red",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ColorHues.Red",
                            "Number"
                        ],
                        "pyQName": "ColorHues.RED"
                    },
                    "ColorHues.Orange": {
                        "retType": "ColorHues.Orange",
                        "attributes": {
                            "block": "orange",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "orange",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ColorHues.Orange",
                            "Number"
                        ],
                        "pyQName": "ColorHues.ORANGE"
                    },
                    "ColorHues.Yellow": {
                        "retType": "ColorHues.Yellow",
                        "attributes": {
                            "block": "yellow",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "yellow",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ColorHues.Yellow",
                            "Number"
                        ],
                        "pyQName": "ColorHues.YELLOW"
                    },
                    "ColorHues.Green": {
                        "retType": "ColorHues.Green",
                        "attributes": {
                            "block": "green",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "green",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ColorHues.Green",
                            "Number"
                        ],
                        "pyQName": "ColorHues.GREEN"
                    },
                    "ColorHues.Aqua": {
                        "retType": "ColorHues.Aqua",
                        "attributes": {
                            "block": "aqua",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "aqua",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ColorHues.Aqua",
                            "Number"
                        ],
                        "pyQName": "ColorHues.AQUA"
                    },
                    "ColorHues.Blue": {
                        "retType": "ColorHues.Blue",
                        "attributes": {
                            "block": "blue",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "blue",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ColorHues.Blue",
                            "Number"
                        ],
                        "pyQName": "ColorHues.BLUE"
                    },
                    "ColorHues.Purple": {
                        "retType": "ColorHues.Purple",
                        "attributes": {
                            "block": "purple",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "purple",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ColorHues.Purple",
                            "Number"
                        ],
                        "pyQName": "ColorHues.PURPLE"
                    },
                    "ColorHues.Magenta": {
                        "retType": "ColorHues.Magenta",
                        "attributes": {
                            "block": "magenta",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "magenta",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ColorHues.Magenta",
                            "Number"
                        ],
                        "pyQName": "ColorHues.MAGENTA"
                    },
                    "ColorHues.Pink": {
                        "retType": "ColorHues.Pink",
                        "attributes": {
                            "block": "pink",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pink",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "ColorHues.Pink",
                            "Number"
                        ],
                        "pyQName": "ColorHues.PINK"
                    },
                    "color": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "advanced": true,
                            "jsDoc": "Color manipulation"
                        }
                    },
                    "color.rgb": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "red": "255",
                                "green": "255",
                                "blue": "255"
                            },
                            "blockId": "colorsrgb",
                            "block": "red %red|green %green|blue %blue",
                            "paramMin": {
                                "red": "0",
                                "green": "0",
                                "blue": "0"
                            },
                            "paramMax": {
                                "red": "255",
                                "green": "255",
                                "blue": "255"
                            },
                            "help": "colors/rgb",
                            "weight": 19,
                            "blockGap": "8",
                            "blockHidden": true,
                            "paramHelp": {
                                "red": "value of the red channel between 0 and 255. eg: 255",
                                "green": "value of the green channel between 0 and 255. eg: 255",
                                "blue": "value of the blue channel between 0 and 255. eg: 255"
                            },
                            "jsDoc": "Converts red, green, blue channels into a RGB color",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "red ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "red",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "green ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "green",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "blue ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "blue",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "red",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "green",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "blue",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "red",
                                "description": "value of the red channel between 0 and 255. eg: 255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            },
                            {
                                "name": "green",
                                "description": "value of the green channel between 0 and 255. eg: 255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            },
                            {
                                "name": "blue",
                                "description": "value of the blue channel between 0 and 255. eg: 255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            }
                        ]
                    },
                    "color.argb": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "alpha"
                            },
                            {
                                "name": "red"
                            },
                            {
                                "name": "green"
                            },
                            {
                                "name": "blue"
                            }
                        ]
                    },
                    "color.wellKnown": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "blockId": "colorscolors",
                            "block": "%color",
                            "help": "colors/well-known",
                            "shim": "TD_ID",
                            "weight": 20,
                            "blockGap": "8",
                            "blockHidden": true,
                            "jsDoc": "Get the RGB value of a known color",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "color",
                                "type": "Colors",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "color.well_known"
                    },
                    "color.hsv": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "hue": "255",
                                "sat": "255",
                                "val": "255"
                            },
                            "blockId": "colorshsv",
                            "block": "hue %hue|sat %sat|val %val",
                            "paramMin": {
                                "hue": "0",
                                "sat": "0",
                                "val": "0"
                            },
                            "paramMax": {
                                "hue": "255",
                                "sat": "255",
                                "val": "255"
                            },
                            "help": "colors/hsv",
                            "weight": 17,
                            "blockHidden": true,
                            "paramHelp": {
                                "hue": "value of the hue channel between 0 and 255. eg: 255",
                                "sat": "value of the saturation channel between 0 and 255. eg: 255",
                                "val": "value of the value channel between 0 and 255. eg: 255"
                            },
                            "jsDoc": "Convert an HSV (hue, saturation, value) color to RGB",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "hue ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "hue",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "sat ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sat",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "val ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "val",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "hue",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sat",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "val",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "hue",
                                "description": "value of the hue channel between 0 and 255. eg: 255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            },
                            {
                                "name": "sat",
                                "description": "value of the saturation channel between 0 and 255. eg: 255",
                                "initializer": "255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            },
                            {
                                "name": "val",
                                "description": "value of the value channel between 0 and 255. eg: 255",
                                "initializer": "255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            }
                        ]
                    },
                    "color.fade": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "brightness": "128"
                            },
                            "blockId": "colorsfade",
                            "block": "fade %color=neopixel_colors|by %brightness",
                            "paramMin": {
                                "brightness": "0"
                            },
                            "paramMax": {
                                "brightness": "255"
                            },
                            "help": "light/fade",
                            "group": "Color",
                            "weight": 18,
                            "blockGap": "8",
                            "blockHidden": true,
                            "paramHelp": {
                                "color": "color to fade",
                                "brightness": "the amount of brightness to apply to the color, eg: 128"
                            },
                            "jsDoc": "Fade the color by the brightness",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "fade ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "shadowBlockId": "neopixel_colors",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "by ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "brightness",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "shadowBlockId": "neopixel_colors",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "brightness",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "color",
                                "description": "color to fade"
                            },
                            {
                                "name": "brightness",
                                "description": "the amount of brightness to apply to the color, eg: 128",
                                "default": "128",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            }
                        ]
                    },
                    "color.blend": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "color"
                            },
                            {
                                "name": "alpha"
                            },
                            {
                                "name": "otherColor"
                            }
                        ]
                    },
                    "color.gradient": {
                        "kind": -3,
                        "retType": "color.ColorBuffer",
                        "parameters": [
                            {
                                "name": "startColor"
                            },
                            {
                                "name": "endColor"
                            },
                            {
                                "name": "steps"
                            }
                        ]
                    },
                    "color.unpackR": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "rgb"
                            }
                        ],
                        "pyQName": "color.unpack_r"
                    },
                    "color.unpackG": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "rgb"
                            }
                        ],
                        "pyQName": "color.unpack_g"
                    },
                    "color.unpackB": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "rgb"
                            }
                        ],
                        "pyQName": "color.unpack_b"
                    },
                    "color.parseColor": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "color",
                                "type": "string"
                            }
                        ],
                        "pyQName": "color.parse_color"
                    },
                    "color.ColorBufferLayout": {
                        "kind": 6,
                        "retType": "color.ColorBufferLayout",
                        "extendsTypes": [
                            "color.ColorBufferLayout",
                            "Number"
                        ]
                    },
                    "color.ColorBufferLayout.RGB": {
                        "retType": "color.ColorBufferLayout.RGB",
                        "attributes": {
                            "jsDoc": "24bit RGB color"
                        },
                        "extendsTypes": [
                            "color.ColorBufferLayout.RGB",
                            "Number"
                        ]
                    },
                    "color.ColorBufferLayout.ARGB": {
                        "retType": "color.ColorBufferLayout.ARGB",
                        "attributes": {
                            "jsDoc": "32bit RGB color with alpha"
                        },
                        "extendsTypes": [
                            "color.ColorBufferLayout.ARGB",
                            "Number"
                        ]
                    },
                    "color.ColorBuffer": {
                        "kind": 8,
                        "retType": "color.ColorBuffer",
                        "attributes": {
                            "jsDoc": "A buffer of colors"
                        },
                        "extendsTypes": []
                    },
                    "color.ColorBuffer.layout": {
                        "kind": 2,
                        "retType": "color.ColorBufferLayout",
                        "isInstance": true
                    },
                    "color.ColorBuffer.buf": {
                        "kind": 2,
                        "retType": "Buffer",
                        "isInstance": true
                    },
                    "color.ColorBuffer.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "length"
                            },
                            {
                                "name": "layout",
                                "type": "color.ColorBufferLayout",
                                "initializer": "undefined",
                                "isEnum": true
                            }
                        ],
                        "isInstance": true
                    },
                    "color.ColorBuffer.fromBuffer": {
                        "kind": -1,
                        "retType": "color.ColorBuffer",
                        "parameters": [
                            {
                                "name": "buffer",
                                "type": "Buffer"
                            },
                            {
                                "name": "layout",
                                "type": "color.ColorBufferLayout",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "color.ColorBuffer.from_buffer"
                    },
                    "color.ColorBuffer.stride": {
                        "kind": -2,
                        "retType": "number",
                        "isInstance": true,
                        "isReadOnly": true
                    },
                    "color.ColorBuffer.length": {
                        "kind": -2,
                        "retType": "number",
                        "isInstance": true,
                        "isReadOnly": true
                    },
                    "color.ColorBuffer.color": {
                        "kind": -1,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "index"
                            }
                        ],
                        "isInstance": true
                    },
                    "color.ColorBuffer.setColor": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "index"
                            },
                            {
                                "name": "color"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "color.ColorBuffer.set_color"
                    },
                    "color.ColorBuffer.slice": {
                        "kind": -1,
                        "retType": "color.ColorBuffer",
                        "parameters": [
                            {
                                "name": "start",
                                "initializer": "undefined"
                            },
                            {
                                "name": "length",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true
                    },
                    "color.ColorBuffer.write": {
                        "kind": -1,
                        "attributes": {
                            "paramHelp": {
                                "dstOffset": "@param src"
                            },
                            "jsDoc": "Writes the content of the src color buffer starting at the start dstOffset in the current buffer"
                        },
                        "parameters": [
                            {
                                "name": "dstOffset",
                                "description": "@param src"
                            },
                            {
                                "name": "src",
                                "type": "color.ColorBuffer"
                            }
                        ],
                        "isInstance": true
                    },
                    "color.createBuffer": {
                        "kind": -3,
                        "retType": "color.ColorBuffer",
                        "attributes": {
                            "jsDoc": "Converts an array of colors into a color buffer"
                        },
                        "parameters": [
                            {
                                "name": "colors",
                                "type": "number[]"
                            },
                            {
                                "name": "layout",
                                "type": "color.ColorBufferLayout",
                                "initializer": "undefined",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "color.create_buffer"
                    },
                    "gamepad": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "icon": "",
                            "color": "#303030"
                        }
                    },
                    "gamepad.setButton": {
                        "kind": -3,
                        "attributes": {
                            "help": "gamepad/set-button",
                            "blockId": "joystickSetButton",
                            "block": "gamepad button %index=joystickStandardButton|",
                            "weight": 100,
                            "jsDoc": "Set the button state to down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "gamepad button ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "shadowBlockId": "joystickStandardButton",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "shadowBlockId": "joystickStandardButton",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "index"
                            }
                        ],
                        "pyQName": "gamepad.set_button"
                    },
                    "gamepad.move": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "gamepadMove",
                            "block": "gamepad %index|move by x %x|y %y",
                            "help": "gamepad/move",
                            "paramMin": {
                                "index": "0"
                            },
                            "paramMax": {
                                "index": "1"
                            },
                            "blockGap": "8",
                            "jsDoc": "Set the current move on the gamepad",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "gamepad ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "move by x ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "x",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "y ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "y",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "x",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "y",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "index",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "1"
                                    }
                                }
                            },
                            {
                                "name": "x"
                            },
                            {
                                "name": "y"
                            }
                        ]
                    },
                    "gamepad.setThrottle": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "gamepadSetThrottle",
                            "block": "gamepad set throttle %index|to %value",
                            "gamepad": "true",
                            "paramMin": {
                                "index": "0",
                                "value": "0"
                            },
                            "paramMax": {
                                "index": "1",
                                "value": "31"
                            },
                            "help": "gamepad/set-throttle",
                            "jsDoc": "Set the throttle state",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "gamepad set throttle ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "index",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "1"
                                    }
                                }
                            },
                            {
                                "name": "value",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "31"
                                    }
                                }
                            }
                        ],
                        "pyQName": "gamepad.set_throttle"
                    },
                    "GamepadButton": {
                        "kind": 6,
                        "retType": "GamepadButton",
                        "extendsTypes": [
                            "GamepadButton",
                            "Number"
                        ]
                    },
                    "GamepadButton.B": {
                        "retType": "GamepadButton.B",
                        "attributes": {
                            "blockIdentity": "gamepad.button",
                            "enumval": "0"
                        },
                        "extendsTypes": [
                            "GamepadButton.B",
                            "Number"
                        ]
                    },
                    "GamepadButton.A": {
                        "retType": "GamepadButton.A",
                        "attributes": {
                            "blockIdentity": "gamepad.button",
                            "enumval": "1"
                        },
                        "extendsTypes": [
                            "GamepadButton.A",
                            "Number"
                        ]
                    },
                    "GamepadButton.Y": {
                        "retType": "GamepadButton.Y",
                        "attributes": {
                            "blockIdentity": "gamepad.button",
                            "enumval": "2"
                        },
                        "extendsTypes": [
                            "GamepadButton.Y",
                            "Number"
                        ]
                    },
                    "GamepadButton.X": {
                        "retType": "GamepadButton.X",
                        "attributes": {
                            "blockIdentity": "gamepad.button",
                            "enumval": "3"
                        },
                        "extendsTypes": [
                            "GamepadButton.X",
                            "Number"
                        ]
                    },
                    "GamepadButton.LeftBumper": {
                        "retType": "GamepadButton.LeftBumper",
                        "attributes": {
                            "block": "left bumper",
                            "blockIdentity": "gamepad.button",
                            "enumval": "4",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "left bumper",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.LeftBumper",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.LEFT_BUMPER"
                    },
                    "GamepadButton.RightBumper": {
                        "retType": "GamepadButton.RightBumper",
                        "attributes": {
                            "block": "right bumper",
                            "blockIdentity": "gamepad.button",
                            "enumval": "5",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "right bumper",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.RightBumper",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.RIGHT_BUMPER"
                    },
                    "GamepadButton.LeftTrigger": {
                        "retType": "GamepadButton.LeftTrigger",
                        "attributes": {
                            "block": "left trigger",
                            "blockIdentity": "gamepad.button",
                            "enumval": "6",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "left trigger",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.LeftTrigger",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.LEFT_TRIGGER"
                    },
                    "GamepadButton.RightTrigger": {
                        "retType": "GamepadButton.RightTrigger",
                        "attributes": {
                            "block": "right trigger",
                            "blockIdentity": "gamepad.button",
                            "enumval": "7",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "right trigger",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.RightTrigger",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.RIGHT_TRIGGER"
                    },
                    "GamepadButton.Select": {
                        "retType": "GamepadButton.Select",
                        "attributes": {
                            "block": "select",
                            "blockIdentity": "gamepad.button",
                            "enumval": "8",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "select",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.Select",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.SELECT"
                    },
                    "GamepadButton.Start": {
                        "retType": "GamepadButton.Start",
                        "attributes": {
                            "block": "start",
                            "blockIdentity": "gamepad.button",
                            "enumval": "9",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "start",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.Start",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.START"
                    },
                    "GamepadButton.LeftStick": {
                        "retType": "GamepadButton.LeftStick",
                        "attributes": {
                            "block": "left stick",
                            "blockIdentity": "gamepad.button",
                            "enumval": "10",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "left stick",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.LeftStick",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.LEFT_STICK"
                    },
                    "GamepadButton.RightStick": {
                        "retType": "GamepadButton.RightStick",
                        "attributes": {
                            "block": "right stick",
                            "blockIdentity": "gamepad.button",
                            "enumval": "11",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "right stick",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.RightStick",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.RIGHT_STICK"
                    },
                    "GamepadButton.Up": {
                        "retType": "GamepadButton.Up",
                        "attributes": {
                            "block": "up",
                            "blockIdentity": "gamepad.button",
                            "enumval": "12",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.Up",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.UP"
                    },
                    "GamepadButton.Down": {
                        "retType": "GamepadButton.Down",
                        "attributes": {
                            "block": "down",
                            "blockIdentity": "gamepad.button",
                            "enumval": "13",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.Down",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.DOWN"
                    },
                    "GamepadButton.Left": {
                        "retType": "GamepadButton.Left",
                        "attributes": {
                            "block": "left",
                            "blockIdentity": "gamepad.button",
                            "enumval": "14",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "left",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.Left",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.LEFT"
                    },
                    "GamepadButton.Right": {
                        "retType": "GamepadButton.Right",
                        "attributes": {
                            "block": "right",
                            "blockIdentity": "gamepad.button",
                            "enumval": "15",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "right",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "GamepadButton.Right",
                            "Number"
                        ],
                        "pyQName": "GamepadButton.RIGHT"
                    },
                    "gamepad.button": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "blockId": "joystickStandardButton",
                            "block": "%button",
                            "shim": "TD_ID",
                            "blockHidden": true,
                            "paramHelp": {
                                "button": "the name of the button"
                            },
                            "jsDoc": "Maps to a standard layout button to the button index",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "button",
                                "description": "the name of the button",
                                "type": "GamepadButton",
                                "isEnum": true
                            }
                        ]
                    },
                    "network": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#E3008C",
                            "weight": 89,
                            "icon": "",
                            "groups": [
                                "Infrared",
                                "Cable"
                            ],
                            "jsDoc": "Communication between devices"
                        }
                    },
                    "network.cableSendPacket": {
                        "kind": -3,
                        "attributes": {
                            "parts": "cable",
                            "jsDoc": "Send data over cable."
                        },
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "network.cable_send_packet"
                    },
                    "network.cablePacket": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "parts": "cable",
                            "jsDoc": "Get most recent packet received over cable."
                        },
                        "parameters": [],
                        "pyQName": "network.cable_packet"
                    },
                    "network.onCablePacket": {
                        "kind": -3,
                        "attributes": {
                            "parts": "cable",
                            "jsDoc": "Run action after a packet is recieved over cable."
                        },
                        "parameters": [
                            {
                                "name": "body",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "network.on_cable_packet"
                    },
                    "network.onCableError": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Run action after there's an error reciving packet over cable."
                        },
                        "parameters": [
                            {
                                "name": "body",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "network.on_cable_error"
                    },
                    "InfraredPacket": {
                        "kind": 8,
                        "retType": "InfraredPacket",
                        "extendsTypes": []
                    },
                    "InfraredPacket.receivedNumber": {
                        "kind": 2,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "The first number in the payload."
                        },
                        "isInstance": true,
                        "pyQName": "InfraredPacket.received_number"
                    },
                    "InfraredPacket.receivedNumbers": {
                        "kind": 2,
                        "retType": "number[]",
                        "attributes": {
                            "jsDoc": "The array of numbers of received."
                        },
                        "isInstance": true,
                        "pyQName": "InfraredPacket.received_numbers"
                    },
                    "InfraredPacket.receivedBuffer": {
                        "kind": 2,
                        "retType": "Buffer",
                        "attributes": {
                            "jsDoc": "The raw buffer of data received"
                        },
                        "isInstance": true,
                        "pyQName": "InfraredPacket.received_buffer"
                    },
                    "network.infraredSendNumber": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "ir_send_number",
                            "block": "infrared send number %value",
                            "help": "network/infrared-send-number",
                            "parts": "ir",
                            "weight": 90,
                            "group": "Infrared",
                            "paramHelp": {
                                "value": "number to send"
                            },
                            "jsDoc": "Send a number over the infrared transmitter.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "infrared send number ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "number to send"
                            }
                        ],
                        "pyQName": "network.infrared_send_number"
                    },
                    "network.infraredSendNumbers": {
                        "kind": -3,
                        "attributes": {
                            "parts": "ir",
                            "group": "Infrared",
                            "paramHelp": {
                                "values": ""
                            },
                            "jsDoc": "Send an array of numbers over infrared. The array size has to be 32 bytes or less."
                        },
                        "parameters": [
                            {
                                "name": "values",
                                "type": "number[]"
                            }
                        ],
                        "pyQName": "network.infrared_send_numbers"
                    },
                    "network.onInfraredReceivedNumber": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "ir_on_infrared_received",
                            "block": "on infrared received",
                            "blockGap": "8",
                            "help": "network/on-infrared-received-number",
                            "parts": "ir",
                            "group": "Infrared",
                            "jsDoc": "Run some code when the infrared receiver gets a number.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on infrared received",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "(num: number) => void",
                                "handlerParameters": [
                                    {
                                        "name": "num",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "network.on_infrared_received_number"
                    },
                    "network.onInfraredReceivedNumbers": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Run some code when the infrared receiver gets a list of numbers."
                        },
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "(nums: number[]) => void",
                                "handlerParameters": [
                                    {
                                        "name": "nums",
                                        "type": "number[]"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "network.on_infrared_received_numbers"
                    },
                    "network.onInfraredReceivedBuffer": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Run some code when the infrared receiver gets a buffer."
                        },
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "(buf: Buffer) => void",
                                "handlerParameters": [
                                    {
                                        "name": "buf",
                                        "type": "Buffer"
                                    }
                                ]
                            }
                        ],
                        "pyQName": "network.on_infrared_received_buffer"
                    },
                    "network.onInfraredPacketReceived": {
                        "kind": -3,
                        "attributes": {
                            "mutate": "objectdestructuring",
                            "mutateText": "InfraredPacket",
                            "mutateDefaults": "receivedNumber",
                            "blockId": "ir_on_packet_received",
                            "block": "on infrared received",
                            "blockGap": "8",
                            "parts": "ir",
                            "group": "Infrared",
                            "blockHidden": true,
                            "deprecated": "1",
                            "jsDoc": "Run some code when the infrared receiver gets a packet.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on infrared received",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [
                            {
                                "name": "cb",
                                "type": "(p: InfraredPacket) => void"
                            }
                        ],
                        "pyQName": "network.on_infrared_packet_received"
                    },
                    "network.infraredSendPacket": {
                        "kind": -3,
                        "attributes": {
                            "parts": "ir",
                            "jsDoc": "Send data over IR."
                        },
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "network.infrared_send_packet"
                    },
                    "network.infraredPacket": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "parts": "ir",
                            "jsDoc": "Get most recent packet received over IR."
                        },
                        "parameters": [],
                        "pyQName": "network.infrared_packet"
                    },
                    "network.onInfraredPacket": {
                        "kind": -3,
                        "attributes": {
                            "parts": "ir",
                            "jsDoc": "Run action after a packet is recieved over IR."
                        },
                        "parameters": [
                            {
                                "name": "body",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "network.on_infrared_packet"
                    },
                    "network.onInfraredError": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Run action after there's an error recieving packet over IR."
                        },
                        "parameters": [
                            {
                                "name": "body",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "network.on_infrared_error"
                    },
                    "jcNamespace": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "190",
                            "weight": 100,
                            "block": "jc",
                            "jsDoc": "access to jc",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "jc",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "jcNamespace.readSomething": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "blockId": "jcNamespace_readSomething",
                            "block": "readSomething",
                            "jsDoc": "function to return something\n@returns something",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "readSomething",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "jcNamespace.read_something"
                    },
                    "input.onEvent": {
                        "kind": -3,
                        "attributes": {
                            "help": "input/on-event",
                            "blockId": "input_on_event",
                            "block": "on event",
                            "weight": 88,
                            "blockGap": "12",
                            "jsDoc": "Registers an event",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on event",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "input.on_event"
                    },
                    "input.trigger": {
                        "kind": -3,
                        "attributes": {
                            "help": "input/trigger",
                            "blockId": "input_trigger",
                            "block": "trigger",
                            "weight": 14,
                            "blockGap": "8",
                            "jsDoc": "trigger the event",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "trigger",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": []
                    },
                    "jctwo": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "190",
                            "weight": 100,
                            "block": "jc more",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "jc more",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "jctwo.readsome": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "blockId": "jcreadsomething",
                            "block": "readsomme",
                            "jsDoc": "Reads something\n@returns something",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "readsomme",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": []
                    },
                    "NeoPixelMode": {
                        "kind": 6,
                        "retType": "NeoPixelMode",
                        "attributes": {
                            "jsDoc": "Different modes for RGB or RGB+W NeoPixel strips"
                        },
                        "extendsTypes": [
                            "NeoPixelMode",
                            "Number"
                        ]
                    },
                    "NeoPixelMode.RGB": {
                        "retType": "NeoPixelMode.RGB",
                        "attributes": {
                            "block": "RGB (GRB format)",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "RGB (GRB format)",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "NeoPixelMode.RGB",
                            "Number"
                        ]
                    },
                    "NeoPixelMode.RGBW": {
                        "retType": "NeoPixelMode.RGBW",
                        "attributes": {
                            "block": "RGB+W",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "RGB+W",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "NeoPixelMode.RGBW",
                            "Number"
                        ]
                    },
                    "NeoPixelMode.RGB_RGB": {
                        "retType": "NeoPixelMode.RGB_RGB",
                        "attributes": {
                            "block": "RGB (RGB format)",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "RGB (RGB format)",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "NeoPixelMode.RGB_RGB",
                            "Number"
                        ]
                    },
                    "NeoPixelMode.APA102": {
                        "retType": "NeoPixelMode.APA102",
                        "attributes": {
                            "block": "APA102",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "APA102",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "NeoPixelMode.APA102",
                            "Number"
                        ]
                    },
                    "LightMove": {
                        "kind": 6,
                        "retType": "LightMove",
                        "extendsTypes": [
                            "LightMove",
                            "Number"
                        ]
                    },
                    "LightMove.Rotate": {
                        "retType": "LightMove.Rotate",
                        "attributes": {
                            "block": "rotate",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "rotate",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LightMove.Rotate",
                            "Number"
                        ],
                        "pyQName": "LightMove.ROTATE"
                    },
                    "LightMove.Shift": {
                        "retType": "LightMove.Shift",
                        "attributes": {
                            "block": "shift",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "shift",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LightMove.Shift",
                            "Number"
                        ],
                        "pyQName": "LightMove.SHIFT"
                    },
                    "PhotonMode": {
                        "kind": 6,
                        "retType": "PhotonMode",
                        "attributes": {
                            "jsDoc": "A determines the mode of the photon"
                        },
                        "extendsTypes": [
                            "PhotonMode",
                            "Number"
                        ]
                    },
                    "PhotonMode.PenUp": {
                        "retType": "PhotonMode.PenUp",
                        "attributes": {
                            "block": "pen up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pen up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PhotonMode.PenUp",
                            "Number"
                        ],
                        "pyQName": "PhotonMode.PEN_UP"
                    },
                    "PhotonMode.PenDown": {
                        "retType": "PhotonMode.PenDown",
                        "attributes": {
                            "block": "pen down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pen down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PhotonMode.PenDown",
                            "Number"
                        ],
                        "pyQName": "PhotonMode.PEN_DOWN"
                    },
                    "PhotonMode.Eraser": {
                        "retType": "PhotonMode.Eraser",
                        "attributes": {
                            "block": "eraser",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "eraser",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PhotonMode.Eraser",
                            "Number"
                        ],
                        "pyQName": "PhotonMode.ERASER"
                    },
                    "PhotonMode.Off": {
                        "retType": "PhotonMode.Off",
                        "attributes": {
                            "block": "off",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "off",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "PhotonMode.Off",
                            "Number"
                        ],
                        "pyQName": "PhotonMode.OFF"
                    },
                    "LightAnimation": {
                        "kind": 6,
                        "retType": "LightAnimation",
                        "extendsTypes": [
                            "LightAnimation",
                            "Number"
                        ]
                    },
                    "LightAnimation.Rainbow": {
                        "retType": "LightAnimation.Rainbow",
                        "attributes": {
                            "blockImage": "1",
                            "block": "rainbow",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "rainbow",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LightAnimation.Rainbow",
                            "Number"
                        ],
                        "pyQName": "LightAnimation.RAINBOW"
                    },
                    "LightAnimation.RunningLights": {
                        "retType": "LightAnimation.RunningLights",
                        "attributes": {
                            "blockImage": "1",
                            "block": "running lights",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "running lights",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LightAnimation.RunningLights",
                            "Number"
                        ],
                        "pyQName": "LightAnimation.RUNNING_LIGHTS"
                    },
                    "LightAnimation.Comet": {
                        "retType": "LightAnimation.Comet",
                        "attributes": {
                            "blockImage": "1",
                            "block": "comet",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "comet",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LightAnimation.Comet",
                            "Number"
                        ],
                        "pyQName": "LightAnimation.COMET"
                    },
                    "LightAnimation.Sparkle": {
                        "retType": "LightAnimation.Sparkle",
                        "attributes": {
                            "blockImage": "1",
                            "block": "sparkle",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "sparkle",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LightAnimation.Sparkle",
                            "Number"
                        ],
                        "pyQName": "LightAnimation.SPARKLE"
                    },
                    "LightAnimation.TheaterChase": {
                        "retType": "LightAnimation.TheaterChase",
                        "attributes": {
                            "blockImage": "1",
                            "block": "theater chase",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "theater chase",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LightAnimation.TheaterChase",
                            "Number"
                        ],
                        "pyQName": "LightAnimation.THEATER_CHASE"
                    },
                    "LightAnimation.ColorWipe": {
                        "retType": "LightAnimation.ColorWipe",
                        "attributes": {
                            "blockImage": "1",
                            "block": "color wipe",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "color wipe",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LightAnimation.ColorWipe",
                            "Number"
                        ],
                        "pyQName": "LightAnimation.COLOR_WIPE"
                    },
                    "light.NeoPixelStrip": {
                        "kind": 8,
                        "retType": "light.NeoPixelStrip",
                        "attributes": {
                            "jsDoc": "A NeoPixel strip"
                        },
                        "extendsTypes": []
                    },
                    "light.NeoPixelStrip._parent": {
                        "kind": 2,
                        "retType": "light.NeoPixelStrip",
                        "isInstance": true
                    },
                    "light.NeoPixelStrip._dataPin": {
                        "kind": 2,
                        "retType": "DigitalInOutPin",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._data_pin"
                    },
                    "light.NeoPixelStrip._clkPin": {
                        "kind": 2,
                        "retType": "DigitalInOutPin",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._clk_pin"
                    },
                    "light.NeoPixelStrip._buf": {
                        "kind": 2,
                        "retType": "Buffer",
                        "isInstance": true
                    },
                    "light.NeoPixelStrip._brightnessBuf": {
                        "kind": 2,
                        "retType": "Buffer",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._brightness_buf"
                    },
                    "light.NeoPixelStrip._sendBuf": {
                        "kind": 2,
                        "retType": "Buffer",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._send_buf"
                    },
                    "light.NeoPixelStrip._brightness": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "light.NeoPixelStrip._start": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "light.NeoPixelStrip._length": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "light.NeoPixelStrip._mode": {
                        "kind": 2,
                        "retType": "NeoPixelMode",
                        "isInstance": true
                    },
                    "light.NeoPixelStrip._buffered": {
                        "kind": 2,
                        "retType": "boolean",
                        "isInstance": true
                    },
                    "light.NeoPixelStrip._animationQueue": {
                        "kind": 2,
                        "retType": "control.AnimationQueue",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._animation_queue"
                    },
                    "light.NeoPixelStrip._barGraphHigh": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._bar_graph_high"
                    },
                    "light.NeoPixelStrip._barGraphHighLast": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._bar_graph_high_last"
                    },
                    "light.NeoPixelStrip._photonMode": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._photon_mode"
                    },
                    "light.NeoPixelStrip._photonPos": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._photon_pos"
                    },
                    "light.NeoPixelStrip._photonDir": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._photon_dir"
                    },
                    "light.NeoPixelStrip._photonPenColor": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._photon_pen_color"
                    },
                    "light.NeoPixelStrip._lastAnimation": {
                        "kind": 2,
                        "retType": "light.NeoPixelAnimation",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._last_animation"
                    },
                    "light.NeoPixelStrip._lastAnimationRenderer": {
                        "kind": 2,
                        "retType": "() => boolean",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._last_animation_renderer"
                    },
                    "light.NeoPixelStrip._transitionPlayer": {
                        "kind": 2,
                        "retType": "light.BrightnessTransitionPlayer",
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip._transition_player"
                    },
                    "light.NeoPixelStrip.__constructor": {
                        "kind": -3,
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.buf": {
                        "kind": -2,
                        "retType": "Buffer",
                        "attributes": {
                            "jsDoc": "Gets the underlying color buffer for the entire strip"
                        },
                        "isInstance": true,
                        "isReadOnly": true
                    },
                    "light.NeoPixelStrip.brightnessBuf": {
                        "kind": -2,
                        "retType": "Buffer",
                        "isInstance": true,
                        "isReadOnly": true,
                        "pyQName": "light.NeoPixelStrip.brightness_buf"
                    },
                    "light.NeoPixelStrip.mode": {
                        "kind": -2,
                        "retType": "NeoPixelMode",
                        "attributes": {
                            "jsDoc": "Gets the LED data layout mode"
                        },
                        "isInstance": true,
                        "isReadOnly": true
                    },
                    "light.NeoPixelStrip.setAll": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_set_strip_color",
                            "block": "set %strip all pixels to %rgb=colorNumberPicker",
                            "help": "light/neopixelstrip/set-all",
                            "weight": 80,
                            "blockGap": "8",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "rgb": "RGB color of the LED"
                            },
                            "jsDoc": "Set all of the pixels on the strip to one RGB color.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " all pixels to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "rgb"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_all"
                    },
                    "light.NeoPixelStrip.setGradient": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "lightsetgradient",
                            "block": "set %strip gradient from %startColor=colorNumberPicker to %endColor=colorNumberPicker",
                            "weight": 79,
                            "blockGap": "8",
                            "group": "More",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "startColor": "the start color",
                                "endColor": "the end color"
                            },
                            "jsDoc": "Sets a gradient between two colors",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " gradient from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "startColor",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "endColor",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "startColor",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "endColor",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "startColor"
                            },
                            {
                                "name": "endColor"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_gradient"
                    },
                    "light.NeoPixelStrip.graph": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_show_bar_graph",
                            "block": "%strip|graph %value||up to %high",
                            "icon": "",
                            "help": "light/neopixelstrip/graph",
                            "weight": 70,
                            "blockGap": "8",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "value": "current value to plot",
                                "high": "maximum value, 0 to autoscale"
                            },
                            "jsDoc": "Display a vertical bar graph based on the `value` and `high` value.\nIf `high` is 0, the chart gets adjusted automatically.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "graph ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            },
                            "_expandedDef": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "up to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value"
                            },
                            {
                                "name": "high"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.setPixelColor": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_set_pixel_color",
                            "block": "set %strip pixel color at %pixeloffset|to %rgb=colorNumberPicker",
                            "help": "light/neopixelstrip/set-pixel-color",
                            "weight": 79,
                            "blockGap": "8",
                            "group": "More",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "pixeloffset": "position of the NeoPixel in the strip",
                                "color": "RGB color of the LED"
                            },
                            "jsDoc": "Set the pixel to a given color.\nYou need to call ``show`` to make the changes visible.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " pixel color at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pixeloffset"
                            },
                            {
                                "name": "color"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_pixel_color"
                    },
                    "light.NeoPixelStrip.pixelColor": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "blockId": "light_get_pixel_color",
                            "block": "%strip|pixel color at %pixeloffset",
                            "help": "light/neopixelstrip/pixel-color",
                            "weight": 9,
                            "blockGap": "8",
                            "group": "More",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "pixeloffset": "position of the NeoPixel in the strip"
                            },
                            "jsDoc": "Gets the pixel color.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pixel color at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pixeloffset"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.pixel_color"
                    },
                    "light.NeoPixelStrip.setPixelWhiteLED": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_set_pixel_white_led",
                            "block": "set %strip pixel white LED at %pixeloffset|to %white",
                            "help": "light/neopixelstrip/set-pixel-white-led",
                            "weight": 5,
                            "blockGap": "8",
                            "group": "More",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "pixeloffset": "position of the LED in the strip",
                                "white": "brightness of the white LED"
                            },
                            "jsDoc": "Set the white brightness of a pixel in a NeoPixel strip of RGB+W LEDs.\nThis only works for RGB+W NeoPixels.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " pixel white LED at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "white",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "white",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pixeloffset"
                            },
                            {
                                "name": "white"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_pixel_white_led"
                    },
                    "light.NeoPixelStrip.show": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_show",
                            "block": "%strip|show",
                            "help": "light/neopixelstrip/show",
                            "weight": 86,
                            "blockGap": "8",
                            "group": "More",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "jsDoc": "Make the strip show all the new changes for the pixels.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "show",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.clear": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_clear",
                            "block": "%strip|clear",
                            "help": "light/neopixelstrip/clear",
                            "weight": 85,
                            "blockGap": "8",
                            "group": "More",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "jsDoc": "Turn off all pixel LEDs.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "clear",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.length": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "blockId": "light_length",
                            "block": "%strip|length",
                            "help": "light/neopixelstrip/length",
                            "weight": 8,
                            "blockGap": "8",
                            "group": "More",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "jsDoc": "Get the number of pixels on the strip",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "length",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.setBrightness": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "brightness": "20"
                            },
                            "blockId": "light_set_brightness",
                            "block": "set %strip brightness %brightness",
                            "paramMin": {
                                "brightness": "0"
                            },
                            "paramMax": {
                                "brightness": "255"
                            },
                            "help": "light/neopixelstrip/set-brightness",
                            "weight": 2,
                            "blockGap": "8",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "brightness": "a measure of LED brightness in 0-255. eg: 20"
                            },
                            "jsDoc": "Set the brightness of the strip. This flag only applies to future operation.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " brightness ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "brightness",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "brightness",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "brightness"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_brightness"
                    },
                    "light.NeoPixelStrip.setPixelBrightness": {
                        "kind": -1,
                        "attributes": {
                            "paramHelp": {
                                "index": "@param brightness "
                            },
                            "jsDoc": "Sets an individual pixel brightness"
                        },
                        "parameters": [
                            {
                                "name": "index",
                                "description": "@param brightness "
                            },
                            {
                                "name": "brightness"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_pixel_brightness"
                    },
                    "light.NeoPixelStrip.brightness": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "blockId": "light_get_brightness",
                            "block": "%strip|brightness",
                            "help": "light/neopixelstrip/brightness",
                            "parts": "neopixel",
                            "weight": 7,
                            "blockGap": "8",
                            "group": "More",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "jsDoc": "Get the brightness of the pixel strip.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "brightness",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.range": {
                        "kind": -1,
                        "retType": "light.NeoPixelStrip",
                        "attributes": {
                            "paramDefl": {
                                "length": "4"
                            },
                            "blockId": "light_range",
                            "block": "%strip|range from %start|with %length|pixels",
                            "help": "light/neopixelstrip/range",
                            "weight": 99,
                            "blockGap": "30",
                            "blockSetVariable": "strip",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "start": "offset in the NeoPixel strip to start the range",
                                "length": "number of pixels in the range, eg: 4"
                            },
                            "jsDoc": "Create a range of pixels.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "range from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "start",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "with ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "length",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pixels",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "start",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "length",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "start"
                            },
                            {
                                "name": "length"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.move": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "offset": "1"
                            },
                            "blockId": "light_move_pixels",
                            "block": "%strip|%kind=MoveKind|by %offset",
                            "help": "light/neopixelstrip/move",
                            "weight": 87,
                            "blockGap": "8",
                            "group": "More",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "offset": "number of pixels to shift forward, eg: 1"
                            },
                            "jsDoc": "Shift LEDs forward and clear with zeros.\nYou need to call ``show`` to make the changes visible.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "kind",
                                        "shadowBlockId": "MoveKind",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "by ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "offset",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "kind",
                                        "shadowBlockId": "MoveKind",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "offset",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "kind",
                                "type": "LightMove",
                                "isEnum": true
                            },
                            {
                                "name": "offset"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.initPhoton": {
                        "kind": -1,
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.init_photon"
                    },
                    "light.NeoPixelStrip.photonForward": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "steps": "1"
                            },
                            "blockId": "light_photon_fd",
                            "block": "%strip|photon forward by %steps",
                            "help": "light/neopixelstrip/photon-forward",
                            "weight": 41,
                            "blockGap": "8",
                            "group": "Photon",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "steps": "number of steps (lights) to move, eg: 1"
                            },
                            "jsDoc": "Move a photon effect along the pixel strip by a number of steps.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "photon forward by ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "steps",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "steps",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "steps"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.photon_forward"
                    },
                    "light.NeoPixelStrip.photonFlip": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_photon_flip",
                            "block": "%strip|photon flip",
                            "help": "light/neopixelstrip/photon-flip",
                            "weight": 40,
                            "blockGap": "8",
                            "group": "Photon",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "jsDoc": "Switch the direction of the photon pulse.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "photon flip",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.photon_flip"
                    },
                    "light.NeoPixelStrip.setPhotonPosition": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_photon_set_position",
                            "block": "%strip|photon set position %index",
                            "help": "light/neopixelstrip/set-photon-position",
                            "weight": 39,
                            "blockGap": "8",
                            "group": "Photon",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "index": "index of the light, if out of bound, the index is wrapped"
                            },
                            "jsDoc": "Sets the photon position to a given light index",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "photon set position ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "index"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_photon_position"
                    },
                    "light.NeoPixelStrip.setPhotonPenColor": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_photon_set_pen_color",
                            "block": "%strip=variables_get|photon set pen color %color=colorNumberPicker",
                            "help": "light/neopixelstrip/set-photon-pen-color",
                            "weight": 38,
                            "blockGap": "8",
                            "group": "Photon",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "color": "the color of the photon"
                            },
                            "jsDoc": "Set the photon color.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "shadowBlockId": "variables_get",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "photon set pen color ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "shadowBlockId": "variables_get",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "color"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_photon_pen_color"
                    },
                    "light.NeoPixelStrip.setPhotonPenHue": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_photon_set_pen_hue",
                            "block": "%strip=variables_get|photon set pen hue %hue=colorWheelHsvPicker",
                            "help": "light/neopixelstrip/set-photon-pen-hue",
                            "weight": 39,
                            "blockGap": "8",
                            "group": "Photon",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "hue": "the hue of the photon color"
                            },
                            "jsDoc": "Sets the photon hue.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "shadowBlockId": "variables_get",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "photon set pen hue ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "hue",
                                        "shadowBlockId": "colorWheelHsvPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "shadowBlockId": "variables_get",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "hue",
                                        "shadowBlockId": "colorWheelHsvPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "hue"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_photon_pen_hue"
                    },
                    "light.NeoPixelStrip.setPhotonColor": {
                        "kind": -1,
                        "attributes": {
                            "deprecated": "1",
                            "blockHidden": true,
                            "group": "Photon",
                            "advanced": true
                        },
                        "parameters": [
                            {
                                "name": "hue"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_photon_color"
                    },
                    "light.NeoPixelStrip.setPhotonMode": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_photon_set_photon",
                            "block": "%strip|photon %mode",
                            "help": "light/neopixelstrip/set-photon-mode",
                            "weight": 38,
                            "group": "Photon",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "mode": "the desired mode"
                            },
                            "jsDoc": "Set the photon mode to pen up, pen down, or eraser.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "photon ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "mode",
                                "type": "PhotonMode",
                                "isEnum": true
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_photon_mode"
                    },
                    "light.NeoPixelStrip.startBrightnessTransition": {
                        "kind": -1,
                        "attributes": {
                            "paramHelp": {
                                "transition": "@param duration "
                            },
                            "jsDoc": "Starts a brightness transition on the strip (and cancels any other running transition)"
                        },
                        "parameters": [
                            {
                                "name": "startBrightness"
                            },
                            {
                                "name": "endBrightness"
                            },
                            {
                                "name": "duration"
                            },
                            {
                                "name": "repeat",
                                "initializer": "undefined"
                            },
                            {
                                "name": "yoyo",
                                "type": "boolean",
                                "initializer": "undefined"
                            },
                            {
                                "name": "transition",
                                "description": "@param duration ",
                                "type": "light.BrightnessTransition",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.start_brightness_transition"
                    },
                    "light.NeoPixelStrip.stopBrightnessTransition": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Stops any running brightness transition"
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.stop_brightness_transition"
                    },
                    "light.NeoPixelStrip.showAnimation": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "duration": "500"
                            },
                            "blockId": "light_show_animation",
                            "block": "%strip|show animation %animation=light_animation_picker|for %duration=timePicker|ms",
                            "help": "light/neopixelstrip/show-animation",
                            "weight": 90,
                            "blockGap": "8",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "animation": "the animation to run",
                                "duration": "the duration to run in milliseconds, eg: 500"
                            },
                            "jsDoc": "Show an animation or queue an animation in the animation queue",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "show animation ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation_picker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "for ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "timePicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "ms",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation_picker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "timePicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "animation",
                                "type": "light.NeoPixelAnimation"
                            },
                            {
                                "name": "duration"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.show_animation"
                    },
                    "light.NeoPixelStrip.showAnimationFrame": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_show_animation_frame",
                            "block": "%strip|show frame of %animation=light_animation_picker|animation",
                            "help": "light/neopixelstrip/show-animation-frame",
                            "weight": 87,
                            "blockGap": "8",
                            "group": "More",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "animation": "the animation to run"
                            },
                            "jsDoc": "Show a single animation frame.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "show frame of ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation_picker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "animation",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation_picker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "animation",
                                "type": "light.NeoPixelAnimation"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.show_animation_frame"
                    },
                    "light.NeoPixelStrip.showColors": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Renders a pattern of colors on the strip"
                        },
                        "parameters": [
                            {
                                "name": "leds",
                                "type": "string"
                            },
                            {
                                "name": "interval",
                                "initializer": "400"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.show_colors"
                    },
                    "light.NeoPixelStrip.stopAllAnimations": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_stop_all_animations",
                            "block": "%strip|stop all animations",
                            "help": "light/neopixelstrip/stop-all-animations",
                            "weight": 85,
                            "blockGap": "8",
                            "group": "More",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "jsDoc": "Stop the current animation and any other animations ready to show.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "stop all animations",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.stop_all_animations"
                    },
                    "light.NeoPixelStrip.setBuffered": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_set_buffered",
                            "block": "set %strip buffered  %on",
                            "help": "light/neopixelstrip/set-buffered",
                            "weight": 86,
                            "blockGap": "8",
                            "group": "Configuration",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "on": "call show whenever a light is modified"
                            },
                            "jsDoc": "Enables or disables automatically calling show when a change is made",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " buffered  ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "on",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "on",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "on",
                                "type": "boolean"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_buffered"
                    },
                    "light.NeoPixelStrip.buffered": {
                        "kind": -1,
                        "retType": "boolean",
                        "attributes": {
                            "weight": 85,
                            "blockGap": "8",
                            "group": "Configuration",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "jsDoc": "Gets a value indicated if the changes are buffered"
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.setMode": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_set_mode",
                            "block": "set %strip mode to %mode",
                            "help": "light/neopixelstrip/set-mode",
                            "weight": 1,
                            "blockGap": "8",
                            "group": "Configuration",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "mode": "the kind of color encoding required by the programmable lights"
                            },
                            "jsDoc": "Sets the color mode and clears the colors.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " mode to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "mode",
                                "type": "NeoPixelMode",
                                "isEnum": true
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_mode"
                    },
                    "light.NeoPixelStrip.setLength": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "light_set_length",
                            "block": "set %strip length to %length pixels",
                            "weight": 1,
                            "blockGap": "8",
                            "_shadowOverrides": {
                                "length": "lightLengthPicker"
                            },
                            "group": "Configuration",
                            "advanced": false,
                            "subcategory": "NeoPixel",
                            "paramHelp": {
                                "numleds": ""
                            },
                            "jsDoc": "Sets the number of LEDs on a strip",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " length to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "length",
                                        "shadowBlockId": "lightLengthPicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " pixels",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "strip",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "length",
                                        "shadowBlockId": "lightLengthPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "length"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelStrip.set_length"
                    },
                    "light.NeoPixelStrip.__setAll": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neopixel_set_strip_color",
                            "block": "set all pixels to %rgb=colorNumberPicker",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "rgb": "RGB color of the LED"
                            },
                            "jsDoc": "Set all of the pixels on the strip to one RGB color.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set all pixels to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "rgb",
                                "description": "RGB color of the LED"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__graph": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neopixel_show_bar_graph",
                            "block": "graph %value |up to %high",
                            "icon": "",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "value": "current value to plot",
                                "high": "maximum value, 0 to autoscale"
                            },
                            "jsDoc": "Display a vertical bar graph based on the `value` and `high` value.\nIf `high` is 0, the chart gets adjusted automatically.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "graph ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " ",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "up to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "current value to plot"
                            },
                            {
                                "name": "high",
                                "description": "maximum value, 0 to autoscale"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__setPixelColor": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neopixel_set_pixel_color",
                            "block": "set pixel color at %pixeloffset|to %rgb=colorNumberPicker",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "pixeloffset": "position of the NeoPixel in the strip",
                                "color": "RGB color of the LED"
                            },
                            "jsDoc": "Set the pixel to a given color.\nYou need to call ``show`` to make the changes visible.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set pixel color at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pixeloffset",
                                "description": "position of the NeoPixel in the strip"
                            },
                            {
                                "name": "color",
                                "description": "RGB color of the LED"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__pixelColor": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "blockId": "neopixel_get_pixel_color",
                            "block": "pixel color at %pixeloffset",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "pixeloffset": "position of the NeoPixel in the strip"
                            },
                            "jsDoc": "Gets the pixel color.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pixel color at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pixeloffset",
                                "description": "position of the NeoPixel in the strip"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__setPixelWhiteLED": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neopixel_set_pixel_white_led",
                            "block": "set pixel white LED at %pixeloffset|to %white",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "pixeloffset": "position of the LED in the strip",
                                "white": "brightness of the white LED"
                            },
                            "jsDoc": "Set the white brightness of a pixel in a NeoPixel strip of RGB+W LEDs.\nThis only works for RGB+W NeoPixels.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set pixel white LED at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "white",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "white",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pixeloffset",
                                "description": "position of the LED in the strip"
                            },
                            {
                                "name": "white",
                                "description": "brightness of the white LED"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__show": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neopixel_show",
                            "block": "show",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "jsDoc": "Make the strip show all the new changes for the pixels.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "show",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__clear": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neopixel_clear",
                            "block": "clear",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "jsDoc": "Turn off all pixel LEDs.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "clear",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__length": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "blockId": "neopixel_length",
                            "block": "length",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "jsDoc": "Get the number of pixels on the strip",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "length",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__setBrightness": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "brightness": "20"
                            },
                            "blockId": "neopixel_set_brightness",
                            "block": "set brightness %brightness",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "brightness": "a measure of LED brightness in 0-255. eg: 20"
                            },
                            "jsDoc": "Set the brightness of the strip. This flag only applies to future operation.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set brightness ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "brightness",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "brightness",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "brightness",
                                "description": "a measure of LED brightness in 0-255. eg: 20",
                                "default": "20"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__brightness": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "blockId": "neopixel_get_brightness",
                            "block": "brightness",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "jsDoc": "Get the brightness of the pixel strip.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "brightness",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__range": {
                        "kind": -1,
                        "retType": "light.NeoPixelStrip",
                        "attributes": {
                            "paramDefl": {
                                "length": "4"
                            },
                            "blockId": "neopixel_range",
                            "block": "range from %start|with %length|pixels",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "start": "offset in the NeoPixel strip to start the range",
                                "length": "number of pixels in the range. eg: 4"
                            },
                            "jsDoc": "Create a range of pixels.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "range from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "start",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "with ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "length",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pixels",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "start",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "length",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "start",
                                "description": "offset in the NeoPixel strip to start the range"
                            },
                            {
                                "name": "length",
                                "description": "number of pixels in the range. eg: 4",
                                "default": "4"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__move": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "offset": "1"
                            },
                            "blockId": "neopixel_move_pixels",
                            "block": "%kind=MoveKind|by %offset",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "offset": "number of pixels to shift forward, eg: 1"
                            },
                            "jsDoc": "Shift LEDs forward and clear with zeros.\nYou need to call ``show`` to make the changes visible.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "kind",
                                        "shadowBlockId": "MoveKind",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "by ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "offset",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "kind",
                                        "shadowBlockId": "MoveKind",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "offset",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "kind",
                                "type": "LightMove",
                                "isEnum": true
                            },
                            {
                                "name": "offset",
                                "description": "number of pixels to shift forward, eg: 1",
                                "initializer": "1",
                                "default": "1"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__photonForward": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "steps": "1"
                            },
                            "blockId": "neophoton_fd",
                            "block": "photon forward by %steps",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "steps": "number of steps (lights) to move, eg: 1"
                            },
                            "jsDoc": "Move a photon effect along the pixel strip by a number of steps.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "photon forward by ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "steps",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "steps",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "steps",
                                "description": "number of steps (lights) to move, eg: 1",
                                "default": "1"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__photonFlip": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neophoton_flip",
                            "block": "photon flip",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "jsDoc": "Switch the direction of the photon pulse.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "photon flip",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__setPhotonColor": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neophoton_set_color",
                            "block": "photon set pen color %color",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "color": "the color of the photon"
                            },
                            "jsDoc": "Set the photon color.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "photon set pen color ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "color",
                                "description": "the color of the photon"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__setPhotonMode": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neophoton_set_photon",
                            "block": "photon %mode",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "mode": "the desired mode"
                            },
                            "jsDoc": "Set the photon mode to pen up, pen down, or eraser.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "photon ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "mode",
                                "description": "the desired mode",
                                "type": "PhotonMode",
                                "isEnum": true
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__showAnimation": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "duration": "500"
                            },
                            "blockId": "neopixel_show_animation",
                            "block": "show %animation=light_animation|animation for %duration=timePicker|ms",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "animation": "the animation to run",
                                "duration": "the duration to run in milliseconds, eg: 500"
                            },
                            "jsDoc": "Show an animation or queue an animation in the animation queue",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "show ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "animation for ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "timePicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "ms",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "timePicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "animation",
                                "description": "the animation to run",
                                "type": "light.NeoPixelAnimation"
                            },
                            {
                                "name": "duration",
                                "description": "the duration to run in milliseconds, eg: 500",
                                "default": "500"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__showAnimationFrame": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neopixel_show_animation_frame",
                            "block": "show animation frame %animation=light_animation",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "animation": "the animation to run"
                            },
                            "jsDoc": "Show a single animation frame",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "show animation frame ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "animation",
                                "description": "the animation to run",
                                "type": "light.NeoPixelAnimation"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__stopAllAnimations": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neopixel_stop_all_animations",
                            "block": "stop all animations",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "jsDoc": "Stop the current animation and any other animations ready to show.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "stop all animations",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__setBuffered": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neopixel_set_buffered",
                            "block": "set buffered  %on",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "on": "call show whenever a light is modified"
                            },
                            "jsDoc": "Enables or disables automatically calling show when a change is made",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set buffered  ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "on",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "on",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "on",
                                "description": "call show whenever a light is modified",
                                "type": "boolean"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.NeoPixelStrip.__setMode": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "neopixel_set_mode",
                            "block": "set mode %mode",
                            "deprecated": "1",
                            "defaultInstance": "light.pixels",
                            "paramHelp": {
                                "mode": "the kind of color encoding required by the programmable lights"
                            },
                            "jsDoc": "Sets the color mode and clears the colors.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set mode ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "mode",
                                "description": "the kind of color encoding required by the programmable lights",
                                "type": "NeoPixelMode",
                                "isEnum": true
                            }
                        ],
                        "isInstance": true
                    },
                    "light.createNeoPixelStrip": {
                        "kind": -3,
                        "retType": "light.NeoPixelStrip",
                        "attributes": {
                            "blockId": "neopixel_create",
                            "block": "create WS2812 strip|pin %pin|with %numleds pixels",
                            "help": "light/create-neo-pixel-strip",
                            "trackArgs": [
                                0,
                                2
                            ],
                            "parts": "neopixel",
                            "weight": 100,
                            "blockSetVariable": "strip",
                            "advanced": true,
                            "blockHidden": true,
                            "jsDoc": "Creates a strip of colored LEDs (WS2812b)",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "create WS2812 strip",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pin ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "with ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "numleds",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " pixels",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "numleds",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pin",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "numleds",
                                "initializer": "10"
                            },
                            {
                                "name": "mode",
                                "type": "NeoPixelMode",
                                "initializer": "undefined",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "light.create_neo_pixel_strip"
                    },
                    "light.rgb": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "red": "255",
                                "green": "255",
                                "blue": "255"
                            },
                            "blockId": "neopixel_rgb",
                            "block": "red %red|green %green|blue %blue",
                            "paramMin": {
                                "red": "0",
                                "green": "0",
                                "blue": "0"
                            },
                            "paramMax": {
                                "red": "255",
                                "green": "255",
                                "blue": "255"
                            },
                            "help": "light/rgb",
                            "group": "Color",
                            "weight": 19,
                            "blockGap": "8",
                            "paramHelp": {
                                "red": "value of the red channel between 0 and 255. eg: 255",
                                "green": "value of the green channel between 0 and 255. eg: 255",
                                "blue": "value of the blue channel between 0 and 255. eg: 255"
                            },
                            "jsDoc": "Converts red, green, blue channels into a RGB color",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "red ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "red",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "green ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "green",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "blue ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "blue",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "red",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "green",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "blue",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "red",
                                "description": "value of the red channel between 0 and 255. eg: 255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            },
                            {
                                "name": "green",
                                "description": "value of the green channel between 0 and 255. eg: 255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            },
                            {
                                "name": "blue",
                                "description": "value of the blue channel between 0 and 255. eg: 255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            }
                        ]
                    },
                    "light.colors": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "blockId": "neopixel_colors",
                            "block": "%color",
                            "help": "light/colors",
                            "shim": "TD_ID",
                            "group": "Color",
                            "weight": 20,
                            "blockGap": "8",
                            "jsDoc": "Get the RGB value of a known color",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "color",
                                "type": "Colors",
                                "isEnum": true
                            }
                        ]
                    },
                    "light.hsv": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "hue": "255",
                                "sat": "255",
                                "val": "255"
                            },
                            "blockId": "neopixel_hsv",
                            "block": "hue %hue|sat %sat|val %val",
                            "paramMin": {
                                "hue": "0",
                                "sat": "0",
                                "val": "0"
                            },
                            "paramMax": {
                                "hue": "255",
                                "sat": "255",
                                "val": "255"
                            },
                            "help": "light/hsv",
                            "group": "Color",
                            "weight": 17,
                            "paramHelp": {
                                "hue": "value of the hue channel between 0 and 255. eg: 255",
                                "sat": "value of the saturation channel between 0 and 255. eg: 255",
                                "val": "value of the value channel between 0 and 255. eg: 255"
                            },
                            "jsDoc": "Convert an HSV (hue, saturation, value) color to RGB",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "hue ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "hue",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "sat ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sat",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "val ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "val",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "hue",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sat",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "val",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "hue",
                                "description": "value of the hue channel between 0 and 255. eg: 255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            },
                            {
                                "name": "sat",
                                "description": "value of the saturation channel between 0 and 255. eg: 255",
                                "initializer": "255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            },
                            {
                                "name": "val",
                                "description": "value of the value channel between 0 and 255. eg: 255",
                                "initializer": "255",
                                "default": "255",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            }
                        ]
                    },
                    "light.fade": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "brightness": "128"
                            },
                            "blockId": "neopixel_fade",
                            "block": "fade %color=neopixel_colors|by %brightness",
                            "paramMin": {
                                "brightness": "0"
                            },
                            "paramMax": {
                                "brightness": "255"
                            },
                            "help": "light/fade",
                            "group": "Color",
                            "weight": 18,
                            "blockGap": "8",
                            "blockHidden": true,
                            "deprecated": "true",
                            "paramHelp": {
                                "color": "color to fade",
                                "brightness": "the amount of brightness to apply to the color, eg: 128"
                            },
                            "jsDoc": "Use color.fade instead",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "fade ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "shadowBlockId": "neopixel_colors",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "by ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "brightness",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "color",
                                        "shadowBlockId": "neopixel_colors",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "brightness",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "c"
                            },
                            {
                                "name": "brightness",
                                "description": "the amount of brightness to apply to the color, eg: 128",
                                "default": "128",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            }
                        ]
                    },
                    "light.NeoPixelAnimation": {
                        "kind": 8,
                        "retType": "light.NeoPixelAnimation",
                        "attributes": {
                            "fixedInstances": "true",
                            "jsDoc": "An animation of a NeoPixel"
                        },
                        "extendsTypes": [
                            "light.NeoPixelAnimation"
                        ]
                    },
                    "light.NeoPixelAnimation.__constructor": {
                        "kind": -3,
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.NeoPixelAnimation.createRenderer": {
                        "kind": -1,
                        "retType": "() => boolean",
                        "attributes": {
                            "paramHelp": {
                                "strip": "the strip to execute on"
                            },
                            "jsDoc": "Creates an animator instance"
                        },
                        "parameters": [
                            {
                                "name": "strip",
                                "description": "the strip to execute on",
                                "type": "light.NeoPixelStrip"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.NeoPixelAnimation.create_renderer"
                    },
                    "light.RainbowCycleAnimation": {
                        "kind": 8,
                        "retType": "light.RainbowCycleAnimation",
                        "extendsTypes": [
                            "light.RainbowCycleAnimation",
                            "light.NeoPixelAnimation"
                        ]
                    },
                    "light.RainbowCycleAnimation.delay": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "light.RainbowCycleAnimation.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "delay"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.RainbowCycleAnimation.createRenderer": {
                        "kind": -1,
                        "retType": "() => boolean",
                        "parameters": [
                            {
                                "name": "strip",
                                "type": "light.NeoPixelStrip"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.RainbowCycleAnimation.create_renderer"
                    },
                    "light.rainbowAnimation": {
                        "kind": 4,
                        "retType": "light.NeoPixelAnimation",
                        "attributes": {
                            "fixedInstance": "true",
                            "block": "rainbow",
                            "whenUsed": true,
                            "jres": "true",
                            "blockIdentity": "light._animationPicker",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "rainbow",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "light.rainbow_animation"
                    },
                    "light.RunningLightsAnimation": {
                        "kind": 8,
                        "retType": "light.RunningLightsAnimation",
                        "extendsTypes": [
                            "light.RunningLightsAnimation",
                            "light.NeoPixelAnimation"
                        ]
                    },
                    "light.RunningLightsAnimation.red": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "light.RunningLightsAnimation.green": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "light.RunningLightsAnimation.blue": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "light.RunningLightsAnimation.delay": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "light.RunningLightsAnimation.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "red"
                            },
                            {
                                "name": "green"
                            },
                            {
                                "name": "blue"
                            },
                            {
                                "name": "delay"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.RunningLightsAnimation.createRenderer": {
                        "kind": -1,
                        "retType": "() => boolean",
                        "parameters": [
                            {
                                "name": "strip",
                                "type": "light.NeoPixelStrip"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.RunningLightsAnimation.create_renderer"
                    },
                    "light.runningLightsAnimation": {
                        "kind": 4,
                        "retType": "light.NeoPixelAnimation",
                        "attributes": {
                            "fixedInstance": "true",
                            "block": "running lights",
                            "jres": "true",
                            "blockIdentity": "light._animationPicker",
                            "whenUsed": true,
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "running lights",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "light.running_lights_animation"
                    },
                    "light.cometAnimation": {
                        "kind": 4,
                        "retType": "light.NeoPixelAnimation",
                        "attributes": {
                            "fixedInstance": "true",
                            "block": "comet",
                            "jres": "true",
                            "blockIdentity": "light._animationPicker",
                            "whenUsed": true,
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "comet",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "light.comet_animation"
                    },
                    "light.SparkleAnimation": {
                        "kind": 8,
                        "retType": "light.SparkleAnimation",
                        "extendsTypes": [
                            "light.SparkleAnimation",
                            "light.NeoPixelAnimation"
                        ]
                    },
                    "light.SparkleAnimation.rgb": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "light.SparkleAnimation.delay": {
                        "kind": 2,
                        "retType": "number",
                        "isInstance": true
                    },
                    "light.SparkleAnimation.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "red"
                            },
                            {
                                "name": "green"
                            },
                            {
                                "name": "blue"
                            },
                            {
                                "name": "delay"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.SparkleAnimation.createRenderer": {
                        "kind": -1,
                        "retType": "() => boolean",
                        "parameters": [
                            {
                                "name": "strip",
                                "type": "light.NeoPixelStrip"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "light.SparkleAnimation.create_renderer"
                    },
                    "light.sparkleAnimation": {
                        "kind": 4,
                        "retType": "light.NeoPixelAnimation",
                        "attributes": {
                            "fixedInstance": "true",
                            "block": "sparkle",
                            "jres": "true",
                            "blockIdentity": "light._animationPicker",
                            "whenUsed": true,
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "sparkle",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "light.sparkle_animation"
                    },
                    "light.colorWipeAnimation": {
                        "kind": 4,
                        "retType": "light.NeoPixelAnimation",
                        "attributes": {
                            "fixedInstance": "true",
                            "block": "color wipe",
                            "jres": "true",
                            "blockIdentity": "light._animationPicker",
                            "whenUsed": true,
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "color wipe",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "light.color_wipe_animation"
                    },
                    "light.theaterChaseAnimation": {
                        "kind": 4,
                        "retType": "light.NeoPixelAnimation",
                        "attributes": {
                            "fixedInstance": "true",
                            "block": "theater chase",
                            "jres": "true",
                            "blockIdentity": "light._animationPicker",
                            "whenUsed": true,
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "theater chase",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "light.theater_chase_animation"
                    },
                    "light._animationPicker": {
                        "kind": -3,
                        "retType": "light.NeoPixelAnimation",
                        "attributes": {
                            "blockId": "light_animation_picker",
                            "block": "%animation",
                            "shim": "TD_ID",
                            "paramFieldEditor": {
                                "animation": "imagedropdown"
                            },
                            "paramFieldEditorOptions": {
                                "animation": {
                                    "columns": "3"
                                }
                            },
                            "weight": 0,
                            "group": "More",
                            "paramHelp": {
                                "animation": "The animation type"
                            },
                            "jsDoc": "An animation that can be shown on a light strip",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "animation",
                                "description": "The animation type",
                                "type": "light.NeoPixelAnimation"
                            }
                        ],
                        "pyQName": "light._animation_picker"
                    },
                    "light.__lengthPicker": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "blockId": "lightLengthPicker",
                            "block": "%pixels",
                            "blockHidden": true,
                            "shim": "TD_ID",
                            "colorSecondary": "#FFFFFF",
                            "paramFieldEditor": {
                                "pixels": "numberdropdown"
                            },
                            "paramFieldEditorOptions": {
                                "pixels": {
                                    "decompileLiterals": "true",
                                    "data": "[[\"7\", 7], [\"8\", 8], [\"12\", 12], [\"16\", 16], [\"24\", 24], [\"30\", 30], [\"60\", 60], [\"64\", 64], [\"90\", 90], [\"120\", 120], [\"144\", 144]]"
                                }
                            },
                            "paramHelp": {
                                "pixels": "number of LEDs"
                            },
                            "jsDoc": "Get the light length picker",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "pixels",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pixels",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pixels",
                                "description": "number of LEDs"
                            }
                        ]
                    },
                    "easing": {
                        "kind": 5,
                        "retType": ""
                    },
                    "easing.linear": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "t"
                            }
                        ]
                    },
                    "easing.inQuad": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "t"
                            }
                        ],
                        "pyQName": "easing.in_quad"
                    },
                    "easing.outQuad": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "t"
                            }
                        ],
                        "pyQName": "easing.out_quad"
                    },
                    "easing.inOutQuad": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "t"
                            }
                        ],
                        "pyQName": "easing.in_out_quad"
                    },
                    "easing.inCubic": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "t"
                            }
                        ],
                        "pyQName": "easing.in_cubic"
                    },
                    "easing.outCubic": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "t"
                            }
                        ],
                        "pyQName": "easing.out_cubic"
                    },
                    "easing.inOutCubic": {
                        "kind": -3,
                        "retType": "number",
                        "parameters": [
                            {
                                "name": "t"
                            }
                        ],
                        "pyQName": "easing.in_out_cubic"
                    },
                    "light.BrightnessTransition": {
                        "kind": 8,
                        "retType": "light.BrightnessTransition",
                        "extendsTypes": [
                            "light.BrightnessTransition"
                        ]
                    },
                    "light.BrightnessTransition.__constructor": {
                        "kind": -3,
                        "parameters": [],
                        "isInstance": true
                    },
                    "light.BrightnessTransition.apply": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "strip",
                                "type": "light.NeoPixelStrip"
                            },
                            {
                                "name": "t"
                            },
                            {
                                "name": "start"
                            },
                            {
                                "name": "end"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.EasingBrightnessTransition": {
                        "kind": 8,
                        "retType": "light.EasingBrightnessTransition",
                        "extendsTypes": [
                            "light.EasingBrightnessTransition",
                            "light.BrightnessTransition"
                        ]
                    },
                    "light.EasingBrightnessTransition.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "timeEasing",
                                "type": "(t: number) => number",
                                "handlerParameters": [
                                    {
                                        "name": "t",
                                        "type": "number"
                                    }
                                ]
                            },
                            {
                                "name": "spatialEasing",
                                "type": "(t: number) => number",
                                "initializer": "undefined",
                                "handlerParameters": [
                                    {
                                        "name": "t",
                                        "type": "number"
                                    }
                                ]
                            }
                        ],
                        "isInstance": true
                    },
                    "light.EasingBrightnessTransition.apply": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "strip",
                                "type": "light.NeoPixelStrip"
                            },
                            {
                                "name": "t"
                            },
                            {
                                "name": "start"
                            },
                            {
                                "name": "end"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.BrightnessTransitionPlayer": {
                        "kind": 8,
                        "retType": "light.BrightnessTransitionPlayer",
                        "extendsTypes": []
                    },
                    "light.BrightnessTransitionPlayer.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "transition",
                                "type": "light.BrightnessTransition"
                            },
                            {
                                "name": "startBrightness"
                            },
                            {
                                "name": "endBrightness"
                            },
                            {
                                "name": "duration"
                            },
                            {
                                "name": "repeat"
                            },
                            {
                                "name": "yoyo",
                                "type": "boolean"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.BrightnessTransitionPlayer.update": {
                        "kind": -1,
                        "retType": "boolean",
                        "parameters": [
                            {
                                "name": "strip",
                                "type": "light.NeoPixelStrip"
                            }
                        ],
                        "isInstance": true
                    },
                    "light.createStrip": {
                        "kind": -3,
                        "retType": "light.NeoPixelStrip",
                        "attributes": {
                            "paramDefl": {
                                "pin": "pins.A1",
                                "numleds": "30",
                                "mode": "NeoPixelMode.RGB_GRB"
                            },
                            "blockId": "neopixel_create_strip",
                            "block": "create strip on %pin with %numleds pixels",
                            "help": "light/create-strip",
                            "trackArgs": [
                                0,
                                2
                            ],
                            "parts": "neopixel",
                            "weight": 100,
                            "blockGap": "8",
                            "subcategory": "NeoPixel",
                            "blockSetVariable": "strip",
                            "paramHelp": {
                                "pin": "the pin where the neopixel is connected, eg: pins.A1",
                                "numleds": "number of leds in the strip, eg: 30",
                                "mode": "the light encoding mode for different LED strips, eg: NeoPixelMode.RGB_GRB"
                            },
                            "jsDoc": "Create a new programmable light strip.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "create strip on ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " with ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "numleds",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " pixels",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pin",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "numleds",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pin",
                                "description": "the pin where the neopixel is connected, eg: pins.A1",
                                "type": "DigitalInOutPin",
                                "initializer": "null",
                                "default": "pins.A1"
                            },
                            {
                                "name": "numleds",
                                "description": "number of leds in the strip, eg: 30",
                                "initializer": "10",
                                "default": "30"
                            },
                            {
                                "name": "mode",
                                "description": "the light encoding mode for different LED strips, eg: NeoPixelMode.RGB_GRB",
                                "type": "NeoPixelMode",
                                "initializer": "NeoPixelMode.RGB",
                                "default": "NeoPixelMode.RGB_GRB",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "light.create_strip"
                    },
                    "light.createAPA102Strip": {
                        "kind": -3,
                        "retType": "light.NeoPixelStrip",
                        "attributes": {
                            "blockId": "light_create_dotstar",
                            "block": "create APA102 strip|data %data|clock %clk|with %numleds pixels",
                            "help": "light/create-apa102-strip",
                            "trackArgs": [
                                0,
                                1,
                                2
                            ],
                            "parts": "dotstar",
                            "weight": 100,
                            "blockSetVariable": "strip",
                            "subcategory": "NeoPixel",
                            "jsDoc": "Creates a strip of colored LEDs (APA102)",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "create APA102 strip",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "data ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "clock ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "clk",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "with ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "numleds",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " pixels",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "clk",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "numleds",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "dataPin",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "clkPin",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "numleds"
                            }
                        ],
                        "pyQName": "light.create_apa102_strip"
                    },
                    "light.defaultStrip": {
                        "kind": -3,
                        "retType": "light.NeoPixelStrip",
                        "attributes": {
                            "help": "light/default-strip",
                            "blockId": "neopixel_default_strip",
                            "block": "default strip",
                            "weight": 110,
                            "blockGap": "8",
                            "parts": "pixels",
                            "blockHidden": true,
                            "jsDoc": "Gets the default light strip",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "default strip",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "light.default_strip"
                    },
                    "light.onboardStrip": {
                        "kind": -3,
                        "retType": "light.NeoPixelStrip",
                        "attributes": {
                            "help": "light/onboard-strip",
                            "blockId": "neopixel_onboard_strip",
                            "block": "onboard strip",
                            "weight": 111,
                            "blockGap": "8",
                            "subcategory": "NeoPixel",
                            "jsDoc": "Get the default light strip.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "onboard strip",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "light.onboard_strip"
                    },
                    "light.pixels": {
                        "kind": 4,
                        "retType": "light.NeoPixelStrip",
                        "attributes": {
                            "whenUsed": "true",
                            "jsDoc": "Gets the default external light strip"
                        }
                    },
                    "light.setAll": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "builtin_neopixel_set_strip_color",
                            "block": "set all pixels to %rgb=colorNumberPicker",
                            "help": "light/set-all",
                            "weight": 79,
                            "blockGap": "8",
                            "paramHelp": {
                                "rgb": "RGB color of the LED"
                            },
                            "jsDoc": "Set all of the pixels on the strip to one RGB color.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set all pixels to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "rgb",
                                "description": "RGB color of the LED"
                            }
                        ],
                        "pyQName": "light.set_all"
                    },
                    "light.setGradient": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "builtinlightsetgradient",
                            "block": "set gradient from %startRgb=colorNumberPicker to %endRgb=colorNumberPicker",
                            "weight": 78,
                            "blockGap": "8",
                            "blockHidden": true,
                            "paramHelp": {
                                "startColor": "the start color",
                                "endColor": "the end color"
                            },
                            "jsDoc": "Sets a gradient between two colors",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set gradient from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "startRgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "endRgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "startRgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "endRgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "startRgb"
                            },
                            {
                                "name": "endRgb"
                            }
                        ],
                        "pyQName": "light.set_gradient"
                    },
                    "light.clear": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "builtin_neopixel_clear",
                            "block": "clear",
                            "parts": "neopixel",
                            "help": "light/clear",
                            "group": "More",
                            "weight": 9,
                            "blockGap": "8",
                            "jsDoc": "Turn off all pixel LEDs on the onboard strip.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "clear",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": []
                    },
                    "light.graph": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "builtin_neopixel_show_bar_graph",
                            "block": "graph %value||up to %high",
                            "icon": "",
                            "help": "light/graph",
                            "blockGap": "8",
                            "weight": 10,
                            "paramHelp": {
                                "value": "current value to plot",
                                "high": "maximum value, 0 to autoscale"
                            },
                            "jsDoc": "Display a vertical bar graph based on the `value` and `high` value.\nIf `high` is 0, the chart gets adjusted automatically.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "graph ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            },
                            "_expandedDef": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "up to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "high",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "description": "current value to plot"
                            },
                            {
                                "name": "high",
                                "description": "maximum value, 0 to autoscale",
                                "initializer": "undefined"
                            }
                        ]
                    },
                    "light.setPixelColor": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "builtin_neopixel_set_pixel_color",
                            "block": "set pixel color at %pixeloffset|to %rgb=colorNumberPicker",
                            "help": "light/set-pixel-color",
                            "group": "More",
                            "weight": 89,
                            "blockGap": "8",
                            "paramHelp": {
                                "pixeloffset": "position of the NeoPixel in the strip",
                                "color": "RGB color of the LED"
                            },
                            "jsDoc": "Set the pixel to a given color.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set pixel color at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rgb",
                                        "shadowBlockId": "colorNumberPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pixeloffset",
                                "description": "position of the NeoPixel in the strip"
                            },
                            {
                                "name": "color",
                                "description": "RGB color of the LED"
                            }
                        ],
                        "pyQName": "light.set_pixel_color"
                    },
                    "light.pixelColor": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "blockId": "builtin_neopixel_pixel_color",
                            "block": "pixel color at %pixeloffset",
                            "help": "light/pixel-color",
                            "group": "More",
                            "weight": 88,
                            "paramHelp": {
                                "pixeloffset": "position of the NeoPixel in the strip"
                            },
                            "jsDoc": "Gets the pixel color at a given offset.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pixel color at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "pixeloffset",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "pixeloffset",
                                "description": "position of the NeoPixel in the strip"
                            }
                        ],
                        "pyQName": "light.pixel_color"
                    },
                    "light.setBrightness": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "brightness": "20"
                            },
                            "blockId": "builtin_neopixel_set_brightness",
                            "block": "set brightness %brightness",
                            "paramMin": {
                                "brightness": "0"
                            },
                            "paramMax": {
                                "brightness": "255"
                            },
                            "help": "light/set-brightness",
                            "weight": 2,
                            "blockGap": "8",
                            "paramHelp": {
                                "brightness": "a measure of LED brightness in 0-255. eg: 20"
                            },
                            "jsDoc": "Set the brightness of the strip. This flag only applies to future operation.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set brightness ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "brightness",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "brightness",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "brightness",
                                "description": "a measure of LED brightness in 0-255. eg: 20",
                                "default": "20",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            }
                        ],
                        "pyQName": "light.set_brightness"
                    },
                    "light.photonForward": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "steps": "1"
                            },
                            "blockId": "builtin_neophoton_fd",
                            "block": "photon forward by %steps",
                            "help": "light/photon-forward",
                            "group": "Photon",
                            "weight": 41,
                            "blockGap": "8",
                            "paramHelp": {
                                "steps": "number of steps (lights) to move, eg: 1"
                            },
                            "jsDoc": "Move a photon effect along the pixel strip by a number of steps.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "photon forward by ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "steps",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "steps",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "steps",
                                "description": "number of steps (lights) to move, eg: 1",
                                "default": "1"
                            }
                        ],
                        "pyQName": "light.photon_forward"
                    },
                    "light.photonFlip": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "builtin_neophoton_flip",
                            "block": "photon flip",
                            "help": "light/photon-flip",
                            "parts": "neopixel",
                            "group": "Photon",
                            "weight": 40,
                            "blockGap": "8",
                            "jsDoc": "Switch the direction of the photon pulse.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "photon flip",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "light.photon_flip"
                    },
                    "light.setPhotonPosition": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "builtin_light_photon_set_position",
                            "block": "photon set position %index",
                            "help": "light/set-photon-position",
                            "parts": "neopixel",
                            "group": "Photon",
                            "weight": 39,
                            "blockGap": "8",
                            "paramHelp": {
                                "index": "index of the light, if out of bound, the index is wrapped"
                            },
                            "jsDoc": "Sets the photon position to a given light index",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "photon set position ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "index",
                                "description": "index of the light, if out of bound, the index is wrapped"
                            }
                        ],
                        "pyQName": "light.set_photon_position"
                    },
                    "light.setPhotonPenHue": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "builtin_neophoton_set_pen_hue",
                            "block": "photon set pen hue %hue=colorWheelHsvPicker",
                            "help": "light/set-photon-pen-hue",
                            "group": "Photon",
                            "weight": 39,
                            "blockGap": "8",
                            "paramHelp": {
                                "hue": "the color hue of the photon"
                            },
                            "jsDoc": "Set the photon color hue.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "photon set pen hue ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "hue",
                                        "shadowBlockId": "colorWheelHsvPicker",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "hue",
                                        "shadowBlockId": "colorWheelHsvPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "hue",
                                "description": "the color hue of the photon"
                            }
                        ],
                        "pyQName": "light.set_photon_pen_hue"
                    },
                    "light.setPhotonMode": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "builtin_neophoton_set_photon",
                            "block": "photon %mode",
                            "help": "light/set-photon-mode",
                            "group": "Photon",
                            "weight": 38,
                            "paramHelp": {
                                "mode": "the desired mode"
                            },
                            "jsDoc": "Set the photon mode to pen up, pen down, or eraser.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "photon ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "mode",
                                "description": "the desired mode",
                                "type": "PhotonMode",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "light.set_photon_mode"
                    },
                    "light.showAnimation": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "animation": "light.rainbowAnimation",
                                "duration": "500"
                            },
                            "blockId": "builtin_neopixel_show_animation",
                            "block": "show animation %animation=light_animation_picker|for %duration=timePicker|ms",
                            "help": "light/show-animation",
                            "blockGap": "8",
                            "weight": 81,
                            "paramHelp": {
                                "animation": "the animation to run, eg: light.rainbowAnimation",
                                "duration": "the duration to run in milliseconds, eg: 500"
                            },
                            "jsDoc": "Show an animation or queue an animation in the animation queue",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "show animation ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation_picker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "for ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "timePicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "ms",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation_picker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "timePicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "animation",
                                "description": "the animation to run, eg: light.rainbowAnimation",
                                "type": "light.NeoPixelAnimation",
                                "default": "light.rainbowAnimation"
                            },
                            {
                                "name": "duration",
                                "description": "the duration to run in milliseconds, eg: 500",
                                "default": "500"
                            }
                        ],
                        "pyQName": "light.show_animation"
                    },
                    "light.showAnimationFrame": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "animation": "light.rainbowAnimation"
                            },
                            "blockId": "builtin_neopixel_show_animation_frame",
                            "block": "show frame of %animation=light_animation_picker|animation",
                            "help": "light/show-animation-frame",
                            "group": "More",
                            "weight": 24,
                            "blockGap": "8",
                            "paramHelp": {
                                "animation": "the animation to run, eg: light.rainbowAnimation"
                            },
                            "jsDoc": "Show a single animation frame",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "show frame of ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation_picker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "animation",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "animation",
                                        "shadowBlockId": "light_animation_picker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "animation",
                                "description": "the animation to run, eg: light.rainbowAnimation",
                                "type": "light.NeoPixelAnimation",
                                "default": "light.rainbowAnimation"
                            }
                        ],
                        "pyQName": "light.show_animation_frame"
                    },
                    "light.stopAllAnimations": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "builtin_neopixel_stop_all_animations",
                            "block": "stop all animations",
                            "help": "light/stop-all-animations",
                            "group": "More",
                            "weight": 23,
                            "jsDoc": "Stop the current animation and any other animations ready to show.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "stop all animations",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "light.stop_all_animations"
                    },
                    "light.animation": {
                        "kind": -3,
                        "retType": "light.NeoPixelAnimation",
                        "attributes": {
                            "paramFieldEditor": {
                                "kind": "imagedropdown"
                            },
                            "paramFieldEditorOptions": {
                                "kind": {
                                    "columns": "3"
                                }
                            },
                            "blockGap": "8",
                            "blockId": "light_animation",
                            "block": "%kind",
                            "group": "More",
                            "weight": 25,
                            "help": "light/animation",
                            "blockHidden": true,
                            "deprecated": "1",
                            "paramHelp": {
                                "kind": "the type of animation"
                            },
                            "jsDoc": "Creates a builtin animation",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "kind",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "kind",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "kind",
                                "description": "the type of animation",
                                "type": "LightAnimation",
                                "isEnum": true
                            }
                        ]
                    },
                    "light.range": {
                        "kind": -3,
                        "retType": "light.NeoPixelStrip",
                        "attributes": {
                            "paramDefl": {
                                "length": "4"
                            },
                            "blockId": "lightstrip_range",
                            "block": "range from %start|with %length|pixels",
                            "weight": 1,
                            "blockHidden": true,
                            "paramHelp": {
                                "start": "offset in the NeoPixel strip to start the range",
                                "length": "number of pixels in the range, eg: 4"
                            },
                            "jsDoc": "Create a range of pixels.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "range from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "start",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "with ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "length",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "pixels",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "start",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "length",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "start",
                                "description": "offset in the NeoPixel strip to start the range"
                            },
                            {
                                "name": "length",
                                "description": "number of pixels in the range, eg: 4",
                                "default": "4"
                            }
                        ]
                    },
                    "light.setLength": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "numleds": "30"
                            },
                            "blockId": "lightds_setlength",
                            "block": "set pixels length to %numleds pixels",
                            "explicitDefaults": [
                                "numleds"
                            ],
                            "_shadowOverrides": {
                                "numleds": "lightLengthPicker"
                            },
                            "weight": 0,
                            "blockHidden": true,
                            "jsDoc": "Sets the number of LEDS on the default light strip",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set pixels length to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "numleds",
                                        "shadowBlockId": "lightLengthPicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " pixels",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "numleds",
                                        "shadowBlockId": "lightLengthPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "numleds",
                                "initializer": "30",
                                "default": "30"
                            }
                        ],
                        "pyQName": "light.set_length"
                    },
                    "light.setMode": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "lightds_setmode",
                            "block": "set default strip mode to %mode",
                            "weight": 0,
                            "blockHidden": true,
                            "jsDoc": "Sets the type of RGB light on the default strip",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set default strip mode to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "mode",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "mode",
                                "type": "NeoPixelMode",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "light.set_mode"
                    },
                    "light.NeoPixelStrip@type": {
                        "kind": 9,
                        "retType": "light.NeoPixelStrip",
                        "extendsTypes": [],
                        "pyQName": "light.NeoPixelStrip"
                    },
                    "input.onLightConditionChanged": {
                        "kind": -3,
                        "attributes": {
                            "help": "input/on-light-condition-changed",
                            "blockId": "input_on_light_condition_changed",
                            "block": "on light %condition",
                            "parts": "lightsensor",
                            "weight": 84,
                            "blockGap": "12",
                            "paramHelp": {
                                "condition": "the condition that event triggers on"
                            },
                            "jsDoc": "Register an event that runs when light conditions (darker or brighter) change.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on light ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "condition",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "condition",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "condition",
                                "description": "the condition that event triggers on",
                                "type": "LightCondition",
                                "isEnum": true
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "input.on_light_condition_changed"
                    },
                    "input.lightLevel": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "input/light-level",
                            "blockId": "device_get_light_level",
                            "block": "light level",
                            "parts": "lightsensor",
                            "weight": 30,
                            "blockGap": "8",
                            "jsDoc": "Read the light level applied to the LED screen in a range from 0 (dark) to 255 (bright).",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "light level",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "input.light_level"
                    },
                    "input.setLightThreshold": {
                        "kind": -3,
                        "attributes": {
                            "help": "input/set-light-threshold",
                            "blockId": "lightsensor_set_threshold",
                            "block": "set %condition| light threshold to %value",
                            "parts": "lightsensor",
                            "paramMin": {
                                "value": "1"
                            },
                            "paramMax": {
                                "value": "255"
                            },
                            "group": "More",
                            "weight": 13,
                            "blockGap": "8",
                            "jsDoc": "Set the threshold value for the light condition event.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "condition",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": " light threshold to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "condition",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "condition",
                                "type": "LightCondition",
                                "isEnum": true
                            },
                            {
                                "name": "value",
                                "options": {
                                    "min": {
                                        "value": "1"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            }
                        ],
                        "pyQName": "input.set_light_threshold"
                    },
                    "LightCondition": {
                        "kind": 6,
                        "retType": "LightCondition",
                        "extendsTypes": [
                            "LightCondition",
                            "Number"
                        ]
                    },
                    "LightCondition.Dark": {
                        "retType": "LightCondition.Dark",
                        "attributes": {
                            "block": "dark",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "dark",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LightCondition.Dark",
                            "Number"
                        ],
                        "pyQName": "LightCondition.DARK"
                    },
                    "LightCondition.Bright": {
                        "retType": "LightCondition.Bright",
                        "attributes": {
                            "block": "bright",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "bright",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LightCondition.Bright",
                            "Number"
                        ],
                        "pyQName": "LightCondition.BRIGHT"
                    },
                    "LoudnessCondition": {
                        "kind": 6,
                        "retType": "LoudnessCondition",
                        "extendsTypes": [
                            "LoudnessCondition",
                            "Number"
                        ]
                    },
                    "LoudnessCondition.Loud": {
                        "retType": "LoudnessCondition.Loud",
                        "attributes": {
                            "block": "loud",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "loud",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LoudnessCondition.Loud",
                            "Number"
                        ],
                        "pyQName": "LoudnessCondition.LOUD"
                    },
                    "LoudnessCondition.Quiet": {
                        "retType": "LoudnessCondition.Quiet",
                        "attributes": {
                            "block": "quiet",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "quiet",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LoudnessCondition.Quiet",
                            "Number"
                        ],
                        "pyQName": "LoudnessCondition.QUIET"
                    },
                    "input.onLoudSound": {
                        "kind": -3,
                        "attributes": {
                            "help": "input/on-loud-sound",
                            "blockId": "input_on_loud_sound",
                            "block": "on loud sound",
                            "parts": "microphone",
                            "weight": 88,
                            "blockGap": "12",
                            "jsDoc": "Registers an event that runs when a loud sound is detected",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on loud sound",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "input.on_loud_sound"
                    },
                    "input.soundLevel": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "input/sound-level",
                            "blockId": "device_get_sound_level",
                            "block": "sound level",
                            "parts": "microphone",
                            "weight": 34,
                            "blockGap": "8",
                            "jsDoc": "Reads the loudness through the microphone from 0 (silent) to 255 (loud)",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "sound level",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "input.sound_level"
                    },
                    "input.setLoudSoundThreshold": {
                        "kind": -3,
                        "attributes": {
                            "help": "input/set-loud-sound-threshold",
                            "blockId": "input_set_loud_sound_threshold",
                            "block": "set loud sound threshold %value",
                            "parts": "microphone",
                            "paramMin": {
                                "value": "1"
                            },
                            "paramMax": {
                                "value": "255"
                            },
                            "group": "More",
                            "weight": 14,
                            "blockGap": "8",
                            "jsDoc": "Sets the minimum threshold for a loud sound",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set loud sound threshold ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value",
                                "options": {
                                    "min": {
                                        "value": "1"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            }
                        ],
                        "pyQName": "input.set_loud_sound_threshold"
                    },
                    "MusicOutput": {
                        "kind": 6,
                        "retType": "MusicOutput",
                        "extendsTypes": [
                            "MusicOutput",
                            "Number"
                        ]
                    },
                    "MusicOutput.AutoDetect": {
                        "retType": "MusicOutput.AutoDetect",
                        "extendsTypes": [
                            "MusicOutput.AutoDetect",
                            "Number"
                        ],
                        "pyQName": "MusicOutput.AUTO_DETECT"
                    },
                    "MusicOutput.Buzzer": {
                        "retType": "MusicOutput.Buzzer",
                        "extendsTypes": [
                            "MusicOutput.Buzzer",
                            "Number"
                        ],
                        "pyQName": "MusicOutput.BUZZER"
                    },
                    "MusicOutput.HeadPhones": {
                        "retType": "MusicOutput.HeadPhones",
                        "extendsTypes": [
                            "MusicOutput.HeadPhones",
                            "Number"
                        ],
                        "pyQName": "MusicOutput.HEAD_PHONES"
                    },
                    "music": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#F55D3E",
                            "weight": 90,
                            "icon": "",
                            "blockGap": "8",
                            "groups": [
                                "Sounds",
                                "Melody",
                                "Tone",
                                "Volume",
                                "Tempo"
                            ],
                            "jsDoc": "Generation of music tones."
                        }
                    },
                    "music.forceOutput": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "buf",
                                "type": "MusicOutput",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "music.force_output"
                    },
                    "music.setVolume": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "volume": "20"
                            },
                            "blockId": "synth_set_volume",
                            "block": "set volume %volume",
                            "parts": "speaker",
                            "paramMin": {
                                "volume": "0"
                            },
                            "paramMax": {
                                "volume": "255"
                            },
                            "explicitDefaults": [
                                "volume"
                            ],
                            "help": "music/set-volume",
                            "weight": 70,
                            "group": "Volume",
                            "paramHelp": {
                                "volume": "the volume 0...255"
                            },
                            "jsDoc": "Set the default output volume of the sound synthesizer.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set volume ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "volume",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "volume",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "volume",
                                "description": "the volume 0...255",
                                "initializer": "20",
                                "default": "20",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "255"
                                    }
                                }
                            }
                        ],
                        "pyQName": "music.set_volume"
                    },
                    "music.volume": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "parts": "speaker",
                            "weight": 70,
                            "jsDoc": "Gets the current volume"
                        },
                        "parameters": []
                    },
                    "music.playTone": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "frequency": "Note.C",
                                "ms": "BeatFraction.Half"
                            },
                            "callingConvention": 1,
                            "help": "music/play-tone",
                            "blockId": "mixer_play_note",
                            "block": "play tone|at %note=device_note|for %duration=device_beat",
                            "parts": "headphone",
                            "async": "true",
                            "blockNamespace": "music",
                            "weight": 76,
                            "blockGap": "8",
                            "group": "Tone",
                            "paramHelp": {
                                "frequency": "pitch of the tone to play in Hertz (Hz), eg: Note.C",
                                "ms": "tone duration in milliseconds (ms), eg: BeatFraction.Half"
                            },
                            "jsDoc": "Play a tone through the speaker for some amount of time.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "play tone",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "note",
                                        "shadowBlockId": "device_note",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "for ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "device_beat",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "note",
                                        "shadowBlockId": "device_note",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "device_beat",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "frequency",
                                "description": "pitch of the tone to play in Hertz (Hz), eg: Note.C",
                                "default": "Note.C"
                            },
                            {
                                "name": "ms",
                                "description": "tone duration in milliseconds (ms), eg: BeatFraction.Half",
                                "default": "BeatFraction.Half"
                            }
                        ],
                        "pyQName": "music.play_tone"
                    },
                    "music.playMelody": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "tempo": "120"
                            },
                            "block": "play melody $melody at tempo $tempo|(bpm)",
                            "blockId": "playMelody",
                            "blockNamespace": "music",
                            "weight": 85,
                            "blockGap": "8",
                            "help": "music/play-melody",
                            "group": "Melody",
                            "_shadowOverrides": {
                                "melody": "melody_editor"
                            },
                            "paramMin": {
                                "tempo": "40"
                            },
                            "paramMax": {
                                "tempo": "500"
                            },
                            "explicitDefaults": [
                                "tempo"
                            ],
                            "paramHelp": {
                                "melody": "- string of up to eight notes [C D E F G A B C5] or rests [-] separated by spaces, ",
                                "tempo": "- number in beats per minute (bpm), dictating how long each note will play for"
                            },
                            "jsDoc": "Play a melody from the melody editor.\n\nwhich will be played one at a time, ex: \"E D G F B A C5 B \"",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "play melody ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "melody",
                                        "shadowBlockId": "melody_editor",
                                        "ref": true
                                    },
                                    {
                                        "kind": "label",
                                        "text": " at tempo ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "tempo",
                                        "ref": true
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "(bpm)",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "melody",
                                        "shadowBlockId": "melody_editor",
                                        "ref": true
                                    },
                                    {
                                        "kind": "param",
                                        "name": "tempo",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "melody",
                                "description": "- string of up to eight notes [C D E F G A B C5] or rests [-] separated by spaces, ",
                                "type": "string"
                            },
                            {
                                "name": "tempo",
                                "description": "- number in beats per minute (bpm), dictating how long each note will play for",
                                "initializer": "120",
                                "default": "120",
                                "options": {
                                    "min": {
                                        "value": "40"
                                    },
                                    "max": {
                                        "value": "500"
                                    }
                                }
                            }
                        ],
                        "pyQName": "music.play_melody"
                    },
                    "music.melodyEditor": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "block": "$melody",
                            "blockId": "melody_editor",
                            "blockNamespace": "music",
                            "blockHidden": true,
                            "weight": 85,
                            "blockGap": "8",
                            "help": "music/melody-editor",
                            "group": "Melody",
                            "duplicateShadowOnDrag": true,
                            "paramFieldEditor": {
                                "melody": "melody"
                            },
                            "paramFieldEditorOptions": {
                                "melody": {
                                    "decompileLiterals": "true",
                                    "decompileIndirectFixedInstances": "true",
                                    "onParentBlock": "true"
                                }
                            },
                            "shim": "TD_ID",
                            "paramHelp": {
                                "melody": ""
                            },
                            "jsDoc": "Create a melody with the melody editor.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "melody",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "melody",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "melody",
                                "type": "string"
                            }
                        ],
                        "pyQName": "music.melody_editor"
                    },
                    "music.stopAllSounds": {
                        "kind": -3,
                        "attributes": {
                            "help": "music/stop-all-sounds",
                            "blockId": "music_stop_all_sounds",
                            "block": "stop all sounds",
                            "weight": 10,
                            "group": "Sounds",
                            "jsDoc": "Stop all sounds from playing.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "stop all sounds",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "music.stop_all_sounds"
                    },
                    "music.Melody": {
                        "kind": 8,
                        "retType": "music.Melody",
                        "attributes": {
                            "fixedInstances": "true"
                        },
                        "extendsTypes": []
                    },
                    "music.Melody._text": {
                        "kind": 2,
                        "retType": "string",
                        "isInstance": true
                    },
                    "music.Melody.stopAll": {
                        "kind": -1,
                        "parameters": [],
                        "pyQName": "music.Melody.stop_all"
                    },
                    "music.Melody.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "text",
                                "type": "string"
                            }
                        ],
                        "isInstance": true
                    },
                    "music.Melody.text": {
                        "kind": -2,
                        "retType": "string",
                        "isInstance": true,
                        "isReadOnly": true
                    },
                    "music.Melody.stop": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "mixer_stop",
                            "block": "stop sound %sound",
                            "help": "music/melody/stop",
                            "parts": "headphone",
                            "weight": 92,
                            "blockGap": "8",
                            "group": "Sounds",
                            "jsDoc": "Stop playing a sound",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "stop sound ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "music.Melody.loop": {
                        "kind": -1,
                        "attributes": {
                            "help": "music/melody/loop",
                            "blockId": "mixer_loop_sound",
                            "block": "loop sound %sound",
                            "parts": "headphone",
                            "weight": 93,
                            "blockGap": "8",
                            "group": "Sounds",
                            "paramHelp": {
                                "sound": "the melody to play"
                            },
                            "jsDoc": "Start playing a sound in a loop and don't wait for it to finish.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "loop sound ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "volume",
                                "initializer": "255"
                            }
                        ],
                        "isInstance": true
                    },
                    "music.Melody.play": {
                        "kind": -1,
                        "attributes": {
                            "help": "music/melody/play",
                            "blockId": "mixer_play_sound",
                            "block": "play sound %sound",
                            "parts": "headphone",
                            "weight": 95,
                            "blockGap": "8",
                            "group": "Sounds",
                            "paramHelp": {
                                "sound": "the melody to play"
                            },
                            "jsDoc": "Start playing a sound and don't wait for it to finish.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "play sound ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "volume",
                                "initializer": "255"
                            }
                        ],
                        "isInstance": true
                    },
                    "music.Melody.playUntilDone": {
                        "kind": -1,
                        "attributes": {
                            "help": "music/melody/play-until-done",
                            "blockId": "mixer_play_sound_until_done",
                            "block": "play sound %sound|until done",
                            "parts": "headphone",
                            "weight": 94,
                            "blockGap": "8",
                            "group": "Sounds",
                            "paramHelp": {
                                "sound": "the melody to play"
                            },
                            "jsDoc": "Play a sound and wait until the sound is done.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "play sound ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "until done",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "volume",
                                "initializer": "255"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "music.Melody.play_until_done"
                    },
                    "music.Melody.toString": {
                        "kind": -1,
                        "retType": "string",
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "music.Melody.to_string"
                    },
                    "music.MelodyPlayer": {
                        "kind": 8,
                        "retType": "music.MelodyPlayer",
                        "extendsTypes": []
                    },
                    "music.MelodyPlayer.melody": {
                        "kind": 2,
                        "retType": "music.Melody",
                        "isInstance": true
                    },
                    "music.MelodyPlayer.onPlayFinished": {
                        "kind": 2,
                        "retType": "() => void",
                        "isInstance": true,
                        "pyQName": "music.MelodyPlayer.on_play_finished"
                    },
                    "music.MelodyPlayer.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "m",
                                "type": "music.Melody"
                            }
                        ],
                        "isInstance": true
                    },
                    "music.MelodyPlayer.stop": {
                        "kind": -1,
                        "parameters": [],
                        "isInstance": true
                    },
                    "music.MelodyPlayer.play": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "volume"
                            }
                        ],
                        "isInstance": true
                    },
                    "music.baDing": {
                        "kind": 4,
                        "retType": "music.Melody",
                        "attributes": {
                            "fixedInstance": "true",
                            "whenUsed": "true",
                            "block": "ba ding",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "ba ding",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "music.ba_ding"
                    },
                    "music.wawawawaa": {
                        "kind": 4,
                        "retType": "music.Melody",
                        "attributes": {
                            "fixedInstance": "true",
                            "whenUsed": "true",
                            "block": "wawawawaa",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "wawawawaa",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "music.jumpUp": {
                        "kind": 4,
                        "retType": "music.Melody",
                        "attributes": {
                            "fixedInstance": "true",
                            "whenUsed": "true",
                            "block": "jump up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "jump up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "music.jump_up"
                    },
                    "music.jumpDown": {
                        "kind": 4,
                        "retType": "music.Melody",
                        "attributes": {
                            "fixedInstance": "true",
                            "whenUsed": "true",
                            "block": "jump down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "jump down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "music.jump_down"
                    },
                    "music.powerUp": {
                        "kind": 4,
                        "retType": "music.Melody",
                        "attributes": {
                            "fixedInstance": "true",
                            "whenUsed": "true",
                            "block": "power up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "power up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "music.power_up"
                    },
                    "music.powerDown": {
                        "kind": 4,
                        "retType": "music.Melody",
                        "attributes": {
                            "fixedInstance": "true",
                            "whenUsed": "true",
                            "block": "power down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "power down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "music.power_down"
                    },
                    "music.magicWand": {
                        "kind": 4,
                        "retType": "music.Melody",
                        "attributes": {
                            "fixedInstance": "true",
                            "whenUsed": "true",
                            "block": "magic wand",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "magic wand",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "music.magic_wand"
                    },
                    "music.siren": {
                        "kind": 4,
                        "retType": "music.Melody",
                        "attributes": {
                            "fixedInstance": "true",
                            "whenUsed": "true",
                            "block": "siren",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "siren",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "music.pewPew": {
                        "kind": 4,
                        "retType": "music.Melody",
                        "attributes": {
                            "fixedInstance": "true",
                            "whenUsed": "true",
                            "block": "pew pew",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pew pew",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "music.pew_pew"
                    },
                    "music.noteFrequency": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "note": "262",
                                "name": "Note.C"
                            },
                            "weight": 10,
                            "help": "music/note-frequency",
                            "blockId": "device_note",
                            "block": "%note",
                            "shim": "TD_ID",
                            "color": "#FFFFFF",
                            "colorSecondary": "#FFFFFF",
                            "colorTertiary": "#D83B01",
                            "paramFieldEditor": {
                                "note": "note"
                            },
                            "explicitDefaults": [
                                "note"
                            ],
                            "paramFieldEditorOptions": {
                                "note": {
                                    "decompileLiterals": "true"
                                }
                            },
                            "useEnumVal": "1",
                            "blockGap": "8",
                            "group": "Tone",
                            "paramHelp": {
                                "name": "the note name, eg: Note.C"
                            },
                            "jsDoc": "Get the frequency of a note.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "note",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "note",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "name",
                                "description": "the note name, eg: Note.C",
                                "type": "Note",
                                "default": "Note.C",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "music.note_frequency"
                    },
                    "Sounds": {
                        "kind": 6,
                        "retType": "Sounds",
                        "attributes": {
                            "deprecated": "true",
                            "hidden": "true"
                        },
                        "extendsTypes": [
                            "Sounds",
                            "Number"
                        ]
                    },
                    "Sounds.PowerUp": {
                        "retType": "Sounds.PowerUp",
                        "attributes": {
                            "block": "power up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "power up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Sounds.PowerUp",
                            "Number"
                        ],
                        "pyQName": "Sounds.POWER_UP"
                    },
                    "Sounds.PowerDown": {
                        "retType": "Sounds.PowerDown",
                        "attributes": {
                            "block": "power down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "power down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Sounds.PowerDown",
                            "Number"
                        ],
                        "pyQName": "Sounds.POWER_DOWN"
                    },
                    "Sounds.JumpUp": {
                        "retType": "Sounds.JumpUp",
                        "attributes": {
                            "block": "jump up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "jump up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Sounds.JumpUp",
                            "Number"
                        ],
                        "pyQName": "Sounds.JUMP_UP"
                    },
                    "Sounds.JumpDown": {
                        "retType": "Sounds.JumpDown",
                        "attributes": {
                            "block": "jump down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "jump down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Sounds.JumpDown",
                            "Number"
                        ],
                        "pyQName": "Sounds.JUMP_DOWN"
                    },
                    "Sounds.BaDing": {
                        "retType": "Sounds.BaDing",
                        "attributes": {
                            "block": "ba ding",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "ba ding",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Sounds.BaDing",
                            "Number"
                        ],
                        "pyQName": "Sounds.BA_DING"
                    },
                    "Sounds.Wawawawaa": {
                        "retType": "Sounds.Wawawawaa",
                        "attributes": {
                            "block": "wawawawaa",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "wawawawaa",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Sounds.Wawawawaa",
                            "Number"
                        ],
                        "pyQName": "Sounds.WAWAWAWAA"
                    },
                    "Sounds.MagicWand": {
                        "retType": "Sounds.MagicWand",
                        "attributes": {
                            "block": "magic wand",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "magic wand",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Sounds.MagicWand",
                            "Number"
                        ],
                        "pyQName": "Sounds.MAGIC_WAND"
                    },
                    "Sounds.Siren": {
                        "retType": "Sounds.Siren",
                        "attributes": {
                            "block": "siren",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "siren",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Sounds.Siren",
                            "Number"
                        ],
                        "pyQName": "Sounds.SIREN"
                    },
                    "music.sounds": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "paramDefl": {
                                "name": "Note.C"
                            },
                            "help": "music/sounds",
                            "blockId": "music_sounds",
                            "block": "%name",
                            "blockHidden": true,
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "285",
                                    "columns": "3"
                                }
                            },
                            "paramHelp": {
                                "name": "the note name, eg: Note.C"
                            },
                            "jsDoc": "Get the melody string for a built-in melody.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "name",
                                "description": "the note name, eg: Note.C",
                                "type": "Sounds",
                                "default": "Note.C",
                                "isEnum": true
                            }
                        ]
                    },
                    "music.playSound": {
                        "kind": -3,
                        "attributes": {
                            "help": "music/play-sound",
                            "blockId": "music_play_sound",
                            "block": "play sound %sound=music_sounds",
                            "parts": "headphone",
                            "weight": 95,
                            "blockGap": "8",
                            "deprecated": "true",
                            "hidden": "true",
                            "paramHelp": {
                                "sound": "the melody to play"
                            },
                            "jsDoc": "Start playing a sound and don't wait for it to finish.\nNotes are expressed as a string of characters with this format: NOTE[octave][:duration]",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "play sound ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "shadowBlockId": "music_sounds",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "shadowBlockId": "music_sounds",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "sound",
                                "description": "the melody to play",
                                "type": "string"
                            }
                        ],
                        "pyQName": "music.play_sound"
                    },
                    "music.playSoundUntilDone": {
                        "kind": -3,
                        "attributes": {
                            "help": "music/play-sound-until-done",
                            "blockId": "music_play_sound_until_done",
                            "block": "play sound %sound=music_sounds|until done",
                            "parts": "headphone",
                            "weight": 94,
                            "blockGap": "8",
                            "deprecated": "true",
                            "hidden": "true",
                            "paramHelp": {
                                "sound": "the melody to play"
                            },
                            "jsDoc": "Play a sound and wait until the sound is done.\nNotes are expressed as a string of characters with this format: NOTE[octave][:duration]",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "play sound ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "shadowBlockId": "music_sounds",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "until done",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "sound",
                                        "shadowBlockId": "music_sounds",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "sound",
                                "description": "the melody to play",
                                "type": "string"
                            }
                        ],
                        "pyQName": "music.play_sound_until_done"
                    },
                    "Note": {
                        "kind": 6,
                        "retType": "Note",
                        "extendsTypes": [
                            "Note",
                            "Number"
                        ]
                    },
                    "Note.C": {
                        "retType": "Note.C",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "262"
                        },
                        "extendsTypes": [
                            "Note.C",
                            "Number"
                        ]
                    },
                    "Note.CSharp": {
                        "retType": "Note.CSharp",
                        "attributes": {
                            "block": "C#",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "277",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "C#",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.CSharp",
                            "Number"
                        ],
                        "pyQName": "Note.CSHARP"
                    },
                    "Note.D": {
                        "retType": "Note.D",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "294"
                        },
                        "extendsTypes": [
                            "Note.D",
                            "Number"
                        ]
                    },
                    "Note.Eb": {
                        "retType": "Note.Eb",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "311"
                        },
                        "extendsTypes": [
                            "Note.Eb",
                            "Number"
                        ],
                        "pyQName": "Note.EB"
                    },
                    "Note.E": {
                        "retType": "Note.E",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "330"
                        },
                        "extendsTypes": [
                            "Note.E",
                            "Number"
                        ]
                    },
                    "Note.F": {
                        "retType": "Note.F",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "349"
                        },
                        "extendsTypes": [
                            "Note.F",
                            "Number"
                        ]
                    },
                    "Note.FSharp": {
                        "retType": "Note.FSharp",
                        "attributes": {
                            "block": "F#",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "370",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F#",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.FSharp",
                            "Number"
                        ],
                        "pyQName": "Note.FSHARP"
                    },
                    "Note.G": {
                        "retType": "Note.G",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "392"
                        },
                        "extendsTypes": [
                            "Note.G",
                            "Number"
                        ]
                    },
                    "Note.GSharp": {
                        "retType": "Note.GSharp",
                        "attributes": {
                            "block": "G#",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "415",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "G#",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.GSharp",
                            "Number"
                        ],
                        "pyQName": "Note.GSHARP"
                    },
                    "Note.A": {
                        "retType": "Note.A",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "440"
                        },
                        "extendsTypes": [
                            "Note.A",
                            "Number"
                        ]
                    },
                    "Note.Bb": {
                        "retType": "Note.Bb",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "466"
                        },
                        "extendsTypes": [
                            "Note.Bb",
                            "Number"
                        ],
                        "pyQName": "Note.BB"
                    },
                    "Note.B": {
                        "retType": "Note.B",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "494"
                        },
                        "extendsTypes": [
                            "Note.B",
                            "Number"
                        ]
                    },
                    "Note.C3": {
                        "retType": "Note.C3",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "131"
                        },
                        "extendsTypes": [
                            "Note.C3",
                            "Number"
                        ]
                    },
                    "Note.CSharp3": {
                        "retType": "Note.CSharp3",
                        "attributes": {
                            "block": "C#3",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "139",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "C#3",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.CSharp3",
                            "Number"
                        ],
                        "pyQName": "Note.CSHARP3"
                    },
                    "Note.D3": {
                        "retType": "Note.D3",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "147"
                        },
                        "extendsTypes": [
                            "Note.D3",
                            "Number"
                        ]
                    },
                    "Note.Eb3": {
                        "retType": "Note.Eb3",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "156"
                        },
                        "extendsTypes": [
                            "Note.Eb3",
                            "Number"
                        ],
                        "pyQName": "Note.EB3"
                    },
                    "Note.E3": {
                        "retType": "Note.E3",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "165"
                        },
                        "extendsTypes": [
                            "Note.E3",
                            "Number"
                        ]
                    },
                    "Note.F3": {
                        "retType": "Note.F3",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "175"
                        },
                        "extendsTypes": [
                            "Note.F3",
                            "Number"
                        ]
                    },
                    "Note.FSharp3": {
                        "retType": "Note.FSharp3",
                        "attributes": {
                            "block": "F#3",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "185",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F#3",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.FSharp3",
                            "Number"
                        ],
                        "pyQName": "Note.FSHARP3"
                    },
                    "Note.G3": {
                        "retType": "Note.G3",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "196"
                        },
                        "extendsTypes": [
                            "Note.G3",
                            "Number"
                        ]
                    },
                    "Note.GSharp3": {
                        "retType": "Note.GSharp3",
                        "attributes": {
                            "block": "G#3",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "208",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "G#3",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.GSharp3",
                            "Number"
                        ],
                        "pyQName": "Note.GSHARP3"
                    },
                    "Note.A3": {
                        "retType": "Note.A3",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "220"
                        },
                        "extendsTypes": [
                            "Note.A3",
                            "Number"
                        ]
                    },
                    "Note.Bb3": {
                        "retType": "Note.Bb3",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "233"
                        },
                        "extendsTypes": [
                            "Note.Bb3",
                            "Number"
                        ],
                        "pyQName": "Note.BB3"
                    },
                    "Note.B3": {
                        "retType": "Note.B3",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "247"
                        },
                        "extendsTypes": [
                            "Note.B3",
                            "Number"
                        ]
                    },
                    "Note.C4": {
                        "retType": "Note.C",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "262"
                        },
                        "extendsTypes": [
                            "Note.C4",
                            "Number"
                        ]
                    },
                    "Note.CSharp4": {
                        "retType": "Note.CSharp",
                        "attributes": {
                            "block": "C#4",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "277",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "C#4",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.CSharp4",
                            "Number"
                        ],
                        "pyQName": "Note.CSHARP4"
                    },
                    "Note.D4": {
                        "retType": "Note.D",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "294"
                        },
                        "extendsTypes": [
                            "Note.D4",
                            "Number"
                        ]
                    },
                    "Note.Eb4": {
                        "retType": "Note.Eb",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "311"
                        },
                        "extendsTypes": [
                            "Note.Eb4",
                            "Number"
                        ],
                        "pyQName": "Note.EB4"
                    },
                    "Note.E4": {
                        "retType": "Note.E",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "330"
                        },
                        "extendsTypes": [
                            "Note.E4",
                            "Number"
                        ]
                    },
                    "Note.F4": {
                        "retType": "Note.F",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "349"
                        },
                        "extendsTypes": [
                            "Note.F4",
                            "Number"
                        ]
                    },
                    "Note.FSharp4": {
                        "retType": "Note.FSharp",
                        "attributes": {
                            "block": "F#4",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "370",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F#4",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.FSharp4",
                            "Number"
                        ],
                        "pyQName": "Note.FSHARP4"
                    },
                    "Note.G4": {
                        "retType": "Note.G",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "392"
                        },
                        "extendsTypes": [
                            "Note.G4",
                            "Number"
                        ]
                    },
                    "Note.GSharp4": {
                        "retType": "Note.GSharp",
                        "attributes": {
                            "block": "G#4",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "415",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "G#4",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.GSharp4",
                            "Number"
                        ],
                        "pyQName": "Note.GSHARP4"
                    },
                    "Note.A4": {
                        "retType": "Note.A",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "440"
                        },
                        "extendsTypes": [
                            "Note.A4",
                            "Number"
                        ]
                    },
                    "Note.Bb4": {
                        "retType": "Note.Bb",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "466"
                        },
                        "extendsTypes": [
                            "Note.Bb4",
                            "Number"
                        ],
                        "pyQName": "Note.BB4"
                    },
                    "Note.B4": {
                        "retType": "Note.B",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "494"
                        },
                        "extendsTypes": [
                            "Note.B4",
                            "Number"
                        ]
                    },
                    "Note.C5": {
                        "retType": "Note.C5",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "523"
                        },
                        "extendsTypes": [
                            "Note.C5",
                            "Number"
                        ]
                    },
                    "Note.CSharp5": {
                        "retType": "Note.CSharp5",
                        "attributes": {
                            "block": "C#5",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "555",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "C#5",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.CSharp5",
                            "Number"
                        ],
                        "pyQName": "Note.CSHARP5"
                    },
                    "Note.D5": {
                        "retType": "Note.D5",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "587"
                        },
                        "extendsTypes": [
                            "Note.D5",
                            "Number"
                        ]
                    },
                    "Note.Eb5": {
                        "retType": "Note.Eb5",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "622"
                        },
                        "extendsTypes": [
                            "Note.Eb5",
                            "Number"
                        ],
                        "pyQName": "Note.EB5"
                    },
                    "Note.E5": {
                        "retType": "Note.E5",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "659"
                        },
                        "extendsTypes": [
                            "Note.E5",
                            "Number"
                        ]
                    },
                    "Note.F5": {
                        "retType": "Note.F5",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "698"
                        },
                        "extendsTypes": [
                            "Note.F5",
                            "Number"
                        ]
                    },
                    "Note.FSharp5": {
                        "retType": "Note.FSharp5",
                        "attributes": {
                            "block": "F#5",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "740",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F#5",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.FSharp5",
                            "Number"
                        ],
                        "pyQName": "Note.FSHARP5"
                    },
                    "Note.G5": {
                        "retType": "Note.G5",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "784"
                        },
                        "extendsTypes": [
                            "Note.G5",
                            "Number"
                        ]
                    },
                    "Note.GSharp5": {
                        "retType": "Note.GSharp5",
                        "attributes": {
                            "block": "G#5",
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "831",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "G#5",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Note.GSharp5",
                            "Number"
                        ],
                        "pyQName": "Note.GSHARP5"
                    },
                    "Note.A5": {
                        "retType": "Note.A5",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "880"
                        },
                        "extendsTypes": [
                            "Note.A5",
                            "Number"
                        ]
                    },
                    "Note.Bb5": {
                        "retType": "Note.Bb5",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "932"
                        },
                        "extendsTypes": [
                            "Note.Bb5",
                            "Number"
                        ],
                        "pyQName": "Note.BB5"
                    },
                    "Note.B5": {
                        "retType": "Note.B5",
                        "attributes": {
                            "blockIdentity": "music.noteFrequency",
                            "enumval": "988"
                        },
                        "extendsTypes": [
                            "Note.B5",
                            "Number"
                        ]
                    },
                    "BeatFraction": {
                        "kind": 6,
                        "retType": "BeatFraction",
                        "extendsTypes": [
                            "BeatFraction",
                            "Number"
                        ]
                    },
                    "BeatFraction.Whole": {
                        "retType": "BeatFraction.Whole",
                        "attributes": {
                            "block": "1",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "1",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BeatFraction.Whole",
                            "Number"
                        ],
                        "pyQName": "BeatFraction.WHOLE"
                    },
                    "BeatFraction.Half": {
                        "retType": "BeatFraction.Half",
                        "attributes": {
                            "block": "1/2",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "1/2",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BeatFraction.Half",
                            "Number"
                        ],
                        "pyQName": "BeatFraction.HALF"
                    },
                    "BeatFraction.Quarter": {
                        "retType": "BeatFraction.Quarter",
                        "attributes": {
                            "block": "1/4",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "1/4",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BeatFraction.Quarter",
                            "Number"
                        ],
                        "pyQName": "BeatFraction.QUARTER"
                    },
                    "BeatFraction.Eighth": {
                        "retType": "BeatFraction.Eighth",
                        "attributes": {
                            "block": "1/8",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "1/8",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BeatFraction.Eighth",
                            "Number"
                        ],
                        "pyQName": "BeatFraction.EIGHTH"
                    },
                    "BeatFraction.Sixteenth": {
                        "retType": "BeatFraction.Sixteenth",
                        "attributes": {
                            "block": "1/16",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "1/16",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BeatFraction.Sixteenth",
                            "Number"
                        ],
                        "pyQName": "BeatFraction.SIXTEENTH"
                    },
                    "BeatFraction.Double": {
                        "retType": "BeatFraction.Double",
                        "attributes": {
                            "block": "2",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "2",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BeatFraction.Double",
                            "Number"
                        ],
                        "pyQName": "BeatFraction.DOUBLE"
                    },
                    "BeatFraction.Breve": {
                        "retType": "BeatFraction.Breve",
                        "attributes": {
                            "block": "4",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "4",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BeatFraction.Breve",
                            "Number"
                        ],
                        "pyQName": "BeatFraction.BREVE"
                    },
                    "music.ringTone": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "frequency": "Note.C"
                            },
                            "help": "music/ring-tone",
                            "blockId": "music_ring",
                            "block": "ring tone|at %note=device_note",
                            "parts": "headphone",
                            "trackArgs": [
                                0
                            ],
                            "blockNamespace": "music",
                            "inBasicCategory": "true",
                            "weight": 75,
                            "blockGap": "8",
                            "group": "Tone",
                            "paramHelp": {
                                "frequency": "pitch of the tone to play in Hertz (Hz), eg: Note.C"
                            },
                            "jsDoc": "Play a tone.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "ring tone",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "note",
                                        "shadowBlockId": "device_note",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "note",
                                        "shadowBlockId": "device_note",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "frequency",
                                "description": "pitch of the tone to play in Hertz (Hz), eg: Note.C",
                                "default": "Note.C"
                            }
                        ],
                        "pyQName": "music.ring_tone"
                    },
                    "music.rest": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "ms": "BeatFraction.Half"
                            },
                            "help": "music/rest",
                            "blockId": "music_rest",
                            "block": "rest|for %duration=device_beat",
                            "parts": "headphone",
                            "trackArgs": [
                                0
                            ],
                            "blockNamespace": "music",
                            "weight": 74,
                            "group": "Tone",
                            "paramHelp": {
                                "ms": "rest duration in milliseconds (ms), eg: BeatFraction.Half"
                            },
                            "jsDoc": "Rest, or play silence, for some time (in milleseconds).",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "rest",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "for ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "device_beat",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "duration",
                                        "shadowBlockId": "device_beat",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "ms",
                                "description": "rest duration in milliseconds (ms), eg: BeatFraction.Half",
                                "default": "BeatFraction.Half"
                            }
                        ]
                    },
                    "music.beat": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "fraction": "BeatFraction.Half"
                            },
                            "help": "music/beat",
                            "blockId": "device_beat",
                            "block": "%fraction|beat",
                            "weight": 9,
                            "blockGap": "8",
                            "group": "Tempo",
                            "paramHelp": {
                                "fraction": "the fraction of the current whole note, eg: BeatFraction.Half"
                            },
                            "jsDoc": "Return the duration of a beat in milliseconds (the beat fraction).",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "fraction",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "beat",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "fraction",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "fraction",
                                "description": "the fraction of the current whole note, eg: BeatFraction.Half",
                                "type": "BeatFraction",
                                "initializer": "undefined",
                                "default": "BeatFraction.Half",
                                "isEnum": true
                            }
                        ]
                    },
                    "music.tempo": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "music/tempo",
                            "blockId": "device_tempo",
                            "block": "tempo (bpm)",
                            "weight": 64,
                            "group": "Tempo",
                            "jsDoc": "Return the tempo in beats per minute (bpm).\nTempo is the speed (bpm = beats per minute) at which notes play. The larger the tempo value, the faster the notes will play.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "tempo (bpm)",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": []
                    },
                    "music.changeTempoBy": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "bpm": "20"
                            },
                            "help": "music/change-tempo-by",
                            "weight": 66,
                            "blockId": "device_change_tempo",
                            "block": "change tempo by %value|(bpm)",
                            "blockGap": "8",
                            "group": "Tempo",
                            "paramHelp": {
                                "bpm": "The change in beats per minute to the tempo, eg: 20"
                            },
                            "jsDoc": "Change the tempo up or down by some amount of beats per minute (bpm).",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "change tempo by ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "(bpm)",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "bpm",
                                "description": "The change in beats per minute to the tempo, eg: 20",
                                "default": "20"
                            }
                        ],
                        "pyQName": "music.change_tempo_by"
                    },
                    "music.setTempo": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "bpm": "120"
                            },
                            "help": "music/set-tempo",
                            "blockId": "device_set_tempo",
                            "block": "set tempo to %value|(bpm)",
                            "paramMin": {
                                "bpm": "4"
                            },
                            "paramMax": {
                                "bpm": "400"
                            },
                            "weight": 65,
                            "blockGap": "8",
                            "group": "Tempo",
                            "paramHelp": {
                                "bpm": "The new tempo in beats per minute, eg: 120"
                            },
                            "jsDoc": "Set the tempo a number of beats per minute (bpm).",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set tempo to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "(bpm)",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "bpm",
                                "description": "The new tempo in beats per minute, eg: 120",
                                "default": "120",
                                "options": {
                                    "min": {
                                        "value": "4"
                                    },
                                    "max": {
                                        "value": "400"
                                    }
                                }
                            }
                        ],
                        "pyQName": "music.set_tempo"
                    },
                    "input.onSwitchMoved": {
                        "kind": -3,
                        "attributes": {
                            "help": "input/on-switch-moved",
                            "blockId": "device_on_switch_moved",
                            "block": "on switch moved %direction",
                            "parts": "switch",
                            "weight": 80,
                            "paramHelp": {
                                "direction": "the direction the switch must be moved to trigger the event"
                            },
                            "jsDoc": "Do something when the slide switch is moved left or right.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on switch moved ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "direction",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "direction",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "direction",
                                "description": "the direction the switch must be moved to trigger the event",
                                "type": "SwitchDirection",
                                "isEnum": true
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "input.on_switch_moved"
                    },
                    "input.switchRight": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "blockId": "device_switch_direction",
                            "block": "switch right",
                            "parts": "switch",
                            "group": "Switch",
                            "weight": 10,
                            "blockGap": "8",
                            "jsDoc": "Gets a value indicating if the switch is positioned to the right",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "switch right",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "input.switch_right"
                    },
                    "SwitchDirection": {
                        "kind": 6,
                        "retType": "SwitchDirection",
                        "extendsTypes": [
                            "SwitchDirection",
                            "Number"
                        ]
                    },
                    "SwitchDirection.Left": {
                        "retType": "SwitchDirection.Left",
                        "attributes": {
                            "block": "left",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "left",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "SwitchDirection.Left",
                            "Number"
                        ],
                        "pyQName": "SwitchDirection.LEFT"
                    },
                    "SwitchDirection.Right": {
                        "retType": "SwitchDirection.Right",
                        "attributes": {
                            "block": "right",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "right",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "SwitchDirection.Right",
                            "Number"
                        ],
                        "pyQName": "SwitchDirection.RIGHT"
                    },
                    "input.onTemperatureConditionChanged": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "temperature": "15"
                            },
                            "blockId": "input_on_temperature_condition_changed",
                            "block": "on temperature %condition|at %temperature|%unit",
                            "parts": "thermometer",
                            "help": "input/on-temperature-condition-changed",
                            "blockExternalInputs": "0",
                            "group": "More",
                            "weight": 76,
                            "inlineInputMode": "external",
                            "paramHelp": {
                                "condition": "the condition, hot or cold, the event triggers on",
                                "temperature": "the temperature at which this event happens, eg: 15",
                                "unit": "the unit of the temperature"
                            },
                            "jsDoc": "Run some code when the temperature changes from hot to cold, or from cold to hot.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "on temperature ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "condition",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "temperature",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "unit",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "condition",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "temperature",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "unit",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "condition",
                                "description": "the condition, hot or cold, the event triggers on",
                                "type": "TemperatureCondition",
                                "isEnum": true
                            },
                            {
                                "name": "temperature",
                                "description": "the temperature at which this event happens, eg: 15",
                                "default": "15"
                            },
                            {
                                "name": "unit",
                                "description": "the unit of the temperature",
                                "type": "TemperatureUnit",
                                "isEnum": true
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "input.on_temperature_condition_changed"
                    },
                    "input.temperature": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "input/temperature",
                            "blockId": "device_temperature",
                            "block": "temperature in %unit",
                            "parts": "thermometer",
                            "weight": 26,
                            "jsDoc": "Get the temperature in Celsius or Fahrenheit degrees.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "temperature in ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "unit",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "unit",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "unit",
                                "type": "TemperatureUnit",
                                "isEnum": true
                            }
                        ]
                    },
                    "TemperatureCondition": {
                        "kind": 6,
                        "retType": "TemperatureCondition",
                        "extendsTypes": [
                            "TemperatureCondition",
                            "Number"
                        ]
                    },
                    "TemperatureCondition.Hot": {
                        "retType": "TemperatureCondition.Hot",
                        "attributes": {
                            "block": "hot",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "hot",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "TemperatureCondition.Hot",
                            "Number"
                        ],
                        "pyQName": "TemperatureCondition.HOT"
                    },
                    "TemperatureCondition.Cold": {
                        "retType": "TemperatureCondition.Cold",
                        "attributes": {
                            "block": "cold",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "cold",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "TemperatureCondition.Cold",
                            "Number"
                        ],
                        "pyQName": "TemperatureCondition.COLD"
                    },
                    "TemperatureUnit": {
                        "kind": 6,
                        "retType": "TemperatureUnit",
                        "extendsTypes": [
                            "TemperatureUnit",
                            "Number"
                        ]
                    },
                    "TemperatureUnit.Celsius": {
                        "retType": "TemperatureUnit.Celsius",
                        "attributes": {
                            "block": "C",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "C",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "TemperatureUnit.Celsius",
                            "Number"
                        ],
                        "pyQName": "TemperatureUnit.CELSIUS"
                    },
                    "TemperatureUnit.Fahrenheit": {
                        "retType": "TemperatureUnit.Fahrenheit",
                        "attributes": {
                            "block": "F",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "TemperatureUnit.Fahrenheit",
                            "Number"
                        ],
                        "pyQName": "TemperatureUnit.FAHRENHEIT"
                    },
                    "TouchButton": {
                        "kind": 9,
                        "retType": "TouchButton",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "TouchButton",
                            "Button"
                        ]
                    },
                    "TouchButton.setThreshold": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "threshold": "200"
                            },
                            "blockId": "touch_set_threshold",
                            "block": "button %button|set threshold %threshold",
                            "blockNamespace": "input",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "paramMin": {
                                "threshold": "0"
                            },
                            "paramMax": {
                                "threshold": "1023"
                            },
                            "group": "More",
                            "weight": 16,
                            "blockGap": "8",
                            "help": "input/touch/set-threshold",
                            "paramHelp": {
                                "name": "button name",
                                "threshold": "minimum value to consider a touch eg:200"
                            },
                            "jsDoc": "Manually define the threshold use to detect a touch event. Any sensed value equal to or greater than this value will be interpreted as a touch.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "button ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "set threshold ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "threshold",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "threshold",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "threshold",
                                "description": "minimum value to consider a touch eg:200",
                                "default": "200",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "1023"
                                    }
                                }
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "TouchButton.set_threshold"
                    },
                    "TouchButton.threshold": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "blockId": "touch_threshold",
                            "block": "button %button|threshold",
                            "blockNamespace": "input",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "group": "More",
                            "weight": 16,
                            "blockGap": "8",
                            "help": "input/touch/threshold",
                            "paramHelp": {
                                "name": "button name"
                            },
                            "jsDoc": "Gets the current threshold",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "button ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "threshold",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "TouchButton.value": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "blockId": "touch_value",
                            "block": "button %button|value",
                            "blockNamespace": "input",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "group": "More",
                            "weight": 49,
                            "blockGap": "8",
                            "help": "input/touch/value",
                            "paramHelp": {
                                "name": "button name"
                            },
                            "jsDoc": "Reads the current value registered with the button.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "button ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "value",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "TouchButton.calibrate": {
                        "kind": -1,
                        "attributes": {
                            "blockId": "touch_calibrate",
                            "block": "button %button calibrate",
                            "blockNamespace": "input",
                            "paramFieldEditor": {
                                "name": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "name": {
                                    "width": "220",
                                    "columns": "4"
                                }
                            },
                            "group": "More",
                            "weight": 49,
                            "blockGap": "8",
                            "help": "input/touch/calibrate",
                            "jsDoc": "Calibrate the touch sensivity",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "button ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " calibrate",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "AnalogInOutPin.touchButton": {
                        "kind": -1,
                        "retType": "TouchButton",
                        "attributes": {
                            "jsDoc": "Get the cap-touch sensor for given pin (if available)"
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "AnalogInOutPin.touch_button"
                    },
                    "pins.A0": {
                        "kind": 4,
                        "retType": "AnalogOutPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.A1": {
                        "kind": 4,
                        "retType": "PwmPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.A2": {
                        "kind": 4,
                        "retType": "PwmPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.A3": {
                        "kind": 4,
                        "retType": "AnalogInPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.A4": {
                        "kind": 4,
                        "retType": "AnalogInPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.A5": {
                        "kind": 4,
                        "retType": "AnalogInPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.A6": {
                        "kind": 4,
                        "retType": "AnalogInPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.A7": {
                        "kind": 4,
                        "retType": "AnalogInPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.SCL": {
                        "kind": 4,
                        "retType": "DigitalInOutPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.SDA": {
                        "kind": 4,
                        "retType": "DigitalInOutPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.RX": {
                        "kind": 4,
                        "retType": "DigitalInOutPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.TX": {
                        "kind": 4,
                        "retType": "DigitalInOutPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.LED": {
                        "kind": 4,
                        "retType": "DigitalInOutPin",
                        "attributes": {
                            "fixedInstance": "true"
                        }
                    },
                    "pins.IROut": {
                        "kind": 4,
                        "retType": "DigitalInOutPin",
                        "attributes": {
                            "fixedInstance": "true"
                        },
                        "pyQName": "pins.ir_out"
                    },
                    "pins.IRIn": {
                        "kind": 4,
                        "retType": "DigitalInOutPin",
                        "attributes": {
                            "fixedInstance": "true"
                        },
                        "pyQName": "pins.ir_in"
                    },
                    "input.buttonA": {
                        "kind": 4,
                        "retType": "Button",
                        "attributes": {
                            "indexedInstanceNS": "input",
                            "indexedInstanceShim": "pxt::getButton",
                            "block": "button A",
                            "weight": 95,
                            "fixedInstance": "true",
                            "jsDoc": "Left button.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "button A",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.button_a"
                    },
                    "input.buttonB": {
                        "kind": 4,
                        "retType": "Button",
                        "attributes": {
                            "block": "button B",
                            "weight": 94,
                            "fixedInstance": "true",
                            "jsDoc": "Right button.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "button B",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.button_b"
                    },
                    "input.buttonsAB": {
                        "kind": 4,
                        "retType": "Button",
                        "attributes": {
                            "block": "buttons A+B",
                            "weight": 93,
                            "fixedInstance": "true",
                            "jsDoc": "Left and Right button.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "buttons A+B",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.buttons_ab"
                    },
                    "input.touchA1": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "touch A1",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A1",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "touch A1",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.touch_a1"
                    },
                    "input.touchA2": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "touch A2",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A2",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "touch A2",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.touch_a2"
                    },
                    "input.touchA3": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "touch A3",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A3",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "touch A3",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.touch_a3"
                    },
                    "input.touchA4": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "touch A4",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A4",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "touch A4",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.touch_a4"
                    },
                    "input.touchA5": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "touch A5",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A5",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "touch A5",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.touch_a5"
                    },
                    "input.touchA6": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "touch A6",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A6",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "touch A6",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.touch_a6"
                    },
                    "input.touchA7": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "touch A7",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A7",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "touch A7",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.touch_a7"
                    },
                    "input.pinA1": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "pin A1",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A1",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pin A1",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.pin_a1"
                    },
                    "input.pinA2": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "pin A2",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A2",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pin A2",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.pin_a2"
                    },
                    "input.pinA3": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "pin A3",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A3",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pin A3",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.pin_a3"
                    },
                    "input.pinA4": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "pin A4",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A4",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pin A4",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.pin_a4"
                    },
                    "input.pinA5": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "pin A5",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A5",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pin A5",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.pin_a5"
                    },
                    "input.pinA6": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "pin A6",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A6",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pin A6",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.pin_a6"
                    },
                    "input.pinA7": {
                        "kind": 4,
                        "retType": "TouchButton",
                        "attributes": {
                            "block": "pin A7",
                            "fixedInstance": "true",
                            "jsDoc": "Capacitive pin A7",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pin A7",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "pyQName": "input.pin_a7"
                    },
                    "config": {
                        "kind": 5,
                        "retType": ""
                    },
                    "config.NUM_NEOPIXELS": {
                        "kind": 4,
                        "retType": "number"
                    },
                    "config.DEFAULT_BUTTON_MODE": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_LIGHT_SENSOR"
                    },
                    "config.PIN_FLASH_MISO": {
                        "kind": 4,
                        "retType": "DAL.JD_SERIAL_BUS_RISE"
                    },
                    "config.PIN_FLASH_MOSI": {
                        "kind": 4,
                        "retType": "DAL.JD_LOGIC_DRIVER_MAX_FILTERS"
                    },
                    "config.PIN_FLASH_SCK": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_SYSTEM_LEVEL_DETECTOR"
                    },
                    "config.PIN_FLASH_CS": {
                        "kind": 4,
                        "retType": "DAL.KEY_COMMA"
                    },
                    "config.PIN_MIC_DATA": {
                        "kind": 4,
                        "retType": "DAL.JD_SERIAL_TX_DRAIN_ENABLE"
                    },
                    "config.PIN_MIC_CLOCK": {
                        "kind": 4,
                        "retType": "DAL.JD_SERIAL_MAX_BUFFERS"
                    },
                    "config.PIN_BTN_SLIDE": {
                        "kind": 4,
                        "retType": "DAL.JD_DEVICE_ERROR_MSK"
                    },
                    "config.PIN_NEOPIXEL": {
                        "kind": 4,
                        "retType": "DAL.KEY_DOT"
                    },
                    "config.PIN_SPEAKER_AMP": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_JACDAC1"
                    },
                    "config.PIN_MICROPHONE": {
                        "kind": 4,
                        "retType": "DAL.JD_SERIAL_TX_DRAIN_ENABLE"
                    },
                    "config.PIN_LIGHT": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_MULTIBUTTON_ATTACH"
                    },
                    "config.ACCELEROMETER_TYPE": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_USB_ERROR"
                    },
                    "config.PIN_ACCELEROMETER_SDA": {
                        "kind": 4,
                        "retType": "DAL.Receiving"
                    },
                    "config.PIN_ACCELEROMETER_SCL": {
                        "kind": 4,
                        "retType": "DAL.JD_SERIAL_EVT_DATA_READY"
                    },
                    "config.PIN_ACCELEROMETER_INT": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_GESTURE"
                    },
                    "config.PIN_TEMPERATURE": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_RADIO"
                    },
                    "config.PIN_IR_OUT": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_MSC"
                    },
                    "config.PIN_IR_IN": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_SERIAL"
                    },
                    "config.PIN_BTN_A": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_PRESSURE"
                    },
                    "config.PIN_BTN_B": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_SYSTEM_TIMER"
                    },
                    "config.PIN_A0": {
                        "kind": 4,
                        "retType": "DAL.JD_SERIAL_RECEIVING"
                    },
                    "config.PIN_A1": {
                        "kind": 4,
                        "retType": "DAL.JD_VERSION"
                    },
                    "config.PIN_A2": {
                        "kind": 4,
                        "retType": "DAL.JD_SERIAL_EVT_BUS_DISCONNECTED"
                    },
                    "config.PIN_A3": {
                        "kind": 4,
                        "retType": "DAL.JD_DRIVER_CLASS_ACCELEROMETER"
                    },
                    "config.PIN_A4": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_SPRITE"
                    },
                    "config.PIN_A5": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_GAME_STATE_MANAGER"
                    },
                    "config.PIN_A6": {
                        "kind": 4,
                        "retType": "DAL.KEY_ESC"
                    },
                    "config.PIN_A7": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_NULL_DEREFERENCE"
                    },
                    "config.PIN_SCL": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_SPRITE"
                    },
                    "config.PIN_SDA": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_GAME_STATE_MANAGER"
                    },
                    "config.PIN_RX": {
                        "kind": 4,
                        "retType": "DAL.KEY_ESC"
                    },
                    "config.PIN_TX": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_NULL_DEREFERENCE"
                    },
                    "config.PIN_A8": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_MULTIBUTTON_ATTACH"
                    },
                    "config.PIN_A9": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_RADIO"
                    },
                    "config.PIN_D4": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_PRESSURE"
                    },
                    "config.PIN_D5": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_SYSTEM_TIMER"
                    },
                    "config.PIN_D7": {
                        "kind": 4,
                        "retType": "DAL.JD_DEVICE_ERROR_MSK"
                    },
                    "config.PIN_D8": {
                        "kind": 4,
                        "retType": "DAL.KEY_DOT"
                    },
                    "config.PIN_D13": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_LIGHT_SENSOR"
                    },
                    "config.PIN_LED": {
                        "kind": 4,
                        "retType": "DAL.DEVICE_ID_LIGHT_SENSOR"
                    },
                    "config.PIN_A10": {
                        "kind": 4,
                        "retType": "DAL.JD_SERIAL_TX_DRAIN_ENABLE"
                    },
                    "input.ambientColor": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "help": "input/ambient-color",
                            "blockId": "device_get_ambient_color",
                            "block": "ambient color",
                            "parts": "rgbsensor",
                            "weight": 29,
                            "blockGap": "8",
                            "jsDoc": "Sense the ambient color using the LED pixel next to the LED sensor.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "ambient color",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "input.ambient_color"
                    },
                    "serial": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#006E90"
                        }
                    },
                    "light.showRing": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "colors": "\"red red red red red red red red red red\"",
                                "interval": "400"
                            },
                            "blockId": "neopixel_show_ring_colors",
                            "block": "show ring |%colors",
                            "weight": 100,
                            "help": "light/show-ring",
                            "paramFieldEditor": {
                                "colors": "lights"
                            },
                            "paramFieldEditorOptions": {
                                "colors": {
                                    "onParentBlock": "true",
                                    "decompileLiterals": "true"
                                }
                            },
                            "blockExternalInputs": "true",
                            "blockGap": "8",
                            "inlineInputMode": "external",
                            "paramHelp": {
                                "colors": "a string describing the colors, eg: \"red red red red red red red red red red\"",
                                "interval": "the duration in milliseconds between frames, eg: 400"
                            },
                            "jsDoc": "Shows a pattern of colors on the pixel ring",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "show ring ",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "colors",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "colors",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "colors",
                                "description": "a string describing the colors, eg: \"red red red red red red red red red red\"",
                                "type": "string",
                                "default": "\"red red red red red red red red red red\""
                            },
                            {
                                "name": "interval",
                                "description": "the duration in milliseconds between frames, eg: 400",
                                "initializer": "400",
                                "default": "400"
                            }
                        ],
                        "pyQName": "light.show_ring"
                    }
                }
            },
            "sha": "a295cef5c744e02eba235c982ed9c7cdcf7f708119aa3049f4261823b58e74fb"
        },
        "libs/mouse": {
            "apis": {
                "byQName": {
                    "control": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 90,
                            "color": "#FF5722",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Program controls and events."
                        }
                    },
                    "pins": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#A80000",
                            "weight": 85,
                            "icon": "",
                            "advanced": true,
                            "groups": [
                                "other",
                                "Servo",
                                "i2c"
                            ],
                            "jsDoc": "Control currents in Pins for analog/digital signals, servos, i2c, ..."
                        }
                    },
                    "loops": {
                        "kind": 5,
                        "retType": ""
                    },
                    "input": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#B4009E",
                            "weight": 98,
                            "icon": "",
                            "groups": [
                                "other",
                                "More"
                            ],
                            "jsDoc": "Respond to and read data from buttons and sensors.\n\nEvents and data from sensors."
                        }
                    },
                    "console": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 12,
                            "color": "#002050",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Reading and writing data to the console output."
                        }
                    },
                    "AnalogInOutPin": {
                        "kind": 9,
                        "retType": "AnalogInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInOutPin",
                            "AnalogInPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "light": {
                        "kind": 5,
                        "retType": ""
                    },
                    "mouse": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "icon": "",
                            "color": "#303030",
                            "jsDoc": "Mouse emulation"
                        }
                    },
                    "mouse.setButton": {
                        "kind": -3,
                        "attributes": {
                            "help": "mouse/set-button",
                            "blockId": "mouseSetButton",
                            "block": "mouse button %index|%down=toggleDownUp",
                            "jsDoc": "Set the mouse button state to up or down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "mouse button ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "down",
                                        "shadowBlockId": "toggleDownUp",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "index",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "down",
                                        "shadowBlockId": "toggleDownUp",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "button",
                                "type": "MouseButton",
                                "isEnum": true
                            },
                            {
                                "name": "down",
                                "type": "boolean"
                            }
                        ],
                        "pyQName": "mouse.set_button"
                    },
                    "mouse.move": {
                        "kind": -3,
                        "attributes": {
                            "help": "mouse/move",
                            "blockId": "mouseMove",
                            "block": "mouse move x %x|y %y",
                            "paramMin": {
                                "x": "-128",
                                "y": "-128"
                            },
                            "paramMax": {
                                "x": "127",
                                "y": "127"
                            },
                            "jsDoc": "Move the mouse in the X and Y direction",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "mouse move x ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "x",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "y ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "y",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "x",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "y",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "x",
                                "options": {
                                    "min": {
                                        "value": "-128"
                                    },
                                    "max": {
                                        "value": "127"
                                    }
                                }
                            },
                            {
                                "name": "y",
                                "options": {
                                    "min": {
                                        "value": "-128"
                                    },
                                    "max": {
                                        "value": "127"
                                    }
                                }
                            }
                        ]
                    },
                    "mouse.turnWheel": {
                        "kind": -3,
                        "attributes": {
                            "help": "mouse/turn-wheel",
                            "blockId": "mouseWheel",
                            "block": "mouse turn wheel %w",
                            "paramMin": {
                                "w": "-128"
                            },
                            "paramMax": {
                                "w": "127"
                            },
                            "jsDoc": "Turn the mouse wheel",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "mouse turn wheel ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "w",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "w",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "w",
                                "options": {
                                    "min": {
                                        "value": "-128"
                                    },
                                    "max": {
                                        "value": "127"
                                    }
                                }
                            }
                        ],
                        "pyQName": "mouse.turn_wheel"
                    },
                    "MouseButton": {
                        "kind": 6,
                        "retType": "MouseButton",
                        "extendsTypes": [
                            "MouseButton",
                            "Number"
                        ]
                    },
                    "MouseButton.Left": {
                        "retType": "MouseButton.Left",
                        "attributes": {
                            "block": "left",
                            "enumval": "1",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "left",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "MouseButton.Left",
                            "Number"
                        ],
                        "pyQName": "MouseButton.LEFT"
                    },
                    "MouseButton.Right": {
                        "retType": "MouseButton.Right",
                        "attributes": {
                            "block": "right",
                            "enumval": "2",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "right",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "MouseButton.Right",
                            "Number"
                        ],
                        "pyQName": "MouseButton.RIGHT"
                    },
                    "MouseButton.Middle": {
                        "retType": "MouseButton.Middle",
                        "attributes": {
                            "block": "middle",
                            "enumval": "4",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "middle",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "MouseButton.Middle",
                            "Number"
                        ],
                        "pyQName": "MouseButton.MIDDLE"
                    },
                    "mouse.click": {
                        "kind": -3,
                        "attributes": {
                            "help": "mouse/click",
                            "blockId": "mouseClick",
                            "block": "mouse click button $button",
                            "weight": 100,
                            "paramHelp": {
                                "button": "the button to click"
                            },
                            "jsDoc": "Generates a mouse click",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "mouse click button ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "button",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "button",
                                "description": "the button to click",
                                "type": "MouseButton",
                                "isEnum": true
                            }
                        ]
                    }
                }
            },
            "sha": "849ec9666892a745cb6d9bf7ea76d7f735de5bf2a293d58ea19fa6614831401c"
        },
        "libs/keyboard": {
            "apis": {
                "byQName": {
                    "control": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 90,
                            "color": "#FF5722",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Program controls and events."
                        }
                    },
                    "pins": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#A80000",
                            "weight": 85,
                            "icon": "",
                            "advanced": true,
                            "groups": [
                                "other",
                                "Servo",
                                "i2c"
                            ],
                            "jsDoc": "Control currents in Pins for analog/digital signals, servos, i2c, ..."
                        }
                    },
                    "loops": {
                        "kind": 5,
                        "retType": ""
                    },
                    "input": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#B4009E",
                            "weight": 98,
                            "icon": "",
                            "groups": [
                                "other",
                                "More"
                            ],
                            "jsDoc": "Respond to and read data from buttons and sensors.\n\nEvents and data from sensors."
                        }
                    },
                    "console": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 12,
                            "color": "#002050",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Reading and writing data to the console output."
                        }
                    },
                    "AnalogInOutPin": {
                        "kind": 9,
                        "retType": "AnalogInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInOutPin",
                            "AnalogInPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "light": {
                        "kind": 5,
                        "retType": ""
                    },
                    "keyboard": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "icon": "",
                            "color": "#303030",
                            "jsDoc": "Keyboard emulation"
                        }
                    },
                    "keyboard.__flush": {
                        "kind": -3,
                        "attributes": {
                            "hidden": "1"
                        },
                        "parameters": []
                    },
                    "keyboard.__type": {
                        "kind": -3,
                        "attributes": {
                            "hidden": "1"
                        },
                        "parameters": [
                            {
                                "name": "text",
                                "type": "string"
                            }
                        ]
                    },
                    "keyboard.__key": {
                        "kind": -3,
                        "attributes": {
                            "hidden": "1"
                        },
                        "parameters": [
                            {
                                "name": "ckey"
                            },
                            {
                                "name": "event",
                                "type": "KeyboardKeyEvent",
                                "isEnum": true
                            }
                        ]
                    },
                    "keyboard.__mediaKey": {
                        "kind": -3,
                        "attributes": {
                            "hidden": "1"
                        },
                        "parameters": [
                            {
                                "name": "key"
                            },
                            {
                                "name": "event",
                                "type": "KeyboardKeyEvent",
                                "isEnum": true
                            }
                        ]
                    },
                    "keyboard.__functionKey": {
                        "kind": -3,
                        "attributes": {
                            "hidden": "1"
                        },
                        "parameters": [
                            {
                                "name": "key"
                            },
                            {
                                "name": "event",
                                "type": "KeyboardKeyEvent",
                                "isEnum": true
                            }
                        ]
                    },
                    "keyboard.__modifierKey": {
                        "kind": -3,
                        "attributes": {
                            "hidden": "1"
                        },
                        "parameters": [
                            {
                                "name": "modifier"
                            },
                            {
                                "name": "event",
                                "type": "KeyboardKeyEvent",
                                "isEnum": true
                            }
                        ]
                    },
                    "KeyboardKeyEvent": {
                        "kind": 6,
                        "retType": "KeyboardKeyEvent",
                        "extendsTypes": [
                            "KeyboardKeyEvent",
                            "Number"
                        ]
                    },
                    "KeyboardKeyEvent.Press": {
                        "retType": "KeyboardKeyEvent.Press",
                        "attributes": {
                            "block": "press",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "press",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardKeyEvent.Press",
                            "Number"
                        ],
                        "pyQName": "KeyboardKeyEvent.PRESS"
                    },
                    "KeyboardKeyEvent.Up": {
                        "retType": "KeyboardKeyEvent.Up",
                        "attributes": {
                            "block": "up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardKeyEvent.Up",
                            "Number"
                        ],
                        "pyQName": "KeyboardKeyEvent.UP"
                    },
                    "KeyboardKeyEvent.Down": {
                        "retType": "KeyboardKeyEvent.Down",
                        "attributes": {
                            "block": "down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardKeyEvent.Down",
                            "Number"
                        ],
                        "pyQName": "KeyboardKeyEvent.DOWN"
                    },
                    "KeyboardMediaKey": {
                        "kind": 6,
                        "retType": "KeyboardMediaKey",
                        "extendsTypes": [
                            "KeyboardMediaKey",
                            "Number"
                        ]
                    },
                    "KeyboardMediaKey.Mute": {
                        "retType": "KeyboardMediaKey.Mute",
                        "attributes": {
                            "block": "mute",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "mute",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.Mute",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.MUTE"
                    },
                    "KeyboardMediaKey.VolumeUp": {
                        "retType": "KeyboardMediaKey.VolumeUp",
                        "attributes": {
                            "block": "volume up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "volume up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.VolumeUp",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.VOLUME_UP"
                    },
                    "KeyboardMediaKey.VolumeDown": {
                        "retType": "KeyboardMediaKey.VolumeDown",
                        "attributes": {
                            "block": "volume down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "volume down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.VolumeDown",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.VOLUME_DOWN"
                    },
                    "KeyboardMediaKey.PlayPause": {
                        "retType": "KeyboardMediaKey.PlayPause",
                        "attributes": {
                            "block": "play pause",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "play pause",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.PlayPause",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.PLAY_PAUSE"
                    },
                    "KeyboardMediaKey.Stop": {
                        "retType": "KeyboardMediaKey.Stop",
                        "attributes": {
                            "block": "stop",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "stop",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.Stop",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.STOP"
                    },
                    "KeyboardMediaKey.PreviousTrack": {
                        "retType": "KeyboardMediaKey.PreviousTrack",
                        "attributes": {
                            "block": "previous track",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "previous track",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.PreviousTrack",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.PREVIOUS_TRACK"
                    },
                    "KeyboardMediaKey.NextTrack": {
                        "retType": "KeyboardMediaKey.NextTrack",
                        "attributes": {
                            "block": "next track",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "next track",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.NextTrack",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.NEXT_TRACK"
                    },
                    "KeyboardMediaKey.Mail": {
                        "retType": "KeyboardMediaKey.Mail",
                        "attributes": {
                            "block": "mail",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "mail",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.Mail",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.MAIL"
                    },
                    "KeyboardMediaKey.Calculator": {
                        "retType": "KeyboardMediaKey.Calculator",
                        "attributes": {
                            "block": "calculator",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "calculator",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.Calculator",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.CALCULATOR"
                    },
                    "KeyboardMediaKey.WebSearch": {
                        "retType": "KeyboardMediaKey.WebSearch",
                        "attributes": {
                            "block": "web search",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "web search",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.WebSearch",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.WEB_SEARCH"
                    },
                    "KeyboardMediaKey.WebHome": {
                        "retType": "KeyboardMediaKey.WebHome",
                        "attributes": {
                            "block": "web home",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "web home",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.WebHome",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.WEB_HOME"
                    },
                    "KeyboardMediaKey.WebFavourites": {
                        "retType": "KeyboardMediaKey.WebFavourites",
                        "attributes": {
                            "block": "web favourites",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "web favourites",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.WebFavourites",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.WEB_FAVOURITES"
                    },
                    "KeyboardMediaKey.WebRefresh": {
                        "retType": "KeyboardMediaKey.WebRefresh",
                        "attributes": {
                            "block": "web refresh",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "web refresh",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.WebRefresh",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.WEB_REFRESH"
                    },
                    "KeyboardMediaKey.WebStop": {
                        "retType": "KeyboardMediaKey.WebStop",
                        "attributes": {
                            "block": "web stop",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "web stop",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.WebStop",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.WEB_STOP"
                    },
                    "KeyboardMediaKey.WebForward": {
                        "retType": "KeyboardMediaKey.WebForward",
                        "attributes": {
                            "block": "web forward",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "web forward",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.WebForward",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.WEB_FORWARD"
                    },
                    "KeyboardMediaKey.WebBack": {
                        "retType": "KeyboardMediaKey.WebBack",
                        "attributes": {
                            "block": "web back",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "web back",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardMediaKey.WebBack",
                            "Number"
                        ],
                        "pyQName": "KeyboardMediaKey.WEB_BACK"
                    },
                    "KeyboardFunctionKey": {
                        "kind": 6,
                        "retType": "KeyboardFunctionKey",
                        "extendsTypes": [
                            "KeyboardFunctionKey",
                            "Number"
                        ]
                    },
                    "KeyboardFunctionKey.F1Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F1",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F1",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F1Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F1_KEY"
                    },
                    "KeyboardFunctionKey.F2Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F2",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F2",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F2Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F2_KEY"
                    },
                    "KeyboardFunctionKey.F3Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F3",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F3",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F3Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F3_KEY"
                    },
                    "KeyboardFunctionKey.F4Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F4",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F4",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F4Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F4_KEY"
                    },
                    "KeyboardFunctionKey.F5Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F5",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F5",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F5Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F5_KEY"
                    },
                    "KeyboardFunctionKey.F6Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F6",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F6",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F6Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F6_KEY"
                    },
                    "KeyboardFunctionKey.F7Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F7",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F7",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F7Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F7_KEY"
                    },
                    "KeyboardFunctionKey.F8Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F8",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F8",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F8Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F8_KEY"
                    },
                    "KeyboardFunctionKey.F9Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F9",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F9",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F9Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F9_KEY"
                    },
                    "KeyboardFunctionKey.F10Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F0",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F0",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F10Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F10_KEY"
                    },
                    "KeyboardFunctionKey.F11Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F11",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F11",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F11Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F11_KEY"
                    },
                    "KeyboardFunctionKey.F12Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F12",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F12",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F12Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F12_KEY"
                    },
                    "KeyboardFunctionKey.F13Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F13",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F13",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F13Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F13_KEY"
                    },
                    "KeyboardFunctionKey.F14Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F14",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F14",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F14Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F14_KEY"
                    },
                    "KeyboardFunctionKey.F15Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F15",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F15",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F15Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F15_KEY"
                    },
                    "KeyboardFunctionKey.F16Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F16",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F16",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F16Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F16_KEY"
                    },
                    "KeyboardFunctionKey.F17Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F17",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F17",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F17Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F17_KEY"
                    },
                    "KeyboardFunctionKey.F18Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F18",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F18",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F18Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F18_KEY"
                    },
                    "KeyboardFunctionKey.F19Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F19",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F19",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F19Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F19_KEY"
                    },
                    "KeyboardFunctionKey.F20Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F20",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F20",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F20Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F20_KEY"
                    },
                    "KeyboardFunctionKey.F21Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F21",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F21",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F21Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F21_KEY"
                    },
                    "KeyboardFunctionKey.F22Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F22",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F22",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F22Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F22_KEY"
                    },
                    "KeyboardFunctionKey.F23Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F23",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F23",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F23Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F23_KEY"
                    },
                    "KeyboardFunctionKey.F24Key": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "F24",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "F24",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.F24Key",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.F24_KEY"
                    },
                    "KeyboardFunctionKey.PrintScreen": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "print screen",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "print screen",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.PrintScreen",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.PRINT_SCREEN"
                    },
                    "KeyboardFunctionKey.ScrollLock": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "scroll lock",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "scroll lock",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.ScrollLock",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.SCROLL_LOCK"
                    },
                    "KeyboardFunctionKey.Pause": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "pause",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "pause",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.Pause",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.PAUSE"
                    },
                    "KeyboardFunctionKey.Insert": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "insert",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "insert",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.Insert",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.INSERT"
                    },
                    "KeyboardFunctionKey.Home": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "home",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "home",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.Home",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.HOME"
                    },
                    "KeyboardFunctionKey.PageUp": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "page up",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "page up",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.PageUp",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.PAGE_UP"
                    },
                    "KeyboardFunctionKey.DeleteForward": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "delete",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "delete",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.DeleteForward",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.DELETE_FORWARD"
                    },
                    "KeyboardFunctionKey.End": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "end",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "end",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.End",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.END"
                    },
                    "KeyboardFunctionKey.PageDown": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "page down",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "page down",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.PageDown",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.PAGE_DOWN"
                    },
                    "KeyboardFunctionKey.RightArrow": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "right arrow",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "right arrow",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.RightArrow",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.RIGHT_ARROW"
                    },
                    "KeyboardFunctionKey.LeftArrow": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "left arrow",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "left arrow",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.LeftArrow",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.LEFT_ARROW"
                    },
                    "KeyboardFunctionKey.DownArrow": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "down arrow",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "down arrow",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.DownArrow",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.DOWN_ARROW"
                    },
                    "KeyboardFunctionKey.UpArrow": {
                        "retType": "KeyboardFunctionKey",
                        "attributes": {
                            "block": "up arrow",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "up arrow",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardFunctionKey.UpArrow",
                            "Number"
                        ],
                        "pyQName": "KeyboardFunctionKey.UP_ARROW"
                    },
                    "KeyboardModifierKey": {
                        "kind": 6,
                        "retType": "KeyboardModifierKey",
                        "extendsTypes": [
                            "KeyboardModifierKey",
                            "Number"
                        ]
                    },
                    "KeyboardModifierKey.Control": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Ctrl",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Ctrl",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.Control",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.CONTROL"
                    },
                    "KeyboardModifierKey.Shift": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Shift",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Shift",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.Shift",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.SHIFT"
                    },
                    "KeyboardModifierKey.Alt": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Alt",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Alt",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.Alt",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.ALT"
                    },
                    "KeyboardModifierKey.Meta": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Command",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Command",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.Meta",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.META"
                    },
                    "KeyboardModifierKey.ControlShift": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Ctrl+Shift",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Ctrl+Shift",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.ControlShift",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.CONTROL_SHIFT"
                    },
                    "KeyboardModifierKey.ControlAlt": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Ctrl+Alt",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Ctrl+Alt",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.ControlAlt",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.CONTROL_ALT"
                    },
                    "KeyboardModifierKey.ShiftAlt": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Shift+Alt",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Shift+Alt",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.ShiftAlt",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.SHIFT_ALT"
                    },
                    "KeyboardModifierKey.ControlCommand": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Ctrl+Cmd",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Ctrl+Cmd",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.ControlCommand",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.CONTROL_COMMAND"
                    },
                    "KeyboardModifierKey.ShiftCommand": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Ctrl+Cmd",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Ctrl+Cmd",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.ShiftCommand",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.SHIFT_COMMAND"
                    },
                    "KeyboardModifierKey.AltCommand": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Alt+Cmd",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Alt+Cmd",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.AltCommand",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.ALT_COMMAND"
                    },
                    "KeyboardModifierKey.ControlShiftAlt": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Ctrl+Shift+Alt",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Ctrl+Shift+Alt",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.ControlShiftAlt",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.CONTROL_SHIFT_ALT"
                    },
                    "KeyboardModifierKey.ControlCommandShiftAlt": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Ctrl+Cmd+Shift+Alt",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Ctrl+Cmd+Shift+Alt",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.ControlCommandShiftAlt",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.CONTROL_COMMAND_SHIFT_ALT"
                    },
                    "KeyboardModifierKey.RightControl": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Right Ctrl",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Right Ctrl",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.RightControl",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.RIGHT_CONTROL"
                    },
                    "KeyboardModifierKey.RightShift": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Right Shift",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Right Shift",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.RightShift",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.RIGHT_SHIFT"
                    },
                    "KeyboardModifierKey.RightAlt": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Right Alt",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Right Alt",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.RightAlt",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.RIGHT_ALT"
                    },
                    "KeyboardModifierKey.RightMeta": {
                        "retType": "KeyboardModifierKey",
                        "attributes": {
                            "block": "Right Command",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "Right Command",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "KeyboardModifierKey.RightMeta",
                            "Number"
                        ],
                        "pyQName": "KeyboardModifierKey.RIGHT_META"
                    },
                    "keyboard.type": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "keyboardType",
                            "block": "keyboard type $text||with $modifiers",
                            "blockGap": "8",
                            "weight": 100,
                            "paramShadowOptions": {
                                "text": {
                                    "toString": "true"
                                }
                            },
                            "help": "keyboard/type",
                            "jsDoc": "Send a sequence of keystrokes to the keyboard",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "keyboard type ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "text",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "text",
                                        "ref": true
                                    }
                                ]
                            },
                            "_expandedDef": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "with ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "modifiers",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "modifiers",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "text",
                                "type": "string"
                            },
                            {
                                "name": "modifiers",
                                "type": "KeyboardModifierKey",
                                "initializer": "undefined",
                                "isEnum": true
                            }
                        ]
                    },
                    "keyboard.key": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "keyboardStandardKey",
                            "block": "keyboard key %key|%event",
                            "blockGap": "8",
                            "weight": 99,
                            "help": "keyboard/key",
                            "jsDoc": "Send a key command",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "keyboard key ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "key",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "key",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "string"
                            },
                            {
                                "name": "event",
                                "type": "KeyboardKeyEvent",
                                "isEnum": true
                            }
                        ]
                    },
                    "keyboard.mediaKey": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "keyboardMediaKey",
                            "block": "keyboard media %key|%event",
                            "blockGap": "8",
                            "help": "keyboard/media-key",
                            "jsDoc": "Send a media key command",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "keyboard media ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "key",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "key",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "KeyboardMediaKey",
                                "isEnum": true
                            },
                            {
                                "name": "event",
                                "type": "KeyboardKeyEvent",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "keyboard.media_key"
                    },
                    "keyboard.functionKey": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "keyboardFunctionKey",
                            "block": "keyboard function %key|%event",
                            "blockGap": "8",
                            "help": "keyboard/function-key",
                            "jsDoc": "Send a function key command",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "keyboard function ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "key",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "key",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "KeyboardFunctionKey",
                                "isEnum": true
                            },
                            {
                                "name": "event",
                                "type": "KeyboardKeyEvent",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "keyboard.function_key"
                    },
                    "keyboard.modifierKey": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "keyboardModiferKey",
                            "block": "keyboard modifier %key|%event",
                            "blockGap": "8",
                            "help": "keyboard/modifier-key",
                            "jsDoc": "Send a modifier key command",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "keyboard modifier ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "key",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "key",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "key",
                                "type": "KeyboardModifierKey",
                                "isEnum": true
                            },
                            {
                                "name": "event",
                                "type": "KeyboardKeyEvent",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "keyboard.modifier_key"
                    },
                    "keyboard.clearAllKeys": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "keyboardClear",
                            "block": "keyboard clear all",
                            "blockGap": "8",
                            "help": "keyboard/clear-all-keys",
                            "weight": 10,
                            "jsDoc": "Send up commands for any remaning down keys",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "keyboard clear all",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "keyboard.clear_all_keys"
                    }
                }
            },
            "sha": "4a592251a07ac2dee799cb3cc020b5934fcc1f089b6852fa8a2a037303144f96"
        },
        "libs/gamepad": {
            "apis": {
                "byQName": {}
            },
            "sha": "52e83cbf8a61b1447c486883b620e665bfaf2edc6e3ec629ab5e6ca57d4a0e09"
        },
        "libs/servo": {
            "apis": {
                "byQName": {
                    "servos": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#03AA74",
                            "weight": 88,
                            "icon": "",
                            "blockGap": "8",
                            "groups": [
                                "Positional",
                                "Continuous",
                                "Configuration"
                            ],
                            "jsDoc": "Servos\n\nControl micro servos"
                        }
                    },
                    "servos.Servo": {
                        "kind": 8,
                        "retType": "servos.Servo",
                        "attributes": {
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "servos.Servo"
                        ]
                    },
                    "servos.Servo.__constructor": {
                        "kind": -3,
                        "parameters": [],
                        "isInstance": true
                    },
                    "servos.Servo.setAngle": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "degrees": "90"
                            },
                            "weight": 100,
                            "help": "servos/set-angle",
                            "blockId": "servoservosetangle",
                            "block": "set %servo angle to %degrees=protractorPicker ",
                            "explicitDefaults": [
                                "degrees"
                            ],
                            "paramFieldEditor": {
                                "servo": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "servo": {
                                    "width": "220",
                                    "columns": "2"
                                }
                            },
                            "blockGap": "8",
                            "parts": "microservo",
                            "trackArgs": [
                                0
                            ],
                            "group": "Positional",
                            "jsDoc": "Set the servo angle",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " angle to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "degrees",
                                        "shadowBlockId": "protractorPicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " ",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "degrees",
                                        "shadowBlockId": "protractorPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "degrees",
                                "initializer": "90",
                                "default": "90"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "servos.Servo.set_angle"
                    },
                    "servos.Servo.angle": {
                        "kind": -2,
                        "retType": "number",
                        "isInstance": true,
                        "isReadOnly": true
                    },
                    "servos.Servo.run": {
                        "kind": -1,
                        "attributes": {
                            "weight": 99,
                            "help": "servos/run",
                            "blockId": "servoservorun",
                            "block": "continuous %servo run at %speed=speedPicker \\%",
                            "paramFieldEditor": {
                                "servo": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "servo": {
                                    "width": "220",
                                    "columns": "2"
                                }
                            },
                            "parts": "microservo",
                            "trackArgs": [
                                0
                            ],
                            "group": "Continuous",
                            "blockGap": "8",
                            "paramHelp": {
                                "speed": "the throttle of the motor from -100% to 100%"
                            },
                            "jsDoc": "Set the throttle on a continuous servo",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "continuous ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " run at ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "speed",
                                        "shadowBlockId": "speedPicker",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " %",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "speed",
                                        "shadowBlockId": "speedPicker",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "speed",
                                "description": "the throttle of the motor from -100% to 100%"
                            }
                        ],
                        "isInstance": true
                    },
                    "servos.Servo.setPulse": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "micros": "1500"
                            },
                            "weight": 10,
                            "help": "servos/set-pulse",
                            "blockId": "servoservosetpulse",
                            "block": "set %servo pulse to %micros s",
                            "paramMin": {
                                "micros": "500"
                            },
                            "paramMax": {
                                "micros": "2500"
                            },
                            "explicitDefaults": [
                                "micros"
                            ],
                            "paramFieldEditor": {
                                "servo": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "servo": {
                                    "width": "220",
                                    "columns": "2"
                                }
                            },
                            "parts": "microservo",
                            "trackArgs": [
                                0
                            ],
                            "group": "Configuration",
                            "blockGap": "8",
                            "paramHelp": {
                                "micros": "the width of the pulse in microseconds"
                            },
                            "jsDoc": "Set the pulse width to the servo in microseconds",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " pulse to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "micros",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " s",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "micros",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "micros",
                                "description": "the width of the pulse in microseconds",
                                "initializer": "1500",
                                "default": "1500",
                                "options": {
                                    "min": {
                                        "value": "500"
                                    },
                                    "max": {
                                        "value": "2500"
                                    }
                                }
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "servos.Servo.set_pulse"
                    },
                    "servos.Servo.stop": {
                        "kind": -1,
                        "attributes": {
                            "weight": 10,
                            "help": "servos/stop",
                            "blockId": "servoservostop",
                            "block": "stop %servo",
                            "paramFieldEditor": {
                                "servo": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "servo": {
                                    "width": "220",
                                    "columns": "2"
                                }
                            },
                            "parts": "microservo",
                            "trackArgs": [
                                0
                            ],
                            "group": "Continuous",
                            "blockGap": "8",
                            "jsDoc": "Stop sending commands to the servo so that its rotation will stop at the current position.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "stop ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "servos.Servo.minAngle": {
                        "kind": -2,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Gets the minimum angle for the servo"
                        },
                        "isInstance": true,
                        "isReadOnly": true,
                        "pyQName": "servos.Servo.min_angle"
                    },
                    "servos.Servo.maxAngle": {
                        "kind": -2,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Gets the maximum angle for the servo"
                        },
                        "isInstance": true,
                        "isReadOnly": true,
                        "pyQName": "servos.Servo.max_angle"
                    },
                    "servos.Servo.setRange": {
                        "kind": -1,
                        "attributes": {
                            "paramDefl": {
                                "maxAngle": "180"
                            },
                            "help": "servos/set-range",
                            "blockId": "servosetrange",
                            "block": "set %servo range from %minAngle to %maxAngle",
                            "paramMin": {
                                "minAngle": "0",
                                "maxAngle": "90"
                            },
                            "paramMax": {
                                "minAngle": "90",
                                "maxAngle": "180"
                            },
                            "explicitDefaults": [
                                "maxAngle"
                            ],
                            "paramFieldEditor": {
                                "servo": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "servo": {
                                    "width": "220",
                                    "columns": "2"
                                }
                            },
                            "parts": "microservo",
                            "trackArgs": [
                                0
                            ],
                            "group": "Configuration",
                            "blockGap": "8",
                            "paramHelp": {
                                "minAngle": "the minimum angle from 0 to 90",
                                "maxAngle": "the maximum angle from 90 to 180"
                            },
                            "jsDoc": "Set the possible rotation range angles for the servo between 0 and 180",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " range from ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "minAngle",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "maxAngle",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "minAngle",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "maxAngle",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "minAngle",
                                "description": "the minimum angle from 0 to 90",
                                "options": {
                                    "min": {
                                        "value": "0"
                                    },
                                    "max": {
                                        "value": "90"
                                    }
                                }
                            },
                            {
                                "name": "maxAngle",
                                "description": "the maximum angle from 90 to 180",
                                "initializer": "180",
                                "default": "180",
                                "options": {
                                    "min": {
                                        "value": "90"
                                    },
                                    "max": {
                                        "value": "180"
                                    }
                                }
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "servos.Servo.set_range"
                    },
                    "servos.Servo.setStopOnNeutral": {
                        "kind": -1,
                        "attributes": {
                            "help": "servos/set-stop-on-neutral",
                            "blockId": "servostoponneutral",
                            "block": "set %servo stop on neutral %enabled",
                            "_shadowOverrides": {
                                "enabled": "toggleOnOff"
                            },
                            "group": "Configuration",
                            "blockGap": "8",
                            "paramFieldEditor": {
                                "servo": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "servo": {
                                    "width": "220",
                                    "columns": "2"
                                }
                            },
                            "paramHelp": {
                                "on": "true to enable this mode"
                            },
                            "jsDoc": "Set a servo stop mode so it will stop when the rotation angle is in the neutral position, 90 degrees.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " stop on neutral ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "enabled",
                                        "shadowBlockId": "toggleOnOff",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "servo",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "enabled",
                                        "shadowBlockId": "toggleOnOff",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "enabled",
                                "type": "boolean"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "servos.Servo.set_stop_on_neutral"
                    },
                    "servos.PinServo": {
                        "kind": 8,
                        "retType": "servos.PinServo",
                        "extendsTypes": [
                            "servos.PinServo",
                            "servos.Servo"
                        ]
                    },
                    "servos.PinServo.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "pin",
                                "type": "PwmOnlyPin"
                            }
                        ],
                        "isInstance": true
                    },
                    "servos.A1": {
                        "kind": 4,
                        "retType": "servos.PinServo",
                        "attributes": {
                            "block": "servo A1",
                            "fixedInstance": "true",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "servo A1",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    },
                    "servos.A2": {
                        "kind": 4,
                        "retType": "servos.PinServo",
                        "attributes": {
                            "block": "servo A2",
                            "fixedInstance": "true",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "servo A2",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        }
                    }
                }
            },
            "sha": "05e3f7d46c6e21a4456513e246aa82c630cc11562e039fe47909088d894c7657"
        },
        "libs/storage": {
            "apis": {
                "byQName": {
                    "control": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 90,
                            "color": "#FF5722",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Program controls and events."
                        }
                    },
                    "pins": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#A80000",
                            "weight": 85,
                            "icon": "",
                            "advanced": true,
                            "groups": [
                                "other",
                                "Servo",
                                "i2c"
                            ],
                            "jsDoc": "Control currents in Pins for analog/digital signals, servos, i2c, ..."
                        }
                    },
                    "loops": {
                        "kind": 5,
                        "retType": ""
                    },
                    "input": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#B4009E",
                            "weight": 98,
                            "icon": "",
                            "groups": [
                                "other",
                                "More"
                            ],
                            "jsDoc": "Respond to and read data from buttons and sensors.\n\nEvents and data from sensors."
                        }
                    },
                    "console": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 12,
                            "color": "#002050",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Reading and writing data to the console output."
                        }
                    },
                    "AnalogInOutPin": {
                        "kind": 9,
                        "retType": "AnalogInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInOutPin",
                            "AnalogInPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "light": {
                        "kind": 5,
                        "retType": ""
                    },
                    "storage": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 5,
                            "color": "#00c0c0",
                            "icon": "",
                            "jsDoc": "File storage operations"
                        }
                    },
                    "storage.NEW_LINE": {
                        "kind": 4,
                        "retType": "string"
                    },
                    "storage.appendLine": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_append_line",
                            "block": "append file $filename with line $data",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Appends a new line to the file",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "append file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "label",
                                        "text": " with line ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            },
                            {
                                "name": "data",
                                "type": "string"
                            }
                        ],
                        "pyQName": "storage.append_line"
                    },
                    "storage.append": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_append",
                            "block": "append file $filename with $data",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Append string data to a new or existing file.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "append file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "label",
                                        "text": " with ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            },
                            {
                                "name": "data",
                                "type": "string"
                            }
                        ]
                    },
                    "storage.overwrite": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_overwrite",
                            "block": "overwrite file $filename with $data",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Overwrite file with string data.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "overwrite file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "label",
                                        "text": " with ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            },
                            {
                                "name": "data",
                                "type": "string"
                            }
                        ]
                    },
                    "storage.read": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_read",
                            "block": "read file $filename",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Read contents of file as a string.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "read file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            }
                        ]
                    },
                    "storage.appendBuffer": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Append a buffer to a new or existing file."
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            },
                            {
                                "name": "data",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "storage.append_buffer"
                    },
                    "storage.overwriteWithBuffer": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Overwrite file with a buffer."
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            },
                            {
                                "name": "data",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "storage.overwrite_with_buffer"
                    },
                    "storage.exists": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_exists",
                            "block": "file $filename exists",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Return true if the file already exists.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "label",
                                        "text": " exists",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            }
                        ]
                    },
                    "storage.remove": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_remove",
                            "block": "remove file $filename",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Delete a file, or do nothing if it doesn't exist.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "remove file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            }
                        ]
                    },
                    "storage.size": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_size",
                            "block": "size of file $filename",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Return the size of the file, or -1 if it doesn't exists.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "size of file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            }
                        ]
                    },
                    "storage.readAsBuffer": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Read contents of file as a buffer."
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            }
                        ],
                        "pyQName": "storage.read_as_buffer"
                    }
                }
            },
            "sha": "6b99741bab3ee52df503835184c53a25c8652b3f307cda1889df77490c821ef8"
        },
        "libs/datalogger": {
            "apis": {
                "byQName": {
                    "control": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 90,
                            "color": "#FF5722",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Program controls and events."
                        }
                    },
                    "pins": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#A80000",
                            "weight": 85,
                            "icon": "",
                            "advanced": true,
                            "groups": [
                                "other",
                                "Servo",
                                "i2c"
                            ],
                            "jsDoc": "Control currents in Pins for analog/digital signals, servos, i2c, ..."
                        }
                    },
                    "loops": {
                        "kind": 5,
                        "retType": ""
                    },
                    "input": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#B4009E",
                            "weight": 98,
                            "icon": "",
                            "groups": [
                                "other",
                                "More"
                            ],
                            "jsDoc": "Respond to and read data from buttons and sensors.\n\nEvents and data from sensors."
                        }
                    },
                    "console": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 12,
                            "color": "#002050",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Reading and writing data to the console output."
                        }
                    },
                    "AnalogInOutPin": {
                        "kind": 9,
                        "retType": "AnalogInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInOutPin",
                            "AnalogInPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "light": {
                        "kind": 5,
                        "retType": ""
                    },
                    "storage": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 5,
                            "color": "#00c0c0",
                            "icon": "",
                            "jsDoc": "File storage operations"
                        }
                    },
                    "storage.NEW_LINE": {
                        "kind": 4,
                        "retType": "string"
                    },
                    "storage.appendLine": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_append_line",
                            "block": "append file $filename with line $data",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Appends a new line to the file",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "append file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "label",
                                        "text": " with line ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            },
                            {
                                "name": "data",
                                "type": "string"
                            }
                        ],
                        "pyQName": "storage.append_line"
                    },
                    "storage.append": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_append",
                            "block": "append file $filename with $data",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Append string data to a new or existing file.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "append file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "label",
                                        "text": " with ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            },
                            {
                                "name": "data",
                                "type": "string"
                            }
                        ]
                    },
                    "storage.overwrite": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_overwrite",
                            "block": "overwrite file $filename with $data",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Overwrite file with string data.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "overwrite file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "label",
                                        "text": " with ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "param",
                                        "name": "data",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            },
                            {
                                "name": "data",
                                "type": "string"
                            }
                        ]
                    },
                    "storage.read": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_read",
                            "block": "read file $filename",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Read contents of file as a string.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "read file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            }
                        ]
                    },
                    "storage.appendBuffer": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Append a buffer to a new or existing file."
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            },
                            {
                                "name": "data",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "storage.append_buffer"
                    },
                    "storage.overwriteWithBuffer": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Overwrite file with a buffer."
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            },
                            {
                                "name": "data",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "storage.overwrite_with_buffer"
                    },
                    "storage.exists": {
                        "kind": -3,
                        "retType": "boolean",
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_exists",
                            "block": "file $filename exists",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Return true if the file already exists.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    },
                                    {
                                        "kind": "label",
                                        "text": " exists",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            }
                        ]
                    },
                    "storage.remove": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_remove",
                            "block": "remove file $filename",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Delete a file, or do nothing if it doesn't exist.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "remove file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            }
                        ]
                    },
                    "storage.size": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "blockId": "storage_size",
                            "block": "size of file $filename",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Return the size of the file, or -1 if it doesn't exists.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "size of file ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "filename",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            }
                        ]
                    },
                    "storage.readAsBuffer": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "paramDefl": {
                                "filename": "log.txt"
                            },
                            "parts": "storage",
                            "paramHelp": {
                                "filename": "name of the file, eg: \"log.txt\""
                            },
                            "jsDoc": "Read contents of file as a buffer."
                        },
                        "parameters": [
                            {
                                "name": "filename",
                                "description": "name of the file, eg: \"log.txt\"",
                                "type": "string",
                                "default": "log.txt"
                            }
                        ],
                        "pyQName": "storage.read_as_buffer"
                    },
                    "LogSeparator": {
                        "kind": 6,
                        "retType": "LogSeparator",
                        "extendsTypes": [
                            "LogSeparator",
                            "Number"
                        ]
                    },
                    "LogSeparator.Tab": {
                        "retType": "LogSeparator.Tab",
                        "attributes": {
                            "block": "tab",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "tab",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LogSeparator.Tab",
                            "Number"
                        ],
                        "pyQName": "LogSeparator.TAB"
                    },
                    "LogSeparator.Comma": {
                        "retType": "LogSeparator.Comma",
                        "attributes": {
                            "block": "comma",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "comma",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LogSeparator.Comma",
                            "Number"
                        ],
                        "pyQName": "LogSeparator.COMMA"
                    },
                    "LogSeparator.Semicolon": {
                        "retType": "LogSeparator.Semicolon",
                        "attributes": {
                            "block": "semicolon",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "semicolon",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "LogSeparator.Semicolon",
                            "Number"
                        ],
                        "pyQName": "LogSeparator.SEMICOLON"
                    },
                    "datalogger": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 80,
                            "color": "#00a0a0",
                            "icon": "",
                            "blockGap": "8",
                            "groups": [
                                "Data",
                                "Configuration"
                            ],
                            "jsDoc": "A tiny data logging framework"
                        }
                    },
                    "datalogger.SEPARATOR": {
                        "kind": 4,
                        "retType": "string"
                    },
                    "datalogger.Storage": {
                        "kind": 8,
                        "retType": "datalogger.Storage",
                        "attributes": {
                            "jsDoc": "A storage for log data"
                        },
                        "extendsTypes": [
                            "datalogger.Storage"
                        ]
                    },
                    "datalogger.Storage.__constructor": {
                        "kind": -3,
                        "parameters": [],
                        "isInstance": true
                    },
                    "datalogger.Storage.init": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Initializes the storage"
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "datalogger.Storage.appendHeaders": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Appends the headers in log"
                        },
                        "parameters": [
                            {
                                "name": "headers",
                                "type": "string[]"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "datalogger.Storage.append_headers"
                    },
                    "datalogger.Storage.appendRow": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Appends a row of data"
                        },
                        "parameters": [
                            {
                                "name": "values",
                                "type": "number[]"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "datalogger.Storage.append_row"
                    },
                    "datalogger.Storage.flush": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Flushes any buffered data"
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "datalogger.addRow": {
                        "kind": -3,
                        "attributes": {
                            "group": "Data",
                            "weight": 100,
                            "blockId": "datalogAddRow",
                            "block": "data logger add row",
                            "help": "datalogger/add-row",
                            "jsDoc": "Start a new row of data",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "data logger add row",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "datalogger.add_row"
                    },
                    "datalogger.addValue": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "name": "x",
                                "value": "0"
                            },
                            "group": "Data",
                            "weight": 99,
                            "blockId": "datalogAddValue",
                            "block": "data logger add %name|=%value",
                            "blockGap": "12",
                            "help": "datalogger/add-value",
                            "paramHelp": {
                                "name": "name of the cell, eg: \"x\"",
                                "value": "value of the cell, eg: 0"
                            },
                            "jsDoc": "Add a named value to the row of data",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "data logger add ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "=",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "name",
                                "description": "name of the cell, eg: \"x\"",
                                "type": "string",
                                "default": "x"
                            },
                            {
                                "name": "value",
                                "description": "value of the cell, eg: 0",
                                "default": "0"
                            }
                        ],
                        "pyQName": "datalogger.add_value"
                    },
                    "datalogger.setStorage": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "* @param storage custom storage solution"
                        },
                        "parameters": [
                            {
                                "name": "storage",
                                "type": "datalogger.Storage"
                            }
                        ],
                        "pyQName": "datalogger.set_storage"
                    },
                    "datalogger.flush": {
                        "kind": -3,
                        "attributes": {
                            "jsDoc": "Commits any buffered row to disk"
                        },
                        "parameters": []
                    },
                    "datalogger.setSampleInterval": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "millis": "50"
                            },
                            "group": "Configuration",
                            "blockId": "datalogSetSamplingInterval",
                            "block": "set data logger sampling interval to $millis|(ms)",
                            "_shadowOverrides": {
                                "millis": "timePicker"
                            },
                            "help": "datalogger/set-sample-interval",
                            "paramHelp": {
                                "millis": "milliseconds between each sample, eg: 50"
                            },
                            "jsDoc": "Set the minimum number of milliseconds between rows",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "set data logger sampling interval to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "millis",
                                        "shadowBlockId": "timePicker",
                                        "ref": true
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "(ms)",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "millis",
                                        "shadowBlockId": "timePicker",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "millis",
                                "description": "milliseconds between each sample, eg: 50",
                                "default": "50"
                            }
                        ],
                        "pyQName": "datalogger.set_sample_interval"
                    },
                    "datalogger.setEnabled": {
                        "kind": -3,
                        "attributes": {
                            "group": "Configuration",
                            "blockId": "datalogEnabled",
                            "block": "data logger $enabled",
                            "_shadowOverrides": {
                                "enabled": "toggleOnOff"
                            },
                            "help": "datalogger/set-enabled",
                            "paramHelp": {
                                "enabled": ""
                            },
                            "jsDoc": "Turn on or off datalogging",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "data logger ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "enabled",
                                        "shadowBlockId": "toggleOnOff",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "enabled",
                                        "shadowBlockId": "toggleOnOff",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "enabled",
                                "type": "boolean"
                            }
                        ],
                        "pyQName": "datalogger.set_enabled"
                    },
                    "datalogger.sendToConsole": {
                        "kind": -3,
                        "attributes": {
                            "group": "Configuration",
                            "blockId": "datalogConsole",
                            "block": "data logger to console $enabled",
                            "_shadowOverrides": {
                                "enabled": "toggleOnOff"
                            },
                            "help": "datalogger/send-to-console",
                            "paramHelp": {
                                "enabled": ""
                            },
                            "jsDoc": "Send the data logger output to the console",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "data logger to console ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "enabled",
                                        "shadowBlockId": "toggleOnOff",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "enabled",
                                        "shadowBlockId": "toggleOnOff",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "enabled",
                                "type": "boolean"
                            }
                        ],
                        "pyQName": "datalogger.send_to_console"
                    },
                    "datalogger.setSeparator": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "separator": "\\t"
                            },
                            "group": "Configuration",
                            "blockId": "datalogSeparator",
                            "block": "data logger set separator $separator",
                            "help": "datalogger/set-separator",
                            "paramHelp": {
                                "separator": "the value separator character, eg: \"\\t\""
                            },
                            "jsDoc": "Set the character used to separate values in a row.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "data logger set separator ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "separator",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "separator",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "separator",
                                "description": "the value separator character, eg: \"\\t\"",
                                "type": "LogSeparator",
                                "default": "\\t",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "datalogger.set_separator"
                    },
                    "datalogger.FileStorage": {
                        "kind": 8,
                        "retType": "datalogger.FileStorage",
                        "attributes": {
                            "jsDoc": "A storage for datalog data"
                        },
                        "extendsTypes": [
                            "datalogger.FileStorage",
                            "datalogger.Storage"
                        ]
                    },
                    "datalogger.FileStorage.filename": {
                        "kind": 2,
                        "retType": "string",
                        "isInstance": true
                    },
                    "datalogger.FileStorage.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "filename",
                                "type": "string"
                            }
                        ],
                        "isInstance": true
                    },
                    "datalogger.FileStorage.init": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Initializes the storage"
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "datalogger.FileStorage.appendHeaders": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Appends the headers in datalog"
                        },
                        "parameters": [
                            {
                                "name": "headers",
                                "type": "string[]"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "datalogger.FileStorage.append_headers"
                    },
                    "datalogger.FileStorage.appendRow": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Appends a row of data"
                        },
                        "parameters": [
                            {
                                "name": "values",
                                "type": "number[]"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "datalogger.FileStorage.append_row"
                    },
                    "datalogger.FileStorage.flush": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Flushes any buffered data"
                        },
                        "parameters": [],
                        "isInstance": true
                    }
                }
            },
            "sha": "bb761d68ea61d6e76ec85aad32387519d77dee6028c6961a7c8e7fe135b3869b"
        },
        "libs/serial": {
            "apis": {
                "byQName": {
                    "control": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 90,
                            "color": "#FF5722",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Program controls and events."
                        }
                    },
                    "pins": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#A80000",
                            "weight": 85,
                            "icon": "",
                            "advanced": true,
                            "groups": [
                                "other",
                                "Servo",
                                "i2c"
                            ],
                            "jsDoc": "Control currents in Pins for analog/digital signals, servos, i2c, ..."
                        }
                    },
                    "loops": {
                        "kind": 5,
                        "retType": ""
                    },
                    "input": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "color": "#B4009E",
                            "weight": 98,
                            "icon": "",
                            "groups": [
                                "other",
                                "More"
                            ],
                            "jsDoc": "Respond to and read data from buttons and sensors.\n\nEvents and data from sensors."
                        }
                    },
                    "console": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 12,
                            "color": "#002050",
                            "icon": "",
                            "advanced": true,
                            "jsDoc": "Reading and writing data to the console output."
                        }
                    },
                    "AnalogInOutPin": {
                        "kind": 9,
                        "retType": "AnalogInOutPin",
                        "attributes": {
                            "noRefCounting": "true",
                            "fixedInstances": "true"
                        },
                        "extendsTypes": [
                            "AnalogInOutPin",
                            "AnalogInPin",
                            "DigitalInOutPin",
                            "AnalogOutPin"
                        ]
                    },
                    "light": {
                        "kind": 5,
                        "retType": ""
                    },
                    "serial": {
                        "kind": 5,
                        "retType": "",
                        "attributes": {
                            "weight": 2,
                            "color": "#002050",
                            "icon": "",
                            "advanced": true,
                            "blockGap": "8",
                            "groups": [
                                "Write",
                                "Read",
                                "Events",
                                "Configuration"
                            ],
                            "jsDoc": "Reading and writing data over a serial connection."
                        }
                    },
                    "serial.createSerial": {
                        "kind": -3,
                        "retType": "serial.Serial",
                        "attributes": {
                            "help": "serial/create-serial",
                            "parts": "serial",
                            "paramHelp": {
                                "tx": "@param rx ",
                                "id": ""
                            },
                            "jsDoc": "Creates a serial comm device"
                        },
                        "parameters": [
                            {
                                "name": "tx",
                                "description": "@param rx ",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "rx",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "id",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "serial.create_serial"
                    },
                    "serial.device": {
                        "kind": -3,
                        "retType": "serial.Serial",
                        "parameters": []
                    },
                    "serial.redirect": {
                        "kind": -3,
                        "attributes": {
                            "weight": 10,
                            "help": "serial/redirect",
                            "blockId": "serial_redirect",
                            "block": "serial|redirect to|TX %tx|RX %rx at rate %rate",
                            "paramFieldEditor": {
                                "tx": "gridpicker",
                                "rx": "gridpicker"
                            },
                            "paramFieldEditorOptions": {
                                "tx": {
                                    "columns": "3",
                                    "tooltips": "false"
                                },
                                "rx": {
                                    "columns": "3",
                                    "tooltips": "false"
                                }
                            },
                            "blockGap": "8",
                            "inlineInputMode": "inline",
                            "group": "Configuration",
                            "paramHelp": {
                                "tx": "the new transmission pin",
                                "rx": "the new reception pin",
                                "rate": "the new baud rate"
                            },
                            "jsDoc": "Set the serial input and output to use pins instead of the USB connection.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "redirect to",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "TX ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "tx",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "RX ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rx",
                                        "ref": false
                                    },
                                    {
                                        "kind": "label",
                                        "text": " at rate ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rate",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "tx",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rx",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rate",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "tx",
                                "description": "the new transmission pin",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "rx",
                                "description": "the new reception pin",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "rate",
                                "description": "the new baud rate",
                                "type": "BaudRate",
                                "isEnum": true
                            }
                        ]
                    },
                    "serial.NEW_LINE": {
                        "kind": 4,
                        "retType": "string"
                    },
                    "serial.NEW_LINE_DELIMITER": {
                        "kind": 4,
                        "retType": "Delimiters"
                    },
                    "serial.Serial": {
                        "kind": 8,
                        "retType": "serial.Serial",
                        "extendsTypes": []
                    },
                    "serial.Serial.serialDevice": {
                        "kind": 2,
                        "retType": "SerialDevice",
                        "isInstance": true,
                        "pyQName": "serial.Serial.serial_device"
                    },
                    "serial.Serial.decoder": {
                        "kind": 2,
                        "retType": "UTF8Decoder",
                        "isInstance": true
                    },
                    "serial.Serial.__constructor": {
                        "kind": -3,
                        "parameters": [
                            {
                                "name": "serialDevice",
                                "type": "SerialDevice"
                            }
                        ],
                        "isInstance": true
                    },
                    "serial.Serial.readString": {
                        "kind": -1,
                        "retType": "string",
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "serial.Serial.read_string"
                    },
                    "serial.Serial.readLine": {
                        "kind": -1,
                        "retType": "string",
                        "parameters": [
                            {
                                "name": "timeOut",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "serial.Serial.read_line"
                    },
                    "serial.Serial.readUntil": {
                        "kind": -1,
                        "retType": "string",
                        "parameters": [
                            {
                                "name": "delimiter",
                                "type": "Delimiters",
                                "isEnum": true
                            },
                            {
                                "name": "timeOut",
                                "initializer": "undefined"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "serial.Serial.read_until"
                    },
                    "serial.Serial.writeString": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "text",
                                "type": "string"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "serial.Serial.write_string"
                    },
                    "serial.Serial.writeLine": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "text",
                                "type": "string"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "serial.Serial.write_line"
                    },
                    "serial.readString": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "help": "serial/read-string",
                            "blockId": "serial_read_string",
                            "block": "serial|read string",
                            "weight": 18,
                            "group": "Read",
                            "jsDoc": "Read the buffered received data as a string",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "read string",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "serial.read_string"
                    },
                    "serial.readLine": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "help": "serial/read-line",
                            "blockId": "serial_read_line",
                            "block": "serial|read line",
                            "weight": 20,
                            "blockGap": "8",
                            "group": "Read",
                            "jsDoc": "Read a line of text from the serial port.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "read line",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "serial.read_line"
                    },
                    "serial.readUntil": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "help": "serial/read-until",
                            "blockId": "serial_read_until",
                            "block": "serial|read until %delimiter=serial_delimiter_conv",
                            "weight": 19,
                            "group": "Read",
                            "paramHelp": {
                                "delimiter": "text delimiter that separates each text chunk"
                            },
                            "jsDoc": "Read a line of text from the serial port and return the buffer when the delimiter is met.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "read until ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "delimiter",
                                        "shadowBlockId": "serial_delimiter_conv",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "delimiter",
                                        "shadowBlockId": "serial_delimiter_conv",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "delimiter",
                                "description": "text delimiter that separates each text chunk",
                                "type": "Delimiters",
                                "isEnum": true
                            },
                            {
                                "name": "timeOut",
                                "initializer": "undefined"
                            }
                        ],
                        "pyQName": "serial.read_until"
                    },
                    "serial.writeString": {
                        "kind": -3,
                        "attributes": {
                            "help": "serial/write-string",
                            "weight": 87,
                            "blockId": "serial_writestring",
                            "block": "serial|write string %text",
                            "group": "Write",
                            "jsDoc": "Write some text to the serial port.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "write string ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "text",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "text",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "text",
                                "type": "string"
                            }
                        ],
                        "pyQName": "serial.write_string"
                    },
                    "serial.writeLine": {
                        "kind": -3,
                        "attributes": {
                            "weight": 90,
                            "help": "serial/write-line",
                            "blockGap": "8",
                            "blockId": "serial_writeline",
                            "block": "serial|write line %text",
                            "group": "Write",
                            "paramHelp": {
                                "value": "to send over serial"
                            },
                            "jsDoc": "Write a line of text to the serial port.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "write line ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "text",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "text",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "text",
                                "type": "string"
                            }
                        ],
                        "pyQName": "serial.write_line"
                    },
                    "serial.writeNumber": {
                        "kind": -3,
                        "attributes": {
                            "help": "serial/write-number",
                            "weight": 89,
                            "blockGap": "8",
                            "blockId": "serial_writenumber",
                            "block": "serial|write number %value",
                            "group": "Write",
                            "jsDoc": "Write a number to the serial port.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "write number ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "value"
                            }
                        ],
                        "pyQName": "serial.write_number"
                    },
                    "serial.writeValue": {
                        "kind": -3,
                        "attributes": {
                            "paramDefl": {
                                "name": "x"
                            },
                            "weight": 88,
                            "blockGap": "8",
                            "help": "serial/write-value",
                            "blockId": "serial_writevalue",
                            "block": "serial|write value %name|= %value",
                            "group": "Write",
                            "paramHelp": {
                                "name": "name of the value stream, eg: \"x\"",
                                "value": "to write"
                            },
                            "jsDoc": "Write a name:value pair as a line of text to the serial port.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "write value ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "= ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "name",
                                        "ref": false
                                    },
                                    {
                                        "kind": "param",
                                        "name": "value",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "name",
                                "description": "name of the value stream, eg: \"x\"",
                                "type": "string",
                                "default": "x"
                            },
                            {
                                "name": "value",
                                "description": "to write"
                            }
                        ],
                        "pyQName": "serial.write_value"
                    },
                    "serial.setRxBufferSize": {
                        "kind": -3,
                        "attributes": {
                            "help": "serial/set-rx-buffer-size",
                            "blockId": "serialsetrxbuffersize",
                            "block": "serial set rx buffer size to $size",
                            "weight": 10,
                            "group": "Configuration",
                            "jsDoc": "Sets the size of the RX buffer in bytes",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial set rx buffer size to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "size",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "size",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "size"
                            }
                        ],
                        "pyQName": "serial.set_rx_buffer_size"
                    },
                    "serial.setTxBufferSize": {
                        "kind": -3,
                        "attributes": {
                            "help": "serial/set-tx-buffer-size",
                            "blockId": "serialsettxbuffersize",
                            "block": "serial set tx buffer size to $size",
                            "weight": 9,
                            "group": "Configuration",
                            "jsDoc": "Sets the size of the TX buffer in bytes",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial set tx buffer size to ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "size",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "size",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "size"
                            }
                        ],
                        "pyQName": "serial.set_tx_buffer_size"
                    },
                    "serial.read": {
                        "kind": -3,
                        "retType": "number",
                        "attributes": {
                            "Group": "Read",
                            "jsDoc": "Reads a single byte from the serial receive buffer. Negative if error, 0 if no data."
                        },
                        "parameters": []
                    },
                    "serial.readBuffer": {
                        "kind": -3,
                        "retType": "Buffer",
                        "attributes": {
                            "help": "serial/read-buffer",
                            "blockId": "serial_read_buffer",
                            "block": "serial|read buffer",
                            "weight": 17,
                            "group": "Read",
                            "jsDoc": "Read the buffered received data as a buffer",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "read buffer",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "serial.read_buffer"
                    },
                    "serial.writeBuffer": {
                        "kind": -3,
                        "attributes": {
                            "help": "serial/write-buffer",
                            "weight": 6,
                            "blockId": "serial_writebuffer",
                            "block": "serial|write buffer %buffer",
                            "group": "Write",
                            "jsDoc": "Send a buffer across the serial connection.",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "write buffer ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "buffer",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "buffer",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "buffer",
                                "type": "Buffer"
                            }
                        ],
                        "pyQName": "serial.write_buffer"
                    },
                    "serial.setBaudRate": {
                        "kind": -3,
                        "attributes": {
                            "weight": 10,
                            "blockId": "serial_setbaudrate",
                            "block": "serial|set baud rate %rate",
                            "blockGap": "8",
                            "inlineInputMode": "inline",
                            "help": "serial/set-baud-rate",
                            "group": "Configuration",
                            "jsDoc": "Set the baud rate of the serial port",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial",
                                        "style": []
                                    },
                                    {
                                        "kind": "break"
                                    },
                                    {
                                        "kind": "label",
                                        "text": "set baud rate ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "rate",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "rate",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "rate",
                                "type": "BaudRate",
                                "isEnum": true
                            }
                        ],
                        "pyQName": "serial.set_baud_rate"
                    },
                    "serial.attachToConsole": {
                        "kind": -3,
                        "attributes": {
                            "blockId": "serialsendtoconsole",
                            "block": "serial attach to console",
                            "group": "Configuration",
                            "help": "serial/attach-to-console",
                            "jsDoc": "Send console messages through the TX, RX pins",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial attach to console",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "parameters": [],
                        "pyQName": "serial.attach_to_console"
                    },
                    "serial.onEvent": {
                        "kind": -3,
                        "attributes": {
                            "weight": 9,
                            "help": "serial/on-event",
                            "blockId": "serial_onevent",
                            "block": "serial on %event",
                            "blockGap": "8",
                            "group": "Events",
                            "jsDoc": "Registers code when serial events happen",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial on ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "event",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "event",
                                "type": "SerialEvent",
                                "isEnum": true
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "serial.on_event"
                    },
                    "serial.onDelimiterReceived": {
                        "kind": -3,
                        "attributes": {
                            "weight": 10,
                            "help": "serial/on-delimiter-received",
                            "blockId": "serial_ondelimiter",
                            "block": "serial on delimiter $delimiter received",
                            "blockGap": "8",
                            "group": "Events",
                            "jsDoc": "Registers code when a delimiter is received",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "serial on delimiter ",
                                        "style": []
                                    },
                                    {
                                        "kind": "param",
                                        "name": "delimiter",
                                        "ref": true
                                    },
                                    {
                                        "kind": "label",
                                        "text": " received",
                                        "style": []
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "delimiter",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "delimiter",
                                "type": "Delimiters",
                                "isEnum": true
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "pyQName": "serial.on_delimiter_received"
                    },
                    "serial.delimiters": {
                        "kind": -3,
                        "retType": "string",
                        "attributes": {
                            "blockId": "serial_delimiter_conv",
                            "block": "%del",
                            "weight": 1,
                            "blockHidden": true,
                            "hidden": "true",
                            "jsDoc": "Return the corresponding delimiter string",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "del",
                                        "ref": false
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "del",
                                        "ref": false
                                    }
                                ]
                            }
                        },
                        "parameters": [
                            {
                                "name": "del",
                                "type": "Delimiters",
                                "isEnum": true
                            }
                        ]
                    },
                    "BaudRate": {
                        "kind": 6,
                        "retType": "BaudRate",
                        "extendsTypes": [
                            "BaudRate",
                            "Number"
                        ]
                    },
                    "BaudRate.BaudRate115200": {
                        "retType": "BaudRate.BaudRate115200",
                        "attributes": {
                            "block": "115200",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "115200",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate115200",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE115200"
                    },
                    "BaudRate.BaudRate57600": {
                        "retType": "BaudRate.BaudRate57600",
                        "attributes": {
                            "block": "57600",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "57600",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate57600",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE57600"
                    },
                    "BaudRate.BaudRate38400": {
                        "retType": "BaudRate.BaudRate38400",
                        "attributes": {
                            "block": "38400",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "38400",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate38400",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE38400"
                    },
                    "BaudRate.BaudRate31250": {
                        "retType": "BaudRate.BaudRate31250",
                        "attributes": {
                            "block": "31250",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "31250",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate31250",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE31250"
                    },
                    "BaudRate.BaudRate28800": {
                        "retType": "BaudRate.BaudRate28800",
                        "attributes": {
                            "block": "28800",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "28800",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate28800",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE28800"
                    },
                    "BaudRate.BaudRate19200": {
                        "retType": "BaudRate.BaudRate19200",
                        "attributes": {
                            "block": "19200",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "19200",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate19200",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE19200"
                    },
                    "BaudRate.BaudRate14400": {
                        "retType": "BaudRate.BaudRate14400",
                        "attributes": {
                            "block": "14400",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "14400",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate14400",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE14400"
                    },
                    "BaudRate.BaudRate9600": {
                        "retType": "BaudRate.BaudRate9600",
                        "attributes": {
                            "block": "9600",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "9600",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate9600",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE9600"
                    },
                    "BaudRate.BaudRate4800": {
                        "retType": "BaudRate.BaudRate4800",
                        "attributes": {
                            "block": "4800",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "4800",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate4800",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE4800"
                    },
                    "BaudRate.BaudRate2400": {
                        "retType": "BaudRate.BaudRate2400",
                        "attributes": {
                            "block": "2400",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "2400",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate2400",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE2400"
                    },
                    "BaudRate.BaudRate1200": {
                        "retType": "BaudRate.BaudRate1200",
                        "attributes": {
                            "block": "1200",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "1200",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate1200",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE1200"
                    },
                    "BaudRate.BaudRate300": {
                        "retType": "BaudRate.BaudRate300",
                        "attributes": {
                            "block": "300",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "300",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "BaudRate.BaudRate300",
                            "Number"
                        ],
                        "pyQName": "BaudRate.BAUD_RATE300"
                    },
                    "SerialEvent": {
                        "kind": 6,
                        "retType": "SerialEvent",
                        "extendsTypes": [
                            "SerialEvent",
                            "Number"
                        ]
                    },
                    "SerialEvent.DataReceived": {
                        "retType": "SerialEvent.DataReceived",
                        "attributes": {
                            "block": "data received",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "data received",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "SerialEvent.DataReceived",
                            "Number"
                        ],
                        "pyQName": "SerialEvent.DATA_RECEIVED"
                    },
                    "SerialEvent.RxBufferFull": {
                        "retType": "SerialEvent.RxBufferFull",
                        "attributes": {
                            "block": "rx buffer full",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "rx buffer full",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "SerialEvent.RxBufferFull",
                            "Number"
                        ],
                        "pyQName": "SerialEvent.RX_BUFFER_FULL"
                    },
                    "Delimiters": {
                        "kind": 6,
                        "retType": "Delimiters",
                        "extendsTypes": [
                            "Delimiters",
                            "Number"
                        ]
                    },
                    "Delimiters.NewLine": {
                        "retType": "Delimiters.NewLine",
                        "attributes": {
                            "block": "new line (\n)",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "new line (\n)",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Delimiters.NewLine",
                            "Number"
                        ],
                        "pyQName": "Delimiters.NEW_LINE"
                    },
                    "Delimiters.Comma": {
                        "retType": "Delimiters.Comma",
                        "attributes": {
                            "block": ",",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": ",",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Delimiters.Comma",
                            "Number"
                        ],
                        "pyQName": "Delimiters.COMMA"
                    },
                    "Delimiters.Dollar": {
                        "retType": "Delimiters.Dollar",
                        "attributes": {
                            "block": "$",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "param",
                                        "name": "",
                                        "ref": true
                                    }
                                ],
                                "parameters": [
                                    {
                                        "kind": "param",
                                        "name": "",
                                        "ref": true
                                    }
                                ]
                            }
                        },
                        "extendsTypes": [
                            "Delimiters.Dollar",
                            "Number"
                        ],
                        "pyQName": "Delimiters.DOLLAR"
                    },
                    "Delimiters.Colon": {
                        "retType": "Delimiters.Colon",
                        "attributes": {
                            "block": ":",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": ":",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Delimiters.Colon",
                            "Number"
                        ],
                        "pyQName": "Delimiters.COLON"
                    },
                    "Delimiters.Fullstop": {
                        "retType": "Delimiters.Fullstop",
                        "attributes": {
                            "block": ".",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": ".",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Delimiters.Fullstop",
                            "Number"
                        ],
                        "pyQName": "Delimiters.FULLSTOP"
                    },
                    "Delimiters.Hash": {
                        "retType": "Delimiters.Hash",
                        "attributes": {
                            "block": "#",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "#",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Delimiters.Hash",
                            "Number"
                        ],
                        "pyQName": "Delimiters.HASH"
                    },
                    "Delimiters.CarriageReturn": {
                        "retType": "Delimiters.CarriageReturn",
                        "attributes": {
                            "block": "carriage return (\r)",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "carriage return (\r)",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Delimiters.CarriageReturn",
                            "Number"
                        ],
                        "pyQName": "Delimiters.CARRIAGE_RETURN"
                    },
                    "Delimiters.Space": {
                        "retType": "Delimiters.Space",
                        "attributes": {
                            "block": "space",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "space",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Delimiters.Space",
                            "Number"
                        ],
                        "pyQName": "Delimiters.SPACE"
                    },
                    "Delimiters.Tab": {
                        "retType": "Delimiters.Tab",
                        "attributes": {
                            "block": "tab (\t)",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": "tab (\t)",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Delimiters.Tab",
                            "Number"
                        ],
                        "pyQName": "Delimiters.TAB"
                    },
                    "Delimiters.Pipe": {
                        "retType": "Delimiters.Pipe",
                        "attributes": {
                            "block": "|",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "break"
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Delimiters.Pipe",
                            "Number"
                        ],
                        "pyQName": "Delimiters.PIPE"
                    },
                    "Delimiters.SemiColon": {
                        "retType": "Delimiters.SemiColon",
                        "attributes": {
                            "block": ";",
                            "_def": {
                                "parts": [
                                    {
                                        "kind": "label",
                                        "text": ";",
                                        "style": []
                                    }
                                ],
                                "parameters": []
                            }
                        },
                        "extendsTypes": [
                            "Delimiters.SemiColon",
                            "Number"
                        ],
                        "pyQName": "Delimiters.SEMI_COLON"
                    },
                    "serial.internalCreateSerialDevice": {
                        "kind": -3,
                        "retType": "SerialDevice",
                        "attributes": {
                            "jsDoc": "Opens a Serial communication driver"
                        },
                        "parameters": [
                            {
                                "name": "tx",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "rx",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "id"
                            }
                        ],
                        "pyQName": "serial.internal_create_serial_device"
                    },
                    "SerialDevice": {
                        "kind": 9,
                        "retType": "SerialDevice",
                        "extendsTypes": []
                    },
                    "SerialDevice.redirect": {
                        "kind": -1,
                        "parameters": [
                            {
                                "name": "tx",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "rx",
                                "type": "DigitalInOutPin"
                            },
                            {
                                "name": "rate",
                                "type": "BaudRate",
                                "isEnum": true
                            }
                        ],
                        "isInstance": true
                    },
                    "SerialDevice.setRxBufferSize": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Sets the size of the RX buffer in bytes"
                        },
                        "parameters": [
                            {
                                "name": "size"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "SerialDevice.set_rx_buffer_size"
                    },
                    "SerialDevice.setTxBufferSize": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Sets the size of the TX buffer in bytes"
                        },
                        "parameters": [
                            {
                                "name": "size"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "SerialDevice.set_tx_buffer_size"
                    },
                    "SerialDevice.setBaudRate": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Set the baud rate of the serial port"
                        },
                        "parameters": [
                            {
                                "name": "rate",
                                "type": "BaudRate",
                                "isEnum": true
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "SerialDevice.set_baud_rate"
                    },
                    "SerialDevice.read": {
                        "kind": -1,
                        "retType": "number",
                        "attributes": {
                            "jsDoc": "Reads a single byte from the serial receive buffer. Negative if error, 0 if no data."
                        },
                        "parameters": [],
                        "isInstance": true
                    },
                    "SerialDevice.readBuffer": {
                        "kind": -1,
                        "retType": "Buffer",
                        "attributes": {
                            "jsDoc": "Read the buffered received data as a buffer"
                        },
                        "parameters": [],
                        "isInstance": true,
                        "pyQName": "SerialDevice.read_buffer"
                    },
                    "SerialDevice.writeBuffer": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Send a buffer across the serial connection."
                        },
                        "parameters": [
                            {
                                "name": "buffer",
                                "type": "Buffer"
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "SerialDevice.write_buffer"
                    },
                    "SerialDevice.onEvent": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Register code when a serial event occurs"
                        },
                        "parameters": [
                            {
                                "name": "event",
                                "type": "SerialEvent",
                                "isEnum": true
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "SerialDevice.on_event"
                    },
                    "SerialDevice.onDelimiterReceived": {
                        "kind": -1,
                        "attributes": {
                            "jsDoc": "Registers code when a delimiter is received"
                        },
                        "parameters": [
                            {
                                "name": "delimiter",
                                "type": "Delimiters",
                                "isEnum": true
                            },
                            {
                                "name": "handler",
                                "type": "() => void",
                                "handlerParameters": []
                            }
                        ],
                        "isInstance": true,
                        "pyQName": "SerialDevice.on_delimiter_received"
                    }
                }
            },
            "sha": "5deff8a1e0d949d683ea15cb2f69b669a73e9f99a6d725a874a0ba909f08c8fb"
        },
        "libs\\blocksprj": {
            "apis": {
                "byQName": {}
            },
            "sha": "07b2750256ca3c29cd88b30cc909fdd78114db373e6590cd566fd844e020b535"
        }
    }
}